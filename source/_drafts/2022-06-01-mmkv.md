---
title: MMKV - 高效的本地 Key-Value 存储
date: 2022-06-01 12:00:00 +0800
tags: [SharedPreferences, SP, MMKV, Jetpack-DataStore, mmap]
---

# mmap

[mmap](https://man7.org/linux/man-pages/man2/mmap.2.html) 在进程的虚拟地址空间开辟一块区域，这块区域映射文件在磁盘上的物理地址，是将内存地址空间映射到磁盘地址空间的一种方法

读/写操作访问虚拟地址空间这一段映射地址，通过查询页表发现这一段地址并不在物理页面上（因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中），因此引发缺页异常，内核发起请求调页过程。调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用 nopage 函数把所缺的页从磁盘装入到主存中。

之后如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程；修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用 `msync()` 来强制同步, 这样所写的内容就能立即保存到文件里了

它的优点有：

1. 常规文件操作需要从磁盘到页缓存再到用户主存的 **两次数据拷贝**，而 mmap 操控文件只需要从磁盘到用户主存的 **一次数据拷贝** 过程

2. 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。

3. 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。如果进程 A 和进程 B 都映射了区域 C，当 A 第一次读取 C 时通过缺页从磁盘复制文件页到内存中；但当 B 再读 C 的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。

4. 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件 I/O 操作，极大影响效率。这个问题可以通过 mmap 映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap 都可以发挥其功效。

## MemoryFile

[MMKV](https://github.com/Tencent/MMKV) 使用 `MemoryFile` 包装 mmap 相关逻辑

> 使用 mmap 需要注意的一个关键点是，mmap 映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap 从磁盘到虚拟地址空间的映射也必须是页。

```cpp
class MemoryFile {
    File m_diskFile;    // 磁盘上的文件
    void *m_ptr;        // 映射到文件物理地址的区域（在内存地址空间里），它的起始地址
    size_t m_size;      // 内存空间区域的大小
}

using MMKVFileHandle_t = HANDLE;
using MMKVPath_t = std::wstring;

class File {
    MMKVPath_t m_path;        // 文件路径
    MMKVFileHandle_t m_fd;    // 打开的文件描述符
}

// 通过系统调用 open 打开文件拿到文件描述符 fd，并用系统调用 fstat 拿到文件大小，然后 mmap 这整个文件获得映射区域的内存地址

using MMKVPath_t = std::wstring;

MemoryFile::MemoryFile(MMKVPath_t path) : m_diskFile(std::move(path), OpenFlag::ReadWrite | OpenFlag::Create), m_ptr(nullptr), m_size(0) {
    reloadFromFile();
}

void MemoryFile::reloadFromFile() {
    if (!m_diskFile.open()) {
        MMKVError("fail to open:%s, %s", m_diskFile.m_path.c_str(), strerror(errno));
    } else {
        FileLock fileLock(m_diskFile.m_fd);
        InterProcessLock lock(&fileLock, ExclusiveLockType);
        SCOPED_LOCK(&lock);

        mmkv::getFileSize(m_diskFile.m_fd, m_size);
        if (m_size < DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) {    // 确保文件大小是内存页大小的整数倍
            size_t roundSize = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;
            truncate(roundSize);
        } else {
            auto ret = mmap();
            if (!ret) {
                doCleanMemoryCache(true);
            }
        }
    }
}

bool File::open() {
    if (isFileValid()) {
        return true;
    }
    m_fd = ::open(m_path.c_str(), OpenFlag2NativeFlag(m_flag), S_IRWXU);
    if (!isFileValid()) {
        MMKVError("fail to open [%s], %d(%s)", m_path.c_str(), errno, strerror(errno));
        return false;
    }
    MMKVInfo("open fd[%p], %s", m_fd, m_path.c_str());
    return true;
}

bool getFileSize(int fd, size_t &size) {
    struct stat st = {};
    if (fstat(fd, &st) != -1) {
        size = (size_t) st.st_size;
        return true;
    }
    return false;
}

bool MemoryFile::mmap() {
    m_ptr = (char *) ::mmap(m_ptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_diskFile.m_fd, 0);
    if (m_ptr == MAP_FAILED) {
        MMKVError("fail to mmap [%s], %s", m_diskFile.m_path.c_str(), strerror(errno));
        m_ptr = nullptr;
        return false;
    }

    return true;
}
```

# Encoding - 数据格式

在 [深入 SharedPreferences：架构、缺点和优化](../../../../2022/05/16/sharedpreferences/) 研究过 `SharedPreferences` 本质上是内存中的 `HashMap` 和磁盘上的 XML 文件，Java HashMap 提供了 CURD Api，持久化时序列化为 XML 格式，本质上是以字符串存储

但在 MMKV 里面对的是一整块内存区域，怎么对这块区域进行 CURD 操作呢？怎么实现 Key-Value Mapping 呢？

在内存空间里，MMKV 使用 `std::unordered_map` 这一数据结构实现 Key-Value Mapping，而 Key-Value 对的内容则是以一种很紧凑的格式存储在 mmap 开辟的内存区域

```
[(key-size)(key-data)(value-size)(value-data)][(key-size)(key-data)(value-size)(value-data)]...
```

因为 mmap 内存区域是对文件物理地址的映射，所以持久化在磁盘上的格式也是上面这种紧凑格式

# Varints - 变长的 size

上面的 `key-size` 和 `value-size` 分别表示 key 和 value 的长度，这两个字段所占大小是可变的，具体规则如下：

1. 先读取一个字节（8 bits），如果 > 0（第一个 bit 是 0）则余下 7 bits 就表示其值，返回

2. 否则说明余下 7 bits 不能完整地表示值，把这 7 bits 作为低 7 位存储在 `result`，继续找值的高位

3. 读取一个字节，如果 > 0 则余下 7 bits 作为 `result` 的高 7 位，与上面获得的低 7 位共 14 bits 就是值，返回

4. 否则又继续找下 7 bits...

5. 也就是每次读取一个字节，第一个 bit 表示需不需要读取下一个字节（0 - 不需要，1 - 需要），剩下 7 bits 构成了值的一部分

下面的 `pbRawVarint32Size` 和 `readRawVarint32` 就是在计算变长的 size 字段到底有几个字节的长度，上面这个算法是参考 [Protocol Buffers - Base 128 Varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)

# Put - 写操作

```cpp
public class MMKV implements SharedPreferences, SharedPreferences.Editor {

    @Override
    public Editor putString(String key, @Nullable String value) {
        encodeString(nativeHandle, key, value);
        return this;
    }

    private native boolean encodeString(long handle, String key, @Nullable String value);    
}

MMKV_JNI jboolean encodeString(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue) {
    MMKV *kv = reinterpret_cast<MMKV *>(handle);
    if (kv && oKey) {
        string key = jstring2string(env, oKey);
        if (oValue) {
            string value = jstring2string(env, oValue);
            return (jboolean) kv->set(value, key);
        } else {
            kv->removeValueForKey(key);
            return (jboolean) true;
        }
    }
    return (jboolean) false;
}

bool MMKV::set(const string &value, MMKVKey_t key) {    // using MMKVKey_t = const std::string &;
    if (isKeyEmpty(key)) {
        return false;
    }
    return setDataForKey(MMBuffer((void *) value.data(), value.length(), MMBufferNoCopy), key, true);
}

bool MMKV::setDataForKey(MMBuffer &&data, MMKVKey_t key, bool isDataHolder) {
    if ((!isDataHolder && data.length() == 0) || isKeyEmpty(key)) {
        return false;
    }
    SCOPED_LOCK(m_lock);
    SCOPED_LOCK(m_exclusiveProcessLock);
    checkLoadData();
    {
        auto itr = m_dic->find(key);    // using MMKVMap = std::unordered_map<std::string, mmkv::KeyValueHolder>;
        if (itr != m_dic->end()) {      // mmkv::MMKVMap *m_dic;
            auto ret = appendDataWithKey(data, itr->second, isDataHolder);
            if (!ret.first) {
                return false;
            }
            itr->second = std::move(ret.second);
        } else {                        // key 不存在的情况
            auto ret = appendDataWithKey(data, key, isDataHolder);
            if (!ret.first) {
                return false;
            }
            m_dic->emplace(key, std::move(ret.second));
        }
    }
    m_hasFullWriteback = false;
    return true;
}

KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, MMKVKey_t key, bool isDataHolder) {    // key 不存在的情况
    auto keyData = MMBuffer((void *) key.data(), key.size(), MMBufferNoCopy);
    return doAppendDataWithKey(data, keyData, isDataHolder, static_cast<uint32_t>(keyData.length()));
}

class MMBuffer {    // MMBuffer 代表一块内存区域
    size_t size;    // 内存区域的大小
    void *ptr;      // 内存区域的起始地址
}

// 写操作 isDataHolder 总是 true，isDataHolder 为 false 表示删除 key，后面会讲到
KVHolderRet_t
MMKV::doAppendDataWithKey(const MMBuffer &data, const MMBuffer &keyData, bool isDataHolder, uint32_t originKeyLength) {
    auto isKeyEncoded = (originKeyLength < keyData.length());    // 对于 key 不存在的情况，isKeyEncoded == false
    auto keyLength = static_cast<uint32_t>(keyData.length());
    auto valueLength = static_cast<uint32_t>(data.length());
    if (isDataHolder) {
        valueLength += pbRawVarint32Size(valueLength);
    }
    // size needed to encode the key
    size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));
    // size needed to encode the value
    size += valueLength + pbRawVarint32Size(valueLength);
    SCOPED_LOCK(m_exclusiveProcessLock);

    bool hasEnoughSize = ensureMemorySize(size);
    if (!hasEnoughSize || !isFileValid()) {
        return make_pair(false, KeyValueHolder());
    }

    // writeRawData 写入数据内容，writeData 先写入数据长度再写入数据内容
    // 对于 key 不存在的情况，isKeyEncoded == false，isDataHolder == true
    // 那么写入的顺序是：写入 key 长度，写入 key 内容，写入 value 长度，写入 value 内容
    // 正如上面数据格式里描述的一样
    try {
        if (isKeyEncoded) {
            m_output->writeRawData(keyData);
        } else {
            m_output->writeData(keyData);
        }
        if (isDataHolder) {
            m_output->writeRawVarint32((int32_t) valueLength);
        }
        m_output->writeData(data); // note: write size of data
    } catch (std::exception &e) {
        MMKVError("%s", e.what());
        return make_pair(false, KeyValueHolder());
    }

    // 返回一个 pair，first 表示操作成功 or 失败
    // second 记录了这个 Key-Value 对在内存和文件的偏移量，以及 key 和 value 的大小
    // 这样就能够通过 key 找到 KeyValueHolder 并快速地定位出 value 所在内存地址
    auto offset = static_cast<uint32_t>(m_actualSize);
    auto ptr = (uint8_t *) m_file->getMemory() + Fixed32Size + m_actualSize;
    m_actualSize += size;
    updateCRCDigest(ptr, size);
    return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));
}

struct KeyValueHolder {
    uint16_t keySize;      // key 的大小
    uint32_t valueSize;    // value 的大小
    uint32_t offset;       // 相对于 mmap 内存区域的偏移量，也是这个 Key-Value 对在文件内的偏移量（这样才能从文件恢复）
};

void CodedOutputData::writeData(const MMBuffer &value) {
    this->writeRawVarint32((int32_t) value.length());
    this->writeRawData(value);
}

void CodedOutputData::writeRawData(const MMBuffer &data) {
    size_t numberOfBytes = data.length();
    if (m_position + numberOfBytes > m_size) {
        auto msg = "m_position: " + to_string(m_position) + ", numberOfBytes: " + to_string(numberOfBytes) +
                   ", m_size: " + to_string(m_size);
        throw out_of_range(msg);
    }
    memcpy(m_ptr + m_position, data.getPtr(), numberOfBytes);
    m_position += numberOfBytes;
}
```

# Update - 修改的情况

在上面的基本流程里，如果 key 存在则进行修改操作，但此时存在一个问题，Key-Value 对是紧凑地排列在一块连续的内存区域上的，如果改变某个 value 的长度那后面的内容对应地需要整体前移或后移，这样修改的代价就会变得很大

所以 MMKV 采取一个用空间换时间的策略：不修改原有的 Key-Value 对，而是将新的 Key-Value 对附加（append）到末尾（当然此时 key 是一样的）

```cpp
// 修改/更新的情况下，从词典里找到已存在的键值对 KeyValueHolder
// 新增的情况，第二个参数是 MMKVKey_t key
KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, const KeyValueHolder &kvHolder, bool isDataHolder) {
    SCOPED_LOCK(m_exclusiveProcessLock);

    uint32_t keyLength = kvHolder.keySize;
    // size needed to encode the key
    size_t rawKeySize = keyLength + pbRawVarint32Size(keyLength);

    // ensureMemorySize() might change kvHolder.offset, so have to do it early
    {
        auto valueLength = static_cast<uint32_t>(data.length());
        if (isDataHolder) {
            valueLength += pbRawVarint32Size(valueLength);
        }
        auto size = rawKeySize + valueLength + pbRawVarint32Size(valueLength);
        bool hasEnoughSize = ensureMemorySize(size);
        if (!hasEnoughSize) {
            return make_pair(false, KeyValueHolder());
        }
    }

    // 跟新增的情况一样进入 doAppendDataWithKey，但有所不同
    // keyLength 指的是 key data size，跟新增时一样
    // 第二个参数 MMBuffer keyData 它指向 key 在 mmap 内存区域的起始地址，size 是整个 key entry 的长度（包含 key data size 部分）
    auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
    MMBuffer keyData(basePtr + kvHolder.offset, rawKeySize, MMBufferNoCopy);
    return doAppendDataWithKey(data, keyData, isDataHolder, keyLength);
}

// 修改时 isDataHolder 也是 true
KVHolderRet_t MMKV::doAppendDataWithKey(const MMBuffer &data, const MMBuffer &keyData, bool isDataHolder, uint32_t originKeyLength) {
    auto isKeyEncoded = (originKeyLength < keyData.length());    // 修改时 isKeyEncoded == true，原因是 keyData 包含了 key data size 部分
    auto keyLength = static_cast<uint32_t>(keyData.length());
    auto valueLength = static_cast<uint32_t>(data.length());
    if (isDataHolder) {
        valueLength += pbRawVarint32Size(valueLength);
    }
    // size needed to encode the key
    size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));
    // size needed to encode the value
    size += valueLength + pbRawVarint32Size(valueLength);
    SCOPED_LOCK(m_exclusiveProcessLock);

    bool hasEnoughSize = ensureMemorySize(size);
    if (!hasEnoughSize || !isFileValid()) {
        return make_pair(false, KeyValueHolder());
    }

    // 这里可以看到修改已有的 Key-Value 并不会真正地去 mmap 内存区域里做修改操作，
    // 而是将修改后的 Key-Value append 至 mmap 内存区域尾部，也即是 append 到磁盘文件尾部
    // isKeyEncoded == true，用 writeRawData 将 keyData 对应的整块内存写入，keyData 是从 dic 里查找出来的，包含完整的 key data size 和 key data
    // 然后写 value data size 和 value data
    try {
        if (isKeyEncoded) {
            m_output->writeRawData(keyData);
        } else {
            m_output->writeData(keyData);
        }
        if (isDataHolder) {
            m_output->writeRawVarint32((int32_t) valueLength);
        }
        m_output->writeData(data); // note: write size of data
    } catch (std::exception &e) {
        MMKVError("%s", e.what());
        return make_pair(false, KeyValueHolder());
    }
    auto offset = static_cast<uint32_t>(m_actualSize);
    auto ptr = (uint8_t *) m_file->getMemory() + Fixed32Size + m_actualSize;
    m_actualSize += size;
    updateCRCDigest(ptr, size);

    // 返回一个新的 KeyValueHolder 实例，指向刚刚 append 的 Key-Value 对在 mmap 内存区域的地址，但 key 部分跟旧的是一样的
    return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));
}

bool MMKV::setDataForKey(MMBuffer &&data, MMKVKey_t key, bool isDataHolder) {
    if ((!isDataHolder && data.length() == 0) || isKeyEmpty(key)) {
        return false;
    }
    SCOPED_LOCK(m_lock);
    SCOPED_LOCK(m_exclusiveProcessLock);
    checkLoadData();
    {
        auto itr = m_dic->find(key);    // using MMKVMap = std::unordered_map<std::string, mmkv::KeyValueHolder>;
        if (itr != m_dic->end()) {      // mmkv::MMKVMap *m_dic;
            auto ret = appendDataWithKey(data, itr->second, isDataHolder);
            if (!ret.first) {
                return false;
            }
            itr->second = std::move(ret.second);
        } else {                        // key 不存在的情况
            auto ret = appendDataWithKey(data, key, isDataHolder);
            if (!ret.first) {
                return false;
            }
            // 更新词典，后续通过这个 key 找到的就是 append 至内存区域末尾的最新的 value 值
            m_dic->emplace(key, std::move(ret.second));
        }
    }
    m_hasFullWriteback = false;
    return true;
}
```

# Remove - 删除操作

上面聊过由于 Key-Value 对是以下面这种紧凑的格式一个个排列在一起的，如果修改操作改变了已有的某个 Value 的长度，那么后面的数据就要整块前移或者后移

删除操作也是一样的，将某个 Key-Value 对删除后，那么后面的 Key-Value 对也要整体前移，这样删除操作的效率就会很低，所以 MMKV 把删除操作改为 append 一个相同 key 但 value data size 为 0 的新项，并从词典里移除此 key 对应的项

```
[(key-size)(key-data)(value-size)(value-data)][(key-size)(key-data)(value-size)(value-data)]...
```

```cpp
public class MMKV implements SharedPreferences, SharedPreferences.Editor {

    @Override
    public Editor remove(String key) {
        removeValueForKey(key);
        return this;
    }

    public void removeValueForKey(String key) {
        removeValueForKey(nativeHandle, key);
    }

    private native void removeValueForKey(long handle, String key);  
}

MMKV_EXPORT void removeValueForKey(void *handle, char *oKey) {
    MMKV *kv = static_cast<MMKV *>(handle);
    if (kv && oKey) {
        string key(oKey);
        kv->removeValueForKey(key);
    }
}

void MMKV::removeValueForKey(MMKVKey_t key) {    // using MMKVKey_t = const std::string &;
    if (isKeyEmpty(key)) {
        return;
    }
    SCOPED_LOCK(m_lock);
    SCOPED_LOCK(m_exclusiveProcessLock);
    checkLoadData();

    removeDataForKey(key);
}

bool MMKV::removeDataForKey(MMKVKey_t key) {
    if (isKeyEmpty(key)) {
        return false;
    }
    {
        auto itr = m_dic->find(key);
        if (itr != m_dic->end()) {
            m_hasFullWriteback = false;
            static MMBuffer nan;      // size == 0，ptr == null
            auto ret = appendDataWithKey(nan, itr->second);
            if (ret.first) {
                m_dic->erase(itr);    // 对于 mmap 内存区域是 append 一个 empty value 的项，对于用以 mapping 的词典是移除此项
            }
            return ret.first;
        }
    }
    return false;
}

// 删除操作下 isDataHolder == false，data.size == 0，data.ptr == null
KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, MMKVKey_t key, bool isDataHolder) {
    auto keyData = MMBuffer((void *) key.data(), key.size(), MMBufferNoCopy);
    return doAppendDataWithKey(data, keyData, isDataHolder, static_cast<uint32_t>(keyData.length()));
}

KVHolderRet_t
MMKV::doAppendDataWithKey(const MMBuffer &data, const MMBuffer &keyData, bool isDataHolder, uint32_t originKeyLength) {
    auto isKeyEncoded = (originKeyLength < keyData.length());    // 删除的情况下，isKeyEncoded == true
    auto keyLength = static_cast<uint32_t>(keyData.length());
    auto valueLength = static_cast<uint32_t>(data.length());
    if (isDataHolder) {
        valueLength += pbRawVarint32Size(valueLength);
    }
    // size needed to encode the key
    size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));
    // size needed to encode the value
    size += valueLength + pbRawVarint32Size(valueLength);
    SCOPED_LOCK(m_exclusiveProcessLock);

    bool hasEnoughSize = ensureMemorySize(size);
    if (!hasEnoughSize || !isFileValid()) {
        return make_pair(false, KeyValueHolder());
    }

    // writeRawData 写入数据内容，writeData 先写入数据长度再写入数据内容
    // 在删除操作里，isKeyEncoded == true，isDataHolder == false
    // key 包含 size 和 data，原封不动写入
    // value 写入 size 0，没有 data
    try {
        if (isKeyEncoded) {
            m_output->writeRawData(keyData);
        } else {
            m_output->writeData(keyData);
        }
        if (isDataHolder) {
            m_output->writeRawVarint32((int32_t) valueLength);
        }
        m_output->writeData(data); // note: write size of data
    } catch (std::exception &e) {
        MMKVError("%s", e.what());
        return make_pair(false, KeyValueHolder());
    }
    auto offset = static_cast<uint32_t>(m_actualSize);
    auto ptr = (uint8_t *) m_file->getMemory() + Fixed32Size + m_actualSize;
    m_actualSize += size;
    updateCRCDigest(ptr, size);
    return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));
}
```

# Get - 查找操作

查询操作比较简单：

1. 根据 string key 从词典里查找出 KeyValueHolder

2. KeyValueHolder.offset 是键值对在 mmap 内存区域的偏移量，加上内存区域的起始地址即可定位出键值对在虚拟内存中的起始地址

3. 加上 key size 和 key data 的偏移量就是 value 的内存地址

4. 再加上 value size 的偏移量就是 value data 的内存地址

```cpp
public class MMKV implements SharedPreferences, SharedPreferences.Editor {

    @Nullable
    @Override
    public String getString(String key, @Nullable String defValue) {
        return decodeString(nativeHandle, key, defValue);
    }

    @Nullable
    private native String decodeString(long handle, String key, @Nullable String defaultValue);
}

MMKV_JNI jstring decodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) {
    MMKV *kv = reinterpret_cast<MMKV *>(handle);
    if (kv && oKey) {
        string key = jstring2string(env, oKey);
        string value;
        bool hasValue = kv->getString(key, value);
        if (hasValue) {
            return string2jstring(env, value);
        }
    }
    return oDefaultValue;
}

bool MMKV::getString(MMKVKey_t key, string &result) {           // using MMKVKey_t = const std::string &;
    if (isKeyEmpty(key)) {
        return false;
    }
    SCOPED_LOCK(m_lock);
    auto data = getDataForKey(key);
    if (data.length() > 0) {
        try {
            CodedInputData input(data.getPtr(), data.length());  // 包含了 value size 和 value data
            result = input.readString();
            return true;
        } catch (std::exception &exception) {
            MMKVError("%s", exception.what());
        }
    }
    return false;
}

MMBuffer MMKV::getDataForKey(MMKVKey_t key) {
    checkLoadData();
    {
        auto itr = m_dic->find(key);
        if (itr != m_dic->end()) {
            auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;  // mmap 内存区域的起始地址
            return itr->second.toMMBuffer(basePtr);  // 加上 offset 就是键值对的内存地址，加上 key size 和 key value 偏移量则是 value 的内存地址                          
        }
    }
    MMBuffer nan;
    return nan;
}

string CodedInputData::readString() {
    int32_t size = readRawVarint32();                         // 计算变长的 size 值，在上面的章节中有讲过计算过程
    if (size < 0) {
        throw length_error("InvalidProtocolBuffer negativeSize");
    }

    auto s_size = static_cast<size_t>(size);
    if (s_size <= m_size - m_position) {
        string result((char *) (m_ptr + m_position), s_size);  // 加上 value size 的偏移量就是 value data，作为 string 返回
        m_position += s_size;
        return result;
    } else {
        throw out_of_range("InvalidProtocolBuffer truncatedMessage");
    }
}

// 在章节 [Varints - 变长的 size] 里讲过，一个字节里，高 1 位表示是否需要读取下一个字节来解析，低 7 位存储数值
int32_t CodedInputData::readRawVarint32() {
    int8_t tmp = this->readRawByte();
    if (tmp >= 0) {
        return tmp;
    }
    int32_t result = tmp & 0x7f;
    if ((tmp = this->readRawByte()) >= 0) {
        result |= tmp << 7;
    } else {
        result |= (tmp & 0x7f) << 7;
        if ((tmp = this->readRawByte()) >= 0) {
            result |= tmp << 14;
        } else {
            result |= (tmp & 0x7f) << 14;
            if ((tmp = this->readRawByte()) >= 0) {
                result |= tmp << 21;
            } else {
                result |= (tmp & 0x7f) << 21;
                result |= (tmp = this->readRawByte()) << 28;
                if (tmp < 0) {
                    // discard upper 32 bits
                    for (int i = 0; i < 5; i++) {
                        if (this->readRawByte() >= 0) {
                            return result;
                        }
                    }
                    throw invalid_argument("InvalidProtocolBuffer malformed varint32");
                }
            }
        }
    }
    return result;
}
```

# 从文件构建 KV 服务

MMKV 依靠 `std::unordered_map` 词典数据结构提供 Key-Value 映射和查找服务，但这个词典结构只存在于内存里并没有实现持久化，所以当第一次打开某个 MMKV 数据文件时，需要将文件从头到尾扫描解析一遍，以构建和还原整个词典数据结构

从下面的结构可以看出，`reloadFromFile` 的过程并不需要将 mmap 映射内存区域的所有页都加载进内存，只需要根据 key size 和 value size 跳跃式地访问内存页即可，所需信息包括：

1. offset - 键值对在 mmap 映射文件里的偏移量

2. keySize - key 大小，它是一个变长的数值

3. keyData - 作为 string 用以查找

4. valueSize - value 的大小

5. valueData 在被访问前是不需要加载进内存的，所以会有大量的虚拟页无需分配

```cpp
struct KeyValueHolder {
    uint16_t computedKVSize; // internal use only
    uint16_t keySize;
    uint32_t valueSize;
    uint32_t offset;
};

using MMKVMap = std::unordered_map<std::string, mmkv::KeyValueHolder>;

class MMKV {
    mmkv::MMKVMap *m_dic;
}
```

上面介绍过所有的 CURD 操作都是 append 一个键值对到文件末尾，而从文件构建 mapping 词典时，是从文件头扫描到文件尾的，所以旧的键值对会被新 append 的键值对替换/删除，看下具体流程：

```cpp
public static MMKV mmkvWithID(String mmapID) throws RuntimeException {
    if (rootDir == null) {
        throw new IllegalStateException("You should Call MMKV.initialize() first.");
    }
    long handle = getMMKVWithID(mmapID, SINGLE_PROCESS_MODE, null, null);
    return checkProcessMode(handle, mmapID, SINGLE_PROCESS_MODE);
}

private native static long getMMKVWithID(String mmapID, int mode, @Nullable String cryptKey, @Nullable String rootPath);

MMKV_EXPORT void *getMMKVWithID(const char *mmapID, int32_t mode, const char *cryptKey, const char *rootPath) {
    MMKV *kv = nullptr;
    if (!mmapID) {
        return kv;
    }
    string str = mmapID;

    bool done = false;
    if (cryptKey) {
        string crypt = cryptKey;
        if (crypt.length() > 0) {
            if (rootPath) {
                string path = rootPath;
                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &crypt, &path);
            } else {
                kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &crypt, nullptr);
            }
            done = true;
        }
    }
    if (!done) {
        if (rootPath) {
            string path = rootPath;
            kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, nullptr, &path);
        } else {
            kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, nullptr, nullptr);  // 走这条路
        }
    }

    return kv;
}

MMKV *MMKV::mmkvWithID(const string &mmapID, int size, MMKVMode mode, string *cryptKey, string *rootPath) {
    if (mmapID.empty()) {
        return nullptr;
    }
    SCOPED_LOCK(g_instanceLock);

    auto mmapKey = mmapedKVKey(mmapID, rootPath);  // id 对应的 MMKV 实例如果已创建则直接返回
    auto itr = g_instanceDic->find(mmapKey);
    if (itr != g_instanceDic->end()) {
        MMKV *kv = itr->second;
        return kv;
    }
    if (rootPath) {                                // 准备所需的目录
        if (!isFileExist(*rootPath)) {
            if (!mkPath(*rootPath)) {
                return nullptr;
            }
        }
        MMKVInfo("prepare to load %s (id %s) from rootPath %s", mmapID.c_str(), mmapKey.c_str(), rootPath->c_str());
    }
    auto kv = new MMKV(mmapID, size, mode, cryptKey, rootPath);  // 看这里如何创建 MMKV 实例
    (*g_instanceDic)[mmapKey] = kv;
    return kv;
}

// mmapID 是文件名，size 取默认值则为一个内存页的大小 4K，其余参数为 null
MMKV::MMKV(const string &mmapID, int size, MMKVMode mode, string *cryptKey, string *rootPath)
    : m_mmapID((mode & MMKV_BACKUP) ? mmapID : mmapedKVKey(mmapID, rootPath)) // historically Android mistakenly use mmapKey as mmapID
    , m_path(mappedKVPathWithID(m_mmapID, mode, rootPath))    // mmap 文件路径
    , m_crcPath(crcPathWithID(m_mmapID, mode, rootPath))
    , m_dic(nullptr)                                          // 用以实现 Key-Value 映射的词典，后续会初始化
    , m_dicCrypt(nullptr)
    , m_file(new MemoryFile(m_path, size, (mode & MMKV_ASHMEM) ? MMFILE_TYPE_ASHMEM : MMFILE_TYPE_FILE))  // mmap 内存区域（MemoryFile 上面介绍过，就是一块内存区域）
    , m_metaFile(new MemoryFile(m_crcPath, DEFAULT_MMAP_SIZE, m_file->m_fileType))
    , m_metaInfo(new MMKVMetaInfo())
    , m_crypter(nullptr)
    , m_lock(new ThreadLock())
    , m_fileLock(new FileLock(m_metaFile->getFd(), (mode & MMKV_ASHMEM)))
    , m_sharedProcessLock(new InterProcessLock(m_fileLock, SharedLockType))
    , m_exclusiveProcessLock(new InterProcessLock(m_fileLock, ExclusiveLockType))
    , m_isInterProcess((mode & MMKV_MULTI_PROCESS) != 0 || (mode & CONTEXT_MODE_MULTI_PROCESS) != 0) {
    m_actualSize = 0;
    m_output = nullptr;

    // force use fcntl(), otherwise will conflict with MemoryFile::reloadFromFile()
    m_fileModeLock = new FileLock(m_file->getFd(), true);
    m_sharedProcessModeLock = new InterProcessLock(m_fileModeLock, SharedLockType);
    m_exclusiveProcessModeLock = nullptr;

    {
        m_dic = new MMKVMap();
    }

    m_needLoadFromFile = true;
    m_hasFullWriteback = false;

    m_crcDigest = 0;

    m_sharedProcessLock->m_enable = m_isInterProcess;
    m_exclusiveProcessLock->m_enable = m_isInterProcess;

    // sensitive zone
    {
        SCOPED_LOCK(m_sharedProcessLock);
        loadFromFile();
    }
}

void MMKV::loadFromFile() {
    if (!m_file->isFileValid()) {  
        m_file->reloadFromFile();  // m_file 是 MemoryFile，上面介绍过，这里主要是进行 open file 和 mmap 映射内存区域
    }

    if (!m_file->isFileValid()) {
        MMKVError("file [%s] not valid", m_path.c_str());
    } else {
        bool loadFromFile = false, needFullWriteback = false;
        checkDataValid(loadFromFile, needFullWriteback);

        auto ptr = (uint8_t *) m_file->getMemory();  // mmap 映射内存区域地址
        if (loadFromFile && m_actualSize > 0) {
            MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);
            if (m_crypter) {
                clearDictionary(m_dicCrypt);
            } else {
                clearDictionary(m_dic);
            }
            if (needFullWriteback) {
                MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer);
            } else {
                MiniPBCoder::decodeMap(*m_dic, inputBuffer);    // 解析 mmap 文件，构建出词典结构以供后续查找使用
            }
            m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
            m_output->seek(m_actualSize);    // m_output 指向文件末尾，用以 append 键值对
            if (needFullWriteback) {
                fullWriteback();
            }
        } else {
            // file not valid or empty, discard everything
            SCOPED_LOCK(m_exclusiveProcessLock);

            m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
            if (m_actualSize > 0) {
                writeActualSize(0, 0, nullptr, IncreaseSequence);
                sync(MMKV_SYNC);
            } else {
                writeActualSize(0, 0, nullptr, KeepSequence);
            }
        }
        auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
        MMKVInfo("loaded [%s] with %zu key-values", m_mmapID.c_str(), count);
    }

    m_needLoadFromFile = false;
}

void MiniPBCoder::decodeMap(MMKVMap &dic, const MMBuffer &oData, size_t position) {  // position 默认为 0
    MiniPBCoder oCoder(&oData);
    oCoder.decodeOneMap(dic, position, false);
}

void MiniPBCoder::decodeOneMap(MMKVMap &dic, size_t position, bool greedy) {  // position == 0，greedy == false
    auto block = [position, this](MMKVMap &dictionary) {
        if (position) {
            m_inputData->seek(position);
        } else {
            m_inputData->readInt32();    // 文件头 32 bits ?
        }
        while (!m_inputData->isAtEnd()) {                         // 因为是从文件头扫描到文件尾，旧的键值对就会被新 append 的键值对替换 or 删除
            KeyValueHolder kvHolder;
            const auto &key = m_inputData->readString(kvHolder);  // 读取 key 的内容为 string
            if (key.length() > 0) {
                m_inputData->readData(kvHolder);                  // 读取 value size（没有读取 value data 哦）
                if (kvHolder.valueSize > 0) {                     // value size > 0 说明是正常的键值对，添加到词典里
                    dictionary[key] = move(kvHolder);
                } else {
                    auto itr = dictionary.find(key);              // [Remove - 删除操作] 里介绍过删除就是 append 一个 data size 为 0 的键值对
                    if (itr != dictionary.end()) {                // 所以这里遇到 data size == 0 就表示要从词典里移除这个 key
                        dictionary.erase(itr);
                    }
                }
            }
        }
    };

    if (greedy) {
        try {
            block(dic);
        } catch (std::exception &exception) {
            MMKVError("%s", exception.what());
        }
    } else {
        try {
            MMKVMap tmpDic;
            block(tmpDic);
            dic.swap(tmpDic);
        } catch (std::exception &exception) {
            MMKVError("%s", exception.what());
        }
    }
}
```

# mmap 扩容

## 内存区域大小与文件大小的关系

情形一：一个文件的大小是 5000 字节，mmap 函数从一个文件的起始位置开始映射 5000 字节到虚拟内存中

分析：因为单位物理页面的大小是 4096 字节，虽然被映射的文件只有 5000 字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此 mmap 函数执行后实际映射到虚拟内存区域 8192 字节，5000~8191 的字节部分用零填充

1. 读/写前 5000 字节（0~4999）会返回操作文件内容
2. 读字节 5000~8191 时结果全为 0，写 5000~8191 时进程不会报错，但是所写的内容不会写入原文件中
3. 读/写 8192 以外的磁盘部分会返回一个 SIGSECV 错误

情形二：一个文件的大小是 5000 字节，mmap 函数从一个文件的起始位置开始映射 15000 字节到虚拟内存中，即映射大小超过了原始文件的大小

分析：由于文件的大小是 5000 字节，和情形一一样其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出 5000 的部分不会体现在原文件中。由于程序要求映射 15000 字节而文件只占两个物理页，因此 8192~15000 都不能读写，操作时会返回异常

1. 进程可以正常读/写被映射的前 5000 字节，写操作的改动会在一定时间后反映在原文件中
2. 对于 5000~8191 字节，进程可以进行读写过程不会报错。但是内容在写入前均为 0，另外写入后不会反映在文件中
3. 对于 8192~14999 字节进程不能对其进行读写，会报 SIGBUS 错误
4. 对于 15000 以外的字节进程不能对其读写，会引发 SIGSEGV 错误

情形三：一个文件初始大小为 0，使用 mmap 操作映射了 1000*4K 的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。

分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。

但是如果，每次操作ptr读写前，先增加文件的大小，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr ~ [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。

这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。

```cpp
// since we use append mode, when -[setData: forKey:] many times, space may not be enough
// try a full rewrite to make space
// size 表示 mmap 内存区域需要有至少 size 大小的剩余空间，不是说整个内存区域要调整为 size 大小
// size 一般是新 append 的键值对的大小
bool MMKV::ensureMemorySize(size_t newSize) {
    if (!isFileValid()) {
        MMKVWarning("[%s] file not valid", m_mmapID.c_str());
        return false;
    }
    if (newSize >= m_output->spaceLeft() || (m_crypter ? m_dicCrypt->empty() : m_dic->empty())) {

        // try a full rewrite to make space
        auto fileSize = m_file->getFileSize();
        auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
        auto sizeOfDic = preparedData.second;
        size_t lenNeeded = sizeOfDic + Fixed32Size + newSize;
        size_t dicCount = m_crypter ? m_dicCrypt->size() : m_dic->size();
        size_t avgItemSize = lenNeeded / std::max<size_t>(1, dicCount);
        size_t futureUsage = avgItemSize * std::max<size_t>(8, (dicCount + 1) / 2);
        // 1. no space for a full rewrite, double it
        // 2. or space is not large enough for future usage, double it to avoid frequently full rewrite
        if (lenNeeded >= fileSize || (lenNeeded + futureUsage) >= fileSize) {
            size_t oldSize = fileSize;
            do {
                fileSize *= 2;
            } while (lenNeeded + futureUsage >= fileSize);    // 计算出新的文件大小，每次 double 文件大小直到放得下新 append 的键值对

            // if we can't extend size, rollback to old state
            if (!m_file->truncate(fileSize)) {                // 真正的 mmap 扩容操作
                return false;
            }

            // check if we fail to make more space
            if (!isFileValid()) {
                MMKVWarning("[%s] file not valid", m_mmapID.c_str());
                return false;
            }
        }
        return doFullWriteBack(move(preparedData), nullptr);
    }
    return true;
}

bool MemoryFile::truncate(size_t size) {    // 将 mmap 扩容至 size 大小
    if (!m_diskFile.isFileValid()) {
        return false;
    }
    if (size == m_size) {
        return true;
    }

    auto oldSize = m_size;
    m_size = size;
    // round up to (n * pagesize)
    if (m_size < DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) {  // 使文件大小刚好是内存页大小的整数倍，这是 mmap 的规定
        m_size = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;
    }

    if (::ftruncate(m_diskFile.m_fd, static_cast<off_t>(m_size)) != 0) {    // 重新设置文件为扩容后的大小
        MMKVError("fail to truncate [%s] to size %zu, %s", m_diskFile.m_path.c_str(), m_size, strerror(errno));
        m_size = oldSize;
        return false;
    }
    if (m_size > oldSize) {                                                 // 扩容后的空白区域要填充 0，否则 reloadFromFile 时会加载到错误的键值对
        if (!zeroFillFile(m_diskFile.m_fd, oldSize, m_size - oldSize)) {
            MMKVError("fail to zeroFile [%s] to size %zu, %s", m_diskFile.m_path.c_str(), m_size, strerror(errno));
            m_size = oldSize;
            return false;
        }
    }

    if (m_ptr) {                                                             // 如果已经 mmap 过了则通过系统调用 munmap 取消映射
        if (munmap(m_ptr, oldSize) != 0) {
            MMKVError("fail to munmap [%s], %s", m_diskFile.m_path.c_str(), strerror(errno));
        }
    }
    auto ret = mmap();                                                       // 重新执行 mmap 映射
    if (!ret) {
        doCleanMemoryCache(true);
    }
    return ret;
}
```

# 参考

1. [认真分析 mmap：是什么 为什么 怎么用 - Alan Hu - 博客园](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

2. [Protocol Buffers - Base 128 Varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)
