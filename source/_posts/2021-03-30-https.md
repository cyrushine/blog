---
title: 什么是 https ？
date: 2021-03-30 12:00:00 +0800
tags: [https]
---

`https = http + tls`

`tcp` 三次握手建立连接后，再进行 `tls` 握手/协商得到一个秘钥，然后双方使用这个秘钥加密（对称加密）明文的 http 为密文后再发送，同样双方收到密文后也用这个秘钥解密得到明文

**对称加密** 使用同一秘钥加密和解密，性能高，http 明文就是通过对称加密后才进行传输的，对称加密算法有：`DES`、`3DES`、`AES` 等；但秘钥交换是个问题，所以需要非对称加密的帮助

**非对称加密** 公钥加密则私钥解密，私钥加密则公钥解密，性能比对称加密要差，不适合加解密大量的数据，但很适合于解决秘钥交换的问题，常用的有：`RSA`、`DSA` 等

## tls 协商的过程

### Client Hello

客户端发送：**客户端随机数**（client random）和客户端支持的 **加密套件列表**

### Server Hello

服务端从客户端支持的加密套件中选择一个，然后发送：**服务端随机数**（server random）和 **选用的套件**，比如 `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384` 就是：
 * 密钥协商使用 `ECDHE`
 * 签名算法使用 `RSA`
 * 加密 http 明文所使用的对称加密算法是 `AES`，密钥长度 256，分组模式 `GCM`
 * 摘要算法使用 `SHA384`

### Server Certificate

服务端发送 **CA 证书**

### Server Key Exchange

服务端生成一个随机数作为 **服务端椭圆曲线私钥**，选择一个 **椭圆曲线**（比如 named_curve）和 **椭圆曲线基点 G**，根据 G 和服务端椭圆曲线私钥生成 **服务端椭圆曲线公钥**

为了确保服务端椭圆曲线公钥不被篡改，服务端用 RSA + 服务端 CA 私钥给服务端椭圆曲线公钥做个签名 **signature**

最后发送椭圆曲线、G、服务端椭圆曲线公钥和 signature 给客户端

### Server Hello Done

服务端告诉客户端我这边的信息已经发送完毕

### Client Key Exchange

客户端进行 CA 证书校验；同样生成一个随机数作为 **客户端椭圆曲线私钥**，根据服务端给的 G 和客户端椭圆曲线私钥生成 **客户端椭圆曲线公钥** 发给服务端（服务端 CA 公钥加密签名防篡改）

此时客户端算出椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端也算出椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)

而两端算出的 **椭圆曲线秘钥** 是一致的，但这还没有结束，对 http 明文进行加密的 **主秘钥** = server random + client random + 椭圆曲线秘钥

### Change Cipher Spec

服务端和客户端都通知对方，后续的数据传输将使用 RSA + 主秘钥加密了

### Finish

第一个由 tls 记录层协议进行加密保护的信息，双方需要验证对方发送的 Finished 信息，保证协商的密钥是可用的，保证协商过程中，没有被篡改

## 总结

https 使用对称加密（比如 `RSA`）对 http 明文进行加密传输，这个秘钥叫 **主秘钥**，但要确保 **秘钥交换** 过程是安全的；那怎样的交换过程是安全的呢？当然不交换，服务端和客户端各自按照一定的规则生成相同秘钥最安全！

上面说到主秘钥 = server random + client random + 椭圆曲线秘钥，server random 和 client random 都是公开的不安全的（引入它俩的目的是增加随机性），那么主秘钥的安全性全靠椭圆曲线秘钥了

客户端椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)，公钥都是公开的所以由私钥确保安全性，而私钥都是随机产生且不经过网络传输的，所以椭圆曲线秘钥是安全的（椭圆曲线的数学特性确保其客户端和服务端算出的是一致的）

总的来说 `ECDHE` 靠本地计算替代网络传输保证了秘钥的安全

## 提问时间

### 怎么证明CA机构的公钥是可信的

CA 证书是从上到下一级一级地签发下来的，操作系统内置 root CA，可以从下到上逐级确认

### 如何防范中间人攻击

计算报文的 hash，并用服务器的私钥加密生成数字签名；客户端用服务器的公钥解密数字签名得到报文 hash 并与实际计算出的报文 hash 值比对，即可判断出报文有没被修改过


