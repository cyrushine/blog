

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/favicon.png">
  <link rel="icon" href="/image/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#141414">
  <meta name="author" content="Cyrus">
  <meta name="keywords" content="">
  
    <meta name="description" content="学习 binder 我感觉得从上到下：先对 binder 架构&#x2F;理论有个大概的认识、对 binder 里的数据结构有个印象，再深入代码细节；整个 binder 涉及到应用侧和驱动侧、app 侧和 framework 侧、java 层和 native 层，代码量巨大而且跨度很大，只有对整个 binder 架构有清晰的认识才不会迷失在细节里 Linux 设备 linux 系统将设备分为3类：字符设备、">
<meta property="og:type" content="article">
<meta property="og:title" content="深入 Binder 之架构篇">
<meta property="og:url" content="https://www.dalvik.work/2022/06/15/binder-arch/index.html">
<meta property="og:site_name" content="Cyrus Blog">
<meta property="og:description" content="学习 binder 我感觉得从上到下：先对 binder 架构&#x2F;理论有个大概的认识、对 binder 里的数据结构有个印象，再深入代码细节；整个 binder 涉及到应用侧和驱动侧、app 侧和 framework 侧、java 层和 native 层，代码量巨大而且跨度很大，只有对整个 binder 架构有清晰的认识才不会迷失在细节里 Linux 设备 linux 系统将设备分为3类：字符设备、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/devices.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/device_driver.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/chrdev.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/systemcall.png">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/binderdriver_frame.png">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/java_binder_frame.png">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/java_binder_framework_class.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/bindermodel.png">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/memory_model.png">
<meta property="og:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/memory_mapping.png">
<meta property="article:published_time" content="2022-06-15T04:00:00.000Z">
<meta property="article:modified_time" content="2023-02-16T10:11:28.534Z">
<meta property="article:author" content="Cyrus">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.dalvik.work/image/2022-06-15-binder-arch/devices.jpg">
  
  
  
  <title>深入 Binder 之架构篇 - Cyrus Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.dalvik.work","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#91cb3e","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":99},"lazyload":{"enable":true,"loading_img":"/image/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"7d0c9146781b5fb9ae68cfc826d0be54","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cyrus Land</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/sunset_sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">深入 Binder 之架构篇</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-15 04:00" pubdate>
          2022年6月15日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          108 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入 Binder 之架构篇</h1>
            
            
              <div class="markdown-body">
                
                <p>学习 binder 我感觉得从上到下：先对 binder 架构/理论有个大概的认识、对 binder 里的数据结构有个印象，再深入代码细节；整个 binder 涉及到应用侧和驱动侧、app 侧和 framework 侧、java 层和 native 层，代码量巨大而且跨度很大，只有对整个 binder 架构有清晰的认识才不会迷失在细节里</p>
<h1 id="Linux-设备"><a href="#Linux-设备" class="headerlink" title="Linux 设备"></a>Linux 设备</h1><p><img src="../../../../image/2022-06-15-binder-arch/devices.jpg" srcset="/image/loading.gif" lazyload alt="devices.jpg"></p>
<p>linux 系统将设备分为3类：字符设备、块设备和网络设备：</p>
<ol>
<li><p><code>字符设备</code> 是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后顺序。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和 LED 设备等</p>
</li>
<li><p><code>块设备</code> 是指可以从设备的任意位置读取一定长度数据的设备。块设备包括硬盘、磁盘、U 盘和 SD 卡等</p>
</li>
</ol>
<p>每个字符设备或块设备都在 <code>/dev</code> 目录下对应一个设备文件，linux 用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备和块设备；驱动调用的实质，就是通过设备文件找到与之对应设备号的设备，再通过设备初始化时绑定的操作函数对硬件进行控制</p>
<h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>字符设备、字符设备驱动与用户空间访问该设备的程序三者之间的关系如下图：</p>
<ul>
<li>使用 cdev 结构体来描述字符设备</li>
<li>通过其成员 dev_t 来定义设备号（分为主、次设备号）以确定字符设备的唯一性</li>
<li>通过其成员 file_operations 来定义字符设备驱动提供给 VFS 的接口函数，如常见的 open()、read()、write() 等</li>
</ul>
<p><img src="../../../../image/2022-06-15-binder-arch/device_driver.jpg" srcset="/image/loading.gif" lazyload alt="device_driver.jpg"></p>
<p>在 Linux 字符设备驱动中：</p>
<ul>
<li>模块加载函数通过 register_chrdev_region 或 alloc_chrdev_region 来静态或者动态获取设备号</li>
<li>通过 cdev_init 建立 cdev 与 file_operations 之间的连接，通过 cdev_add 向系统添加一个 cdev 以完成注册</li>
<li>模块卸载函数通过 cdev_del 来注销 cdev，通过 unregister_chrdev_region 来释放设备号</li>
</ul>
<p><img src="../../../../image/2022-06-15-binder-arch/chrdev.jpg" srcset="/image/loading.gif" lazyload alt="chrdev.jpg"></p>
<h2 id="杂项设备"><a href="#杂项设备" class="headerlink" title="杂项设备"></a>杂项设备</h2><p>杂项设备也是在嵌入式系统中用得比较多的一种设备驱动，使用 <code>misc_register(struct miscdevice *misc)</code> 注册杂项设备，<code>misc_deregister(struct miscdevice *misc)</code> 释放杂项设备</p>
<p>在 Linux 内核的 include/linux 目录下有 Miscdevice.h 文件，要把自己定义的 misc device 设备定义在这里。其实是因为这些字符设备不符合预先确定的字符设备范畴，所有这些设备采用主编号 10 ，一起归于 misc device，其实 misc_register 就是用主标号 10 调用 register_chrdev() 的，也就是说 misc device 就是特殊的字符设备，可自动生成设备节点</p>
<p>misc device 是特殊字符设备，注册驱动程序时采用 misc_register 函数注册，此函数中会自动创建设备节点（即设备文件），无需 mknod 指令手动创建设备文件</p>
<p>杂项字符设备和一般字符设备的区别：</p>
<ol>
<li>一般字符设备首先申请设备号，但是杂项字符设备的主设备号为 10 次设备号通过结构体 miscdevice 中的 minor 来设置</li>
<li>一般字符设备要创建设备文件，但是杂项字符设备在注册时会自动创建</li>
<li>一般字符设备要分配一个 cdev（字符设备），但是杂项字符设备只要创建 miscdevice 结构体即可</li>
<li>一般字符设备需要初始化 cdev，即给字符设备设置对应的操作函数集 file_operation，但是杂项字符设备在结构体 miscdevice 中定义</li>
<li>一般字符设备使用注册函数 cdev_add 而杂项字符设备使用 misc_register 来注册</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">miscdevice</span>&#123;
　　<span class="hljs-type">int</span> minor;                          <span class="hljs-comment">// 杂项设备的此设备号(如果设置为 MISC_DYNAMIC_MINOR，表示系统自动分配未使用的 minor)</span>
　　<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;
　　<span class="hljs-type">const</span> stuct file_operations *fops;  <span class="hljs-comment">// 驱动主题函数入口指针</span>
　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list;
　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *parent;
　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *<span class="hljs-keyword">this</span> device;
　　<span class="hljs-type">const</span> <span class="hljs-type">char</span> *nodename;              <span class="hljs-comment">// 在 /dev 目录下面创建的设备驱动节点</span>
　　<span class="hljs-type">mode_t</span> mode;
&#125;;</code></pre></div>

<h2 id="常见的设备列表"><a href="#常见的设备列表" class="headerlink" title="常见的设备列表"></a>常见的设备列表</h2><table>
<thead>
<tr>
<th>主设备号</th>
<th>次设备号</th>
<th>文件名</th>
<th>设备类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3</td>
<td>/dev/null</td>
<td>char</td>
<td>空设备。任何写入都将被直接丢弃(但返回”成功”)；任何读取都将得到 EOF (文件结束标志)</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>/dev/tty0</td>
<td>char</td>
<td>当前虚拟控制台</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>/dev/tty1</td>
<td>char</td>
<td>第 1 个虚拟控制台</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>/dev/sda</td>
<td>block</td>
<td>第 1 个磁盘</td>
</tr>
<tr>
<td></td>
<td>16</td>
<td>/dev/sdb</td>
<td>block</td>
<td>第 2 个磁盘</td>
</tr>
<tr>
<td></td>
<td>32</td>
<td>/dev/sdc</td>
<td>block</td>
<td>第 3 个磁盘</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>/dev/psaux</td>
<td>char</td>
<td>PS/2 鼠标</td>
</tr>
<tr>
<td></td>
<td>156</td>
<td>/dev/lcd</td>
<td>char</td>
<td>液晶(LCD)显示屏</td>
</tr>
</tbody></table>
<h1 id="Binder-也是设备"><a href="#Binder-也是设备" class="headerlink" title="Binder 也是设备"></a>Binder 也是设备</h1><p>Binder 以杂项设备（misc device，是特殊的字符设备）进行注册，作为虚拟字符设备没有直接操作硬件，只是对设备内存的处理，Binder 驱动的主要方法有：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">binder_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <span class="hljs-comment">// 驱动的初始化</span></span>
<span class="hljs-function"><span class="hljs-title">device_initcall</span><span class="hljs-params">(binder_init)</span></span>;

<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> binder_fops = &#123;
	.owner = THIS_MODULE,
	.poll = binder_poll,
	.unlocked_ioctl = binder_ioctl,  <span class="hljs-comment">// syscall ioctl 的回调，客户端主要通过此方法与 binder 驱动交互</span>
	.compat_ioctl = compat_ptr_ioctl,
	.mmap = binder_mmap,             <span class="hljs-comment">// syscall mmap 的回调，与 binder 交互前需要分配一块物理内存地址存放 IPC 数据（参数和返回值）</span>
	.open = binder_open,             <span class="hljs-comment">// syscall open 的回调，与 binder 交互前需要 open(&quot;/dev/binder&quot;) 拿到 binder fd</span>
	.flush = binder_flush,
	.release = binder_release,
&#125;;</code></pre></div>

<p>Binder Driver 是 Android 专用的，但底层的驱动架构与 Linux 设备驱动一样，用户态的程序调用 Kernel 层驱动是需要陷入内核态进行系统调用（syscall）</p>
<p>比如打开 Binder Driver 方法的调用链是 <code>open() -&gt; __open() -&gt; binder_open()</code></p>
<ol>
<li>open() 为用户空间的方法</li>
<li>_open() 是系统调用中相应的处理方法</li>
<li>通过查找，对应调用到内核 Binder Driver 的 binder_open 方法</li>
</ol>
<p><img src="../../../../image/2022-06-15-binder-arch/systemcall.png" srcset="/image/loading.gif" lazyload alt="systemcall.png"></p>
<h2 id="Binder-在-IPC-中的位置"><a href="#Binder-在-IPC-中的位置" class="headerlink" title="Binder 在 IPC 中的位置"></a>Binder 在 IPC 中的位置</h2><p>Client 进程通过 RPC(Remote Procedure Call Protocol) 与 Server 通信的过程，可以简单的分为三层：驱动层、IPC 层和业务层</p>
<ul>
<li>demo() 是 client 和 server 共同协商好的统一方法</li>
<li>RPC 数据、code、handle 和协议这四项组成了 IPC 的层的数据，通过 IPC 层进行数据传输</li>
<li>而真正在 Client 和 Server 两端建立通信的基础设施是 Binder Driver</li>
</ul>
<p><img src="../../../../image/2022-06-15-binder-arch/binderdriver_frame.png" srcset="/image/loading.gif" lazyload alt="binderdriver_frame.png"></p>
<h1 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h1><ul>
<li><p>从 IPC 角度看，Binder 是 Android 中一种跨进程通信方式，这种通信方式是 Android 独有的</p>
</li>
<li><p>从 Android APP 层面看，Binder 是客户端和服务端进行 IPC 通信的媒介，例如当 bindService 的时候，服务端就会返回一个包含服务端业务调用的 Binder 对象，通过这个 Binder 对象客户端可以获取服务端提供的服务或者数据，归属于属于 RPC</p>
</li>
<li><p>从 Android Framework 层面看，Binder 是各种 Manager(ActivityManager、WindowManager 等) 和相应 XXXManagerService 的桥梁</p>
</li>
<li><p>从 Android Native 层面看，Binder 是创建 ServiceManager 以及 BpBinder/BBinder 模型，搭建与 binder 驱动的桥梁</p>
</li>
<li><p>从 Android Driver 层面看，Binder 是一个虚拟的字符设备，它的设备驱动路径是 <code>/dev/binder</code></p>
</li>
</ul>
<p><img src="../../../../image/2022-06-15-binder-arch/java_binder_frame.png" srcset="/image/loading.gif" lazyload alt="java_binder_frame.png"></p>
<p>Binder 在整个 Android 系统中具有重要的作用，在 native 层有一套完整的 binder 通信的 C/S 架构：<code>BpBinder</code> 作为客户端，<code>BBinder</code> 作为服务端</p>
<p>java 层也有一套镜像功能的 binder C/S 架构，通过 JNI 和 native binder 相对应，并且最终都是交给 native binder 来完成的</p>
<p><img src="../../../../image/2022-06-15-binder-arch/java_binder_framework_class.jpg" srcset="/image/loading.gif" lazyload alt="java_binder_framework_class.jpg"></p>
<h1 id="通讯模型"><a href="#通讯模型" class="headerlink" title="通讯模型"></a>通讯模型</h1><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><blockquote>
<p>ioctl - control device <br><br></p>
<p><code>int ioctl(int fd, unsigned long request, ...);</code><br><br></p>
<p>The ioctl() system call manipulates the underlying device<br>parameters of special files.  In particular, many operating<br>characteristics of character special files (e.g., terminals) may<br>be controlled with ioctl() requests.  The argument <code>fd</code> must be an<br>open file descriptor.<br><br></p>
<p>The second argument is a <code>device-dependent request code</code>.  The<br>third argument is <code>an untyped pointer to memory</code>.<br><br></p>
<p>Ioctl command values are 32-bit constants.  In principle these<br>constants are completely arbitrary, but people have tried to<br>build some structure into them.<br><br></p>
<p>Later (0.98p5) some more information was built into the number.<br>One has 2 direction bits (00: none, 01: write, 10: read, 11:<br>read/write) followed by 14 size bits (giving the size of the<br>argument), followed by an 8-bit type (collecting the ioctls in<br>groups for a common purpose or a common driver), and an 8-bit<br>serial number.<br><br></p>
<p>The macros describing this structure live in &lt;asm/ioctl.h&gt; and<br>are _IO(type,nr) and {_IOR,_IOW,_IOWR}(type,nr,size).  They use<br>sizeof(size) so that size is a misnomer here: this third argument<br>is a data type.</p>
</blockquote>
<p>Linux 下用户空间通过系统调用 <code>ioctl</code> 与设备驱动进行交互，也就说当想用 binder 实现 IPC 通讯时得通过 ioctl 进行，例如 <code>ioctl(binder_fd, BINDER_WRITE_READ, p_bwr)</code></p>
<ul>
<li><code>BINDER_WRITE_READ</code> 告诉 binder 收发 IPC 数据</li>
<li><code>p_bwr</code> 是一个指向 <code>struct binder_write_read</code> 的指针，结构体包含需要发送的数据的地址和长度，以及需要将数据接收放在哪里</li>
</ul>
<p>完整的 binder ioctl 命令如下：</p>
<table>
<thead>
<tr>
<th>ioctl命令</th>
<th>数据类型</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>BINDER_WRITE_READ</td>
<td>struct binder_write_read</td>
<td>收发 Binder IPC 数据（最主要、最常用的命令）</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>__u32</td>
<td>设置 Binder 线程最大个数</td>
</tr>
<tr>
<td>BINDER_SET_CONTEXT_MGR</td>
<td>__s32</td>
<td>设置 service manager 节点（也即是经常用到的 services 注册表）</td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>__s32</td>
<td>释放 Binder 线程</td>
</tr>
<tr>
<td>BINDER_VERSION</td>
<td>struct binder_version</td>
<td>获取 Binder 版本信息</td>
</tr>
<tr>
<td>BINDER_GET_NODE_DEBUG_INFO</td>
<td>struct binder_node_debug_info</td>
<td>获取 binder debug 信息</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/android/binder.c</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-comment">// ...</span>
	<span class="hljs-keyword">switch</span> (cmd) &#123;
	<span class="hljs-keyword">case</span> BINDER_WRITE_READ:
		<span class="hljs-built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);
		<span class="hljs-comment">// ...</span>

	<span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR:
		<span class="hljs-built_in">binder_ioctl_set_ctx_mgr</span>(filp, <span class="hljs-literal">NULL</span>);
		<span class="hljs-comment">// ...</span>

	<span class="hljs-keyword">case</span> BINDER_THREAD_EXIT:
	<span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT:
	<span class="hljs-keyword">case</span> BINDER_SET_MAX_THREADS:
	<span class="hljs-keyword">case</span> BINDER_VERSION:
	<span class="hljs-keyword">case</span> BINDER_GET_NODE_INFO_FOR_REF:
	<span class="hljs-keyword">case</span> BINDER_GET_NODE_DEBUG_INFO:
	<span class="hljs-keyword">case</span> BINDER_FREEZE:
	<span class="hljs-keyword">case</span> BINDER_GET_FROZEN_INFO:
	<span class="hljs-keyword">case</span> BINDER_ENABLE_ONEWAY_SPAM_DETECTION:
	<span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<h2 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h2><p>ioctl 命令 <code>BINDER_WRITE_READ</code> 对应的处理器方法是 <code>binder_ioctl_write_read</code>，对应的数据结构/内存布局是 <code>struct binder_write_read</code>（ioctl 第三个参数指针指向的内存）</p>
<p>处理器的整个逻辑也很简单：</p>
<ul>
<li>如果 <code>write_buffer</code> 有数据就用 <code>binder_thread_write</code> 处理，write_buffer 是紧凑的布局 <code>[BC_][struct][BC_][struct][BC_][struct]...</code></li>
<li>如果 <code>read_buffer</code> 有数据就用 <code>binder_thread_read</code> 处理</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/external/kernel-headers/+/refs/tags/android-mainline-12.0.0_r114/original/uapi/linux/android/binder.h</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> &#123;
	<span class="hljs-type">binder_size_t</span>		write_size;	    <span class="hljs-comment">/* bytes to write */</span>
	<span class="hljs-type">binder_size_t</span>		write_consumed;	<span class="hljs-comment">/* bytes consumed by driver */</span>
	<span class="hljs-type">binder_uintptr_t</span>	write_buffer;   <span class="hljs-comment">/* client/server 发送给 driver 的数据 */</span>
	<span class="hljs-type">binder_size_t</span>		read_size;	    <span class="hljs-comment">/* bytes to read */</span>
	<span class="hljs-type">binder_size_t</span>		read_consumed;	<span class="hljs-comment">/* bytes consumed by driver */</span>
	<span class="hljs-type">binder_uintptr_t</span>	read_buffer;    <span class="hljs-comment">/* client/server 接收来自 driver 的数据 */</span>
&#125;;

<span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/android/binder.c</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span>
<span class="hljs-params"><span class="hljs-function">				<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span></span>
<span class="hljs-params"><span class="hljs-function">				<span class="hljs-keyword">struct</span> binder_thread *thread)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-comment">// ...</span>
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> bwr;
	<span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;
		ret = <span class="hljs-built_in">binder_thread_write</span>(proc, thread,
					  bwr.write_buffer,
					  bwr.write_size,
					  &amp;bwr.write_consumed);
		<span class="hljs-built_in">trace_binder_write_done</span>(ret);
		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;
			bwr.read_consumed = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))
				ret = -EFAULT;
			<span class="hljs-keyword">goto</span> out;
		&#125;
	&#125;
	<span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) &#123;
		ret = <span class="hljs-built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer,
					 bwr.read_size,
					 &amp;bwr.read_consumed,
					 filp-&gt;f_flags &amp; O_NONBLOCK);
		<span class="hljs-built_in">trace_binder_read_done</span>(ret);
		<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);
		<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))
			<span class="hljs-built_in">binder_wakeup_proc_ilocked</span>(proc);
		<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);
		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))
				ret = -EFAULT;
			<span class="hljs-keyword">goto</span> out;
		&#125;
	&#125;
	<span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/heads/android12-5.10-lts/drivers/android/binder.c</span>
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc, <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span>
<span class="hljs-params"><span class="hljs-function">			<span class="hljs-type">binder_uintptr_t</span> binder_buffer,  <span class="hljs-comment">// 对应 binder_write_read.write_buffer</span></span></span>
<span class="hljs-params"><span class="hljs-function">			<span class="hljs-type">size_t</span> size,                     <span class="hljs-comment">// 对应 binder_write_read.write_size</span></span></span>
<span class="hljs-params"><span class="hljs-function">			<span class="hljs-type">binder_size_t</span> *consumed          <span class="hljs-comment">// 对应 binder_write_read.write_consumed</span></span></span>
<span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;
	<span class="hljs-type">uint32_t</span> cmd;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_context</span> *context = proc-&gt;context;
	<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;
	<span class="hljs-type">void</span> __user *ptr = buffer + *consumed;
	<span class="hljs-type">void</span> __user *end = buffer + size;
	<span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;
		<span class="hljs-type">int</span> ret;
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))  <span class="hljs-comment">// 32 bits 的 BC 命令</span>
			<span class="hljs-keyword">return</span> -EFAULT;
		ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);
		
		<span class="hljs-keyword">switch</span> (cmd) &#123;
		<span class="hljs-keyword">case</span> BC_TRANSACTION:
        <span class="hljs-keyword">case</span> BC_REPLY: &#123;
			<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> tr;
			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;tr, ptr, <span class="hljs-built_in">sizeof</span>(tr)))  <span class="hljs-comment">// 命令后紧跟着对应的结构体</span>
				<span class="hljs-keyword">return</span> -EFAULT;
			ptr += <span class="hljs-built_in">sizeof</span>(tr);
			<span class="hljs-built_in">binder_transaction</span>(proc, thread, &amp;tr,
					   cmd == BC_REPLY, <span class="hljs-number">0</span>);
			<span class="hljs-keyword">break</span>;
		&#125;			
		<span class="hljs-keyword">case</span> BC_INCREFS:
		<span class="hljs-keyword">case</span> BC_ACQUIRE:
		<span class="hljs-keyword">case</span> BC_RELEASE:
		<span class="hljs-keyword">case</span> BC_DECREFS:
		<span class="hljs-keyword">case</span> BC_INCREFS_DONE:
		<span class="hljs-keyword">case</span> BC_ACQUIRE_DONE:
		<span class="hljs-comment">// ...</span>
		&#125;
		*consumed = ptr - buffer;
	&#125;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>Binder IPC 通信至少是两个进程的交互，一次完整的 Binder 通信过程如下</p>
<ul>
<li>BINDER_COMMAND_PROTOCOL：binder 请求码，以 BC_ 开头，简称 <code>BC</code> 码，表示将数据从 client/server 传递到 Binder Driver</li>
<li> BINDER_RETURN_PROTOCOL：binder 响应码，以 BR_ 开头，简称 <code>BR</code> 码，表示将数据从 Binder Driver 传递到 client/server</li>
<li>client 进程执行 binder_thread_write，根据 BC 命令生成相应的 binder_work</li>
<li>server 进程执行 binder_thread_read，根据 binder_work_type 类型生成 BR，发送到用户空间处理</li>
</ul>
<p><img src="../../../../image/2022-06-15-binder-arch/bindermodel.png" srcset="/image/loading.gif" lazyload alt="bindermodel.png"></p>
<p>请求码是在 <code>binder_driver_command_protocol</code> 中定义的，用于应用程序向 binder 驱动设备发送请求消息，应用程序包含 Client 和 Server 端，以 BC_ 开头，总共 19 条</p>
<table>
<thead>
<tr>
<th>请求码</th>
<th>参数类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>BC_TRANSACTION</td>
<td>binder_transaction_data</td>
<td>Client 向 Binder 驱动发送的请求数据</td>
</tr>
<tr>
<td>BC_REPLY</td>
<td>binder_transaction_data</td>
<td>Server 向 Binder 驱动发送的回复数据</td>
</tr>
<tr>
<td>BC_ACQUIRE_RESULT</td>
<td>__s32</td>
<td>暂时不支持</td>
</tr>
<tr>
<td>BC_FREE_BUFFER</td>
<td>binder_uintptr_t</td>
<td>释放内存</td>
</tr>
<tr>
<td>BC_INCREFS</td>
<td>__u32</td>
<td>binder_ref 弱引用加1操作（这些请求码的作用是对 binder 的强/弱引用的计数操作，用于实现强/弱指针的功能）</td>
</tr>
<tr>
<td>BC_ACQUIRE</td>
<td>__u32</td>
<td>binder_ref 弱引用减1操作</td>
</tr>
<tr>
<td>BC_RELEASE</td>
<td>__u32</td>
<td>binder_ref 强引用加1操作</td>
</tr>
<tr>
<td>BC_DECREFS</td>
<td>__u32</td>
<td>binder_ref 强引用减1操作</td>
</tr>
<tr>
<td>BC_INCREFS_DONE</td>
<td>binder_ptr_cookie</td>
<td>binder_node 强引用减1操作</td>
</tr>
<tr>
<td>BC_ACQUIRE_DONE</td>
<td>binder_ptr_cookie</td>
<td>binder_node 弱引用减1操作</td>
</tr>
<tr>
<td>BC_ATTEMPT_ACQUIRE</td>
<td>binder_pri_desc</td>
<td>暂时不支持</td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>无参数</td>
<td>创建新的 Looper 线程</td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>无参数</td>
<td>应用线程进入 Looper</td>
</tr>
<tr>
<td>BC_EXIT_LOOPER</td>
<td>无参数</td>
<td>应用线程退出 Looper</td>
</tr>
<tr>
<td>BC_REQUEST_DEATH_NOTIFICATION</td>
<td>binder_handle_cookie</td>
<td>注册死亡通知</td>
</tr>
<tr>
<td>BC_CLEAR_DEATH_NOTIFICATION</td>
<td>binder_handle_cookie</td>
<td>取消注册的死亡通知</td>
</tr>
<tr>
<td>BC_DEAD_BINDER_DONE</td>
<td>binder_uintptr_t</td>
<td>已经完成的死亡通知</td>
</tr>
<tr>
<td>BC_TRANSACTION_SG</td>
<td>binder_transaction_data_sg</td>
<td>Client 向 Binder 驱动发送的 Command</td>
</tr>
<tr>
<td>BC_REPLY_SG</td>
<td>binder_transaction_data_sg</td>
<td>Server 向 Binder 驱动发送的 Command</td>
</tr>
</tbody></table>
<p>响应码在 <code>binder_driver_return_protocol</code> 中定义，是 binder 设备向应用程序回复的消息，应用程序包括 client 和 server 端，以 BR_ 开头，总共 18 条</p>
<table>
<thead>
<tr>
<th>响应码</th>
<th>参数类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>BR_ERROR</td>
<td>__s32</td>
<td>操作发送错误</td>
</tr>
<tr>
<td>BR_OK</td>
<td>无参数</td>
<td>操作完成</td>
</tr>
<tr>
<td>BR_TRANSACTION</td>
<td>binder_transaction_data</td>
<td>Binder 驱动向 Server 发送的请求数据</td>
</tr>
<tr>
<td>BR_REPLY</td>
<td>binder_transaction_data</td>
<td>Binder 驱动向 Client 发送的回复数据</td>
</tr>
<tr>
<td>BR_ACQUIRE_RESULT</td>
<td>__s32</td>
<td>暂时不支持</td>
</tr>
<tr>
<td>BR_DEAD_REPLY</td>
<td>无参数</td>
<td>回复失败，线程或节点为空</td>
</tr>
<tr>
<td>BR_TRANSACTION_COMPLETE</td>
<td>无参数</td>
<td>对请求发送的成功反馈</td>
</tr>
<tr>
<td>BR_INCREFS</td>
<td>binder_ptr_cookie</td>
<td>binder_ref 弱引用加1操作</td>
</tr>
<tr>
<td>BR_ACQUIRE</td>
<td>binder_ptr_cookie</td>
<td>binder_ref 弱引用减1操作</td>
</tr>
<tr>
<td>BR_RELEASE</td>
<td>binder_ptr_cookie</td>
<td>binder_ref 强引用加1操作</td>
</tr>
<tr>
<td>BR_DECREFS</td>
<td>binder_ptr_cookie</td>
<td>binder_ref 强引用减1操作</td>
</tr>
<tr>
<td>BR_ATTEMPT_ACQUIRE</td>
<td>binder_pri_ptr_cookie</td>
<td>暂时不支持</td>
</tr>
<tr>
<td>BR_NOOP</td>
<td>无参数</td>
<td>不做任何事情</td>
</tr>
<tr>
<td>BR_SPAWN_LOOPER</td>
<td>无参数</td>
<td>创建新的 Looper 线程</td>
</tr>
<tr>
<td>BR_FINISHED</td>
<td>无参数</td>
<td>暂时不支持</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>binder_uintptr_t</td>
<td>Binder 驱动向 client 发送死亡通知</td>
</tr>
<tr>
<td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td>
<td>binder_uintptr_t</td>
<td>清除死亡通知</td>
</tr>
<tr>
<td>BR_FAILED_REPLY</td>
<td>无参数</td>
<td>回复失败，transaction 出错导致</td>
</tr>
</tbody></table>
<h2 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h2><p>Binder 作为一种高效的 IPC 方式，在进程间进行数据传递自然是最核心的任务，所以 <code>_TRANSACTION_</code> 相关的命令是最常使用、最重要的命令，对应方法 <code>binder_transaction</code>，对应结构体 <code>binder_transaction_data</code></p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/external/kernel-headers/+/refs/tags/android-mainline-12.0.0_r114/original/uapi/linux/android/binder.h</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> &#123;
	<span class="hljs-comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span>
<span class="hljs-comment">	 * identifying the target and contents of the transaction.</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-keyword">union</span> &#123;
		__u32	handle;	<span class="hljs-comment">/* target descriptor of command transaction */</span>
		<span class="hljs-type">binder_uintptr_t</span> ptr;	<span class="hljs-comment">/* target descriptor of return transaction */</span>
	&#125; target;
	<span class="hljs-type">binder_uintptr_t</span>	cookie;	<span class="hljs-comment">/* target object cookie */</span>
	__u32		code;		<span class="hljs-comment">/* transaction command */</span>
	<span class="hljs-comment">/* General information about the transaction. */</span>
	__u32	        flags;
	<span class="hljs-type">pid_t</span>		sender_pid;
	<span class="hljs-type">uid_t</span>		sender_euid;
	<span class="hljs-type">binder_size_t</span>	data_size;	<span class="hljs-comment">/* number of bytes of data */</span>
	<span class="hljs-type">binder_size_t</span>	offsets_size;	<span class="hljs-comment">/* number of bytes of offsets */</span>
	<span class="hljs-comment">/* If this transaction is inline, the data immediately</span>
<span class="hljs-comment">	 * follows here; otherwise, it ends with a pointer to</span>
<span class="hljs-comment">	 * the data buffer.</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-keyword">union</span> &#123;
		<span class="hljs-keyword">struct</span> &#123;
			<span class="hljs-comment">/* transaction data */</span>
			<span class="hljs-type">binder_uintptr_t</span>	buffer;
			<span class="hljs-comment">/* offsets from buffer to flat_binder_object structs */</span>
			<span class="hljs-type">binder_uintptr_t</span>	offsets;
		&#125; ptr;
		__u8	buf[<span class="hljs-number">8</span>];
	&#125; data;
&#125;;

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_transaction</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span>
<span class="hljs-params"><span class="hljs-function">			       <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span>
<span class="hljs-params"><span class="hljs-function">			       <span class="hljs-keyword">struct</span> binder_transaction_data *tr, <span class="hljs-type">int</span> reply,</span></span>
<span class="hljs-params"><span class="hljs-function">			       <span class="hljs-type">binder_size_t</span> extra_buffers_size)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-comment">// ...</span>
	<span class="hljs-keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;
	     buffer_offset += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>)) &#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object_header</span> *hdr;
		<span class="hljs-type">size_t</span> object_size;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object</span> object;
		<span class="hljs-type">binder_size_t</span> object_offset;
		<span class="hljs-type">binder_size_t</span> copy_size;

		object_size = <span class="hljs-built_in">binder_get_object</span>(target_proc, user_buffer,
				t-&gt;buffer, object_offset, &amp;object);
		hdr = &amp;object.hdr;
		<span class="hljs-keyword">switch</span> (hdr-&gt;type) &#123;    <span class="hljs-comment">// 传输各种类型的数据</span>
		<span class="hljs-keyword">case</span> BINDER_TYPE_PTR:
		<span class="hljs-keyword">case</span> BINDER_TYPE_BINDER:
		<span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_BINDER:
		<span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE:
		<span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_HANDLE:
		<span class="hljs-keyword">case</span> BINDER_TYPE_FD:
		<span class="hljs-keyword">case</span> BINDER_TYPE_FDA:
		<span class="hljs-comment">// ...</span>
	    &#125;
    &#125;
&#125;</code></pre></div>

<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>binder_mmap 是 Binder 进程间通信的高效的核心机制所在，其模型如下：</p>
<p><img src="../../../../image/2022-06-15-binder-arch/memory_model.png" srcset="/image/loading.gif" lazyload alt="memory_model.png"></p>
<p>一般的 IPC 需要 client 进程空间拷贝到内核空间，再由内核空间拷贝到 server 进程空间，共发生两次内存拷贝；而 Binder IPC 整个过程只发生一次内存拷贝：</p>
<ul>
<li>虚拟进程地址空间（vm_area_struct）和虚拟内核地址空间（vm_struct）都映射到同一块物理内存空间</li>
<li>当 client 与 server 发送数据时，client 作为数据发送端，先从自己的进程空间把 IPC 通信数据 copy_from_user 拷贝到内核空间</li>
<li>而 server 作为数据接收端与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量获取内存地址</li>
</ul>
<p><img src="../../../../image/2022-06-15-binder-arch/memory_mapping.png" srcset="/image/loading.gif" lazyload alt="memory_mapping.png"></p>
<p>对于进程和内核虚拟地址映射到同一个物理内存的操作（通过地址偏移量来实现）是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。为什么不直接让发送端和接收端直接映射到同一块物理空间，那样连一次复制的操作都不需要，0 次复制那就和 Linux 标准内核的共享内存 IPC 没有区别了，对于共享内存虽然效率高，但是对于多进程同步的问题比较复杂，而管道/消息队列等 IPC 需要复制两次，效率较低。总之Android 选择 Binder 是基于速度和安全性的考虑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B65-binder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/">深入理解 Binder 机制 5 - binder 驱动分析 - Skytoby</a></li>
<li><a target="_blank" rel="noopener" href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B66-%E6%80%BB%E7%BB%93%E7%AF%87/">深入理解 Binder 机制 6 - 总结篇 - Skytoby</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/26/binder-servicemanager/" title="深入 Binder 之 servicemanager 进程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入 Binder 之 servicemanager 进程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/08/binder-aidl/" title="深入 Binder 之 AIDL">
                        <span class="hidden-mobile">深入 Binder 之 AIDL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
