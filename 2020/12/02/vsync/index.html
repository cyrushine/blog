

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/favicon.png">
  <link rel="icon" href="/image/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#141414">
  <meta name="author" content="Cyrus">
  <meta name="keywords" content="">
  
    <meta name="description" content="android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作 从 View.invalidate() 说起 看上图，View.invalidate() 主要做了两件事：  将 V">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 图形栈（一）vsync">
<meta property="og:url" content="https://www.dalvik.work/2020/12/02/vsync/index.html">
<meta property="og:site_name" content="Cyrus Blog">
<meta property="og:description" content="android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作 从 View.invalidate() 说起 看上图，View.invalidate() 主要做了两件事：  将 V">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/invalidate.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/vsync_flow.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/hw_vsync.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/on_vsync.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/consumer.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/45517.png">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/45545.png">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/45553.png">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/45532.png">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/45628.png">
<meta property="og:image" content="https://www.dalvik.work/image/2020-12-02-vsync/45643.png">
<meta property="article:published_time" content="2020-12-02T04:00:00.000Z">
<meta property="article:modified_time" content="2022-12-05T11:11:58.350Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="vsync">
<meta property="article:tag" content="invalidate">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.dalvik.work/image/2020-12-02-vsync/invalidate.jpg">
  
  
  
  <title>Android 图形栈（一）vsync - Cyrus Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.dalvik.work","root":"/","version":"1.9.3","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#91cb3e","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":99},"lazyload":{"enable":true,"loading_img":"/image/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"7d0c9146781b5fb9ae68cfc826d0be54","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cyrus Land</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/sunset_sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Android 图形栈（一）vsync</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-12-02 04:00" pubdate>
          2020年12月2日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          104 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android 图形栈（一）vsync</h1>
            
            
              <div class="markdown-body">
                
                <p>android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 <code>View.invalidate</code> 讲起，看看简单的一个 <code>invalidate</code> 后面隐藏着多么复杂的工作</p>
<h2 id="从-View-invalidate-说起"><a href="#从-View-invalidate-说起" class="headerlink" title="从 View.invalidate() 说起"></a>从 <code>View.invalidate()</code> 说起</h2><p><img src="../../../../image/2020-12-02-vsync/invalidate.jpg" srcset="/image/loading.gif" lazyload alt="invalidate.jpg"></p>
<p>看上图，<code>View.invalidate()</code> 主要做了两件事：</p>
<ol>
<li>将 <code>ViewRootImpl.doTraversal()</code> 加入到 <code>Choreographer</code> 的任务列表里，等待下一次 vsync 信号到来时执行；<code>doTraversal()</code>主要执行 view tree 的三个重要方法：measure、layout 和 draw；<code>Choreographer</code>则是在一次 vsync 信号到来时，依次执行 <code>INPUT</code>，<code>ANIMATION</code> 和 <code>TRAVERSAL</code> 这三个类别的任务；也就是说 view tree 的渲染和 input 的处理都是从 vsync 到来时开始的，而且此时会开启同步栅栏，屏蔽非 ui 任务（用户任务），集中力量在下一次的 vsync 到来前完成一帧的渲染</li>
<li>唤醒 <code>EventThread</code> 去看看有没 vsync 信号的到来；<code>EventThread</code> 看名字就知道是一个线程，看它的 loop 流程，是将 <code>mPendingEvents</code> 分发给 consumer，那么我们可以猜想下，event 也许包含了 vsync，而 consumer 很有可能最终走到 <code>Choreographer.doFrame</code>里触发 view tree 的绘制</li>
</ol>
<p>按照从下到上追踪法，下一步就是看看是谁在什么时候把 event 放到 <code>mPendingEvents</code> 里，但这里我选择掉转方向盘，先从 surfaceflinger 讲起</p>
<p>继续之前，我们得先了解几个跟硬件有关的概念</p>
<h2 id="HAL，Hardware-Abstract-Layer，硬件抽象层"><a href="#HAL，Hardware-Abstract-Layer，硬件抽象层" class="headerlink" title="HAL，Hardware Abstract Layer，硬件抽象层"></a>HAL，Hardware Abstract Layer，硬件抽象层</h2><p>看名字就知道这是跟硬件、设备相关的东西，应该是最贴近硬件的那一层软件，我没有做过相关的开发，但是结合 google 和这两篇文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，我大概了解了它是干什么的，我说说我的理解：</p>
<ul>
<li>它用接口的方式定义协议，而协议则定义了组件间的沟通规范；Android app 开发其实也就这个概念，就是各个业务、基础能力的 interface；我做过 java web 开发，所以对这个概念比较熟悉；整个 java web 是由很多协议构成的：Servlet、JSP、JDBC 等，sun 给出包含这些协议 interface 的 jar 包出来（它自己也可能会给出一个默认实现比如 glassfish），各个厂商给出自己对协议的实现如：Tomcat、Jboss、Resin 等；而 web app 开发者只需根据协议 jar 包开发业务，部署时根据条件可以放在各种厂商的容器上</li>
<li>HAL 也是这个道理，android HWC HAL 定义了各种 interface（在 <code>hardware/interfaces/graphics/composer/2.1/</code> 目录下），各个厂商需要实现这些接口并给出 so 文件；打包 android image 的时候，根据硬件设备挑选合适的 HAL 实现，把 so 文件放到镜像里；而 android framework 开发者只需根据 HAL 接口进行业务开发即可，无需关心实现细节</li>
</ul>
<h2 id="HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言"><a href="#HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言" class="headerlink" title="HIDL，HAL Interface Definition Language，HAL 接口定义语言"></a>HIDL，HAL Interface Definition Language，HAL 接口定义语言</h2><p>看名字好像跟 AIDL 有点渊源啊，对的，它是 HAL 的代码生成器；具体怎么用我们了解下即可：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19923217/article/details/89173162">Android HIDL 之 hal 进程启动及服务注册过程</a></p>
<p>总结下关键点：</p>
<ul>
<li>各个 HAL 是独立进程的（看看 <code>hardware/interfaces/graphics/composer/2.1/default/</code> 是怎么启动 HWC 进程并加载厂商 so 库的），surfaceflinger 进程通过 binder 与 HWC 进程通讯（也就是 C/S 架构，HWC 是 server，surfaceflinger 是 client）</li>
<li>HWC 将服务注册到 <code>hwservicemanager</code>，surfaceflinger 从 <code>hwservicemanager</code> 获取 composer 服务</li>
<li>所以用从下到上的方法找调用栈的时候会发现，onVsync 方法找不到调用的地方，那是因为发送 vsync 信号的代码是厂商代码（framework 提供 callback interface），不在 aosp 里面</li>
</ul>
<h2 id="HWC，硬件图层合成器"><a href="#HWC，硬件图层合成器" class="headerlink" title="HWC，硬件图层合成器"></a>HWC，硬件图层合成器</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a> 这里也介绍了，它是一个合成多个图层的组件（原来状态栏、导航栏、壁纸、app 等不是一起渲染，而是独自渲染最后合成为屏幕内容的），这里只关心它会发出 vsync 信号</p>
<p><img src="../../../../image/2020-12-02-vsync/vsync_flow.jpg" srcset="/image/loading.gif" lazyload alt="vsync_flow.jpg"></p>
<p>我们先理解这张图，屏幕（硬件）发出 vsync 信号（就是上图的 HW_VSYNC），经过软件的一系列的调整生成 SW_VSYNC，然后输出到两路：</p>
<ol>
<li><code>SF_VSYNC</code>，输出到 surfaceflinger</li>
<li><code>APP_VSYNC</code>，输出到 app</li>
</ol>
<h2 id="HW-VSYNC-硬件垂直同步信号"><a href="#HW-VSYNC-硬件垂直同步信号" class="headerlink" title="HW_VSYNC - 硬件垂直同步信号"></a>HW_VSYNC - 硬件垂直同步信号</h2><p><img src="../../../../image/2020-12-02-vsync/hw_vsync.jpg" srcset="/image/loading.gif" lazyload alt="hw_vsync.jpg"></p>
<p>surfaceflinger 是一个很重要的服务进程，它跟图像和显示有关，源码在 <code>/frameworks/native/services/surfaceflinger</code>；目录下有个编译配置文件 <code>Android.bp</code> ，看下它的内容，它输出了可执行文件 surfaceflinger、共享库 libsurfaceflinger.so 和 libSurfaceFlingerProp.so；然后有个 <code>surfaceflinger.rc</code>，它是一个启动配置文件，意味着 surfaceflinger 会在系统启动后被 init 进程启动为服务进程，看下里面的内容，可执行文件是 <code>/system/bin/surfaceflinger</code>，<code>main</code> 函数入口在 main_surfaceflinger.cpp</p>
<p>从上图可以看到 surfaceflinger 进程启动后，会查找 HWC server 并注册 callback，当设备发出 hw_vsync 时，<code>SurfaceFlinger.onVsyncReceived</code> 被执行，看上面那张图，hw_vsync 不是直接被使用，而是被调整转换为 sw_vsync，也就是 <code>DispSync.addResyncSample</code></p>
<h2 id="SW-VSYNC-软件垂直同步信号"><a href="#SW-VSYNC-软件垂直同步信号" class="headerlink" title="SW_VSYNC - 软件垂直同步信号"></a>SW_VSYNC - 软件垂直同步信号</h2><p><code>DispSyncThread</code> 和 <code>DispSync</code> 收集 HW_VSYNC，计算并输出 SW_VSYNC；主循环是 <code>DispSyncThread.threadLoop()</code>，但在分析 main loop 之前，我们需要先了解 <code>DispSync</code> 几个重要的属性（参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3e4b1805c92">「Android SurfaceFlinger SW Vsync模型」</a>）</p>
<p><code>mResyncSamples</code> 数组 - 通过上面的分析我们知道 <code>addResyncSample</code> 把 HW_VSYNC 加入 <code>DispSync</code>，但 <code>mResyncSamples</code> 只会保留最新的 32 个以供后续计算；它是个首尾相连、环状的循环列表，容量为 32</p>
<p><code>mPeriod</code> - 两个 HW_VSYNC 之间的时间间隔，相当于刷新率，我们看下它是怎么计算的</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);
    <span class="hljs-comment">// 只有收集到足够多（≥ 6）的 HW_VSYNC 才去计算刷新率（以及其他参数）</span>
    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;
        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Computing...&quot;</span>, mName);
        <span class="hljs-type">nsecs_t</span> durationSum = <span class="hljs-number">0</span>;
        <span class="hljs-type">nsecs_t</span> minDuration = INT64_MAX;
        <span class="hljs-type">nsecs_t</span> maxDuration = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// We skip the first 2 samples because the first vsync duration on some</span>
        <span class="hljs-comment">// devices may be much more inaccurate than on other devices, e.g. due</span>
        <span class="hljs-comment">// to delays in ramping up from a power collapse. By doing so this</span>
        <span class="hljs-comment">// actually increases the accuracy of the DispSync model even though</span>
        <span class="hljs-comment">// we&#x27;re effectively relying on fewer sample points.</span>

        <span class="hljs-comment">// 把收集到的 HW_VSYNC 时间间隔去掉前两个，去掉最大值和最小值，剩下的求平均值</span>
        <span class="hljs-comment">// 这就算出了硬件的刷新率，它是计算出来的一个平均值，因为 HW_VSYNC 速率极可能是会变动的</span>
        <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> numSamplesSkipped = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;
            <span class="hljs-type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;
            <span class="hljs-type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;
            <span class="hljs-type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];
            durationSum += duration;
            minDuration = <span class="hljs-built_in">min</span>(minDuration, duration);
            maxDuration = <span class="hljs-built_in">max</span>(maxDuration, duration);
        &#125;

        <span class="hljs-comment">// Exclude the min and max from the average</span>
        durationSum -= minDuration + maxDuration;
        mPeriod = durationSum / (mNumResyncSamples - numSamplesSkipped - <span class="hljs-number">2</span>);
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p><code>mPhase</code> - <code>mPeriod</code> 的偏差值；我们知道 <code>mPeriod</code> 是一个计算出来的平均值，而且还去除了一些噪音（极大值、极小值等），那么它与真实的 HW_VSYNC 之间必定会有偏差，<code>mPhase</code> 就是这个平均偏差（要从数学理论上去理解）；这里不深入细节了</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);
    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-type">double</span> sampleAvgX = <span class="hljs-number">0</span>;
        <span class="hljs-type">double</span> sampleAvgY = <span class="hljs-number">0</span>;
        <span class="hljs-type">double</span> scale = <span class="hljs-number">2.0</span> * M_PI / <span class="hljs-built_in">double</span>(mPeriod);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;
            <span class="hljs-type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;
            <span class="hljs-type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;
            <span class="hljs-type">double</span> samplePhase = <span class="hljs-built_in">double</span>(sample % mPeriod) * scale;
            sampleAvgX += <span class="hljs-built_in">cos</span>(samplePhase);
            sampleAvgY += <span class="hljs-built_in">sin</span>(samplePhase);
        &#125;

        sampleAvgX /= <span class="hljs-built_in">double</span>(mNumResyncSamples - numSamplesSkipped);
        sampleAvgY /= <span class="hljs-built_in">double</span>(mNumResyncSamples - numSamplesSkipped);

        mPhase = <span class="hljs-built_in">nsecs_t</span>(<span class="hljs-built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);

        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));

        <span class="hljs-keyword">if</span> (mPhase &lt; -(mPeriod / <span class="hljs-number">2</span>)) &#123;
            mPhase += mPeriod;
            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));
        &#125;

        <span class="hljs-comment">// Artificially inflate the period if requested.</span>
        mPeriod += mPeriod * mRefreshSkipCount;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p><code>mReferenceTime</code>，这个最新那个 HW_VSYNC 的时间，每次计算下一个 SW_VSYNC 时都是以该时间作为基准，这样可以减少误差。如果每一个 SW_VSYNC 都以上一个 SW_VSYNC 作为基准，那误差就会不停的累加；而如果以第一个 HW_VSYNC 作基准，那每次 SW_VSYNC 误差是不会累加的</p>
<p>现在我们看下 main loop</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">status_t</span> err;
    <span class="hljs-type">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
        std::vector&lt;CallbackInvocation&gt; callbackInvocations;
        <span class="hljs-type">nsecs_t</span> targetTime = <span class="hljs-number">0</span>;
        &#123; <span class="hljs-comment">// Scope for lock</span>
            <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;
            <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;
                <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);
            &#125;
            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);
            ++mFrameNumber;
            <span class="hljs-keyword">if</span> (mStop) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;

            <span class="hljs-comment">// 收集到足够多的 HW_VSYNC 算出刷新率后，才计算 SW_VSYNC，否则 wait</span>
            <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;
                err = mCond.<span class="hljs-built_in">wait</span>(mMutex);
                <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;
                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                &#125;
                <span class="hljs-keyword">continue</span>;
            &#125;

            <span class="hljs-comment">// computeNextEventTimeLocked 这个方法很重要，我们知道随着 HW_VSYNC 样本的不断更新，</span>
            <span class="hljs-comment">// mPeriod、mPhase 和 mReferenceTime 也跟着轻微变动，上一次的 SW_VSYNC 是根据上一次的参数算出来的</span>
            <span class="hljs-comment">// 下一次的 SW_VSYNC 则在上次时间戳的基础上重新计算</span>
            targetTime = <span class="hljs-built_in">computeNextEventTimeLocked</span>(now);

            <span class="hljs-comment">// 没到时间则 wait</span>
            <span class="hljs-type">bool</span> isWakeup = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (now &lt; targetTime) &#123;
                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DispSync waiting&quot;</span>);
                <span class="hljs-keyword">if</span> (targetTime == INT64_MAX) &#123;
                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting forever&quot;</span>, mName);
                    err = mCond.<span class="hljs-built_in">wait</span>(mMutex);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(targetTime));
                    err = mCond.<span class="hljs-built_in">waitRelative</span>(mMutex, targetTime - now);
                &#125;
                <span class="hljs-keyword">if</span> (err == TIMED_OUT) &#123;
                    isWakeup = <span class="hljs-literal">true</span>;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;
                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                &#125;
            &#125;
            now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);
            <span class="hljs-comment">// Don&#x27;t correct by more than 1.5 ms</span>
            <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">nsecs_t</span> kMaxWakeupLatency = <span class="hljs-built_in">us2ns</span>(<span class="hljs-number">1500</span>);
            <span class="hljs-keyword">if</span> (isWakeup) &#123;
                mWakeupLatency = ((mWakeupLatency * <span class="hljs-number">63</span>) + (now - targetTime)) / <span class="hljs-number">64</span>;
                mWakeupLatency = <span class="hljs-built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);
                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;
                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);
                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);
                &#125;
            &#125;

            <span class="hljs-comment">// 发送时，再次计算发送时间，只有此时到达发送时间的才发送（时间算得很精确）</span>
            callbackInvocations = <span class="hljs-built_in">gatherCallbackInvocationsLocked</span>(now);
        &#125;
        <span class="hljs-keyword">if</span> (callbackInvocations.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-built_in">fireCallbackInvocations</span>(callbackInvocations);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;</code></pre></div>

<p>总的来说，SW_VSYNC 它去除了噪音，而且用过去 32 个 HW_VSYNC 样本的平均值作刷新率，对比 HW_VSYNC 显得平滑了很多</p>
<p>那谁接收 SW_VSYNC？</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;
    <span class="hljs-comment">// ... 一个是 app，叫做 APP_VSYNC 吧</span>
    mAppConnectionHandle =
            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;app&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().app,
                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),
                                         impl::EventThread::<span class="hljs-built_in">InterceptVSyncsCallback</span>());
    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span>
    mSfConnectionHandle =
            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,
                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),
                                         [<span class="hljs-keyword">this</span>](<span class="hljs-type">nsecs_t</span> timestamp) &#123;
                                             mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);
                                         &#125;);
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<h2 id="APP-VSYNC-发送给-app-的垂直同步信号"><a href="#APP-VSYNC-发送给-app-的垂直同步信号" class="headerlink" title="APP_VSYNC - 发送给 app 的垂直同步信号"></a>APP_VSYNC - 发送给 app 的垂直同步信号</h2><p>还记得文章开头那张 <code>View.invalidate()</code> 时序图吗？最后面它唤醒了 <code>EventThread</code>，现在我们来看看 <code>EventThread</code> 的主循环都做了些什么</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventThread::threadMain</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;
    DisplayEventConsumers consumers;

    <span class="hljs-keyword">while</span> (mState != State::Quit) &#123;
        std::optional&lt;DisplayEventReceiver::Event&gt; event;

        <span class="hljs-comment">// 在文章的开头，我们就猜测 mPendingEvents 里放的是同步信号</span>
        <span class="hljs-comment">// 现在我们知道了里面包含 SW_VSYNC，那是谁放进去的呢？</span>
        <span class="hljs-keyword">if</span> (!mPendingEvents.<span class="hljs-built_in">empty</span>()) &#123;
            event = mPendingEvents.<span class="hljs-built_in">front</span>();
            mPendingEvents.<span class="hljs-built_in">pop_front</span>();
						...
        &#125;

        <span class="hljs-type">bool</span> vsyncRequested = <span class="hljs-literal">false</span>;

        <span class="hljs-comment">// Find connections that should consume this event.</span>
        <span class="hljs-keyword">auto</span> it = mDisplayEventConnections.<span class="hljs-built_in">begin</span>();
        <span class="hljs-keyword">while</span> (it != mDisplayEventConnections.<span class="hljs-built_in">end</span>()) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> connection = it-&gt;<span class="hljs-built_in">promote</span>()) &#123;
                vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;

                <span class="hljs-keyword">if</span> (event &amp;&amp; <span class="hljs-built_in">shouldConsumeEvent</span>(*event, connection)) &#123;
                    consumers.<span class="hljs-built_in">push_back</span>(connection);
                &#125;

                ++it;
            &#125; <span class="hljs-keyword">else</span> &#123;
                it = mDisplayEventConnections.<span class="hljs-built_in">erase</span>(it);
            &#125;
        &#125;

        <span class="hljs-comment">// 分发给消费者，怎么回调给 Choreographer？</span>
        <span class="hljs-keyword">if</span> (!consumers.<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-built_in">dispatchEvent</span>(*event, consumers);
            consumers.<span class="hljs-built_in">clear</span>();
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p><code>DispSyncThread</code> 把 SW_VSYNC 压入 <code>EventThread.mPendingEvents</code></p>
<p><img src="../../../../image/2020-12-02-vsync/on_vsync.jpg" srcset="/image/loading.gif" lazyload alt="on_vsync.jpg"></p>
<p>分发 SW_VSYNC 的流程</p>
<ul>
<li><code>ViewRootImpl</code> 里拿到的是接收 APP_VSYNC 的 <code>Choreographer</code></li>
<li><code>Choreographer</code> 在构造函数里通过 <code>SurfaceFlinger</code> 与 <code>EventThread</code> 建立连接；这个连接其实是个 <code>Parcelable</code>，一块可以 io 的内存，<code>EventThread</code> 往里面写入 SW_VSYNC，<code>DisplayEventReceiver</code> 则通过 <code>Looper.addFd</code> 监听（这是 app main looper）</li>
<li>当收到 SW_VSYNC 时<code>FrameDisplayEventReceiver</code> 把 <code>Choreographer.doFrame</code> 放入 message queue，这样 input、animate 和 view 绘制即将执行</li>
</ul>
<p><img src="../../../../image/2020-12-02-vsync/consumer.jpg" srcset="/image/loading.gif" lazyload alt="consumer.jpg"></p>
<h2 id="SF-VSYNC"><a href="#SF-VSYNC" class="headerlink" title="SF_VSYNC"></a>SF_VSYNC</h2><p>上面我们在分析是谁接收 SW_VSYNC 时，除了 APP_VSYNC 外，还有一路 SF_VSYNC</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;
    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span>
    mSfConnectionHandle =
    mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,
                                 mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),
                                 [<span class="hljs-keyword">this</span>](<span class="hljs-type">nsecs_t</span> timestamp) &#123;
                                     mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);
                                 &#125;);
    <span class="hljs-comment">// 看看 mEventQueue-&gt;setEventConnection 做了什么</span>
    mEventQueue-&gt;<span class="hljs-built_in">setEventConnection</span>(mScheduler-&gt;<span class="hljs-built_in">getEventConnection</span>(mSfConnectionHandle));
    <span class="hljs-comment">// ...</span>
&#125; 

<span class="hljs-comment">// 上面有分析过，vsync event 是写入到一块内存里，通过 fd 可以监听到，而回调是 MessageQueue::cb_eventReceiver</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::setEventConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mEventTube.<span class="hljs-built_in">getFd</span>() &gt;= <span class="hljs-number">0</span>) &#123;
        mLooper-&gt;<span class="hljs-built_in">removeFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>());
    &#125;
    mEvents = connection;
    mEvents-&gt;<span class="hljs-built_in">stealReceiveChannel</span>(&amp;mEventTube);
    mLooper-&gt;<span class="hljs-built_in">addFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);
&#125;

<span class="hljs-comment">// 继续看 eventReceiver 方法</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> events, <span class="hljs-type">void</span>* data)</span> </span>&#123;
    MessageQueue* queue = <span class="hljs-built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);
    <span class="hljs-keyword">return</span> queue-&gt;<span class="hljs-built_in">eventReceiver</span>(fd, events);
&#125;

<span class="hljs-comment">// 把 events 解包成 DisplayEventReceiver::Event，当有 vsync 时执行 dispatchInvalidate</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-type">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;
    <span class="hljs-type">ssize_t</span> n;
    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::<span class="hljs-built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;
                mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>();
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;

<span class="hljs-comment">// 看来得找出 Handler.handleMessage，看看里面怎么处理 MessageQueue::INVALIDATE</span>
<span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchInvalidate</span>() &#123;
    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;
        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::INVALIDATE));
    &#125;
&#125;

<span class="hljs-comment">// 最终发现是走到了 SurfaceFlinger::onMessageReceived</span>
<span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">handleMessage</span>(<span class="hljs-type">const</span> Message&amp; message) &#123;
    <span class="hljs-keyword">switch</span> (message.what) &#123;
        <span class="hljs-keyword">case</span> INVALIDATE:
            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);
            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> REFRESH:
            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);
            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);
            <span class="hljs-keyword">break</span>;
    &#125;
&#125;

<span class="hljs-comment">// 代码比较长，这就不贴出来了，总结下：</span>
<span class="hljs-comment">// SF_VSYNC 最终会调用 onMessageReceived(MessageQueue::INVALIDATE)，然后又会调用 onMessageReceived(MessageQueue::REFRESH)</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> what)</span> </span>&#123;&#125;</code></pre></div>

<h2 id="结合-systrace"><a href="#结合-systrace" class="headerlink" title="结合 systrace"></a>结合 systrace</h2><p>为什么会有 APP_VSYNC 和 SF_VSYNC 呢？这就不得不从屏幕上的内容讲起</p>
<p>实际上，我们在屏幕上看到的内容是由多个 layer 组合而成的：前台 app（多窗口模式下会有多个 app 显示）、桌面、壁纸、systemui 等，每个 app ui thread 负责绘制自己的内容，然后由 SurfaceFlinger 将它们合成在一起并显示在屏幕上</p>
<p>也就是说 APP_VSYNC 触发各个 app 的绘制，而最终屏幕内容的改变是由 SF_VSYNC 触发的；是不是这样呢？我们来看下 systrace </p>
<p><img src="../../../../image/2020-12-02-vsync/45517.png" srcset="/image/loading.gif" lazyload alt="45517.png"></p>
<p><img src="../../../../image/2020-12-02-vsync/45545.png" srcset="/image/loading.gif" lazyload alt="45545.png"></p>
<p><img src="../../../../image/2020-12-02-vsync/45553.png" srcset="/image/loading.gif" lazyload alt="45553.png"></p>
<p><img src="../../../../image/2020-12-02-vsync/45532.png" srcset="/image/loading.gif" lazyload alt="45532.png"></p>
<p><img src="../../../../image/2020-12-02-vsync/45628.png" srcset="/image/loading.gif" lazyload alt="45628.png"></p>
<p><img src="../../../../image/2020-12-02-vsync/45643.png" srcset="/image/loading.gif" lazyload alt="45643.png"></p>
<p>可以看到 ui thread doFrame 的确跟随着 APP_VSYNC（render thread 是执行 opengl 的线程，在 ui thread 计算完后获取结果并输出至 gpu），surfaceflinger onMessageReceived 也是跟随着 SF_VSYNC 的；但有没发现，它们俩似乎是同时执行的？surfaceflinger 不是应该等待 app 渲染完它那一层再合成吗？</p>
<p>我们重新回顾 initScheduler，有没发现这两路 vsync 都有一个 offset 参数？没错，就是这个参数控制着收到 vsync 后到执行工作的这一段延迟时间；实际上图 surfaceflinger 的延迟差不多是一个 vsync 的周期时间那么大，每个 surfaceflinger 合成的内容却是上一个周期里 app 渲染的内容；而且在合成工作完成后，当前周期的 app 渲染工作（render thread）才开始，避免了 layer 的内容被覆盖；这几个线程就这样有节奏地工作在一起。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/vsync/">#vsync</a>
      
        <a href="/tags/invalidate/">#invalidate</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/13/ui-thread-in-vsync/" title="Android 图形栈（二）ui thread">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android 图形栈（二）ui thread</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/19/scoped-storage/" title="Scoped Storage（沙盒）">
                        <span class="hidden-mobile">Scoped Storage（沙盒）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
