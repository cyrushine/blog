<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入分析 Kotlin Coroutines 是如何实现的</title>
    <link href="/2021/07/15/kotlin-coroutine/"/>
    <url>/2021/07/15/kotlin-coroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="launch-启动协程"><a href="#launch-启动协程" class="headerlink" title="launch - 启动协程"></a>launch - 启动协程</h1><p>从 kotlin coroutines 的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt">Hello World!</a> 看起</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// this: CoroutineScope</span><br>    launch &#123; <span class="hljs-comment">// launch a new coroutine and continue</span><br>        delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// non-blocking delay for 1 second (default time unit is ms)</span><br>        println(<span class="hljs-string">&quot;World!&quot;</span>) <span class="hljs-comment">// print after delay</span><br>    &#125;<br>    println(<span class="hljs-string">&quot;Hello&quot;</span>) <span class="hljs-comment">// main coroutine continues while a previous one is delayed</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>需要先了解的是 <code>launch</code> 的参数 <code>block: suspend CoroutineScope.() -&gt; Unit</code> 被编译为继承自 <code>SuspendLamda</code> 和 <code>Function2&lt;CoroutineScope, Continuation&gt;</code>，如下面的代码所示（decompile by <a href="https://github.com/Konloch/bytecode-viewer">bytecode-viewer</a>）</p><p><code>SuspendLambda</code> 的继承关系如下：<code>SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl -&gt; Continuation</code>，所以 <code>block</code> 在库代码里一般称为 <code>continuation</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example_basic_01Kt</span>$<span class="hljs-title">main</span>$1 <span class="hljs-keyword">extends</span> <span class="hljs-title">SuspendLambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Function2</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> label;<br>   <span class="hljs-comment">// $FF: synthetic field</span><br>   <span class="hljs-keyword">private</span> Object L$<span class="hljs-number">0</span>;<br><br>   Example_basic_01Kt$main$<span class="hljs-number">1</span>(Continuation $completion) &#123;<br>      <span class="hljs-keyword">super</span>(<span class="hljs-number">2</span>, $completion);<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object var1)</span> </span>&#123;<br>      Object var5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>.label) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         ResultKt.throwOnFailure(var1);<br>         CoroutineScope $<span class="hljs-keyword">this</span>$runBlocking = (CoroutineScope)<span class="hljs-keyword">this</span>.L$<span class="hljs-number">0</span>;<br>         BuildersKt.launch$<span class="hljs-keyword">default</span>($<span class="hljs-keyword">this</span>$runBlocking, (CoroutineContext)<span class="hljs-keyword">null</span>, (CoroutineStart)<span class="hljs-keyword">null</span>, (Function2)(<span class="hljs-keyword">new</span> <span class="hljs-number">1</span>((Continuation)<span class="hljs-keyword">null</span>)), <span class="hljs-number">3</span>, (Object)<span class="hljs-keyword">null</span>);<br>         String var3 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>         <span class="hljs-keyword">boolean</span> var4 = <span class="hljs-keyword">false</span>;<br>         System.out.println(var3);<br>         <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>      <span class="hljs-keyword">default</span>:<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>      Example_basic_01Kt$main$<span class="hljs-number">1</span> var3 = <span class="hljs-keyword">new</span> Example_basic_01Kt$main$<span class="hljs-number">1</span>($completion);<br>      var3.L$<span class="hljs-number">0</span> = value;<br>      <span class="hljs-keyword">return</span> (Continuation)var3;<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineScope p1, <span class="hljs-meta">@Nullable</span> Continuation p2)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> ((Example_basic_01Kt$main$<span class="hljs-number">1</span>)<span class="hljs-keyword">this</span>.create(p1, p2)).invokeSuspend(Unit.INSTANCE);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example_basic_01Kt</span>$<span class="hljs-title">main</span>$1$1 <span class="hljs-keyword">extends</span> <span class="hljs-title">SuspendLambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Function2</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> label;<br><br>   Example_basic_01Kt$main$<span class="hljs-number">1</span>$<span class="hljs-number">1</span>(Continuation $completion) &#123;<br>      <span class="hljs-keyword">super</span>(<span class="hljs-number">2</span>, $completion);<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> </span>&#123;<br>      Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>.label) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         ResultKt.throwOnFailure($result);<br>         Continuation var10001 = (Continuation)<span class="hljs-keyword">this</span>;<br>         <span class="hljs-keyword">this</span>.label = <span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">if</span> (DelayKt.delay(<span class="hljs-number">1000L</span>, var10001) == var4) &#123;<br>            <span class="hljs-keyword">return</span> var4;<br>         &#125;<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         ResultKt.throwOnFailure($result);<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>      &#125;<br><br>      String var2 = <span class="hljs-string">&quot;World!&quot;</span>;<br>      <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>      System.out.println(var2);<br>      <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> (Continuation)(<span class="hljs-keyword">new</span> Example_basic_01Kt$main$<span class="hljs-number">1</span>$<span class="hljs-number">1</span>($completion));<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineScope p1, <span class="hljs-meta">@Nullable</span> Continuation p2)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> ((Example_basic_01Kt$main$<span class="hljs-number">1</span>$<span class="hljs-number">1</span>)<span class="hljs-keyword">this</span>.create(p1, p2)).invokeSuspend(Unit.INSTANCE);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后一路跟踪下去看看 <code>launch</code> 做了什么</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">CoroutineScope.launch                              <span class="hljs-comment">// return Job (实际上是 StandaloneCoroutine/LazyStandaloneCoroutine)</span><br>AbstractCoroutine.start                            <span class="hljs-comment">// 创建 StandaloneCoroutine/LazyStandaloneCoroutine</span><br>CoroutineStart.invoke(block, receiver, completion) <span class="hljs-comment">// CoroutineStart.DEFAULT</span><br>startCoroutineCancellable(receiver, completion, onCancellation)<br>    createCoroutineUnintercepted       <span class="hljs-comment">// 此方法定义在 kotlin-stdlib 包的 /kotlin/coroutines/intrinsics/IntrinsicsJvm.kt 文件里</span><br>        block.create(value = <span class="hljs-literal">null</span>, completion = coroutine) <span class="hljs-comment">// 如上面反编译出来的代码所示，重新创建一个 block 的实例</span><br>    ContinuationImpl.intercepted       <span class="hljs-comment">// 包装为 DispatchedContinuation（dispatcher 是 BlockingEventLoop）</span><br>        BlockingEventLoop.interceptContinuation<br>    Continuation.resumeCancellableWith <span class="hljs-comment">// 将 block 放入任务队列</span><br>        DispatchedContinuation.resumeCancellableWith<br>        BlockingEventLoop.dispatch<br>            BlockingEventLoop.enqueue<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopImplBase</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (enqueueImpl(task)) &#123;<br>            unpark()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DefaultExecutor.enqueue(task)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// _queue 是 Atomic&lt;Any?&gt;，当任务队列里只有一个任务时 _queue 持有此任务的引用，当任务队列里有多个任务时，_queue 是 Queue&lt;Runnable&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueueImpl</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        _queue.loop &#123; queue -&gt;<br>            <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// fail fast if already completed, may still add, but queues will close</span><br>            <span class="hljs-keyword">when</span> (queue) &#123;<br>                <span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">if</span> (_queue.compareAndSet(<span class="hljs-literal">null</span>, task)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">is</span> Queue&lt;*&gt; -&gt; &#123;<br>                    <span class="hljs-keyword">when</span> ((queue <span class="hljs-keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;<br>                        Queue.ADD_SUCCESS -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                        Queue.ADD_CLOSED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                        Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next())<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">when</span> &#123;<br>                    queue === CLOSED_EMPTY -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                    <span class="hljs-keyword">else</span> -&gt; &#123;<br>                        <span class="hljs-comment">// update to full-blown queue to add one more</span><br>                        <span class="hljs-keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="hljs-literal">true</span>)<br>                        newQueue.addLast(queue <span class="hljs-keyword">as</span> Runnable)<br>                        newQueue.addLast(task)<br>                        <span class="hljs-keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;    <br><br><span class="hljs-comment">// Infinite loop that reads this atomic variable and performs the specified action on its value.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> AtomicRef<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">loop</span><span class="hljs-params">(action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Nothing</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        action(value)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>至此知道了 <code>block</code> 是被放到了任务队列里，那是谁在执行任务队列里的任务呢？这就不得不说起 <code>runBlocking</code></p><p><code>runBlocking</code> 通过 <code>BlockingCoroutine.joinBlocking</code> 不断地执行任务队列里的任务（<code>EventLoopBase.processNextEvent</code>）直到队列为空，因此它是 <code>blocking method</code>；第一个加入到任务队列的是 runBlocking block，所以 <code>Hello World!</code> 示例里会先输出 <code>Hello</code> 然后执行第二个 coroutine 输出 <code>World!</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">runBlocking</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">val</span> currentThread = Thread.currentThread()<br>    <span class="hljs-keyword">val</span> contextInterceptor = context[ContinuationInterceptor]<br>    <span class="hljs-keyword">val</span> eventLoop: EventLoop?<br>    <span class="hljs-keyword">val</span> newContext: CoroutineContext<br>    <span class="hljs-keyword">if</span> (contextInterceptor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// create or use private event loop if no dispatcher is specified</span><br>        eventLoop = ThreadLocalEventLoop.eventLoop<br>        newContext = GlobalScope.newCoroutineContext(context + eventLoop)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span><br>        <span class="hljs-comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span><br>        eventLoop = (contextInterceptor <span class="hljs-keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;<br>            ?: ThreadLocalEventLoop.currentOrNull()<br>        newContext = GlobalScope.newCoroutineContext(context)<br>    &#125;<br>    <span class="hljs-keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)<br>    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine.joinBlocking()<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingCoroutine</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinBlocking</span><span class="hljs-params">()</span></span>: T &#123;<br>        registerTimeLoopThread()<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop?.incrementUseCount()<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;DEPRECATION&quot;</span>)</span><br>                    <span class="hljs-keyword">if</span> (Thread.interrupted()) <span class="hljs-keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125;<br>                    <span class="hljs-keyword">val</span> parkNanos = eventLoop?.processNextEvent() ?: <span class="hljs-built_in">Long</span>.MAX_VALUE<br>                    <span class="hljs-comment">// note: process next even may loose unpark flag, so check if completed before parking</span><br>                    <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">break</span><br>                    parkNanos(<span class="hljs-keyword">this</span>, parkNanos)<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// paranoia</span><br>                eventLoop?.decrementUseCount()<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// paranoia</span><br>            unregisterTimeLoopThread()<br>        &#125;<br>        <span class="hljs-comment">// now return result</span><br>        <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state.unboxState()<br>        (state <span class="hljs-keyword">as</span>? CompletedExceptionally)?.let &#123; <span class="hljs-keyword">throw</span> it.cause &#125;<br>        <span class="hljs-keyword">return</span> state <span class="hljs-keyword">as</span> T<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>launch</code> 把 block 放入任务队列等待执行，类似于 <code>ExecutorService.submit</code> 和 <code>Handler.post</code>，同时说明 <code>协程</code> 本质上就是对任务的调度，底层是线程/线程池 + 任务队列</p><h1 id="Dispatcher-任务调度"><a href="#Dispatcher-任务调度" class="headerlink" title="Dispatcher - 任务调度"></a>Dispatcher - 任务调度</h1><p>首先要了解下 <code>CoroutineContext</code> 这个概念，跟 Android 上 <code>Context</code> 的意义是一样的，就是代表了一系列 coroutine API 的 <code>上下文</code>，本质上是一个 <code>Map</code>，通过 <code>CoroutineContext[key] = value</code> 存取</p><p>其中有一个非常重要的组件：<code>CoroutineContext[ContinuationInterceptor]</code>，负责分发/调度 coroutine，有 <code>BlockingEventLoop</code>, <code>Dispatchers.Default</code>, <code>Dispatchers.IO</code> 等等</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineContext</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the element with the given [key] from this context or `null`.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E?<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ContinuationInterceptor</span> : <span class="hljs-type">CoroutineContext.Element &#123;</span></span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The key that defines *the* context interceptor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过 <code>CoroutineScope.launch</code> 启动 coroutine 时，新创建的 coroutine 会继承 scpoe context（<code>launch</code> 的参数 <code>context</code> 会覆盖相同 key 的 scope context element），而且当 context 不含 interceptor 时主动添加 <code>Dispatchers.Default</code> 作为 <code>Dispatcher</code>，也就是说 <code>Dispatcher</code>/<code>CoroutineContext[ContinuationInterceptor]</code> 作为任务调度器是一个 <strong>必不可少</strong> 的 coroutine 组件</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">newCoroutineContext</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;<br>    <span class="hljs-keyword">val</span> combined = coroutineContext + context<br>    <span class="hljs-keyword">val</span> debug = <span class="hljs-keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="hljs-keyword">else</span> combined<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="hljs-literal">null</span>)<br>        debug + Dispatchers.Default <span class="hljs-keyword">else</span> debug<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在回顾下 <code>launch</code></p><ul><li><code>createCoroutineUnintercepted</code> - 创建 block 实例 <code>Continuation</code>，并使其获得 context</li><li><code>ContinuationImpl.intercepted</code> - 从 context 里取出 Dispatcher，由它负责把 <code>Continuation</code> 包装成 <code>DispatchedContinuation</code>（Dispatcher + Continuation），这样 <code>任务</code> 和 <code>调度器</code> 就齐活了</li><li><code>Continuation.resumeCancellableWith</code> - 让 Dispatcher 负责调度 Continuation</li></ul><p>上一章节分析了 coroutine 本质上就是任务队列里的任务，并简单提了下 <code>BlockingEventLoop</code> 这个调度器，这一章节分析各种各样的调度器</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">CoroutineScope.launch<br>AbstractCoroutine.start<br>CoroutineStart.invoke(block, receiver, completion)<br>startCoroutineCancellable(receiver, completion, onCancellation)<br>    createCoroutineUnintercepted<br>        block.create(value = <span class="hljs-literal">null</span>, completion = coroutine)<br>    ContinuationImpl.intercepted<br>        ContinuationInterceptor.interceptContinuation<br>    Continuation.resumeCancellableWith<br>        DispatchedContinuation.resumeCancellableWith<br>        CoroutineDispatcher.dispatch<br><br><span class="hljs-comment">// kotlin-stdlib - kotlin/coroutines/intrinsics/IntrinsicsJvm.kt</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutineUnintercepted(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> probeCompletion = probeCoroutineCreated(completion)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> BaseContinuationImpl) <span class="hljs-comment">// block -&gt; SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl</span><br>        create(receiver, probeCompletion)<br>    <span class="hljs-keyword">else</span> &#123;<br>        createCoroutineFromSuspendFunction(probeCompletion) &#123;<br>            (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)<br>        &#125;<br>    &#125;<br>&#125;            <br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContinuationImpl</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineDispatcher</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =<br>        DispatchedContinuation(<span class="hljs-keyword">this</span>, continuation)   <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="BlockingEventLoop-runBlocking"><a href="#BlockingEventLoop-runBlocking" class="headerlink" title="BlockingEventLoop / runBlocking"></a>BlockingEventLoop / runBlocking</h2><p><code>runBlocking</code> 会往 context 添加 <code>BlockingEventLoop</code></p><ul><li>上一章节介绍过，它是基于 <code>Queue</code> 的任务队列；只有一个任务时 <code>_queue</code> 直接引用这个任务节省空间，多个任务时 <code>_queue</code> 才引用 <code>Queue</code></li><li>它是 <code>ThreadLocal</code> 的，跟 <code>Looper</code> 一样每个线程单独绑定一个 <code>BlockingEventLoop</code></li><li><code>dispatch</code> 只是简单地将任务入队，然后唤醒对应的线程</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">runBlocking</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">val</span> currentThread = Thread.currentThread()<br>    <span class="hljs-keyword">val</span> contextInterceptor = context[ContinuationInterceptor]<br>    <span class="hljs-keyword">val</span> eventLoop: EventLoop?<br>    <span class="hljs-keyword">val</span> newContext: CoroutineContext<br>    <span class="hljs-keyword">if</span> (contextInterceptor == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// create or use private event loop if no dispatcher is specified</span><br>        eventLoop = ThreadLocalEventLoop.eventLoop<br>        newContext = GlobalScope.newCoroutineContext(context + eventLoop)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span><br>        <span class="hljs-comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span><br>        eventLoop = (contextInterceptor <span class="hljs-keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;<br>            ?: ThreadLocalEventLoop.currentOrNull()<br>        newContext = GlobalScope.newCoroutineContext(context)<br>    &#125;<br>    <span class="hljs-keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)<br>    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine.joinBlocking()<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> ThreadLocalEventLoop &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ref = CommonThreadLocal&lt;EventLoop?&gt;()<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> eventLoop: EventLoop<br>        <span class="hljs-keyword">get</span>() = ref.<span class="hljs-keyword">get</span>() ?: createEventLoop().also &#123; ref.<span class="hljs-keyword">set</span>(it) &#125;<br>&#125;<br><br><span class="hljs-comment">// https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/EventLoop.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingEventLoop</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> thread: Thread<br>) : EventLoopImplBase()<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createEventLoop</span><span class="hljs-params">()</span></span>: EventLoop = BlockingEventLoop(Thread.currentThread())<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopImplBase</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _queue = atomic&lt;Any?&gt;(<span class="hljs-literal">null</span>)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> = enqueue(block)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (enqueueImpl(task)) &#123;<br>            <span class="hljs-comment">// todo: we should unpark only when this delayed task became first in the queue</span><br>            unpark()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DefaultExecutor.enqueue(task)<br>        &#125;<br>    &#125;   <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueueImpl</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        _queue.loop &#123; queue -&gt;<br>            <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// fail fast if already completed, may still add, but queues will close</span><br>            <span class="hljs-keyword">when</span> (queue) &#123;<br>                <span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">if</span> (_queue.compareAndSet(<span class="hljs-literal">null</span>, task)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">is</span> Queue&lt;*&gt; -&gt; &#123;<br>                    <span class="hljs-keyword">when</span> ((queue <span class="hljs-keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;<br>                        Queue.ADD_SUCCESS -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                        Queue.ADD_CLOSED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                        Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next())<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">when</span> &#123;<br>                    queue === CLOSED_EMPTY -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                    <span class="hljs-keyword">else</span> -&gt; &#123;<br>                        <span class="hljs-comment">// update to full-blown queue to add one more</span><br>                        <span class="hljs-keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="hljs-literal">true</span>)<br>                        newQueue.addLast(queue <span class="hljs-keyword">as</span> Runnable)<br>                        newQueue.addLast(task)<br>                        <span class="hljs-keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h2><p>上一章节说过 <code>Coroutine.launch</code> 开启协程时，如果 context 不包含 dispatcher，会自动添加默认的 dispatcher: <code>Dispatchers.Default</code>，如下示例代码</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;<br>    <span class="hljs-keyword">val</span> scope = CoroutineScope(EmptyCoroutineContext)<br>    <span class="hljs-keyword">val</span> job = scope.launch &#123;<br>        println(<span class="hljs-string">&quot;Thread name: <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br>    job.join()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从下面的代码可以看到 <code>Dispatchers.Default</code> 最终是通过 <code>CoroutineScheduler</code> 进行任务调度的，<code>CoroutineScheduler</code> 的代码量比较大这里就不深入分析了，但从它的构造函数参数 <code>corePoolSize</code>、<code>maxPoolSize</code> 和 <code>idleWorkerKeepAliveNs</code> 这些熟悉的概念可以看出它是个 <a href="../../../../2021/02/19/threadpool/">线程池</a></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The default [CoroutineDispatcher] that is used by all standard builders like</span><br><span class="hljs-comment">     * [launch][CoroutineScope.launch], [async][CoroutineScope.async], etc</span><br><span class="hljs-comment">     * if no dispatcher nor any other [ContinuationInterceptor] is specified in their context.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * It is backed by a shared pool of threads on JVM. By default, the maximal level of parallelism used</span><br><span class="hljs-comment">     * by this dispatcher is equal to the number of CPU cores, but is at least two.</span><br><span class="hljs-comment">     * Level of parallelism X guarantees that no more than X tasks can be executed in this dispatcher in parallel.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@JvmStatic</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> Default: CoroutineDispatcher = createDefaultDispatcher()<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDefaultDispatcher</span><span class="hljs-params">()</span></span>: CoroutineDispatcher =<br>    <span class="hljs-keyword">if</span> (useCoroutinesScheduler) DefaultScheduler <span class="hljs-keyword">else</span> CommonPool<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher()<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExperimentalCoroutineDispatcher</span></span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> schedulerName: String = <span class="hljs-string">&quot;CoroutineScheduler&quot;</span><br>) : ExecutorCoroutineDispatcher() &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<br>        corePoolSize: <span class="hljs-built_in">Int</span> = CORE_POOL_SIZE,<br>        maxPoolSize: <span class="hljs-built_in">Int</span> = MAX_POOL_SIZE,<br>        schedulerName: String = DEFAULT_SCHEDULER_NAME<br>    ) : <span class="hljs-keyword">this</span>(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS, schedulerName)<br><br>    <span class="hljs-meta">@Deprecated(message = <span class="hljs-meta-string">&quot;Binary compatibility for Ktor 1.0-beta&quot;</span>, level = DeprecationLevel.HIDDEN)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<br>        corePoolSize: <span class="hljs-built_in">Int</span> = CORE_POOL_SIZE,<br>        maxPoolSize: <span class="hljs-built_in">Int</span> = MAX_POOL_SIZE<br>    ) : <span class="hljs-keyword">this</span>(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> executor: Executor<br>        <span class="hljs-keyword">get</span>() = coroutineScheduler<br><br>    <span class="hljs-comment">// This is variable for test purposes, so that we can reinitialize from clean state</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> coroutineScheduler = createScheduler()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span>: <span class="hljs-built_in">Unit</span> =<br>        <span class="hljs-keyword">try</span> &#123;<br>            coroutineScheduler.dispatch(block)<br>        &#125; <span class="hljs-keyword">catch</span> (e: RejectedExecutionException) &#123;<br>            <span class="hljs-comment">// CoroutineScheduler only rejects execution when it is being closed and this behavior is reserved</span><br>            <span class="hljs-comment">// for testing purposes, so we don&#x27;t have to worry about cancelling the affected Job here.</span><br>            DefaultExecutor.dispatch(context, block)<br>        &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createScheduler</span><span class="hljs-params">()</span></span> = CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)        <br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineScheduler</span></span>(<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME<br>) : Executor, Closeable<br></code></pre></div></td></tr></table></figure><h2 id="Dispatchers-IO"><a href="#Dispatchers-IO" class="headerlink" title="Dispatchers.IO"></a>Dispatchers.IO</h2><p><code>Dispatchers.IO</code> 如注释所说的，是一个用以承载阻塞型 IO 操作的线程池，线程池是由上面说的 <code>CoroutineScheduler</code> 实现的，而它本身之所以叫做 <code>LimitingDispatcher</code> 是因为它限制了并发任务数为 64：</p><ul><li><code>inFlightTasks</code> 记录了并发任务数，如果小于阈值 <code>parallelism</code>（默认 64）则提交到线程池</li><li>否则将任务放到任务队列 <code>queue: ConcurrentLinkedQueue</code> 里，等提交到线程池的任务执行完自身逻辑，空出一个并发任务的位置后，再从 <code>queue</code> 里取一个等待中的任务提交到线程池</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The [CoroutineDispatcher] that is designed for offloading blocking IO tasks to a shared pool of threads.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Additional threads in this pool are created and are shutdown on demand.</span><br><span class="hljs-comment">     * The number of threads used by tasks in this dispatcher is limited by the value of</span><br><span class="hljs-comment">     * `kotlinx.coroutines.io.parallelism`&quot; ([IO_PARALLELISM_PROPERTY_NAME]) system property.</span><br><span class="hljs-comment">     * It defaults to the limit of 64 threads or the number of cores (whichever is larger).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Moreover, the maximum configurable number of threads is capped by the</span><br><span class="hljs-comment">     * `kotlinx.coroutines.scheduler.max.pool.size` system property.</span><br><span class="hljs-comment">     * If you need a higher number of parallel threads,</span><br><span class="hljs-comment">     * you should use a custom dispatcher backed by your own thread pool.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * ### Implementation note</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * This dispatcher shares threads with the [Default][Dispatchers.Default] dispatcher, so using</span><br><span class="hljs-comment">     * `withContext(Dispatchers.IO) &#123; ... &#125;` when already running on the [Default][Dispatchers.Default]</span><br><span class="hljs-comment">     * dispatcher does not lead to an actual switching to another thread &amp;mdash; typically execution</span><br><span class="hljs-comment">     * continues in the same thread.</span><br><span class="hljs-comment">     * As a result of thread sharing, more than 64 (default parallelism) threads can be created (but not used)</span><br><span class="hljs-comment">     * during operations over IO dispatcher.</span><br><span class="hljs-comment">     */</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = DefaultScheduler.IO<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher() &#123;<br>    <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = LimitingDispatcher(<br>        <span class="hljs-keyword">this</span>,<br>        systemProp(IO_PARALLELISM_PROPERTY_NAME, <span class="hljs-number">64.</span>coerceAtLeast(AVAILABLE_PROCESSORS)), <span class="hljs-comment">// 64</span><br>        <span class="hljs-string">&quot;Dispatchers.IO&quot;</span>,<br>        TASK_PROBABLY_BLOCKING <span class="hljs-comment">// 1</span><br>    )<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitingDispatcher</span></span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: ExperimentalCoroutineDispatcher,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parallelism: <span class="hljs-built_in">Int</span>,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> taskMode: <span class="hljs-built_in">Int</span><br>) : ExecutorCoroutineDispatcher(), TaskContext, Executor &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ConcurrentLinkedQueue&lt;Runnable&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> inFlightTasks = atomic(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> executor: Executor<br>        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">(command: <span class="hljs-type">Runnable</span>)</span></span> = dispatch(command, <span class="hljs-literal">false</span>)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> = dispatch(block, <span class="hljs-literal">false</span>)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: <span class="hljs-type">Runnable</span>, tailDispatch: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> taskToSchedule = block<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// Commit in-flight tasks slot</span><br>            <span class="hljs-keyword">val</span> inFlight = inFlightTasks.incrementAndGet()<br><br>            <span class="hljs-comment">// Fast path, if parallelism limit is not reached, dispatch task and return</span><br>            <span class="hljs-keyword">if</span> (inFlight &lt;= parallelism) &#123;<br>                dispatcher.dispatchWithContext(taskToSchedule, <span class="hljs-keyword">this</span>, tailDispatch)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            <span class="hljs-comment">// Parallelism limit is reached, add task to the queue</span><br>            queue.add(taskToSchedule)<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * We&#x27;re not actually scheduled anything, so rollback committed in-flight task slot:</span><br><span class="hljs-comment">             * If the amount of in-flight tasks is still above the limit, do nothing</span><br><span class="hljs-comment">             * If the amount of in-flight tasks is lesser than parallelism, then</span><br><span class="hljs-comment">             * it&#x27;s a race with a thread which finished the task from the current context, we should resubmit the first task from the queue</span><br><span class="hljs-comment">             * to avoid starvation.</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * Race example #1 (TN is N-th thread, R is current in-flight tasks number), execution is sequential:</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * T1: submit task, start execution, R == 1</span><br><span class="hljs-comment">             * T2: commit slot for next task, R == 2</span><br><span class="hljs-comment">             * T1: finish T1, R == 1</span><br><span class="hljs-comment">             * T2: submit next task to local queue, decrement R, R == 0</span><br><span class="hljs-comment">             * Without retries, task from T2 will be stuck in the local queue</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (inFlightTasks.decrementAndGet() &gt;= parallelism) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            taskToSchedule = queue.poll() ?: <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchYield</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>        dispatch(block, tailDispatch = <span class="hljs-literal">true</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> name ?: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;super.toString()&#125;</span>[dispatcher = <span class="hljs-variable">$dispatcher</span>]&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tries to dispatch tasks which were blocked due to reaching parallelism limit if there is any.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Implementation note: blocking tasks are scheduled in a fair manner (to local queue tail) to avoid</span><br><span class="hljs-comment">     * non-blocking continuations starvation.</span><br><span class="hljs-comment">     * E.g. for</span><br><span class="hljs-comment">     * ```</span><br><span class="hljs-comment">     * foo()</span><br><span class="hljs-comment">     * blocking()</span><br><span class="hljs-comment">     * bar()</span><br><span class="hljs-comment">     * ```</span><br><span class="hljs-comment">     * it&#x27;s more profitable to execute bar at the end of `blocking` rather than pending blocking task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterTask</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> next = queue.poll()<br>        <span class="hljs-comment">// If we have pending tasks in current blocking context, dispatch first</span><br>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>            dispatcher.dispatchWithContext(next, <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        inFlightTasks.decrementAndGet()<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Re-poll again and try to submit task if it&#x27;s required otherwise tasks may be stuck in the local queue.</span><br><span class="hljs-comment">         * Race example #2 (TN is N-th thread, R is current in-flight tasks number), execution is sequential:</span><br><span class="hljs-comment">         * T1: submit task, start execution, R == 1</span><br><span class="hljs-comment">         * T2: commit slot for next task, R == 2</span><br><span class="hljs-comment">         * T1: finish T1, poll queue (it&#x27;s still empty), R == 2</span><br><span class="hljs-comment">         * T2: submit next task to the local queue, decrement R, R == 1</span><br><span class="hljs-comment">         * T1: decrement R, finish. R == 0</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * The task from T2 is stuck is the local queue</span><br><span class="hljs-comment">         */</span><br>        next = queue.poll() ?: <span class="hljs-keyword">return</span><br>        dispatch(next, <span class="hljs-literal">true</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h2><p><code>Dispatchers.Main</code> 在 Android 代表主线程，也就说这个调度器会把任务放到主线程执行：<code>Handler.post</code></p><p>值得注意的是这里创建的是 <code>Async Handler</code>，<code>Async Handler</code> 创建的 <code>Message</code> 都是异步的：<code>Message.isAsynchronous() == true</code>，也就是说通过 <code>Dispatchers.Main</code> 调度的任务不会受到 <a href="../../../../2020/09/27/handler-messagequeue-looper/">同步栅栏</a> 的影响</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A coroutine dispatcher that is confined to the Main thread operating with UI objects.</span><br><span class="hljs-comment">     * This dispatcher can be used either directly or via [MainScope] factory.</span><br><span class="hljs-comment">     * Usually such dispatcher is single-threaded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Access to this property may throw [IllegalStateException] if no main thread dispatchers are present in the classpath.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Depending on platform and classpath it can be mapped to different dispatchers:</span><br><span class="hljs-comment">     * - On JS and Native it is equivalent of [Default] dispatcher.</span><br><span class="hljs-comment">     * - On JVM it is either Android main thread dispatcher, JavaFx or Swing EDT dispatcher. It is chosen by</span><br><span class="hljs-comment">     *   [`ServiceLoader`](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * In order to work with `Main` dispatcher, the following artifacts should be added to project runtime dependencies:</span><br><span class="hljs-comment">     *  - `kotlinx-coroutines-android` for Android Main thread dispatcher</span><br><span class="hljs-comment">     *  - `kotlinx-coroutines-javafx` for JavaFx Application thread dispatcher</span><br><span class="hljs-comment">     *  - `kotlinx-coroutines-swing` for Swing EDT dispatcher</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * In order to set a custom `Main` dispatcher for testing purposes, add the `kotlinx-coroutines-test` artifact to </span><br><span class="hljs-comment">     * project test dependencies.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Implementation note: [MainCoroutineDispatcher.immediate] is not supported on Native and JS platforms.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@JvmStatic</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> Main: MainCoroutineDispatcher <span class="hljs-keyword">get</span>() = MainDispatcherLoader.dispatcher<br>&#125;<br><br><span class="hljs-comment">// Lazy loader for the main dispatcher</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> MainDispatcherLoader &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> FAST_SERVICE_LOADER_ENABLED = systemProp(FAST_SERVICE_LOADER_PROPERTY_NAME, <span class="hljs-literal">true</span>)<br><br>    <span class="hljs-meta">@JvmField</span><br>    <span class="hljs-keyword">val</span> dispatcher: MainCoroutineDispatcher = loadMainDispatcher()<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcher</span><span class="hljs-params">()</span></span>: MainCoroutineDispatcher &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;<br>                FastServiceLoader.loadMainDispatcherFactory()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We are explicitly using the</span><br>                <span class="hljs-comment">// `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`</span><br>                <span class="hljs-comment">// form of the ServiceLoader call to enable R8 optimization when compiled on Android.</span><br>                ServiceLoader.load(<br>                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java,<br>                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java.classLoader<br>                ).iterator().asSequence().toList()<br>            &#125;<br>            <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;ConstantConditionIf&quot;</span>)</span><br>            factories.maxByOrNull &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)<br>                ?: createMissingDispatcher()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            <span class="hljs-comment">// Service loader can throw an exception as well</span><br>            createMissingDispatcher(e)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidDispatcherFactory</span> : <span class="hljs-type">MainDispatcherFactory &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(allFactories: <span class="hljs-type">List</span>&lt;<span class="hljs-type">MainDispatcherFactory</span>&gt;)</span></span> =<br>        HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>))<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Looper.<span class="hljs-title">asHandler</span><span class="hljs-params">(async: <span class="hljs-type">Boolean</span>)</span></span>: Handler &#123;<br>    <span class="hljs-comment">// Async support was added in API 16.</span><br>    <span class="hljs-keyword">if</span> (!async || Build.VERSION.SDK_INT &lt; <span class="hljs-number">16</span>) &#123;<br>        <span class="hljs-keyword">return</span> Handler(<span class="hljs-keyword">this</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">28</span>) &#123;<br>        <span class="hljs-comment">// TODO compile against API 28 so this can be invoked without reflection.</span><br>        <span class="hljs-keyword">val</span> factoryMethod = Handler::<span class="hljs-keyword">class</span>.java.getDeclaredMethod(<span class="hljs-string">&quot;createAsync&quot;</span>, Looper::<span class="hljs-keyword">class</span>.java)<br>        <span class="hljs-keyword">return</span> factoryMethod.invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>) <span class="hljs-keyword">as</span> Handler<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">constructor</span>: Constructor&lt;Handler&gt;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">constructor</span> = Handler::<span class="hljs-keyword">class</span>.java.getDeclaredConstructor(Looper::<span class="hljs-keyword">class</span>.java,<br>            Handler.Callback::<span class="hljs-keyword">class</span>.java, <span class="hljs-built_in">Boolean</span>::<span class="hljs-keyword">class</span>.javaPrimitiveType)<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: NoSuchMethodException) &#123;<br>        <span class="hljs-comment">// Hidden constructor absent. Fall back to non-async constructor.</span><br>        <span class="hljs-keyword">return</span> Handler(<span class="hljs-keyword">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">constructor</span>.newInstance(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span><br>) : HandlerDispatcher(), Delay &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!handler.post(block)) &#123;<br>            cancelOnRejection(context, block)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="delay-非阻塞"><a href="#delay-非阻塞" class="headerlink" title="delay - 非阻塞"></a>delay - 非阻塞</h1><blockquote><p>Delays coroutine for a given time without blocking a thread and resumes it after a specified time.</p></blockquote><p>正如 <code>delay</code> 的函数文档所说，它是 <code>non-blocking</code> 的，那什么是非阻塞呢？如下代码所示，上面说过 <code>launch coroutine</code> 其实就是任务调度，下面的两个 <code>launch</code> 一共往任务队列放进两个任务，而 <code>runBlocking</code> 底层是单个线程，故两个任务是串行的：先执行 <code>delay(1000)</code> 再执行 <code>delay(500)</code>；然而 <code>500</code> 却先于 <code>1000</code> 输出，说明 <code>delay(1000)</code> 确实没有阻塞线程</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = runBlocking &#123;<br>    launch &#123;<br>        delay(<span class="hljs-number">1000</span>)<br>        println(<span class="hljs-string">&quot;1000&quot;</span>)<br>    &#125;<br>    launch &#123;<br>        delay(<span class="hljs-number">500</span>)<br>        println(<span class="hljs-string">&quot;500&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// 500</span><br><span class="hljs-comment">// 1000</span><br></code></pre></div></td></tr></table></figure><p>跟踪 <code>delay</code> 看看它是怎么实现的，但到 <code>suspendCoroutineUninterceptedOrReturn</code> 就走不下去了因为这个函数并没有什么实质的 body，那就直接看编译后的字节码吧</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// don&#x27;t delay</span><br>    <span class="hljs-keyword">return</span> suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;<br>        <span class="hljs-comment">// if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don&#x27;t schedule.</span><br>        <span class="hljs-keyword">if</span> (timeMillis &lt; <span class="hljs-built_in">Long</span>.MAX_VALUE) &#123;<br>            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: T =<br>    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;<br>        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * For non-atomic cancellation we setup parent-child relationship immediately</span><br><span class="hljs-comment">         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but</span><br><span class="hljs-comment">         * properly supports cancellation.</span><br><span class="hljs-comment">         */</span><br>        cancellable.initCancellability()<br>        block(cancellable)<br>        cancellable.getResult()<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutineUninterceptedOrReturn</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Any</span>?)</span></span>: T &#123;<br>    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;<br>    <span class="hljs-keyword">throw</span> NotImplementedError(<span class="hljs-string">&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;</span>)<br>&#125;    <br></code></pre></div></td></tr></table></figure><p>用 <code>bytecode-viewer</code> 打开如下，关键代码是这一行：<code>getDelay(cont.getContext()).scheduleResumeAfterDelay(timeMillis, cont)</code></p><ul><li>从 context 里取 <code>Delay</code>，key 是 <code>ContinuationInterceptor.Key</code>，咦这不就是上一章节讨论的 <code>Dispatcher</code> 的 key 嘛！也就是说 <code>delay</code> 有可能是由 Dispatcher 实现的</li><li>如果 Dispatcher 没有实现 <code>Delay</code> 接口则由 <code>DefaultDelay</code> 负责</li></ul><p>那么就一个个 Dispatcher 地看吧</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example_basic_01Kt</span>$<span class="hljs-title">main</span>$1$1 <span class="hljs-keyword">extends</span> <span class="hljs-title">SuspendLambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Function2</span> </span>&#123;<br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> </span>&#123;<br>      Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>.label) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         ResultKt.throwOnFailure($result);<br>         Continuation var10001 = (Continuation)<span class="hljs-keyword">this</span>;<br>         <span class="hljs-keyword">this</span>.label = <span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">if</span> (DelayKt.delay(<span class="hljs-number">1000L</span>, var10001) == var4) &#123;<br>            <span class="hljs-keyword">return</span> var4;<br>         &#125;<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         ResultKt.throwOnFailure($result);<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>      &#125;<br><br>      String var2 = <span class="hljs-string">&quot;1000&quot;</span>;<br>      <span class="hljs-keyword">boolean</span> var3 = <span class="hljs-keyword">false</span>;<br>      System.out.println(var2);<br>      <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayKt</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeMillis, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0L</span>) &#123;<br>         <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">int</span> $i$f$suspendCancellableCoroutine = <span class="hljs-keyword">false</span>;<br>         <span class="hljs-keyword">int</span> var5 = <span class="hljs-keyword">false</span>;<br>         CancellableContinuationImpl cancellable$iv = <span class="hljs-keyword">new</span> CancellableContinuationImpl(IntrinsicsKt.intercepted($completion), <span class="hljs-number">1</span>);<br>         cancellable$iv.initCancellability();<br>         CancellableContinuation cont = (CancellableContinuation)cancellable$iv;<br>         <span class="hljs-keyword">int</span> var8 = <span class="hljs-keyword">false</span>;<br>         <span class="hljs-keyword">if</span> (timeMillis &lt; Long.MAX_VALUE) &#123;<br>            getDelay(cont.getContext()).scheduleResumeAfterDelay(timeMillis, cont);<br>         &#125;<br><br>         Object var10000 = cancellable$iv.getResult();<br>         <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;<br>            DebugProbesKt.probeCoroutineSuspended($completion);<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED() ? var10000 : Unit.INSTANCE;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Delay <span class="hljs-title">getDelay</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineContext $<span class="hljs-keyword">this</span>$delay)</span> </span>&#123;<br>      Element var2 = $<span class="hljs-keyword">this</span>$delay.get((Key)ContinuationInterceptor.Key);<br>      Delay var1 = var2 <span class="hljs-keyword">instanceof</span> Delay ? (Delay)var2 : <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">return</span> var1 == <span class="hljs-keyword">null</span> ? DefaultExecutorKt.getDefaultDelay() : var1;<br>   &#125;<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="BlockingEventLoop"><a href="#BlockingEventLoop" class="headerlink" title="BlockingEventLoop"></a>BlockingEventLoop</h2><p>block 被层层包装为 <code>DelayedResumeTask</code> 并被放入 <code>_delayed: atomic&lt;DelayedTaskQueue?&gt;</code>，等待在 <code>delay</code> 毫秒后重新调度，类似于 <code>Handler.postDelayed(r, delayMillis)</code>，可重新调度任务后 block 不就重新被执行了一遍吗？</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingEventLoop</span></span>(<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> thread: Thread<br>) : EventLoopImplBase()<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopImplBase</span>: <span class="hljs-type">EventLoopImplPlatform</span></span>(), Delay &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)<br>        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;<br>            <span class="hljs-keyword">val</span> now = nanoTime()<br>            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt;<br>                continuation.disposeOnCancellation(task)<br>                schedule(now, task)<br>            &#125;<br>        &#125;<br>    &#125;     <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayedTask: <span class="hljs-type">DelayedTask</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (scheduleImpl(now, delayedTask)) &#123;<br>            SCHEDULE_OK -&gt; <span class="hljs-keyword">if</span> (shouldUnpark(delayedTask)) unpark()<br>            SCHEDULE_COMPLETED -&gt; reschedule(now, delayedTask)<br>            SCHEDULE_DISPOSED -&gt; &#123;&#125; <span class="hljs-comment">// do nothing -- task was already disposed</span><br>            <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;unexpected result&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleImpl</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayedTask: <span class="hljs-type">DelayedTask</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span> SCHEDULE_COMPLETED<br>        <span class="hljs-keyword">val</span> delayedQueue = _delayed.value ?: run &#123;<br>            _delayed.compareAndSet(<span class="hljs-literal">null</span>, DelayedTaskQueue(now))<br>            _delayed.value!!<br>        &#125;<br>        <span class="hljs-keyword">return</span> delayedTask.scheduleTask(now, delayedQueue, <span class="hljs-keyword">this</span>)<br>    &#125;        <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedTask</span> </span>&#123;<br>    <span class="hljs-meta">@Synchronized</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleTask</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayed: <span class="hljs-type">DelayedTaskQueue</span>, eventLoop: <span class="hljs-type">EventLoopImplBase</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">if</span> (_heap === DISPOSED_TASK) <span class="hljs-keyword">return</span> SCHEDULE_DISPOSED <span class="hljs-comment">// don&#x27;t add -- was already disposed</span><br>        delayed.addLastIf(<span class="hljs-keyword">this</span>) &#123; firstTask -&gt;<br>            <span class="hljs-keyword">if</span> (eventLoop.isCompleted) <span class="hljs-keyword">return</span> SCHEDULE_COMPLETED <span class="hljs-comment">// non-local return from scheduleTask</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * We are about to add new task and we have to make sure that [DelayedTaskQueue]</span><br><span class="hljs-comment">             * invariant is maintained. The code in this lambda is additionally executed under</span><br><span class="hljs-comment">             * the lock of [DelayedTaskQueue] and working with [DelayedTaskQueue.timeNow] here is thread-safe.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (firstTask == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * When adding the first delayed task we simply update queue&#x27;s [DelayedTaskQueue.timeNow] to</span><br><span class="hljs-comment">                 * the current now time even if that means &quot;going backwards in time&quot;. This makes the structure</span><br><span class="hljs-comment">                 * self-correcting in spite of wild jumps in `nanoTime()` measurements once all delayed tasks</span><br><span class="hljs-comment">                 * are removed from the delayed queue for execution.</span><br><span class="hljs-comment">                 */</span><br>                delayed.timeNow = now<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * Carefully update [DelayedTaskQueue.timeNow] so that it does not sweep past first&#x27;s tasks time</span><br><span class="hljs-comment">                 * and only goes forward in time. We cannot let it go backwards in time or invariant can be</span><br><span class="hljs-comment">                 * violated for tasks that were already scheduled.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">val</span> firstTime = firstTask.nanoTime<br>                <span class="hljs-comment">// compute min(now, firstTime) using a wrap-safe check</span><br>                <span class="hljs-keyword">val</span> minTime = <span class="hljs-keyword">if</span> (firstTime - now &gt;= <span class="hljs-number">0</span>) now <span class="hljs-keyword">else</span> firstTime<br>                <span class="hljs-comment">// update timeNow only when going forward in time</span><br>                <span class="hljs-keyword">if</span> (minTime - delayed.timeNow &gt; <span class="hljs-number">0</span>) delayed.timeNow = minTime<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Here [DelayedTaskQueue.timeNow] was already modified and we have to double-check that newly added</span><br><span class="hljs-comment">             * task does not violate [DelayedTaskQueue] invariant because of that. Note also that this scheduleTask</span><br><span class="hljs-comment">             * function can be called to reschedule from one queue to another and this might be another reason</span><br><span class="hljs-comment">             * where new task&#x27;s time might now violate invariant.</span><br><span class="hljs-comment">             * We correct invariant violation (if any) by simply changing this task&#x27;s time to now.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (nanoTime - delayed.timeNow &lt; <span class="hljs-number">0</span>) nanoTime = delayed.timeNow<br>            <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> SCHEDULE_OK<br>    &#125;    <br>&#125;   <br></code></pre></div></td></tr></table></figure><p>上面的例子一个 block 里只有一个 <code>delay</code>，规律不明显，添加多个 <code>delay</code> 就能看出端倪了：</p><ul><li><code>delay</code> 前的代码段被逐个编号：1, 2, 3…</li><li>引入成员属性 <code>label</code>，执行 block 时根据 <code>label</code> 的指示通过 <code>switch</code> 跳转执行各个代码段</li><li>重新调度时执行完的代码段就不会被再次执行了</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// kotlin</span><br><span class="hljs-function">fun <span class="hljs-title">main</span><span class="hljs-params">()</span>: Unit </span>= runBlocking &#123;<br>    println(<span class="hljs-number">0</span>)<br>    delay(<span class="hljs-number">100</span>)<br>    println(<span class="hljs-number">100</span>)<br>    delay(<span class="hljs-number">200</span>)<br>    println(<span class="hljs-number">200</span>)<br>    delay(<span class="hljs-number">300</span>)<br>    println(<span class="hljs-number">300</span>)<br>    delay(<span class="hljs-number">400</span>)<br>    println(<span class="hljs-number">400</span>)<br>&#125;<br><br><span class="hljs-comment">// decompile by CFR</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example_basic_01Kt</span>.<span class="hljs-title">main</span>.1</span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">SuspendLambda</span></span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">Function2</span>&lt;<span class="hljs-title">CoroutineScope</span>, <span class="hljs-title">Continuation</span>&lt;? <span class="hljs-title">super</span> <span class="hljs-title">Unit</span>&gt;, <span class="hljs-title">Object</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> label;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Unable to fully structure code</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object var1_1)</span> </span>&#123;<br>        var4_2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.label) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;<br>                ResultKt.throwOnFailure((Object)var1_1);<br>                var2_3 = <span class="hljs-number">0</span>;<br>                var3_4 = <span class="hljs-keyword">false</span>;<br>                System.out.println(var2_3);<br>                <span class="hljs-keyword">this</span>.label = <span class="hljs-number">1</span>;<br>                v0 = DelayKt.delay((<span class="hljs-keyword">long</span>)<span class="hljs-number">100L</span>, (Continuation)((Continuation)<span class="hljs-keyword">this</span>));<br>                <span class="hljs-keyword">if</span> (v0 == var4_2) &#123;<br>                    <span class="hljs-keyword">return</span> var4_2;<br>                &#125;<br>                ** GOTO lbl16<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                ResultKt.throwOnFailure((Object)$result);<br>                v0 = $result;<br>lbl16:<br>                <span class="hljs-comment">// 2 sources</span><br><br>                var2_3 = <span class="hljs-number">100</span>;<br>                var3_4 = <span class="hljs-keyword">false</span>;<br>                System.out.println(var2_3);<br>                <span class="hljs-keyword">this</span>.label = <span class="hljs-number">2</span>;<br>                v1 = DelayKt.delay((<span class="hljs-keyword">long</span>)<span class="hljs-number">200L</span>, (Continuation)((Continuation)<span class="hljs-keyword">this</span>));<br>                <span class="hljs-keyword">if</span> (v1 == var4_2) &#123;<br>                    <span class="hljs-keyword">return</span> var4_2;<br>                &#125;<br>                ** GOTO lbl27<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>                ResultKt.throwOnFailure((Object)$result);<br>                v1 = $result;<br>lbl27:<br>                <span class="hljs-comment">// 2 sources</span><br><br>                var2_3 = <span class="hljs-number">200</span>;<br>                var3_4 = <span class="hljs-keyword">false</span>;<br>                System.out.println(var2_3);<br>                <span class="hljs-keyword">this</span>.label = <span class="hljs-number">3</span>;<br>                v2 = DelayKt.delay((<span class="hljs-keyword">long</span>)<span class="hljs-number">300L</span>, (Continuation)((Continuation)<span class="hljs-keyword">this</span>));<br>                <span class="hljs-keyword">if</span> (v2 == var4_2) &#123;<br>                    <span class="hljs-keyword">return</span> var4_2;<br>                &#125;<br>                ** GOTO lbl38<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>                ResultKt.throwOnFailure((Object)$result);<br>                v2 = $result;<br>lbl38:<br>                <span class="hljs-comment">// 2 sources</span><br><br>                var2_3 = <span class="hljs-number">300</span>;<br>                var3_4 = <span class="hljs-keyword">false</span>;<br>                System.out.println(var2_3);<br>                <span class="hljs-keyword">this</span>.label = <span class="hljs-number">4</span>;<br>                v3 = DelayKt.delay((<span class="hljs-keyword">long</span>)<span class="hljs-number">400L</span>, (Continuation)((Continuation)<span class="hljs-keyword">this</span>));<br>                <span class="hljs-keyword">if</span> (v3 == var4_2) &#123;<br>                    <span class="hljs-keyword">return</span> var4_2;<br>                &#125;<br>                ** GOTO lbl49<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: &#123;<br>                ResultKt.throwOnFailure((Object)$result);<br>                v3 = $result;<br>lbl49:<br>                <span class="hljs-comment">// 2 sources</span><br><br>                var2_3 = <span class="hljs-number">400</span>;<br>                var3_4 = <span class="hljs-keyword">false</span>;<br>                System.out.println(var2_3);<br>                <span class="hljs-keyword">return</span> Unit.INSTANCE;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>coroutine 本质是任务队列，而 <code>delay</code> 本质是重新调度（重新入队至 <code>EventLoopImplBase._delay</code>），通过引入成员属性 <code>label</code>，以及将各个代码段用 <code>switch</code> 分段，即可实现在重新调度时跳转到指定 <code>代码行</code> 而不重复执行前面的代码</p><h2 id="HandlerContext"><a href="#HandlerContext" class="headerlink" title="HandlerContext"></a>HandlerContext</h2><p><code>Dispatchers.Main</code> 在 Android 上是底层为单线程/主线程的 <code>HandlerContext(Looper.getMainLooper().asHandler(async = true))</code>，它实现了 <code>Delay</code>，通过 <code>Handler.postDelayed</code> 实现重新调度</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span><br>) : HandlerDispatcher(), Delay &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> block = Runnable &#123;<br>            with(continuation) &#123; resumeUndispatched(<span class="hljs-built_in">Unit</span>) &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) &#123;<br>            continuation.invokeOnCancellation &#123; handler.removeCallbacks(block) &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cancelOnRejection(continuation.context, block)<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="DefaultDelay"><a href="#DefaultDelay" class="headerlink" title="DefaultDelay"></a>DefaultDelay</h2><p><code>Dispatchers.Default</code> 和 <code>Dispatcher.IO</code> 并没有实现 <code>Delay</code> 接口，如上面反编译后的 <code>getDelay</code> 所示，是由 <code>DefaultDelay</code> 来实现的</p><p><code>EventLoopImplBase</code> 在上一章节介绍过，它实现了 <code>Delay</code> 接口，<code>EventLoopImplBase.scheduleResumeAfterDelay</code> 会将任务放入 <code>EventLoopImplBase._delay</code> 任务队列，也就是说这两个调度器上的 delay task 实际上是被放入别人的（<code>DefaultDelay</code>） delay queue 里</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> DefaultDelay: Delay = DefaultExecutor<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> DefaultExecutor : EventLoopImplBase(), Runnable<br></code></pre></div></td></tr></table></figure><p>那这些 delay task 不就被改变了 Dispatcher，跑到 <code>DefaultDelay/DefaultExecutor</code> 里执行了吗？我们从 <code>Delay.scheduleResumeAfterDelay</code> 看下去：</p><ul><li>task 被加入到 <code>_delay</code> 任务队列，然后唤醒对应的线程 <code>DefaultExecutor.run</code></li><li><code>DefaultExecutor</code> 将 <code>_delay</code> 里第一个到执行时间点的 task 转移到任务队列 <code>_queue</code> 并执行</li></ul><p>而任务队列里的 <code>Runnable</code> 实际上是 <code>DispatchedContinuation</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopImplBase</span>: <span class="hljs-type">EventLoopImplPlatform</span></span>(), Delay &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)<br>        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;<br>            <span class="hljs-keyword">val</span> now = nanoTime()<br>            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt;<br>                continuation.disposeOnCancellation(task)<br>                schedule(now, task)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayedTask: <span class="hljs-type">DelayedTask</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (scheduleImpl(now, delayedTask)) &#123;<br>            SCHEDULE_OK -&gt; <span class="hljs-keyword">if</span> (shouldUnpark(delayedTask)) unpark()<br>            SCHEDULE_COMPLETED -&gt; reschedule(now, delayedTask)<br>            SCHEDULE_DISPOSED -&gt; &#123;&#125; <span class="hljs-comment">// do nothing -- task was already disposed</span><br>            <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;unexpected result&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldUnpark</span><span class="hljs-params">(task: <span class="hljs-type">DelayedTask</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = _delayed.value?.peek() === task    <br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopImplPlatform</span>: <span class="hljs-type">EventLoop</span></span>() &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> thread: Thread<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> thread = thread <span class="hljs-comment">// atomic read</span><br>        <span class="hljs-keyword">if</span> (Thread.currentThread() !== thread)<br>            unpark(thread)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> DefaultExecutor: EventLoopImplBase(), Delay &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        ThreadLocalEventLoop.setEventLoop(<span class="hljs-keyword">this</span>)<br>        registerTimeLoopThread()<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> shutdownNanos = <span class="hljs-built_in">Long</span>.MAX_VALUE<br>            <span class="hljs-keyword">if</span> (!notifyStartup()) <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                Thread.interrupted() <span class="hljs-comment">// just reset interruption flag</span><br>                <span class="hljs-keyword">var</span> parkNanos = processNextEvent()<br>                <span class="hljs-keyword">if</span> (parkNanos == <span class="hljs-built_in">Long</span>.MAX_VALUE) &#123;<br>                    <span class="hljs-comment">// nothing to do, initialize shutdown timeout</span><br>                    <span class="hljs-keyword">val</span> now = nanoTime()<br>                    <span class="hljs-keyword">if</span> (shutdownNanos == <span class="hljs-built_in">Long</span>.MAX_VALUE) shutdownNanos = now + KEEP_ALIVE_NANOS<br>                    <span class="hljs-keyword">val</span> tillShutdown = shutdownNanos - now<br>                    <span class="hljs-keyword">if</span> (tillShutdown &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// shut thread down</span><br>                    parkNanos = parkNanos.coerceAtMost(tillShutdown)<br>                &#125; <span class="hljs-keyword">else</span><br>                    shutdownNanos = <span class="hljs-built_in">Long</span>.MAX_VALUE<br>                <span class="hljs-keyword">if</span> (parkNanos &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// check if shutdown was requested and bail out in this case</span><br>                    <span class="hljs-keyword">if</span> (isShutdownRequested) <span class="hljs-keyword">return</span><br>                    parkNanos(<span class="hljs-keyword">this</span>, parkNanos)<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            _thread = <span class="hljs-literal">null</span> <span class="hljs-comment">// this thread is dead</span><br>            acknowledgeShutdownIfNeeded()<br>            unregisterTimeLoopThread()<br>            <span class="hljs-comment">// recheck if queues are empty after _thread reference was set to null (!!!)</span><br>            <span class="hljs-keyword">if</span> (!isEmpty) thread <span class="hljs-comment">// recreate thread if it is needed</span><br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopImplBase</span>: <span class="hljs-type">EventLoopImplPlatform</span></span>(), Delay &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processNextEvent</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>        <span class="hljs-comment">// unconfined events take priority</span><br>        <span class="hljs-keyword">if</span> (processUnconfinedEvent()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-comment">// queue all delayed tasks that are due to be executed</span><br>        <span class="hljs-keyword">val</span> delayed = _delayed.value<br>        <span class="hljs-keyword">if</span> (delayed != <span class="hljs-literal">null</span> &amp;&amp; !delayed.isEmpty) &#123;<br>            <span class="hljs-keyword">val</span> now = nanoTime()<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// make sure that moving from delayed to queue removes from delayed only after it is added to queue</span><br>                <span class="hljs-comment">// to make sure that &#x27;isEmpty&#x27; and `nextTime` that check both of them</span><br>                <span class="hljs-comment">// do not transiently report that both delayed and queue are empty during move</span><br>                delayed.removeFirstIf &#123;<br>                    <span class="hljs-keyword">if</span> (it.timeToExecute(now)) &#123;<br>                        enqueueImpl(it)<br>                    &#125; <span class="hljs-keyword">else</span><br>                        <span class="hljs-literal">false</span><br>                &#125; ?: <span class="hljs-keyword">break</span> <span class="hljs-comment">// quit loop when nothing more to remove or enqueueImpl returns false on &quot;isComplete&quot;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// then process one event from queue</span><br>        <span class="hljs-keyword">val</span> task = dequeue()<br>        <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>            task.run()<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> nextTime<br>    &#125;     <br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面曾经说过 block 会经过重重包装，其中一层就是 <code>DispatchedContinuation</code>，它也是一个 <code>Runnable</code>（被 <code>DefaultExecutor</code> 执行）：<code>SchedulerTask.run</code> -&gt;  <code>DispatchedContinuation.resumeWith</code> -&gt; <code>CoroutineDispatcher.dispatch</code></p><p>也就说 <code>DispatchedContinuation</code> = <code>CoroutineDispatcher</code> + <code>Continuation</code>，它被执行时是将任务交由对应的 Dispatcher 执行而不是由当前的线程执行（正如它的名字描述的那样），同时也实现了一个很重要的概念：<code>线程切换</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatchedContinuation</span>&lt;<span class="hljs-type">in T</span>&gt;</span>(<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> dispatcher: CoroutineDispatcher,<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;<br>) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatchedTask</span>&lt;<span class="hljs-type">in T</span>&gt;</span>(<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> resumeMode: <span class="hljs-built_in">Int</span><br>) : SchedulerTask() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        assert &#123; resumeMode != MODE_UNINITIALIZED &#125; <span class="hljs-comment">// should have been set before dispatching</span><br>        <span class="hljs-keyword">val</span> taskContext = <span class="hljs-keyword">this</span>.taskContext<br>        <span class="hljs-keyword">var</span> fatalException: Throwable? = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> delegate = delegate <span class="hljs-keyword">as</span> DispatchedContinuation&lt;T&gt;<br>            <span class="hljs-keyword">val</span> continuation = delegate.continuation<br>            withContinuationContext(continuation, delegate.countOrElement) &#123;<br>                <span class="hljs-keyword">val</span> context = continuation.context<br>                <span class="hljs-keyword">val</span> state = takeState() <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Must take state in any case, even if cancelled</span><br>                <span class="hljs-keyword">val</span> exception = getExceptionalResult(state)<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * Check whether continuation was originally resumed with an exception.</span><br><span class="hljs-comment">                 * If so, it dominates cancellation, otherwise the original exception</span><br><span class="hljs-comment">                 * will be silently lost.</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) &#123;<br>                    <span class="hljs-keyword">val</span> cause = job.getCancellationException()<br>                    cancelCompletedResult(state, cause)<br>                    continuation.resumeWithStackTrace(cause)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>                        continuation.resumeWithException(exception)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        continuation.resume(getSuccessfulResult(state))<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            <span class="hljs-comment">// This instead of runCatching to have nicer stacktrace and debug experience</span><br>            fatalException = e<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;<br>            handleFatalException(fatalException, result.exceptionOrNull())<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.success(value))<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatchedContinuation</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> context = continuation.context<br>        <span class="hljs-keyword">val</span> state = result.toState()<br>        <span class="hljs-keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;<br>            _state = state<br>            resumeMode = MODE_ATOMIC<br>            dispatcher.dispatch(context, <span class="hljs-keyword">this</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            executeUnconfined(state, MODE_ATOMIC) &#123;<br>                withCoroutineContext(<span class="hljs-keyword">this</span>.context, countOrElement) &#123;<br>                    continuation.resumeWith(result)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;    <br></code></pre></div></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>coroutine API 很多都需要上下文 context，但作为参数传来穿去总是麻烦，于是有了 <code>CoroutineScope</code> 用以承载上下文：</p><ul><li><code>runBlocking</code> - 用当前线程作为调度器，会阻塞代码的执行直到所有协程都执行完毕</li><li><code>CoroutineScope(EmptyCoroutineContext|Dispatchers.Main|Dispatchers.IO|...)</code> - 构造 scope，使用指定的上下文/调度器，如果上下文里不包含调度器则使用默认的 <code>Dispatchers.Default</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The context of this scope.</span><br><span class="hljs-comment">     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.</span><br><span class="hljs-comment">     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>coroutine</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 ANR：产生的根源、处理流程和日志文件</title>
    <link href="/2021/07/10/deep-drive-into-anr/"/>
    <url>/2021/07/10/deep-drive-into-anr/</url>
    
    <content type="html"><![CDATA[<h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>在 <a href="../../../../2020/10/20/anr/">阅读源码系列：ANR 是怎么产生的</a> 聊过不及时消费 input event 会产生 <code>ANR</code>：</p><ol><li><code>InputReaderThread</code> 不断地从 <code>/dev/input</code> 读取 input event 并放入 <code>InputDispatcher.mInboundQueue</code> 等待分发</li><li><code>InputDispatcher</code> 寻找 input event 对应的 window 并分发到它的待发送队列里（<code>outboundQueue</code>）</li><li>input event 通过 socket 发送给 app process 后转移到待消费队列（<code>waitQueue</code>）</li><li>app main thread 在 <code>Choreographer.doFrame</code> 渲染一帧时首先会响应 input event 并通过 socket 告诉 <code>InputDispatcher</code> 从待消费队列里移除</li><li>在执行第二步的过程中，如果发现 window 存在有未消费的 input event 则产生 ANR</li></ol><p><code>产生 ANR - 输出 ANR 日志 - 弹出 ANR 对话框</code> 整个流程的方法栈如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">InputDispatcher::start</span><br><span class="hljs-function">InputDispatcher::dispatchOnce</span><br><span class="hljs-function">InputDispatcher::processAnrsLocked</span><br><span class="hljs-function"><span class="hljs-title">InputDispatcher::onAnrLocked</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Connection&amp; connection)</span></span><br><span class="hljs-function">InputDispatcher::doNotifyAnrLockedInterruptible</span><br><span class="hljs-function">NativeInputManager::notifyAnr</span><br><span class="hljs-function">InputManagerService.<span class="hljs-title">notifyANR</span><span class="hljs-params">(InputApplicationHandle inputApplicationHandle, IBinder token, String reason)</span></span><br><span class="hljs-function">InputManagerCallback.notifyANR</span><br><span class="hljs-function">InputManagerCallback.notifyANRInner</span><br><span class="hljs-function">ActivityManagerService.inputDispatchingTimedOut</span><br><span class="hljs-function">AnrHelper.appNotResponding</span><br><span class="hljs-function">AnrRecord.appNotResponding</span><br><span class="hljs-function">ProcessErrorStateRecord.appNotResponding</span><br><span class="hljs-function">ActivityManagerService.UiHandler.<span class="hljs-title">handleMessage</span><span class="hljs-params">(SHOW_NOT_RESPONDING_UI_MSG)</span></span><br><span class="hljs-function">AppErrors.handleShowAnrUi</span><br><span class="hljs-function">ProcessRecord.ErrorDialogController.showAnrDialogs</span><br></code></pre></div></td></tr></table></figure><h1 id="logcat-system"><a href="#logcat-system" class="headerlink" title="logcat system"></a>logcat system</h1><blockquote><p><code>adb logcat -v threadtime &gt; logcat</code></p><p><code>-b</code> 指定 ring buffer，默认是 <code>main</code>, <code>system</code> 和 <code>crash</code></p></blockquote><p>从上面的代码可以看到 logcat system 里会输出一段 ANR 日志如下，包含以下几部分的信息（它们的次序可能会有所变化）：</p><ol><li><code>ANR</code> 关键字</li><li>发生 ANR 的 app process name 及 android component name</li><li>app process id</li><li>原因/描述（看得出来这是由于没有及时消费 input event 而产生的 ANR）</li><li>parent component (?)</li><li><code>Load: 0.17 / 0.44 / 0.71</code> 读取自 <code>/proc/loadavg</code>，表示 1, 5 和 15 分钟内的系统平均负载</li><li>内存压力统计信息（Pressure Stall Information），读取自 <code>/proc/pressure/memory</code>，表示任务阻塞在内存资源上的总时长</li><li>最近几个采集点之间的 CPU 使用率（CPU Usage）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log"># from mi 9<br>09-29 16:03:03.457  1763 29602 E ActivityManager: ANR in com.example.myapplication (com.example.myapplication/.MainActivity)<br>09-29 16:03:03.457  1763 29602 E ActivityManager: PID: 27750<br>09-29 16:03:03.457  1763 29602 E ActivityManager: Reason: Input dispatching timed out (com.example.myapplication/com.example.myapplication.MainActivity, 23ec514 com.example.myapplication/com.example.myapplication.MainActivity (server) is not responding. Waited 8008ms for MotionEvent(action=DOWN))<br>09-29 16:03:03.457  1763 29602 E ActivityManager: Parent: com.example.myapplication/.MainActivity<br>09-29 16:03:03.457  1763 29602 E ActivityManager: Load: 0.17 / 0.44 / 0.71<br>09-29 16:03:03.457  1763 29602 E ActivityManager: ----- Output from /proc/pressure/memory -----<br>09-29 16:03:03.457  1763 29602 E ActivityManager: some avg10=0.00 avg60=0.00 avg300=0.02 total=32995625<br>09-29 16:03:03.457  1763 29602 E ActivityManager: full avg10=0.00 avg60=0.00 avg300=0.00 total=11591183<br>09-29 16:03:03.457  1763 29602 E ActivityManager: ----- End output from /proc/pressure/memory -----<br>09-29 16:03:03.457  1763 29602 E ActivityManager:<br>09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 0ms to 14680ms later (2021-09-29 16:02:48.726 to 2021-09-29 16:03:03.406):<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   32% 8356/com.taobao.taobao: 17% user + 15% kernel / faults: 9334 minor 85 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   27% 19687/com.tencent.mm: 12% user + 15% kernel / faults: 14028 minor 129 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   13% 1763/system_server: 5.8% user + 7.5% kernel / faults: 7732 minor 29 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   12% 1464/media.codec: 8.5% user + 4.2% kernel / faults: 39180 minor 6 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   5.1% 969/surfaceflinger: 1.1% user + 3.9% kernel / faults: 582 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   4% 26354/com.xiaomi.mi_connect_service: 2.8% user + 1.1% kernel / faults: 2438 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1569/media.swcodec: 0% user + 0% kernel / faults: 21304 minor 8 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 876/media.hwcodec: 0% user + 0% kernel / faults: 6726 minor 20 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 23059/kworker/u16:10: 0% user + 2.3% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 5410/com.sohu.inputmethod.sogou: 1.3% user + 0.9% kernel / faults: 2961 minor 53 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2% 2847/com.android.phone: 1.2% user + 0.7% kernel / faults: 2180 minor 12 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 1283/adbd: 0.5% user + 1.1% kernel / faults: 3 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 1362/cnss_diag: 1.3% user + 0.3% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 22809/kworker/u16:2: 0% user + 1.7% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.2% 22965/kworker/u16:7: 0% user + 1.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1410/media.extractor: 0% user + 0% kernel / faults: 4053 minor 8 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1% 2239/cds_ol_rx_threa: 0% user + 1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1% 21236/kworker/u16:3: 0% user + 1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.9% 22805/kworker/u16:1: 0% user + 0.9% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 150/kswapd0: 0% user + 0.8% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 582/logd: 0.4% user + 0.3% kernel / faults: 1 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 596/android.hardware.keymaster@4.0-service-qti: 0% user + 0.8% kernel / faults: 15 minor 4 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 795/android.hardware.camera.provider@2.4-service_64: 0% user + 0.8% kernel / faults: 74 minor 29 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 835/android.hardware.sensors@1.0-service: 0.4% user + 0.3% kernel / faults: 298 minor 15 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 4647/com.android.nfc: 0.4% user + 0.3% kernel / faults: 1060 minor 4 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.7% 26974/com.miui.player: 0.2% user + 0.5% kernel / faults: 6 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 530/irq/303-fts: 0% user + 0.6% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 5337/com.miui.analytics: 0.2% user + 0.4% kernel / faults: 363 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 23277/com.smile.gifmaker: 0.4% user + 0.2% kernel / faults: 119 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.5% 492/crtc_commit:131: 0% user + 0.5% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.5% 693/netd: 0.1% user + 0.4% kernel / faults: 208 minor 10 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 8387/com.taobao.taobao:channel: 0.3% user + 0.1% kernel / faults: 53 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 27750/com.example.myapplication: 0.4% user + 0% kernel / faults: 1733 minor 17 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 861/vendor.qti.hardware.perf@2.2-service: 0.1% user + 0.2% kernel / faults: 54 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 27850/com.android.browser: 0.1% user + 0.2% kernel / faults: 117 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 9/rcu_preempt: 0% user + 0.3% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 21238/kworker/u16:13: 0% user + 0.3% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 26155/mdnsd: 0.2% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 10/rcu_sched: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 842/android.hardware.wifi@1.0-service: 0.1% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 2457/com.android.systemui: 0.2% user + 0% kernel / faults: 80 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 25386/com.tencent.mm:appbrand0: 0.2% user + 0% kernel / faults: 20 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 26203/com.smile.gifmaker:messagesdk: 0.2% user + 0% kernel / faults: 11 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 26730/logcat: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 1/init: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 12/rcuop/0: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 13/rcuos/0: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 584/servicemanager: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 664/jbd2/sda31-8: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 685/tombstoned: 0% user + 0% kernel / faults: 26 minor 52 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 958/audioserver: 0% user + 0.1% kernel / faults: 89 minor 3 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 3509/irq/33-90cd000.: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 18880/kworker/u16:4: 0% user + 0.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 22/rcuop/1: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 30/rcuop/2: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 46/rcuop/4: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 652/ipacm: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 653/android.system.suspend@1.0-service: 0.1% user + 0% kernel / faults: 70 minor 7 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 692/statsd: 0% user + 0.1% kernel / faults: 73 minor 2 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 794/android.hardware.bluetooth@1.0-service-qti: 0% user + 0% kernel / faults: 15 minor 13 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 815/android.hardware.gnss@2.1-service-qti: 0% user + 0% kernel / faults: 97 minor 17 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 821/android.hardware.health@2.1-service: 0% user + 0.1% kernel / faults: 33 minor 4 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 833/android.hardware.neuralnetworks@1.3-service-qti: 0% user + 0% kernel / faults: 108 minor 34 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 862/qrtr_rx: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1093/mi_thermald: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1371/cameraserver: 0% user + 0% kernel / faults: 46 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1388/keystore: 0% user + 0.1% kernel / faults: 252 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1436/mediaserver: 0% user + 0% kernel / faults: 42 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1651/msm_irqbalance: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 3449/com.google.android.gms.persistent: 0.1% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 3507/irq/32-90b6400.: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 4583/tcpdump: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 4834/com.xiaomi.mircs: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 5105/com.tencent.wework: 0% user + 0% kernel / faults: 5 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 25408/com.tencent.mm:appbrand1: 0.1% user + 0% kernel / faults: 15 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 29363/kworker/0:2: 0% user + 0.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8/ksoftirqd/0: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 15/migration/0: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 31/rcuos/2: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 38/rcuop/3: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 39/rcuos/3: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 54/rcuop/5: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 70/rcuop/7: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 278/qseecom-unload-: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 370/irq/573-dma-gra: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 542/kworker/2:1H: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 556/ueventd: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 585/hwservicemanager: 0% user + 0% kernel / faults: 56 minor 8 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 626/vold: 0% user + 0% kernel / faults: 54 minor 1 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 740/kworker/3:1H: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 783/android.hardware.audio.service: 0% user + 0% kernel / faults: 65 minor 8 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 818/android.hardware.graphics.composer@2.4-service: 0% user + 0% kernel / faults: 215 minor 1 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1095/batteryd: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1272/wlan_logging_th: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1433/media.metrics: 0% user + 0% kernel / faults: 35 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1457/wificond: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1480/ipacm-diag: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1574/cnss-daemon: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1617/android.hardware.biometrics.fingerprint@2.1-service: 0% user + 0% kernel / faults: 24 minor 3 major<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1632/qcrild: 0% user + 0% kernel / faults: 3 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1644/hvdcp_opti: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1665/qcrild: 0% user + 0% kernel / faults: 3 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1853/psimon: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 5514/com.miui.securitycenter.remote: 0% user + 0% kernel / faults: 21 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8782/com.miui.powerkeeper: 0% user + 0% kernel / faults: 23 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8829/com.taobao.taobao:sandboxed_privilege_process0: 0% user + 0% kernel / faults: 3 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8985/com.taobao.taobao:remote: 0% user + 0% kernel / faults: 1 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 9034/cn.ticktick.task: 0% user + 0% kernel / faults: 1 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 13678/com.tencent.mm:toolsmp: 0% user + 0% kernel / faults: 17 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 13906/tv.danmaku.bili:download: 0% user + 0% kernel / faults: 2 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 14396/iptables-restore: 0% user + 0% kernel / faults: 10 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 14408/ip6tables-restore: 0% user + 0% kernel / faults: 1 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 26888/com.miui.player:remote: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 28950/kworker/1:0: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29260/com.miui.aod:settings: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29378/kworker/3:3: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29558/logcat: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29564/kworker/2:0: 0% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager: 19% TOTAL: 8% user + 9.2% kernel + 0.6% iowait + 0.9% irq + 0.4% softirq<br>09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 57ms to 615ms later (2021-09-29 16:02:48.783 to 2021-09-29 16:02:49.341):<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   75% 1763/system_server: 27% user + 47% kernel / faults: 1442 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     54% 29602/AnrConsumer: 15% user + 38% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     15% 1772/HeapTaskDaemon: 13% user + 2.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.2% 1781/android.ui: 0% user + 2.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.2% 3385/Binder:1763_F: 0% user + 2.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   4% 835/android.hardware.sensors@1.0-service: 2% user + 2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   4.2% 969/surfaceflinger: 0% user + 4.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.1% 1040/Binder:969_1: 0% user + 2.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.1% 1214/app: 0% user + 2.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   4.2% 1362/cnss_diag: 4.2% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   5.7% 8356/com.taobao.taobao: 2.8% user + 2.8% kernel / faults: 7 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.8% 8356/m.taobao.taobao: 0% user + 2.8% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.8% 46/rcuop/4: 0% user + 1.8% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.8% 70/rcuop/7: 0% user + 1.8% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 492/crtc_commit:131: 0% user + 1.9% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 542/kworker/2:1H: 0% user + 1.9% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 584/servicemanager: 0% user + 1.9% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.1% 1093/mi_thermald: 0% user + 2.1% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.2% 1665/qcrild: 0% user + 2.2% kernel / faults: 1 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 2239/cds_ol_rx_threa: 0% user + 2.3% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 2847/com.android.phone: 2.3% user + 0% kernel / faults: 19 minor<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.3% 2847/m.android.phone: 2.3% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:     2.3% 3437/Binder:2847_A: 2.3% user + 0% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   2.4% 3509/irq/33-90cd000.: 0% user + 2.4% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   3.2% 19687/com.tencent.mm: 0% user + 3.2% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   3.3% 22965/kworker/u16:7: 0% user + 3.3% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager:   3.5% 26155/mdnsd: 0% user + 3.5% kernel<br>09-29 16:03:03.457  1763 29602 E ActivityManager: 15% TOTAL: 6.1% user + 7.5% kernel + 0.9% irq + 0.4% softirq<br></code></pre></div></td></tr></table></figure><p>上面的日志是在 <code>ProcessErrorStateRecord.appNotResponding</code> 输出的，<code>info</code> 是输出至 logcat system 的日志</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessErrorStateRecord</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">            String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">boolean</span> aboveSystem, String annotation, <span class="hljs-keyword">boolean</span> onlyDumpSelf)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// Log the ANR to the main log.</span><br>        StringBuilder info = <span class="hljs-keyword">new</span> StringBuilder();<br>        info.setLength(<span class="hljs-number">0</span>);<br>        info.append(<span class="hljs-string">&quot;ANR in &quot;</span>).append(mApp.processName);<br>        <span class="hljs-keyword">if</span> (activityShortComponentName != <span class="hljs-keyword">null</span>) &#123;<br>            info.append(<span class="hljs-string">&quot; (&quot;</span>).append(activityShortComponentName).append(<span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;<br>        info.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        info.append(<span class="hljs-string">&quot;PID: &quot;</span>).append(pid).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (annotation != <span class="hljs-keyword">null</span>) &#123;<br>            info.append(<span class="hljs-string">&quot;Reason: &quot;</span>).append(annotation).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (parentShortComponentName != <span class="hljs-keyword">null</span><br>                &amp;&amp; parentShortComponentName.equals(activityShortComponentName)) &#123;<br>            info.append(<span class="hljs-string">&quot;Parent: &quot;</span>).append(parentShortComponentName).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (errorId != <span class="hljs-keyword">null</span>) &#123;<br>            info.append(<span class="hljs-string">&quot;ErrorId: &quot;</span>).append(errorId.toString()).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        info.append(<span class="hljs-string">&quot;Frozen: &quot;</span>).append(mApp.mOptRecord.isFrozen()).append(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-comment">// ...</span><br><br>        StringBuilder report = <span class="hljs-keyword">new</span> StringBuilder();<br>        report.append(MemoryPressureUtil.currentPsiState());<br>        ProcessCpuTracker processCpuTracker = <span class="hljs-keyword">new</span> ProcessCpuTracker(<span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-comment">// don&#x27;t dump native PIDs for background ANRs unless it is the process of interest</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// For background ANRs, don&#x27;t pass the ProcessCpuTracker to</span><br>        <span class="hljs-comment">// avoid spending 1/2 second collecting stats to rank lastPids.</span><br>        StringWriter tracesFileException = <span class="hljs-keyword">new</span> StringWriter();<br>        <span class="hljs-comment">// To hold the start and end offset to the ANR trace file respectively.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">2</span>];<br>        File tracesFile = ActivityManagerService.dumpStackTraces(firstPids,<br>                isSilentAnr ? <span class="hljs-keyword">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-keyword">null</span> : lastPids,<br>                nativePids, tracesFileException, offsets, annotation);<br><br>        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;<br>            mService.updateCpuStatsNow();<br>            mService.mAppProfiler.printCurrentCpuState(report, anrTime);<br>            info.append(processCpuTracker.printCurrentLoad());<br>            info.append(report);<br>        &#125;<br>        report.append(tracesFileException.getBuffer());<br>        info.append(processCpuTracker.printCurrentState(anrTime));<br>        Slog.e(TAG, info.toString());<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="load-average"><a href="#load-average" class="headerlink" title="load average"></a>load average</h2><p>用进程数来描述 CPU 负载压力</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessErrorStateRecord</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appNotResponding</span><span class="hljs-params">(...)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;<br>            mService.updateCpuStatsNow();<br>            <span class="hljs-keyword">synchronized</span> (mService.mProcessCpuTracker) &#123;<br>                report.append(mService.mProcessCpuTracker.printCurrentState(anrTime));<br>            &#125;<br>            info.append(processCpuTracker.printCurrentLoad());  <span class="hljs-comment">// 这里输出系统平均负载</span><br>            info.append(report);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessCpuTracker</span> </span>&#123;<br><br>    <span class="hljs-comment">// 三个值分别对应 mLoad1, mLoad5 和 mLoad15</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">printCurrentLoad</span><span class="hljs-params">()</span> </span>&#123;<br>        StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>        PrintWriter pw = <span class="hljs-keyword">new</span> FastPrintWriter(sw, <span class="hljs-keyword">false</span>, <span class="hljs-number">128</span>);<br>        pw.print(<span class="hljs-string">&quot;Load: &quot;</span>);<br>        pw.print(mLoad1);<br>        pw.print(<span class="hljs-string">&quot; / &quot;</span>);<br>        pw.print(mLoad5);<br>        pw.print(<span class="hljs-string">&quot; / &quot;</span>);<br>        pw.println(mLoad15);<br>        pw.flush();<br>        <span class="hljs-keyword">return</span> sw.toString();<br>    &#125;    <br><br>    <span class="hljs-comment">// 这三个变量来自 /proc/loadavg</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] loadAverages = mLoadAverageData;<br>        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/loadavg&quot;</span>, LOAD_AVERAGE_FORMAT,<br>                <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, loadAverages)) &#123;<br>            <span class="hljs-keyword">float</span> load1 = loadAverages[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">float</span> load5 = loadAverages[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">float</span> load15 = loadAverages[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) &#123;<br>                mLoad1 = load1;<br>                mLoad5 = load5;<br>                mLoad15 = load15;<br>                onLoadChanged(load1, load5, load15);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>man proc.5</p><p>/proc/loadavg</p><p>The  first  three  fields in this file are load average figures giving the number of jobs in the run queue (state R) or waiting for disk I/O (state D) averaged over 1, 5, and 15 minutes.  They are the same as the load average numbers given by uptime(1) and other programs.  </p><p>The fourth field consists of two numbers separated by a slash (/).  The first of these is the number of currently  runnable  kernel  scheduling entities (processes, threads).  The value after the slash is the number of kernel scheduling entities that currently exist on the system.  </p><p>The fifth field is the PID of the process that was most recently created on the system.</p></blockquote><p>在绿联 6812（4 x <a href="mailto:&#x41;&#x35;&#x33;&#64;&#x31;&#x2e;&#x35;&#x47;">&#x41;&#x35;&#x33;&#64;&#x31;&#x2e;&#x35;&#x47;</a>）上获取的值是 <code>13.31 13.74 13.81 2/1167 3888</code></p><ul><li>在过去的 1, 5, 15 分钟内 CPU 的平均负载是 13.31, 13.74, 13.81</li><li>当前有 1167 个进程，其中有 2 个正在运行</li><li>最近创建的一个进程是 3888</li></ul><blockquote><p>在 Linux 系统中，uptime、w、top 等命令都会有系统平均负载 load average 的输出，系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数</p><p>如果一个进程满足以下条件则其就会位于运行队列中：它没有在等待 I/O 操作的结果，它没有主动进入等待状态(也就是没有调用’wait’)，没有被停止(例如：等待终止)</p><p>例如：<br><br>[root@opendigest root]# uptime <br><br>7:51pm up 2 days, 5:43, 2 users, load average: 8.13, 5.90, 4.94 <br><br>命令输出的最后内容表示在过去的 1、5、15 分钟内运行队列中的平均进程数量</p><p>一般来说只要每个 CPU 的当前活动进程数不大于 3 那么系统的性能就是良好的，如果每个 CPU 的任务数大于 5 那么就表示这台机器的性能有严重问题。对于上面的例子来说，假设系统有两个 CPU 那么其每个 CPU 的当前任务数为：8.13 / 2 = 4.065，这表示该系统的性能是可以接受的</p></blockquote><p>这么看来 <code>13.81 / 4 = 3.45</code> 这块绿联屏的性能还是可以接受的</p><h2 id="PSI-Pressure-Stall-Information"><a href="#PSI-Pressure-Stall-Information" class="headerlink" title="PSI (Pressure Stall Information)"></a>PSI (Pressure Stall Information)</h2><blockquote><p>Pressure Stall Information 提供了一种评估系统资源压力的方法。系统有三个基础资源：CPU、Memory 和 IO，无论这些资源配置如何增加，似乎永远无法满足软件的需求。一旦产生资源竞争，就有可能带来延迟增大，使用户体验到卡顿</p><p>如果没有一种相对准确的方法检测系统的资源压力程度，有两种后果：一种是资源使用者过度克制，没有充分使用系统资源；另一种是经常产生资源竞争，过度使用资源导致等待延迟过大。准确的检测方法可以帮忙资源使用者确定合适的工作量，同时也可以帮助系统制定高效的资源调度策略，最大化利用系统资源，最大化改善用户体验</p><p>Facebook 在 2018 年开源了一套解决重要计算集群管理问题的 Linux 内核组件和相关工具，PSI 是其中重要的资源度量工具，它提供了一种实时检测系统资源竞争程度的方法，以竞争等待时间的方式呈现，简单而准确地供用户以及资源调度者进行决策</p><p>在此之前，Linux 也有一些资源压力的评估方法，最具代表性的是 load average 和 vmpressure</p></blockquote><p>每类资源的压力信息都通过 proc 文件系统的独立文件来提供，路径为：<code>/proc/pressure/memory</code>，<code>/proc/pressure/cpu</code> 和 <code>/proc/pressure/io</code>，其中 /proc/pressure/io 输出格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">some avg10=0.30 avg60=0.12 avg300=0.02 total=4170757<br>full avg10=0.12 avg60=0.05 avg300=0.01 total=1856503<br></code></pre></div></td></tr></table></figure><ul><li>avg10、avg60、avg300 分别代表 10s、60s、300s 的时间周期内的阻塞时间百分比</li><li>total 是总累计时间，以毫秒为单位</li><li>some 这一行，代表至少有一个任务在某个资源上阻塞的时间占比</li><li>full 这一行，代表所有的非 idle 任务同时被阻塞的时间占比，这期间 cpu 被完全浪费，会带来严重的性能问题</li></ul><p>我们以 IO 的 some 和 full 来举例说明，假设在 60 秒的时间段内，系统有两个 task，在 60 秒的周期内的运行情况如下图所示：</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/proc_pressure_io_1.png" alt="proc_pressure_io_1"></p><p>红色阴影部分表示任务由于等待 IO 资源而进入阻塞状态。Task A 和 Task B 同时阻塞的部分为 full，占比 16.66%；至少有一个任务阻塞（仅 Task B 阻塞的部分也计算入内）的部分为 some，占比 50%</p><p>some 和 full 都是在某一时间段内阻塞时间占比的总和，阻塞时间不一定连续，如下图所示：</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/proc_pressure_io_2.png" alt="proc_pressure_io_2"></p><p>IO 和 memory 都有 some 和 full 两个维度，那是因为的确有可能系统中的所有任务都阻塞在 IO 或者 memory 资源，同时 CPU 进入 idle 状态</p><p>但是 CPU 资源不可能出现这个情况：不可能全部的 runnable 的任务都等待 CPU 资源，至少有一个 runnable 任务会被调度器选中占有 CPU 资源，因此 CPU 资源没有 full 维度的 PSI 信息呈现</p><p>通过这些阻塞占比数据，我们可以看到短期以及中长期一段时间内各种资源的压力情况，可以较精确的确定时延抖动原因，并制定对应的负载管理策略</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">09-29 16:03:03.457  1763 29602 E ActivityManager: ----- Output from /proc/pressure/memory -----<br>09-29 16:03:03.457  1763 29602 E ActivityManager: some avg10=0.00 avg60=0.00 avg300=0.02 total=32995625<br>09-29 16:03:03.457  1763 29602 E ActivityManager: full avg10=0.00 avg60=0.00 avg300=0.00 total=11591183<br>09-29 16:03:03.457  1763 29602 E ActivityManager: ----- End output from /proc/pressure/memory -----<br></code></pre></div></td></tr></table></figure><p>现在我们来看看 anr logcat 里输出的 /proc/pressure/memory 内容，full 都为零说明任务同时阻塞在内存资源上的情况没有出现，some - avg300=0.02 表明在有任务阻塞在内存资源上 6s（300s * 0.02，注意这 6s 是总和，不一定是连续的）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPressureUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FILE = <span class="hljs-string">&quot;/proc/pressure/memory&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;MemoryPressure&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a stanza about memory PSI to add to a report.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">currentPsiState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();<br>        StringWriter contents = <span class="hljs-keyword">new</span> StringWriter();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> File(FILE).exists()) &#123;<br>                contents.append(<span class="hljs-string">&quot;----- Output from /proc/pressure/memory -----\n&quot;</span>);<br>                contents.append(IoUtils.readFileAsString(FILE));<br>                contents.append(<span class="hljs-string">&quot;----- End output from /proc/pressure/memory -----\n\n&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            Slog.e(TAG, <span class="hljs-string">&quot;Could not read &quot;</span> + FILE, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>        <span class="hljs-keyword">return</span> contents.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MemoryPressureUtil</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="CPU-usage"><a href="#CPU-usage" class="headerlink" title="CPU usage"></a>CPU usage</h2><p><code>ProcessCpuTracker</code> 顾名思义是用来跟踪进程 CPU 使用率的，它的数据是在 <code>ProcessCpuTracker.update()</code> 里采集的（<code>/proc/stat</code>, <code>/proc/[pid]/stat</code>），<code>mCurrentSampleTime</code> 是上一次执行 <code>ProcessCpuTracker.update()</code> 的时间（既是数据快照的时间，也是两次数据快照差值的结束时间），而 <code>mLastSampleTime</code> 是上上次执行 <code>ProcessCpuTracker.update()</code> 的时间（也是两次数据快照差值的开始时间），<code>now</code> 是发生 ANR 的时间，它们的关系有：</p><ol><li>如果是 <code>anr - mLastSampleTime - mCurrentSampleTime</code>，说明 ANR 发生在两次快照差值（统计时间段）之前，对应的是 <code>later</code></li><li>如果是 <code>mLastSampleTime - mCurrentSampleTime - anr</code>，说明 ANR 发生在两次快照差值（统计时间段）之后，对应的是 <code>ago</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">// 第一段 CPU Usage 是由 mService.mAppProfiler.printCurrentCpuState(report, anrTime) 打印出来的<br>09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 0ms to 14680ms later (2021-09-29 16:02:48.726 to 2021-09-29 16:03:03.406):<br>...<br>// 第二段 CPU Usage 是由 info.append(processCpuTracker.printCurrentState(anrTime)) 打印出来的<br>09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 57ms to 615ms later (2021-09-29 16:02:48.783 to 2021-09-29 16:02:49.341):<br>...<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessErrorStateRecord</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">            String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">boolean</span> aboveSystem, String annotation, <span class="hljs-keyword">boolean</span> onlyDumpSelf)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        StringBuilder report = <span class="hljs-keyword">new</span> StringBuilder();<br>        report.append(MemoryPressureUtil.currentPsiState());<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;<br>            mService.updateCpuStatsNow();<br>            mService.mAppProfiler.printCurrentCpuState(report, anrTime);<br>            info.append(processCpuTracker.printCurrentLoad());<br>            info.append(report);<br>        &#125;<br>        report.append(tracesFileException.getBuffer());<br>        info.append(processCpuTracker.printCurrentState(anrTime));<br>        Slog.e(TAG, info.toString());       <span class="hljs-comment">// info 是输出至 logcat system 的日志文本</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppProfiler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printCurrentCpuState</span><span class="hljs-params">(StringBuilder report, <span class="hljs-keyword">long</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (mProcessCpuTracker) &#123;<br>            report.append(mProcessCpuTracker.printCurrentState(time));<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessCpuTracker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">printCurrentState</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);<br><br>        buildWorkingProcs();<br><br>        StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>        PrintWriter pw = <span class="hljs-keyword">new</span> FastPrintWriter(sw, <span class="hljs-keyword">false</span>, <span class="hljs-number">1024</span>);<br><br>        pw.print(<span class="hljs-string">&quot;CPU usage from &quot;</span>);<br>        <span class="hljs-keyword">if</span> (now &gt; mLastSampleTime) &#123;<br>            pw.print(now-mLastSampleTime);<br>            pw.print(<span class="hljs-string">&quot;ms to &quot;</span>);<br>            pw.print(now-mCurrentSampleTime);<br>            pw.print(<span class="hljs-string">&quot;ms ago&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pw.print(mLastSampleTime-now);<br>            pw.print(<span class="hljs-string">&quot;ms to &quot;</span>);<br>            pw.print(mCurrentSampleTime-now);<br>            pw.print(<span class="hljs-string">&quot;ms later&quot;</span>);<br>        &#125;<br>        pw.print(<span class="hljs-string">&quot; (&quot;</span>);<br>        pw.print(sdf.format(<span class="hljs-keyword">new</span> Date(mLastSampleWallTime)));<br>        pw.print(<span class="hljs-string">&quot; to &quot;</span>);<br>        pw.print(sdf.format(<span class="hljs-keyword">new</span> Date(mCurrentSampleWallTime)));<br>        pw.print(<span class="hljs-string">&quot;)&quot;</span>);<br><br>        <span class="hljs-keyword">long</span> sampleTime = mCurrentSampleTime - mLastSampleTime;<br>        <span class="hljs-keyword">long</span> sampleRealTime = mCurrentSampleRealTime - mLastSampleRealTime;<br>        <span class="hljs-keyword">long</span> percAwake = sampleRealTime &gt; <span class="hljs-number">0</span> ? ((sampleTime*<span class="hljs-number">100</span>) / sampleRealTime) : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (percAwake != <span class="hljs-number">100</span>) &#123;<br>            pw.print(<span class="hljs-string">&quot; with &quot;</span>);<br>            pw.print(percAwake);<br>            pw.print(<span class="hljs-string">&quot;% awake&quot;</span>);<br>        &#125;<br>        pw.println(<span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="收集进程-proc-pid"><a href="#收集进程-proc-pid" class="headerlink" title="收集进程 /proc/[pid]"></a>收集进程 <code>/proc/[pid]</code></h3><p><code>Process.getPids(dir, array)</code> 遍历目录 <code>dir</code> （这里传入的是 <code>/proc</code>）下的条目，找到纯数字的条目（即为 <code>pid</code>）加入到 <code>array</code>（pid array），<code>array</code> 会复用，只有当 <code>pid</code> 的数量超过 <code>array</code> 容量时才分配新的数组</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Process.getPids(dir, array)</span><br><span class="hljs-comment">// 从 /proc 获取 pid 列表到 array</span><br><span class="hljs-function">jintArray <span class="hljs-title">android_os_Process_getPids</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     jstring file <span class="hljs-comment">/* /proc */</span>, jintArray lastArray)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (file8 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    DIR* dirp = <span class="hljs-built_in">opendir</span>(file8);<br><br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);<br><br>    <span class="hljs-keyword">if</span>(dirp == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    jsize curCount = <span class="hljs-number">0</span>;<br>    jint* curData = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (lastArray != <span class="hljs-literal">NULL</span>) &#123;<br>        curCount = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(lastArray);<br>        curData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(lastArray, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    jint curPos = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span>* <span class="hljs-title">entry</span>;</span><br>    <span class="hljs-keyword">while</span> ((entry=<span class="hljs-built_in">readdir</span>(dirp)) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* p = entry-&gt;d_name;<br>        <span class="hljs-keyword">while</span> (*p) &#123;<br>            <span class="hljs-keyword">if</span> (*p &lt; <span class="hljs-string">&#x27;0&#x27;</span> || *p &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;<br>            p++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (*p != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">char</span>* end;<br>        <span class="hljs-keyword">int</span> pid = <span class="hljs-built_in">strtol</span>(entry-&gt;d_name, &amp;end, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//ALOGI(&quot;File %s pid=%d\n&quot;, entry-&gt;d_name, pid);</span><br>        <span class="hljs-keyword">if</span> (curPos &gt;= curCount) &#123;<br>            jsize newCount = (curCount == <span class="hljs-number">0</span>) ? <span class="hljs-number">10</span> : (curCount*<span class="hljs-number">2</span>);<br>            jintArray newArray = env-&gt;<span class="hljs-built_in">NewIntArray</span>(newCount);<br>            <span class="hljs-keyword">if</span> (newArray == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">closedir</span>(dirp);<br>                <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            jint* newData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(newArray, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">memcpy</span>(newData, curData, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(jint)*curCount);<br>                env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(lastArray, curData, <span class="hljs-number">0</span>);<br>            &#125;<br>            lastArray = newArray;<br>            curCount = newCount;<br>            curData = newData;<br>        &#125;<br><br>        curData[curPos] = pid;<br>        curPos++;<br>    &#125;<br><br>    <span class="hljs-built_in">closedir</span>(dirp);<br><br>    <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span> &amp;&amp; curPos &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">qsort</span>(curData, curPos, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(jint), pid_compare);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (curPos &lt; curCount) &#123;<br>        curData[curPos] = <span class="hljs-number">-1</span>;<br>        curPos++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span>) &#123;<br>        env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(lastArray, curData, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lastArray;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="进程概览-proc-pid-stat"><a href="#进程概览-proc-pid-stat" class="headerlink" title="进程概览 /proc/[pid]/stat"></a>进程概览 <code>/proc/[pid]/stat</code></h3><p>在 MI 9 上通过 <code>cat /proc/8538/stat</code> 打印出的内容如下（8538 是通过 <code>ps -A | grep com.tencent.mm</code> 查找出的微信的 pid）：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cepheus:/proc $ cat /proc/8538/stat<br>8538 (com.tencent.mm) S 690 690 0 0 -1 1077952832 2355958 1597 22562 6 39676 24386 2 1 20 0 209 0 464604 73654394880 26729 18446744073709551615 1 1 0 0 0 0 4608 4097 1073775868 0 0 0 17 0 0 0 2401 0 0 0 0 0 0 0 0 0 0<br></code></pre></div></td></tr></table></figure><p>一些重要字段的含义如下（来自 <code>man proc.5</code> 里的 <code>/proc/[pid]/stat</code> 章节）：</p><table><thead><tr><th>index</th><th>name</th><th>value</th><th>desc</th></tr></thead><tbody><tr><td>0</td><td>pid</td><td>8538</td><td>pid</td></tr><tr><td>1</td><td>comm</td><td>(com.tencent.mm)</td><td>command, The filename of the executable, 这里是包名</td></tr><tr><td>2</td><td>state</td><td>S</td><td>process state，进程状态：R - Running, S - Sleeping(interruptible), D - Waiting(uninterruptible), Z - Zombie …</td></tr><tr><td>3</td><td>ppid</td><td>690</td><td>父进程的 PID</td></tr><tr><td>4</td><td>pgrp</td><td>690</td><td>group ID</td></tr><tr><td>5</td><td></td><td>0</td><td></td></tr><tr><td>6</td><td></td><td>0</td><td></td></tr><tr><td>7</td><td></td><td>-1</td><td></td></tr><tr><td>8</td><td></td><td>1077952832</td><td></td></tr><tr><td>9</td><td>minflt</td><td>2355958</td><td>minor page faults (which have not required loading a memory page from disk), 加载 CPU 指令时发生缺页错误，但指令以及加载至物理内存，只需将虚存映射到物理内存即可</td></tr><tr><td>10</td><td>cminflt</td><td>1597</td><td></td></tr><tr><td>11</td><td>majflt</td><td>22562</td><td>major page faults (which have required loading a memory page from disk), 同样是加载 CPU 指令时发生缺页错误，但此时需要从磁盘读取指令，比上面的情况要严重</td></tr><tr><td>12</td><td>cmajflt</td><td>6</td><td></td></tr><tr><td>13</td><td>utime</td><td>39676</td><td>Amount of time that this process has been scheduled in user mode, 进程运行在用户态的 CPU 时间</td></tr><tr><td>14</td><td>stime</td><td>24386</td><td>Amount of time that this process has been scheduled in kernel mode, 进程运行在内核态的 CPU 时间</td></tr><tr><td>15</td><td>cutime</td><td>2</td><td></td></tr><tr><td>16</td><td>cstime</td><td>1</td><td></td></tr><tr><td>17</td><td>priority</td><td>20</td><td>优先级（在创建进程的时候就设置好后续不能更改）</td></tr><tr><td>18</td><td>nice</td><td>0</td><td>进程最终优先级 = priorty + nice，nice 值可以在运行时动态修改</td></tr><tr><td>19</td><td>num_threads</td><td>209</td><td></td></tr><tr><td>20</td><td></td><td>0</td><td></td></tr><tr><td>21</td><td>starttime</td><td>464604</td><td>The time the process started after system boot, 进程的运行时间（是一个从系统启动时间开始算起的相对值）</td></tr><tr><td>22</td><td>vsize</td><td>73654394880</td><td>Virtual memory size in bytes</td></tr></tbody></table><blockquote><p>Linux 对于物理内存的管理方法</p><p>由 MMU 把物理内存分割成众多个 page，每个 page 是 4KB. 然后把 page 映射到进程的虚拟内存空间，CPU 在执行进程中的指令时以虚拟内存地址为基础，通过 map 映射进而找到物理内存中实际存放指令的地址</p><p>缺页错误 (page fault)</p><p>严格说这里指的是 major page fault，名字听起来挺严重，实际上并不是什么”错误”</p><p>大致是这样，一个程序可能占几 MB，但并不是所有的指令都要同时运行，有些是在初始化时运行，有些是在特定条件下才会去运行。因此 linux 并不会把所有的指令都从磁盘加载到物理内存，那么当 cpu 在执行指令时如果发现下一条要执行的指令不在物理内存时，就会 raise a page fault 通知 MMU 把下面要执行的指令从磁盘加载到物理内存中</p><p>还有另一种就是 minor fault</p><p>minor page fault 指的是要执行的指令实际上已经在物理内存，只是这个 page 没有映射到当前进程的虚拟内存，这时就会 raise a minor page fault 让 MMU 把这个 page 映射进当前进程的虚拟内存，因此 minor page fault 并不需要去访问磁盘</p><p>What a Swap?</p><p>当物理内存不够时，把一些物理内存 page 写入到磁盘以腾出一些空闲的 page 出来供进程使用，这就是 swap out；反过来说当 CPU 要执行的指令被发现已经 swap out 到了磁盘中，这时就需要从磁盘把这些指令再 swap in 到物理内存中让CPU去执行</p><p>swap in 和 swap out 的操作都是比较耗时的, 频繁的 swap in 和 swap out 操作很影响系统性能</p></blockquote><p><code>ProcessCpuTracker.update</code> 和 <code>ProcessCpuTracker.collectStats</code> 读取并解析 <code>/proc/[pid]/stat</code> 文件内容为 <code>Stats</code> 结构，保存在 <code>ProcessCpuTracker.mProcStats</code> 以供后续打印，它的重要字段有：</p><table><thead><tr><th>field</th><th>desc</th></tr></thead><tbody><tr><td>pid</td><td>进程 ID，来自 <code>/proc</code> 目录下的纯数字目录</td></tr><tr><td>name</td><td>进程名，来自 <code>/proc/[pid]/stat#comm</code></td></tr><tr><td>base_uptime</td><td>取自 <code>SystemClock.uptimeMillis()</code></td></tr><tr><td>base_utime</td><td>运行在用户态的 CPU 时间</td></tr><tr><td>base_stime</td><td>运行在核心态的 CPU 时间</td></tr><tr><td>base_majfaults</td><td>major page faults</td></tr><tr><td>base_minfaults</td><td>minor page faults</td></tr><tr><td>rel_uptime</td><td></td></tr><tr><td>rel_utime</td><td></td></tr><tr><td>rel_stime</td><td></td></tr><tr><td>rel_majfaults</td><td></td></tr><tr><td>rel_minfaults</td><td></td></tr></tbody></table><p>第一次遇到进程时（构造 <code>State</code>）将初始值填入 <code>base_xxx</code>，下次遇到进程时给 <code>rel_xxx</code> 赋值：<code>rel_xxx = [now] - base_xxx</code> 并更新 <code>base_xxx</code> 为当前值 <code>[now]</code>，也就是说 <code>base_xxx</code> 是当前快照而 <code>rel_xxx</code> 是当前与上一次快照的差值</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessCpuTracker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Update: &quot;</span> + <span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowUptime = SystemClock.uptimeMillis();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowRealtime = SystemClock.elapsedRealtime();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowWallTime = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] sysCpu = mSystemCpuData;<br>        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/stat&quot;</span>, SYSTEM_CPU_FORMAT,<br>                <span class="hljs-keyword">null</span>, sysCpu, <span class="hljs-keyword">null</span>)) &#123;<br>            <span class="hljs-comment">// Total user time is user + nice time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> usertime = (sysCpu[<span class="hljs-number">0</span>]+sysCpu[<span class="hljs-number">1</span>]) * mJiffyMillis;<br>            <span class="hljs-comment">// Total system time is simply system time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> systemtime = sysCpu[<span class="hljs-number">2</span>] * mJiffyMillis;<br>            <span class="hljs-comment">// Total idle time is simply idle time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> idletime = sysCpu[<span class="hljs-number">3</span>] * mJiffyMillis;<br>            <span class="hljs-comment">// Total irq time is iowait + irq + softirq time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> iowaittime = sysCpu[<span class="hljs-number">4</span>] * mJiffyMillis;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> irqtime = sysCpu[<span class="hljs-number">5</span>] * mJiffyMillis;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> softirqtime = sysCpu[<span class="hljs-number">6</span>] * mJiffyMillis;<br><br>            <span class="hljs-comment">// This code is trying to avoid issues with idle time going backwards,</span><br>            <span class="hljs-comment">// but currently it gets into situations where it triggers most of the time. :(</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span> || (usertime &gt;= mBaseUserTime &amp;&amp; systemtime &gt;= mBaseSystemTime<br>                    &amp;&amp; iowaittime &gt;= mBaseIoWaitTime &amp;&amp; irqtime &gt;= mBaseIrqTime<br>                    &amp;&amp; softirqtime &gt;= mBaseSoftIrqTime &amp;&amp; idletime &gt;= mBaseIdleTime)) &#123;<br>                mRelUserTime = (<span class="hljs-keyword">int</span>)(usertime - mBaseUserTime);<br>                mRelSystemTime = (<span class="hljs-keyword">int</span>)(systemtime - mBaseSystemTime);<br>                mRelIoWaitTime = (<span class="hljs-keyword">int</span>)(iowaittime - mBaseIoWaitTime);<br>                mRelIrqTime = (<span class="hljs-keyword">int</span>)(irqtime - mBaseIrqTime);<br>                mRelSoftIrqTime = (<span class="hljs-keyword">int</span>)(softirqtime - mBaseSoftIrqTime);<br>                mRelIdleTime = (<span class="hljs-keyword">int</span>)(idletime - mBaseIdleTime);<br>                mRelStatsAreGood = <span class="hljs-keyword">true</span>;<br><br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Total U:&quot;</span> + (sysCpu[<span class="hljs-number">0</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; N:&quot;</span> + (sysCpu[<span class="hljs-number">1</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; S:&quot;</span> + (sysCpu[<span class="hljs-number">2</span>]*mJiffyMillis) + <span class="hljs-string">&quot; I:&quot;</span> + (sysCpu[<span class="hljs-number">3</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; W:&quot;</span> + (sysCpu[<span class="hljs-number">4</span>]*mJiffyMillis) + <span class="hljs-string">&quot; Q:&quot;</span> + (sysCpu[<span class="hljs-number">5</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; O:&quot;</span> + (sysCpu[<span class="hljs-number">6</span>]*mJiffyMillis));<br>                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Rel U:&quot;</span> + mRelUserTime + <span class="hljs-string">&quot; S:&quot;</span> + mRelSystemTime<br>                          + <span class="hljs-string">&quot; I:&quot;</span> + mRelIdleTime + <span class="hljs-string">&quot; Q:&quot;</span> + mRelIrqTime);<br>                &#125;<br><br>                mBaseUserTime = usertime;<br>                mBaseSystemTime = systemtime;<br>                mBaseIoWaitTime = iowaittime;<br>                mBaseIrqTime = irqtime;<br>                mBaseSoftIrqTime = softirqtime;<br>                mBaseIdleTime = idletime;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mRelUserTime = <span class="hljs-number">0</span>;<br>                mRelSystemTime = <span class="hljs-number">0</span>;<br>                mRelIoWaitTime = <span class="hljs-number">0</span>;<br>                mRelIrqTime = <span class="hljs-number">0</span>;<br>                mRelSoftIrqTime = <span class="hljs-number">0</span>;<br>                mRelIdleTime = <span class="hljs-number">0</span>;<br>                mRelStatsAreGood = <span class="hljs-keyword">false</span>;<br>                Slog.w(TAG, <span class="hljs-string">&quot;/proc/stats has gone backwards; skipping CPU update&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        mLastSampleTime = mCurrentSampleTime;<br>        mCurrentSampleTime = nowUptime;<br>        mLastSampleRealTime = mCurrentSampleRealTime;<br>        mCurrentSampleRealTime = nowRealtime;<br>        mLastSampleWallTime = mCurrentSampleWallTime;<br>        mCurrentSampleWallTime = nowWallTime;<br><br>        <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();<br>        <span class="hljs-keyword">try</span> &#123;<br>            mCurPids = collectStats(<span class="hljs-string">&quot;/proc&quot;</span>, -<span class="hljs-number">1</span>, mFirst, mCurPids, mProcStats);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] loadAverages = mLoadAverageData;<br>        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/loadavg&quot;</span>, LOAD_AVERAGE_FORMAT,<br>                <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, loadAverages)) &#123;<br>            <span class="hljs-keyword">float</span> load1 = loadAverages[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">float</span> load5 = loadAverages[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">float</span> load15 = loadAverages[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) &#123;<br>                mLoad1 = load1;<br>                mLoad5 = load5;<br>                mLoad15 = load15;<br>                onLoadChanged(load1, load5, load15);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (DEBUG) Slog.i(TAG, <span class="hljs-string">&quot;*** TIME TO COLLECT STATS: &quot;</span><br>                + (SystemClock.uptimeMillis()-mCurrentSampleTime));<br><br>        mWorkingProcsSorted = <span class="hljs-keyword">false</span>;<br>        mFirst = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] collectStats(String statsFile, <span class="hljs-keyword">int</span> parentPid, <span class="hljs-keyword">boolean</span> first,<br>            <span class="hljs-keyword">int</span>[] curPids, ArrayList&lt;Stats&gt; allProcs) &#123;<br><br>        <span class="hljs-keyword">int</span>[] pids = Process.getPids(statsFile, curPids);<br>        <span class="hljs-keyword">int</span> NP = (pids == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : pids.length;<br>        <span class="hljs-keyword">int</span> NS = allProcs.size();<br>        <span class="hljs-keyword">int</span> curStatsIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;NP; i++) &#123;<br>            <span class="hljs-keyword">int</span> pid = pids[i];<br>            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>                NP = pid;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Stats st = curStatsIndex &lt; NS ? allProcs.get(curStatsIndex) : <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-keyword">null</span> &amp;&amp; st.pid == pid) &#123;<br>                <span class="hljs-comment">// Update an existing process...</span><br>                st.added = <span class="hljs-keyword">false</span>;<br>                st.working = <span class="hljs-keyword">false</span>;<br>                curStatsIndex++;<br>                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Existing &quot;</span><br>                        + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)<br>                        + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);<br><br>                <span class="hljs-keyword">if</span> (st.interesting) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> uptime = SystemClock.uptimeMillis();<br><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] procStats = mProcessStatsData;<br>                    <span class="hljs-keyword">if</span> (!Process.readProcFile(st.statFile.toString(),<br>                            PROCESS_STATS_FORMAT, <span class="hljs-keyword">null</span>, procStats, <span class="hljs-keyword">null</span>)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> minfaults = procStats[PROCESS_STAT_MINOR_FAULTS];<br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> majfaults = procStats[PROCESS_STAT_MAJOR_FAULTS];<br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> utime = procStats[PROCESS_STAT_UTIME] * mJiffyMillis;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> stime = procStats[PROCESS_STAT_STIME] * mJiffyMillis;<br><br>                    <span class="hljs-keyword">if</span> (utime == st.base_utime &amp;&amp; stime == st.base_stime) &#123;<br>                        st.rel_utime = <span class="hljs-number">0</span>;<br>                        st.rel_stime = <span class="hljs-number">0</span>;<br>                        st.rel_minfaults = <span class="hljs-number">0</span>;<br>                        st.rel_majfaults = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">if</span> (st.active) &#123;<br>                            st.active = <span class="hljs-keyword">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (!st.active) &#123;<br>                        st.active = <span class="hljs-keyword">true</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (parentPid &lt; <span class="hljs-number">0</span>) &#123;<br>                        getName(st, st.cmdlineFile);<br>                        <span class="hljs-keyword">if</span> (st.threadStats != <span class="hljs-keyword">null</span>) &#123;<br>                            mCurThreadPids = collectStats(st.threadsDir, pid, <span class="hljs-keyword">false</span>,<br>                                    mCurThreadPids, st.threadStats);<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (DEBUG) Slog.v(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Stats changed &quot;</span> + st.name + <span class="hljs-string">&quot; pid=&quot;</span> + st.pid<br>                            + <span class="hljs-string">&quot; utime=&quot;</span> + utime + <span class="hljs-string">&quot;-&quot;</span> + st.base_utime<br>                            + <span class="hljs-string">&quot; stime=&quot;</span> + stime + <span class="hljs-string">&quot;-&quot;</span> + st.base_stime<br>                            + <span class="hljs-string">&quot; minfaults=&quot;</span> + minfaults + <span class="hljs-string">&quot;-&quot;</span> + st.base_minfaults<br>                            + <span class="hljs-string">&quot; majfaults=&quot;</span> + majfaults + <span class="hljs-string">&quot;-&quot;</span> + st.base_majfaults);<br><br>                    st.rel_uptime = uptime - st.base_uptime;<br>                    st.base_uptime = uptime;<br>                    st.rel_utime = (<span class="hljs-keyword">int</span>)(utime - st.base_utime);<br>                    st.rel_stime = (<span class="hljs-keyword">int</span>)(stime - st.base_stime);<br>                    st.base_utime = utime;<br>                    st.base_stime = stime;<br>                    st.rel_minfaults = (<span class="hljs-keyword">int</span>)(minfaults - st.base_minfaults);<br>                    st.rel_majfaults = (<span class="hljs-keyword">int</span>)(majfaults - st.base_majfaults);<br>                    st.base_minfaults = minfaults;<br>                    st.base_majfaults = majfaults;<br>                    st.working = <span class="hljs-keyword">true</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (st == <span class="hljs-keyword">null</span> || st.pid &gt; pid) &#123;<br>                <span class="hljs-comment">// We have a new process!</span><br>                st = <span class="hljs-keyword">new</span> Stats(pid, parentPid, mIncludeThreads);<br>                allProcs.add(curStatsIndex, st);<br>                curStatsIndex++;<br>                NS++;<br>                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;New &quot;</span><br>                        + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)<br>                        + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);<br><br>                <span class="hljs-keyword">final</span> String[] procStatsString = mProcessFullStatsStringData;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] procStats = mProcessFullStatsData;<br>                st.base_uptime = SystemClock.uptimeMillis();<br>                String path = st.statFile.toString();<br>                <span class="hljs-comment">//Slog.d(TAG, &quot;Reading proc file: &quot; + path);</span><br>                <span class="hljs-keyword">if</span> (Process.readProcFile(path, PROCESS_FULL_STATS_FORMAT, procStatsString,<br>                        procStats, <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-comment">// This is a possible way to filter out processes that</span><br>                    <span class="hljs-comment">// are actually kernel threads...  do we want to?  Some</span><br>                    <span class="hljs-comment">// of them do use CPU, but there can be a *lot* that are</span><br>                    <span class="hljs-comment">// not doing anything.</span><br>                    st.vsize = procStats[PROCESS_FULL_STAT_VSIZE];<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span> || procStats[PROCESS_FULL_STAT_VSIZE] != <span class="hljs-number">0</span>) &#123;<br>                        st.interesting = <span class="hljs-keyword">true</span>;<br>                        st.baseName = procStatsString[<span class="hljs-number">0</span>];<br>                        st.base_minfaults = procStats[PROCESS_FULL_STAT_MINOR_FAULTS];<br>                        st.base_majfaults = procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];<br>                        st.base_utime = procStats[PROCESS_FULL_STAT_UTIME] * mJiffyMillis;<br>                        st.base_stime = procStats[PROCESS_FULL_STAT_STIME] * mJiffyMillis;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        Slog.i(TAG, <span class="hljs-string">&quot;Skipping kernel process pid &quot;</span> + pid<br>                                + <span class="hljs-string">&quot; name &quot;</span> + procStatsString[<span class="hljs-number">0</span>]);<br>                        st.baseName = procStatsString[<span class="hljs-number">0</span>];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Slog.w(TAG, <span class="hljs-string">&quot;Skipping unknown process pid &quot;</span> + pid);<br>                    st.baseName = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;<br>                    st.base_utime = st.base_stime = <span class="hljs-number">0</span>;<br>                    st.base_minfaults = st.base_majfaults = <span class="hljs-number">0</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (parentPid &lt; <span class="hljs-number">0</span>) &#123;<br>                    getName(st, st.cmdlineFile);<br>                    <span class="hljs-keyword">if</span> (st.threadStats != <span class="hljs-keyword">null</span>) &#123;<br>                        mCurThreadPids = collectStats(st.threadsDir, pid, <span class="hljs-keyword">true</span>,<br>                                mCurThreadPids, st.threadStats);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.interesting) &#123;<br>                    st.name = st.baseName;<br>                    st.nameWidth = onMeasureProcessName(st.name);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Stats added &quot;</span> + st.name + <span class="hljs-string">&quot; pid=&quot;</span> + st.pid<br>                        + <span class="hljs-string">&quot; utime=&quot;</span> + st.base_utime + <span class="hljs-string">&quot; stime=&quot;</span> + st.base_stime<br>                        + <span class="hljs-string">&quot; minfaults=&quot;</span> + st.base_minfaults + <span class="hljs-string">&quot; majfaults=&quot;</span> + st.base_majfaults);<br><br>                st.rel_utime = <span class="hljs-number">0</span>;<br>                st.rel_stime = <span class="hljs-number">0</span>;<br>                st.rel_minfaults = <span class="hljs-number">0</span>;<br>                st.rel_majfaults = <span class="hljs-number">0</span>;<br>                st.added = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span> (!first &amp;&amp; st.interesting) &#123;<br>                    st.working = <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// This process has gone away!</span><br>            st.rel_utime = <span class="hljs-number">0</span>;<br>            st.rel_stime = <span class="hljs-number">0</span>;<br>            st.rel_minfaults = <span class="hljs-number">0</span>;<br>            st.rel_majfaults = <span class="hljs-number">0</span>;<br>            st.removed = <span class="hljs-keyword">true</span>;<br>            st.working = <span class="hljs-keyword">true</span>;<br>            allProcs.remove(curStatsIndex);<br>            NS--;<br>            <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Removed &quot;</span><br>                    + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)<br>                    + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);<br>            <span class="hljs-comment">// Decrement the loop counter so that we process the current pid</span><br>            <span class="hljs-comment">// again the next time through the loop.</span><br>            i--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (curStatsIndex &lt; NS) &#123;<br>            <span class="hljs-comment">// This process has gone away!</span><br>            <span class="hljs-keyword">final</span> Stats st = allProcs.get(curStatsIndex);<br>            st.rel_utime = <span class="hljs-number">0</span>;<br>            st.rel_stime = <span class="hljs-number">0</span>;<br>            st.rel_minfaults = <span class="hljs-number">0</span>;<br>            st.rel_majfaults = <span class="hljs-number">0</span>;<br>            st.removed = <span class="hljs-keyword">true</span>;<br>            st.working = <span class="hljs-keyword">true</span>;<br>            allProcs.remove(curStatsIndex);<br>            NS--;<br>            <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Removed pid &quot;</span> + st.pid + <span class="hljs-string">&quot;: &quot;</span> + st);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pids;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">jboolean <span class="hljs-title">android_os_Process_readProcFile</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jstring file, jintArray format, jobjectArray outStrings,</span></span><br><span class="hljs-params"><span class="hljs-function">        jlongArray outLongs, jfloatArray outFloats)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span> || format == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> JNI_FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (file8 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> JNI_FALSE;<br>    &#125;<br><br>    ::android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(open(file8, O_RDONLY | O_CLOEXEC))</span></span>;<br>    <span class="hljs-keyword">if</span> (!fd.<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (kDebugProc) &#123;<br>            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Unable to open process file: %s\n&quot;</span>, file8);<br>        &#125;<br>        env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);<br>        <span class="hljs-keyword">return</span> JNI_FALSE;<br>    &#125;<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);<br><br>    <span class="hljs-comment">// Most proc files we read are small, so we only go through the</span><br>    <span class="hljs-comment">// loop once and use the stack buffer.  We allocate a buffer big</span><br>    <span class="hljs-comment">// enough for the whole file.</span><br><br>    <span class="hljs-keyword">char</span> readBufferStack[kProcReadStackBufferSize];<br>    std::unique_ptr&lt;<span class="hljs-keyword">char</span>[]&gt; readBufferHeap;<br>    <span class="hljs-keyword">char</span>* readBuffer = &amp;readBufferStack[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">ssize_t</span> readBufferSize = kProcReadStackBufferSize;<br>    <span class="hljs-keyword">ssize_t</span> numberBytesRead;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// By using pread, we can avoid an lseek to rewind the FD</span><br>        <span class="hljs-comment">// before retry, saving a system call.</span><br>        numberBytesRead = <span class="hljs-built_in">pread</span>(fd, readBuffer, readBufferSize, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (numberBytesRead &lt; <span class="hljs-number">0</span> &amp;&amp; errno == EINTR) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (numberBytesRead &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (kDebugProc) &#123;<br>                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Unable to open process file: %s fd=%d\n&quot;</span>, file8, fd.<span class="hljs-built_in">get</span>());<br>            &#125;<br>            <span class="hljs-keyword">return</span> JNI_FALSE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (numberBytesRead &lt; readBufferSize) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (readBufferSize &gt; std::numeric_limits&lt;<span class="hljs-keyword">ssize_t</span>&gt;::<span class="hljs-built_in">max</span>() / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (kDebugProc) &#123;<br>                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Proc file too big: %s fd=%d\n&quot;</span>, file8, fd.<span class="hljs-built_in">get</span>());<br>            &#125;<br>            <span class="hljs-keyword">return</span> JNI_FALSE;<br>        &#125;<br>        readBufferSize = std::<span class="hljs-built_in">max</span>(readBufferSize * <span class="hljs-number">2</span>,<br>                                  kProcReadMinHeapBufferSize);<br>        readBufferHeap.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// Free address space before getting more.</span><br>        readBufferHeap = std::make_unique&lt;<span class="hljs-keyword">char</span>[]&gt;(readBufferSize);<br>        <span class="hljs-keyword">if</span> (!readBufferHeap) &#123;<br>            <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">return</span> JNI_FALSE;<br>        &#125;<br>        readBuffer = readBufferHeap.<span class="hljs-built_in">get</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// parseProcLineArray below modifies the buffer while parsing!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">android_os_Process_parseProcLineArray</span>(<br>        env, clazz, readBuffer, <span class="hljs-number">0</span>, numberBytesRead,<br>        format, outStrings, outLongs, outFloats);<br>&#125;<br><br><span class="hljs-function">jboolean <span class="hljs-title">android_os_Process_parseProcLineArray</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">char</span>* buffer, jint startIndex, jint endIndex, jintArray format,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobjectArray outStrings, jlongArray outLongs, jfloatArray outFloats)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">const</span> jsize NF = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(format);<br>    <span class="hljs-keyword">const</span> jsize NS = outStrings ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outStrings) : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> jsize NL = outLongs ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outLongs) : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> jsize NR = outFloats ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outFloats) : <span class="hljs-number">0</span>;<br><br>    jint* formatData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(format, <span class="hljs-number">0</span>);<br>    jlong* longsData = outLongs ?<br>        env-&gt;<span class="hljs-built_in">GetLongArrayElements</span>(outLongs, <span class="hljs-number">0</span>) : <span class="hljs-literal">NULL</span>;<br>    jfloat* floatsData = outFloats ?<br>        env-&gt;<span class="hljs-built_in">GetFloatArrayElements</span>(outFloats, <span class="hljs-number">0</span>) : <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (formatData == <span class="hljs-literal">NULL</span> || (NL &gt; <span class="hljs-number">0</span> &amp;&amp; longsData == <span class="hljs-literal">NULL</span>)<br>            || (NR &gt; <span class="hljs-number">0</span> &amp;&amp; floatsData == <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-keyword">if</span> (formatData != <span class="hljs-literal">NULL</span>) &#123;<br>            env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(format, formatData, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (longsData != <span class="hljs-literal">NULL</span>) &#123;<br>            env-&gt;<span class="hljs-built_in">ReleaseLongArrayElements</span>(outLongs, longsData, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (floatsData != <span class="hljs-literal">NULL</span>) &#123;<br>            env-&gt;<span class="hljs-built_in">ReleaseFloatArrayElements</span>(outFloats, floatsData, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> JNI_FALSE;<br>    &#125;<br><br>    jsize i = startIndex;<br>    jsize di = <span class="hljs-number">0</span>;<br><br>    jboolean res = JNI_TRUE;<br><br>    <span class="hljs-keyword">for</span> (jsize fi=<span class="hljs-number">0</span>; fi&lt;NF; fi++) &#123;<br>        jint mode = formatData[fi];<br>        <span class="hljs-keyword">if</span> ((mode&amp;PROC_PARENS) != <span class="hljs-number">0</span>) &#123;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode&amp;PROC_QUOTES) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i] == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mode &amp;= ~PROC_QUOTES;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> term = (<span class="hljs-keyword">char</span>)(mode&amp;PROC_TERM_MASK);<br>        <span class="hljs-keyword">const</span> jsize start = i;<br>        <span class="hljs-keyword">if</span> (i &gt;= endIndex) &#123;<br>            <span class="hljs-keyword">if</span> (kDebugProc) &#123;<br>                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Ran off end of data @%d&quot;</span>, i);<br>            &#125;<br>            res = JNI_FALSE;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        jsize end = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> ((mode&amp;PROC_PARENS) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] != <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            end = i;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode&amp;PROC_QUOTES) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (buffer[i] != <span class="hljs-string">&#x27;&quot;&#x27;</span> &amp;&amp; i &lt; endIndex) &#123;<br>                i++;<br>            &#125;<br>            end = i;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] != term) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;<br>            end = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; endIndex) &#123;<br>            i++;<br>            <span class="hljs-keyword">if</span> ((mode&amp;PROC_COMBINE) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] == term) &#123;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//ALOGI(&quot;Field %&quot; PRId32 &quot;: %&quot; PRId32 &quot;-%&quot; PRId32 &quot; dest=%&quot; PRId32 &quot; mode=0x%&quot; PRIx32 &quot;\n&quot;, i, start, end, di, mode);</span><br><br>        <span class="hljs-keyword">if</span> ((mode&amp;(PROC_OUT_FLOAT|PROC_OUT_LONG|PROC_OUT_STRING)) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">char</span> c = buffer[end];<br>            buffer[end] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_FLOAT) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NR) &#123;<br>                <span class="hljs-keyword">char</span>* end;<br>                floatsData[di] = <span class="hljs-built_in">strtof</span>(buffer+start, &amp;end);<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_LONG) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NL) &#123;<br>                <span class="hljs-keyword">if</span> ((mode&amp;PROC_CHAR) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// Caller wants single first character returned as one long.</span><br>                    longsData[di] = buffer[start];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">char</span>* end;<br>                    longsData[di] = <span class="hljs-built_in">strtoll</span>(buffer+start, &amp;end, <span class="hljs-number">10</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_STRING) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NS) &#123;<br>                jstring str = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(buffer+start);<br>                env-&gt;<span class="hljs-built_in">SetObjectArrayElement</span>(outStrings, di, str);<br>            &#125;<br>            buffer[end] = c;<br>            di++;<br>        &#125;<br>    &#125;<br><br>    env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(format, formatData, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (longsData != <span class="hljs-literal">NULL</span>) &#123;<br>        env-&gt;<span class="hljs-built_in">ReleaseLongArrayElements</span>(outLongs, longsData, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (floatsData != <span class="hljs-literal">NULL</span>) &#123;<br>        env-&gt;<span class="hljs-built_in">ReleaseFloatArrayElements</span>(outFloats, floatsData, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="CPU-概览-proc-stat"><a href="#CPU-概览-proc-stat" class="headerlink" title="CPU 概览 /proc/stat"></a>CPU 概览 <code>/proc/stat</code></h3><p><code>ProcessCpuTracker.update()</code> 同时也从 <code>/proc/stat</code> 收集了某个时间段内总的 CPU 时间用以计算各进程的 CPU 使用率；下面是从 MI 9 上获取的 <code>/proc/stat</code> 文件内容，看得出来它有八个核心（骁龙 855），CPU 时间的单位为 <code>jiffies</code>，各字段的含义如下：</p><blockquote><p><code>jiffies</code> 是内核中的一个全局变量，用来记录自系统启动以来产生的 <strong>节拍数</strong>，在 linux 中一个节拍大致可理解为操作系统进程调度的最小时间片，不同 linux 内核可能值有不同，通常在 1ms 到 10ms 之间</p></blockquote><table><thead><tr><th>index</th><th>name</th><th>desc</th></tr></thead><tbody><tr><td>0</td><td>user</td><td>处于用户态的运行时间（nice &lt;= 0 的进程）</td></tr><tr><td>1</td><td>nice</td><td>处于用户态的运行时间（nice &gt; 0 的进程）</td></tr><tr><td>2</td><td>system</td><td>处于核心态的运行时间</td></tr><tr><td>3</td><td>idle</td><td>除 IO 等待时间以外的其它等待时间</td></tr><tr><td>4</td><td>iowait</td><td>IO等待时间</td></tr><tr><td>5</td><td>irq</td><td>硬中断时间</td></tr><tr><td>6</td><td>softirq</td><td>软中断时间</td></tr><tr><td>7</td><td>steal</td><td>被盗时间，虚拟化环境中运行其他操作系统上花费的时间（since Linux 2.6.11）</td></tr><tr><td>8</td><td>guest</td><td>来宾时间，操作系统运行虚拟CPU花费的时间(since Linux 2.6.24)</td></tr><tr><td>9</td><td>guest_nice</td><td>nice 来宾时间，运行一个带 nice 值的 guest 花费的时间(since Linux 2.6.33)</td></tr></tbody></table><p>可以看到跟 <code>进程概览</code> 一样，<code>mBaseXxxTime</code> 记录的是当前值，<code>mRelXxxTime</code> 记录的是当前与上一次的差值</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cepheus:/ $ cat /proc/stat<br>cpu  1908033 248762 1291479 9313559 21704 241034 75778 0 0 0<br>cpu0 261151 61609 246778 2138176 9728 89991 29646 0 0 0<br>cpu1 280460 61787 257071 884928 2710 43158 18528 0 0 0<br>cpu2 280724 62167 252355 892787 2211 44246 9462 0 0 0<br>cpu3 184034 10677 205483 975756 2070 33267 12197 0 0 0<br>cpu4 283943 16128 102688 1078345 1403 9754 1747 0 0 0<br>cpu5 289844 13063 106131 1078167 1614 10022 1788 0 0 0<br>cpu6 292748 12779 104992 1080547 1446 9863 1902 0 0 0<br>cpu7 35125 10548 15978 1184849 520 730 504 0 0 0<br>intr 195962347 0 0 0 0 26288625 0 2879495 0 2097574 0 0 0 0 280 76 0 11 0 2 0 199 0 2 0 2 92 0 0 2 30 0 0 390294 340099 0 35976 0 0 0 0 0 0 0 0 0 0 0 138 0 0 0 0 0 0 0 1 0 147 0 102 0 0 66880 0 0 0 0 0 0 6032 0 0 0 0 0 0 0 0 0 0 0 0 0 212 0 0 0 0 0 0 0 0 0 0 0 0 5551 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2308413 6080542 16668 0 0 29 0 0 0 0 0 0 0 2938 1213 12 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3135 0 0 0 0 0 0 0 0 0 0 0 0 467941 0 0 0 0 0 0 0 0 0 0 0 16029 443134 6 192353 303384 26156 0 0 0 0 0 226499 103608 771093 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 498 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 153671 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 4 52028 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65667 0 77 0 0 0 0 0 0 0 330476 0 0 0 0 1342751 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 1 0 1 0 0 0 25847 0 0 72 0 0 0 527 4 0 2 2 0 0 3 0 0 5 0 0 0 0 0 62695 0 0 0 0 0 23 0 0 0 0 0 0 0 0 4 2 0 7 0 0 0 0 0 0 0 6 7 7 0 7 0 30 351 0 0 0 0 0 0 0 0 0 7 0 0 7 0 0 1034 504 0 760 2 0 0 1 0 0 0 0 0 0 0 0 22385 1250 4578494 1293217 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 455534 0 0 23167<br>ctxt 292922052<br>btime 1634510913<br>processes 215684<br>procs_running 1<br>procs_blocked 0<br>softirq 28955158 6101535 6564415 106706 1458910 1999704 0 1242328 6001922 0 5479638<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessCpuTracker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Update: &quot;</span> + <span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowUptime = SystemClock.uptimeMillis();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowRealtime = SystemClock.elapsedRealtime();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nowWallTime = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] sysCpu = mSystemCpuData;<br>        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/stat&quot;</span>, SYSTEM_CPU_FORMAT,<br>                <span class="hljs-keyword">null</span>, sysCpu, <span class="hljs-keyword">null</span>)) &#123;<br>            <span class="hljs-comment">// Total user time is user + nice time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> usertime = (sysCpu[<span class="hljs-number">0</span>]+sysCpu[<span class="hljs-number">1</span>]) * mJiffyMillis;<br>            <span class="hljs-comment">// Total system time is simply system time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> systemtime = sysCpu[<span class="hljs-number">2</span>] * mJiffyMillis;<br>            <span class="hljs-comment">// Total idle time is simply idle time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> idletime = sysCpu[<span class="hljs-number">3</span>] * mJiffyMillis;<br>            <span class="hljs-comment">// Total irq time is iowait + irq + softirq time.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> iowaittime = sysCpu[<span class="hljs-number">4</span>] * mJiffyMillis;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> irqtime = sysCpu[<span class="hljs-number">5</span>] * mJiffyMillis;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> softirqtime = sysCpu[<span class="hljs-number">6</span>] * mJiffyMillis;<br><br>            <span class="hljs-comment">// This code is trying to avoid issues with idle time going backwards,</span><br>            <span class="hljs-comment">// but currently it gets into situations where it triggers most of the time. :(</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span> || (usertime &gt;= mBaseUserTime &amp;&amp; systemtime &gt;= mBaseSystemTime<br>                    &amp;&amp; iowaittime &gt;= mBaseIoWaitTime &amp;&amp; irqtime &gt;= mBaseIrqTime<br>                    &amp;&amp; softirqtime &gt;= mBaseSoftIrqTime &amp;&amp; idletime &gt;= mBaseIdleTime)) &#123;<br>                mRelUserTime = (<span class="hljs-keyword">int</span>)(usertime - mBaseUserTime);<br>                mRelSystemTime = (<span class="hljs-keyword">int</span>)(systemtime - mBaseSystemTime);<br>                mRelIoWaitTime = (<span class="hljs-keyword">int</span>)(iowaittime - mBaseIoWaitTime);<br>                mRelIrqTime = (<span class="hljs-keyword">int</span>)(irqtime - mBaseIrqTime);<br>                mRelSoftIrqTime = (<span class="hljs-keyword">int</span>)(softirqtime - mBaseSoftIrqTime);<br>                mRelIdleTime = (<span class="hljs-keyword">int</span>)(idletime - mBaseIdleTime);<br>                mRelStatsAreGood = <span class="hljs-keyword">true</span>;<br><br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Total U:&quot;</span> + (sysCpu[<span class="hljs-number">0</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; N:&quot;</span> + (sysCpu[<span class="hljs-number">1</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; S:&quot;</span> + (sysCpu[<span class="hljs-number">2</span>]*mJiffyMillis) + <span class="hljs-string">&quot; I:&quot;</span> + (sysCpu[<span class="hljs-number">3</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; W:&quot;</span> + (sysCpu[<span class="hljs-number">4</span>]*mJiffyMillis) + <span class="hljs-string">&quot; Q:&quot;</span> + (sysCpu[<span class="hljs-number">5</span>]*mJiffyMillis)<br>                          + <span class="hljs-string">&quot; O:&quot;</span> + (sysCpu[<span class="hljs-number">6</span>]*mJiffyMillis));<br>                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Rel U:&quot;</span> + mRelUserTime + <span class="hljs-string">&quot; S:&quot;</span> + mRelSystemTime<br>                          + <span class="hljs-string">&quot; I:&quot;</span> + mRelIdleTime + <span class="hljs-string">&quot; Q:&quot;</span> + mRelIrqTime);<br>                &#125;<br><br>                mBaseUserTime = usertime;<br>                mBaseSystemTime = systemtime;<br>                mBaseIoWaitTime = iowaittime;<br>                mBaseIrqTime = irqtime;<br>                mBaseSoftIrqTime = softirqtime;<br>                mBaseIdleTime = idletime;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mRelUserTime = <span class="hljs-number">0</span>;<br>                mRelSystemTime = <span class="hljs-number">0</span>;<br>                mRelIoWaitTime = <span class="hljs-number">0</span>;<br>                mRelIrqTime = <span class="hljs-number">0</span>;<br>                mRelSoftIrqTime = <span class="hljs-number">0</span>;<br>                mRelIdleTime = <span class="hljs-number">0</span>;<br>                mRelStatsAreGood = <span class="hljs-keyword">false</span>;<br>                Slog.w(TAG, <span class="hljs-string">&quot;/proc/stats has gone backwards; skipping CPU update&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        mLastSampleTime = mCurrentSampleTime;<br>        mCurrentSampleTime = nowUptime;<br>        mLastSampleRealTime = mCurrentSampleRealTime;<br>        mCurrentSampleRealTime = nowRealtime;<br>        mLastSampleWallTime = mCurrentSampleWallTime;<br>        mCurrentSampleWallTime = nowWallTime;<br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="打印进程概览"><a href="#打印进程概览" class="headerlink" title="打印进程概览"></a>打印进程概览</h3><p><code>printProcessCPU(prefix, pid, label, totalTime, user, system, iowait, irg, softIrq, minFaults, majFaults)</code> 打印出一行的 CPU 使用率（一行对应一个进程）</p><p><code>ProcessCpuTracker.printCurrentState</code> 会输出两类 CPU 使用率：</p><ol><li>在进程生存的时间段内（<code>SystemClock.uptimeMillis()</code>），分配给进程的 CPU 时间的占比，细分用户态和内核态</li><li>在两个采集点（<code>ProcessCpuTracker.update</code>）之间的时间段内，CPU 的整体使用率（idle time 表示空闲）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">[prefix][(user + system + iowait + irq + softIrq) / totalTime]% [pid]/[label]: <br>[user/totalTime]% user + [system/totalTime]% kernel + [iowait/totalTime]% iowait + [irq/totalTime]% irq + [softirq/totalTime]% softirq / faults: [minFaults] minor [majFaults] major<br><br>32% 8356/com.taobao.taobao: 17% user + 15% kernel / faults: 9334 minor 85 major<br>19% TOTAL: 8% user + 9.2% kernel + 0.6% iowait + 0.9% irq + 0.4% softirq<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessCpuTracker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">printCurrentState</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalTime = mRelUserTime + mRelSystemTime + mRelIoWaitTime<br>                + mRelIrqTime + mRelSoftIrqTime + mRelIdleTime;<br><br>        <span class="hljs-keyword">if</span> (DEBUG) Slog.i(TAG, <span class="hljs-string">&quot;totalTime &quot;</span> + totalTime + <span class="hljs-string">&quot; over sample time &quot;</span><br>                + (mCurrentSampleTime-mLastSampleTime));<br><br>        <span class="hljs-keyword">int</span> N = mWorkingProcs.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            Stats st = mWorkingProcs.get(i);<br>            printProcessCPU(pw, st.added ? <span class="hljs-string">&quot; +&quot;</span> : (st.removed ? <span class="hljs-string">&quot; -&quot;</span>: <span class="hljs-string">&quot;  &quot;</span>),<br>                    st.pid, st.name, (<span class="hljs-keyword">int</span>)st.rel_uptime,<br>                    st.rel_utime, st.rel_stime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, st.rel_minfaults, st.rel_majfaults);<br>            <span class="hljs-keyword">if</span> (!st.removed &amp;&amp; st.workingThreads != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> M = st.workingThreads.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;M; j++) &#123;<br>                    Stats tst = st.workingThreads.get(j);<br>                    printProcessCPU(pw,<br>                            tst.added ? <span class="hljs-string">&quot;   +&quot;</span> : (tst.removed ? <span class="hljs-string">&quot;   -&quot;</span>: <span class="hljs-string">&quot;    &quot;</span>),<br>                            tst.pid, tst.name, (<span class="hljs-keyword">int</span>)st.rel_uptime,<br>                            tst.rel_utime, tst.rel_stime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        printProcessCPU(pw, <span class="hljs-string">&quot;&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;TOTAL&quot;</span>, totalTime, mRelUserTime, mRelSystemTime,<br>                mRelIoWaitTime, mRelIrqTime, mRelSoftIrqTime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        pw.flush();<br>        <span class="hljs-keyword">return</span> sw.toString();<br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessCpuTracker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printProcessCPU</span><span class="hljs-params">(PrintWriter pw, String prefix, <span class="hljs-keyword">int</span> pid, String label,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">int</span> totalTime, <span class="hljs-keyword">int</span> user, <span class="hljs-keyword">int</span> system, <span class="hljs-keyword">int</span> iowait, <span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">int</span> softIrq,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">int</span> minFaults, <span class="hljs-keyword">int</span> majFaults)</span> </span>&#123;<br>        pw.print(prefix);<br>        <span class="hljs-keyword">if</span> (totalTime == <span class="hljs-number">0</span>) totalTime = <span class="hljs-number">1</span>;<br>        printRatio(pw, user+system+iowait+irq+softIrq, totalTime);<br>        pw.print(<span class="hljs-string">&quot;% &quot;</span>);<br>        <span class="hljs-keyword">if</span> (pid &gt;= <span class="hljs-number">0</span>) &#123;<br>            pw.print(pid);<br>            pw.print(<span class="hljs-string">&quot;/&quot;</span>);<br>        &#125;<br>        pw.print(label);<br>        pw.print(<span class="hljs-string">&quot;: &quot;</span>);<br>        printRatio(pw, user, totalTime);<br>        pw.print(<span class="hljs-string">&quot;% user + &quot;</span>);<br>        printRatio(pw, system, totalTime);<br>        pw.print(<span class="hljs-string">&quot;% kernel&quot;</span>);<br>        <span class="hljs-keyword">if</span> (iowait &gt; <span class="hljs-number">0</span>) &#123;<br>            pw.print(<span class="hljs-string">&quot; + &quot;</span>);<br>            printRatio(pw, iowait, totalTime);<br>            pw.print(<span class="hljs-string">&quot;% iowait&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (irq &gt; <span class="hljs-number">0</span>) &#123;<br>            pw.print(<span class="hljs-string">&quot; + &quot;</span>);<br>            printRatio(pw, irq, totalTime);<br>            pw.print(<span class="hljs-string">&quot;% irq&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (softIrq &gt; <span class="hljs-number">0</span>) &#123;<br>            pw.print(<span class="hljs-string">&quot; + &quot;</span>);<br>            printRatio(pw, softIrq, totalTime);<br>            pw.print(<span class="hljs-string">&quot;% softirq&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minFaults &gt; <span class="hljs-number">0</span> || majFaults &gt; <span class="hljs-number">0</span>) &#123;<br>            pw.print(<span class="hljs-string">&quot; / faults:&quot;</span>);<br>            <span class="hljs-keyword">if</span> (minFaults &gt; <span class="hljs-number">0</span>) &#123;<br>                pw.print(<span class="hljs-string">&quot; &quot;</span>);<br>                pw.print(minFaults);<br>                pw.print(<span class="hljs-string">&quot; minor&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (majFaults &gt; <span class="hljs-number">0</span>) &#123;<br>                pw.print(<span class="hljs-string">&quot; &quot;</span>);<br>                pw.print(majFaults);<br>                pw.print(<span class="hljs-string">&quot; major&quot;</span>);<br>            &#125;<br>        &#125;<br>        pw.println();<br>    &#125;   <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印 numerator / denominator 至 pw，最多保留一位小数位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printRatio</span><span class="hljs-params">(PrintWriter pw, <span class="hljs-keyword">long</span> numerator, <span class="hljs-keyword">long</span> denominator)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> thousands = (numerator*<span class="hljs-number">1000</span>)/denominator;<br>        <span class="hljs-keyword">long</span> hundreds = thousands/<span class="hljs-number">10</span>;<br>        pw.print(hundreds);<br>        <span class="hljs-keyword">if</span> (hundreds &lt; <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">long</span> remainder = thousands - (hundreds*<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>                pw.print(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                pw.print(remainder);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="ANR-日志文件"><a href="#ANR-日志文件" class="headerlink" title="ANR 日志文件"></a>ANR 日志文件</h1><p>ANR 日志文件太大了，下面仅展示日志的基本结构，整个示例文件可以在 <a href="../../../../files/2021-06-27-deep-drive-into-anr/anr_2021-09-29-16-02-49-393">这里</a> 下载</p><p>日志文件包含多个进程，每个进程以 <code>----- pid [pid] at [time] -----</code> 开始，以 <code>----- end [pid] -----</code> 结束，而且很明显地分为 <code>java process</code> 和 <code>native process</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log"># java process 包含了 JVM 各种统计信息以及 thread trace<br>----- pid 001 at 2021-09-29 16:02:49 -----<br>Cmd line: com.example.myapplication<br>...<br><br>DALVIK THREADS (16):<br>&quot;main&quot; prio=5 tid=1 Sleeping<br>  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x72313478 self=0xb400007f542bbc00<br>  | sysTid=27750 nice=-10 cgrp=default sched=0/0 handle=0x7f559584f8<br>  | state=S schedstat=( 439366137 82406360 402 ) utm=36 stm=7 core=0 HZ=100<br>  | stack=0x7ffd85d000-0x7ffd85f000 stackSize=8192KB<br>  | held mutexes=<br>  at java.lang.Thread.sleep(Native method)<br>  - sleeping on &lt;0x0bd69ce3&gt; (a java.lang.Object)<br>  at java.lang.Thread.sleep(Thread.java:442)<br>  - locked &lt;0x0bd69ce3&gt; (a java.lang.Object)<br>  at java.lang.Thread.sleep(Thread.java:358)<br>  at com.example.myapplication.MainActivity.onCreate$lambda-0(MainActivity.kt:20)<br>  at com.example.myapplication.MainActivity.lambda$b-o9DaQhxOUy1smA7kVJfKXtbVM(MainActivity.kt:-1)<br>  at com.example.myapplication.-$$Lambda$MainActivity$b-o9DaQhxOUy1smA7kVJfKXtbVM.onClick(lambda:-1)<br>  at android.view.View.performClick(View.java:7509)<br>  at android.view.View.performClickInternal(View.java:7486)<br>  at android.view.View.access$3600(View.java:841)<br>  at android.view.View$PerformClick.run(View.java:28709)<br>  at android.os.Handler.handleCallback(Handler.java:938)<br>  at android.os.Handler.dispatchMessage(Handler.java:99)<br>  at android.os.Looper.loop(Looper.java:236)<br>  at android.app.ActivityThread.main(ActivityThread.java:8061)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)<br><br>...<br><br>----- end 001 -----<br><br># native process 就只有各个线程的 PC 寄存器值<br>----- pid 002 at 2021-09-29 16:02:52 -----<br>Cmd line: media.codec<br>ABI: &#x27;arm&#x27;<br><br>&quot;omx@1.0-service&quot; sysTid=1464<br>    #00 pc 000a0644  /apex/com.android.runtime/lib/bionic/libc.so (__ioctl+8) (BuildId: 3516bc395829323390a814b64aaaf5a1)<br>    #01 pc 0006c56b  /apex/com.android.runtime/lib/bionic/libc.so (ioctl+26) (BuildId: 3516bc395829323390a814b64aaaf5a1)<br>    #02 pc 0005f5f3  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::talkWithDriver(bool)+190) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)<br>    #03 pc 0005f79f  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::getAndExecuteCommand()+22) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)<br>    #04 pc 00060671  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::joinThreadPool(bool)+100) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)<br>    #05 pc 00002389  /vendor/bin/hw/android.hardware.media.omx@1.0-service (main+936) (BuildId: 116b35d790a6fac142d3d1eac096a1b8)<br>    #06 pc 0005fddb  /apex/com.android.runtime/lib/bionic/libc.so (__libc_init+66) (BuildId: 3516bc395829323390a814b64aaaf5a1)<br><br>...<br><br>----- end 002 -----<br></code></pre></div></td></tr></table></figure><h2 id="目录和文件名"><a href="#目录和文件名" class="headerlink" title="目录和文件名"></a>目录和文件名</h2><p><code>ProcessErrorStateRecord.appNotResponding</code> 在输出 logcat 日志的同时也输出了更加详细的 ANR Trace 至文件里，如下代码所示，<code>ActivityManagerService.dumpStackTraces</code> 创建了日志文件 <code>/data/anr/anr_[yyyy-MM-dd-HH-mm-ss-SSS]</code></p><p><code>/data/anr</code> 目录下超过一天，或者超过 64 个日志文件后最旧的，都会被清理掉</p><blockquote><p>旧版本的 Android 上日志文件在 /data/anr/traces.txt</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessErrorStateRecord</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ANR_TRACE_DIR = <span class="hljs-string">&quot;/data/anr&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ANR_FILE_PREFIX = <span class="hljs-string">&quot;anr_&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">            String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">boolean</span> aboveSystem, String annotation, <span class="hljs-keyword">boolean</span> onlyDumpSelf)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">2</span>];<br>        File tracesFile = ActivityManagerService.dumpStackTraces(firstPids,<br>                isSilentAnr ? <span class="hljs-keyword">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-keyword">null</span> : lastPids,<br>                nativePids, tracesFileException, offsets, annotation);<br>        <span class="hljs-comment">// ...                </span><br>        <span class="hljs-keyword">if</span> (tracesFile == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// There is no trace file, so dump (only) the alleged culprit&#x27;s threads to the log</span><br>            Process.sendSignal(pid, Process.SIGNAL_QUIT);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsets[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// We&#x27;ve dumped into the trace file successfully</span><br>            mService.mProcessList.mAppExitInfoTracker.scheduleLogAnrTrace(<br>                    pid, mApp.uid, mApp.getPackageList(), tracesFile, offsets[<span class="hljs-number">0</span>], offsets[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> </span>&#123;<br>    <span class="hljs-comment">/* package */</span> <span class="hljs-function"><span class="hljs-keyword">static</span> File <span class="hljs-title">dumpStackTraces</span><span class="hljs-params">(ArrayList&lt;Integer&gt; firstPids,</span></span><br><span class="hljs-params"><span class="hljs-function">            ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,</span></span><br><span class="hljs-params"><span class="hljs-function">            ArrayList&lt;Integer&gt; nativePids, StringWriter logExceptionCreatingFile,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">long</span>[] firstPidOffsets, String subject)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">final</span> File tracesDir = <span class="hljs-keyword">new</span> File(ANR_TRACE_DIR);<br>        <span class="hljs-comment">// Each set of ANR traces is written to a separate file and dumpstate will process</span><br>        <span class="hljs-comment">// all such files and add them to a captured bug report if they&#x27;re recent enough.</span><br>        maybePruneOldTraces(tracesDir);<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We should consider creating the file in native code atomically once we&#x27;ve</span><br>        <span class="hljs-comment">// gotten rid of the old scheme of dumping and lot of the code that deals with paths</span><br>        <span class="hljs-comment">// can be removed.</span><br>        File tracesFile;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tracesFile = createAnrDumpFile(tracesDir);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Exception creating ANR dump file:&quot;</span>, e);<br>            <span class="hljs-keyword">if</span> (logExceptionCreatingFile != <span class="hljs-keyword">null</span>) &#123;<br>                logExceptionCreatingFile.append(<span class="hljs-string">&quot;----- Exception creating ANR dump file -----\n&quot;</span>);<br>                e.printStackTrace(<span class="hljs-keyword">new</span> PrintWriter(logExceptionCreatingFile));<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> File <span class="hljs-title">createAnrDumpFile</span><span class="hljs-params">(File tracesDir)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (sAnrFileDateFormat == <span class="hljs-keyword">null</span>) &#123;<br>            sAnrFileDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd-HH-mm-ss-SSS&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> String formattedDate = sAnrFileDateFormat.format(<span class="hljs-keyword">new</span> Date());<br>        <span class="hljs-keyword">final</span> File anrFile = <span class="hljs-keyword">new</span> File(tracesDir, ANR_FILE_PREFIX + formattedDate);<br><br>        <span class="hljs-keyword">if</span> (anrFile.createNewFile()) &#123;<br>            FileUtils.setPermissions(anrFile.getAbsolutePath(), <span class="hljs-number">0600</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// -rw-------</span><br>            <span class="hljs-keyword">return</span> anrFile;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Unable to create ANR dump file: createNewFile failed&quot;</span>);<br>        &#125;<br>    &#125;  <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Prune all trace files that are more than a day old.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> It might make sense to move this functionality to tombstoned eventually, along with a</span><br><span class="hljs-comment">     * shift away from anr_XX and tombstone_XX to a more descriptive name. We do it here for now</span><br><span class="hljs-comment">     * since it&#x27;s the system_server that creates trace files for most ANRs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maybePruneOldTraces</span><span class="hljs-params">(File tracesDir)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> File[] files = tracesDir.listFiles();<br>        <span class="hljs-keyword">if</span> (files == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> max = SystemProperties.getInt(<span class="hljs-string">&quot;tombstoned.max_anr_count&quot;</span>, <span class="hljs-number">64</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Arrays.sort(files, Comparator.comparingLong(File::lastModified).reversed());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; files.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; max || (now - files[i].lastModified()) &gt; DAY_IN_MILLIS) &#123;<br>                    <span class="hljs-keyword">if</span> (!files[i].delete()) &#123;<br>                        Slog.w(TAG, <span class="hljs-string">&quot;Unable to prune stale trace file: &quot;</span> + files[i]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>            <span class="hljs-comment">// The modification times changed while we were sorting. Bail...</span><br>            <span class="hljs-comment">// https://issuetracker.google.com/169836837</span><br>            Slog.w(TAG, <span class="hljs-string">&quot;tombstone modification times changed while sorting; not pruning&quot;</span>, e);<br>        &#125;<br>    &#125;          <br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是没有 root 权限的 adb 是没法查看文件的，也就没法通过 <code>adb pull</code> 把日志拉取出来进行分析，想要拿到 ANR Trace 只能通过 <code>adb bugreport</code>（参考 <a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a> 和 <a href="https://developer.android.com/studio/debug/bug-report">Bug Reports</a>）</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/data_anr_permission.png" alt="data_anr_permission"></p><h2 id="进程的次序"><a href="#进程的次序" class="headerlink" title="进程的次序"></a>进程的次序</h2><p>日志文件是由一个个的进程信息组成，而这些进程在 dump 的时候是有次序的，如下代码所示：</p><ol><li>第一个是发生 ANR 的进程的 pid</li><li>第二个是 parent pid（有的话）</li><li>第三个是 system server 进程</li><li>其他 APP 进程（受 AMS 管理的进程，保存在 <code>ActivityManagerService.mProcessList</code>）</li><li>然后是 native processes，其实就是进程的 <code>cmdline</code> 包含在 <code>WatchDog.NATIVE_STACKS_OF_INTEREST</code> 里的进程；进程的 <code>cmdline</code> 读取自 <code>/proc/[pid]/cmdline</code>，APP 是包名，其他则是可执行程序的路径</li><li>最后是 <code>lastPids</code>，它们是 <code>ActivityManagerService.mProcessList</code> 里不正常的进程（比如 ANR process）</li></ol><p>如果进程很多，那么 dump processes 耗费的时间也是很可观的，所以整个 dump processes 的过程有个时间上限 20s，超过这个阈值即使还有进程没有 dump 也会将其忽略，这也就解释了为什么要按上面的逻辑对进程进行排序，因为要优先打印重要的进程信息</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessErrorStateRecord</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">            String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">boolean</span> aboveSystem, String annotation, <span class="hljs-keyword">boolean</span> onlyDumpSelf)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; firstPids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">5</span>);<br>        SparseArray&lt;Boolean&gt; lastPids = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">synchronized</span> (mService) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// Dump thread traces as quickly as we can, starting with &quot;interesting&quot; processes.</span><br>            firstPids.add(pid);<br><br>            <span class="hljs-comment">// Don&#x27;t dump other PIDs if it&#x27;s a background ANR or is requested to only dump self.</span><br>            isSilentAnr = isSilentAnr();<br>            <span class="hljs-keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;<br>                <span class="hljs-keyword">int</span> parentPid = pid;<br>                <span class="hljs-keyword">if</span> (parentProcess != <span class="hljs-keyword">null</span> &amp;&amp; parentProcess.getPid() &gt; <span class="hljs-number">0</span>) &#123;<br>                    parentPid = parentProcess.getPid();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (parentPid != pid) firstPids.add(parentPid);<br><br>                <span class="hljs-keyword">if</span> (MY_PID != pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ppid = parentPid;<br>                mService.mProcessList.forEachLruProcessesLOSP(<span class="hljs-keyword">false</span>, r -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span> &amp;&amp; r.getThread() != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">int</span> myPid = r.getPid();<br>                        <span class="hljs-keyword">if</span> (myPid &gt; <span class="hljs-number">0</span> &amp;&amp; myPid != pid &amp;&amp; myPid != ppid &amp;&amp; myPid != MY_PID) &#123;<br>                            <span class="hljs-keyword">if</span> (r.isPersistent()) &#123;<br>                                firstPids.add(myPid);<br>                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding persistent proc: &quot;</span> + r);<br>                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.mServices.isTreatedLikeActivity()) &#123;<br>                                firstPids.add(myPid);<br>                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding likely IME: &quot;</span> + r);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                lastPids.put(myPid, Boolean.TRUE);<br>                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding ANR proc: &quot;</span> + r);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Log the ANR to the main log ...</span><br><br>        <span class="hljs-comment">// don&#x27;t dump native PIDs for background ANRs unless it is the process of interest</span><br>        String[] nativeProcs = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (isSilentAnr || onlyDumpSelf) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (NATIVE_STACKS_OF_INTEREST[i].equals(mApp.processName)) &#123;<br>                    nativeProcs = <span class="hljs-keyword">new</span> String[] &#123; mApp.processName &#125;;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nativeProcs = NATIVE_STACKS_OF_INTEREST;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] pids = nativeProcs == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : Process.getPidsForCommands(nativeProcs);<br>        ArrayList&lt;Integer&gt; nativePids = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">if</span> (pids != <span class="hljs-keyword">null</span>) &#123;<br>            nativePids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(pids.length);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : pids) &#123;<br>                nativePids.add(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// For background ANRs, don&#x27;t pass the ProcessCpuTracker to</span><br>        <span class="hljs-comment">// avoid spending 1/2 second collecting stats to rank lastPids.</span><br>        StringWriter tracesFileException = <span class="hljs-keyword">new</span> StringWriter();<br>        <span class="hljs-comment">// To hold the start and end offset to the ANR trace file respectively.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">2</span>];<br>        File tracesFile = ActivityManagerService.dumpStackTraces(firstPids,<br>                isSilentAnr ? <span class="hljs-keyword">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-keyword">null</span> : lastPids,<br>                nativePids, tracesFileException, offsets, annotation);<br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WatchDog</span> </span>&#123;<br>    <span class="hljs-comment">// Which native processes to dump into dropbox&#x27;s stack traces</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NATIVE_STACKS_OF_INTEREST = <span class="hljs-keyword">new</span> String[] &#123;<br>        <span class="hljs-string">&quot;/system/bin/audioserver&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/cameraserver&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/drmserver&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/keystore2&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/mediadrmserver&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/mediaserver&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/netd&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/sdcard&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/surfaceflinger&quot;</span>,<br>        <span class="hljs-string">&quot;/system/bin/vold&quot;</span>,<br>        <span class="hljs-string">&quot;media.extractor&quot;</span>, <span class="hljs-comment">// system/bin/mediaextractor</span><br>        <span class="hljs-string">&quot;media.metrics&quot;</span>, <span class="hljs-comment">// system/bin/mediametrics</span><br>        <span class="hljs-string">&quot;media.codec&quot;</span>, <span class="hljs-comment">// vendor/bin/hw/android.hardware.media.omx@1.0-service</span><br>        <span class="hljs-string">&quot;media.swcodec&quot;</span>, <span class="hljs-comment">// /apex/com.android.media.swcodec/bin/mediaswcodec</span><br>        <span class="hljs-string">&quot;media.transcoding&quot;</span>, <span class="hljs-comment">// Media transcoding service</span><br>        <span class="hljs-string">&quot;com.android.bluetooth&quot;</span>,  <span class="hljs-comment">// Bluetooth service</span><br>        <span class="hljs-string">&quot;/apex/com.android.os.statsd/bin/statsd&quot;</span>,  <span class="hljs-comment">// Stats daemon</span><br>    &#125;;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;Long, Long&gt; <span class="hljs-title">dumpStackTraces</span><span class="hljs-params">(String tracesFile, ArrayList&lt;Integer&gt; firstPids,</span></span><br><span class="hljs-params"><span class="hljs-function">            ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids)</span> </span>&#123;<br><br>        Slog.i(TAG, <span class="hljs-string">&quot;Dumping to &quot;</span> + tracesFile);<br><br>        <span class="hljs-comment">// We don&#x27;t need any sort of inotify based monitoring when we&#x27;re dumping traces via</span><br>        <span class="hljs-comment">// tombstoned. Data is piped to an &quot;intercept&quot; FD installed in tombstoned so we&#x27;re in full</span><br>        <span class="hljs-comment">// control of all writes to the file in question.</span><br><br>        <span class="hljs-comment">// We must complete all stack dumps within 20 seconds.</span><br>        <span class="hljs-keyword">long</span> remainingTime = <span class="hljs-number">20</span> * <span class="hljs-number">1000</span> * Build.HW_TIMEOUT_MULTIPLIER;<br><br>        <span class="hljs-comment">// As applications are usually interested with the ANR stack traces, but we can&#x27;t share with</span><br>        <span class="hljs-comment">// them the stack traces other than their own stacks. So after the very first PID is</span><br>        <span class="hljs-comment">// dumped, remember the current file size.</span><br>        <span class="hljs-keyword">long</span> firstPidStart = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> firstPidEnd = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// First collect all of the stacks of the most important pids.</span><br>        <span class="hljs-keyword">if</span> (firstPids != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">int</span> num = firstPids.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pid = firstPids.get(i);<br>                <span class="hljs-comment">// We don&#x27;t copy ANR traces from the system_server intentionally.</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> firstPid = i == <span class="hljs-number">0</span> &amp;&amp; MY_PID != pid;<br>                File tf = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (firstPid) &#123;<br>                    tf = <span class="hljs-keyword">new</span> File(tracesFile);<br>                    firstPidStart = tf.exists() ? tf.length() : <span class="hljs-number">0</span>;<br>                &#125;<br><br>                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for pid &quot;</span> + pid);<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timeTaken = dumpJavaTracesTombstoned(pid, tracesFile,<br>                                                                remainingTime);<br><br>                remainingTime -= timeTaken;<br>                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current firstPid=&quot;</span> + pid<br>                            + <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);<br>                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> Pair&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-keyword">null</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (firstPid) &#123;<br>                    firstPidEnd = tf.length();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;<br>                    Slog.d(TAG, <span class="hljs-string">&quot;Done with pid &quot;</span> + firstPids.get(i) + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Next collect the stacks of the native pids</span><br>        <span class="hljs-keyword">if</span> (nativePids != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pid : nativePids) &#123;<br>                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for native pid &quot;</span> + pid);<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nativeDumpTimeoutMs = Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = SystemClock.elapsedRealtime();<br>                Debug.dumpNativeBacktraceToFileTimeout(<br>                        pid, tracesFile, (<span class="hljs-keyword">int</span>) (nativeDumpTimeoutMs / <span class="hljs-number">1000</span>));<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timeTaken = SystemClock.elapsedRealtime() - start;<br><br>                remainingTime -= timeTaken;<br>                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current native pid=&quot;</span> + pid +<br>                        <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);<br>                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> Pair&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-keyword">null</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;<br>                    Slog.d(TAG, <span class="hljs-string">&quot;Done with native pid &quot;</span> + pid + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Lastly, dump stacks for all extra PIDs from the CPU tracker.</span><br>        <span class="hljs-keyword">if</span> (extraPids != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pid : extraPids) &#123;<br>                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for extra pid &quot;</span> + pid);<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);<br><br>                remainingTime -= timeTaken;<br>                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current extra pid=&quot;</span> + pid +<br>                            <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);<br>                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> Pair&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-keyword">null</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;<br>                    Slog.d(TAG, <span class="hljs-string">&quot;Done with extra pid &quot;</span> + pid + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        Slog.i(TAG, <span class="hljs-string">&quot;Done dumping&quot;</span>);<br>        <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> Pair&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">jintArray <span class="hljs-title">android_os_Process_getPidsForCommands</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobjectArray commandNames)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (commandNames == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    Vector&lt;String8&gt; commands;<br><br>    jsize count = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(commandNames);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;<br>        jobject obj = env-&gt;<span class="hljs-built_in">GetObjectArrayElement</span>(commandNames, i);<br>        <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>((jstring)obj, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (str8 == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;Element in commandNames&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            commands.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">String8</span>(str8));<br>            env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>((jstring)obj, str8);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;Element in commandNames&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br>    Vector&lt;jint&gt; pids;<br><br>    DIR *proc = <span class="hljs-built_in">opendir</span>(<span class="hljs-string">&quot;/proc&quot;</span>);<br>    <span class="hljs-keyword">if</span> (proc == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;/proc: %s\n&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> *<span class="hljs-title">d</span>;</span><br>    <span class="hljs-keyword">while</span> ((d = <span class="hljs-built_in">readdir</span>(proc))) &#123;<br>        <span class="hljs-keyword">int</span> pid = <span class="hljs-built_in">atoi</span>(d-&gt;d_name);<br>        <span class="hljs-keyword">if</span> (pid &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">char</span> path[PATH_MAX];<br>        <span class="hljs-keyword">char</span> data[PATH_MAX];<br>        <span class="hljs-built_in">snprintf</span>(path, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string">&quot;/proc/%d/cmdline&quot;</span>, pid);<br><br>        <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY | O_CLOEXEC);<br>        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">read</span>(fd, data, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data)<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">close</span>(fd);<br><br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        data[len] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                data[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;commands.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (commands[i] == data) &#123;<br>                pids.<span class="hljs-built_in">add</span>(pid);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">closedir</span>(proc);<br><br>    jintArray pidArray = env-&gt;<span class="hljs-built_in">NewIntArray</span>(pids.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">if</span> (pidArray == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pids.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        env-&gt;<span class="hljs-built_in">SetIntArrayRegion</span>(pidArray, <span class="hljs-number">0</span>, pids.<span class="hljs-built_in">size</span>(), pids.<span class="hljs-built_in">array</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pidArray;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="dump-java-traces"><a href="#dump-java-traces" class="headerlink" title="dump java traces"></a>dump java traces</h2><p>dump process 时分为 <code>java process</code> 和 <code>native process</code>，此章节将讨论 dump java process</p><p>跟着下面的代码一路跟踪下去最终会来到 <code>debuggerd_trigger_dump</code>，大概过一遍发现此方法并没有实现 dump java process 逻辑，那它都干了些什么：</p><ol><li>创建一条 <a href="https://man7.org/linux/man-pages/man7/pipe.7.html">管道</a>：<code>pipe_read</code> - <code>pipe_write</code></li><li>创建一个 unix domain socket 连接到 <code>/dev/socket/tombstoned_intercept</code> 并将需要被 dump 的进程的 <code>pid</code>、<code>dumpType</code> 和 <code>pipe_write</code> 发送过去（将 <code>pipe_write</code> 注册到 <code>debuggerd.tombstoned</code>）</li><li>给 <code>pid</code> 进程发送信号 <code>SIGQUIT</code>，进程里的 <code>Signal Catcher</code> 线程被唤醒进行 process dump 操作，并从 <code>debuggerd.tombstoned</code> 拿到 <code>pipe_write</code> 将 dump 写入</li><li>在一个 <code>while(true)</code> 循环里等待 <code>pipe_read</code> 直到可读/有数据（<a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll</code></a>，参考 <a href="../../../../2021/05/11/nonblocking-io/">网络 IO 演变发展过程和模型介绍</a>），将数据写入日志文件，这里的数据就是 process dump 的内容；同时上面有讲过 dump 是有时间上限的，所以循环里还要时刻检查是否还有剩余时间</li></ol><blockquote><p>man pipe.7</p><p>Pipes provide a unidirectional interprocess communication channel.  A pipe has a read end and a write end.  Data written to the write end of a pipe can be read from the read end of the pipe.</p><p>If a process attempts to read from an empty pipe, then read(2) will block until data is available.  If a process attempts to write to a full pipe (see below), then write(2) blocks until sufficient data has been read from &gt; the pipe to allow the write to complete.</p><p>A pipe has a limited capacity.  If the pipe is full, then a write(2) will block or fail, depending on whether the O_NONBLOCK flag is set (see below).  Different implementations have different limits for the pipe capacity.</p><p>In Linux versions before 2.6.11, the capacity of a pipe was the same as the system page size (e.g., 4096 bytes on i386).  </p><p>Since Linux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536 bytes in a system with a page size  of  4096 bytes).  </p><p>Since Linux 2.6.35, the default pipe capacity is 16 pages, but the capacity can be queried and set using the fcntl(2) F_GETPIPE_SZ and F_SETPIPE_SZ operations. </p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dumpJavaTracesTombstoned</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, String fileName, <span class="hljs-keyword">long</span> timeoutMs)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timeStart = SystemClock.elapsedRealtime();<br>        <span class="hljs-keyword">boolean</span> javaSuccess = Debug.dumpJavaBacktraceToFileTimeout(pid, fileName,<br>                (<span class="hljs-keyword">int</span>) (timeoutMs / <span class="hljs-number">1000</span>));<br>        <span class="hljs-keyword">if</span> (javaSuccess) &#123;<br>            <span class="hljs-comment">// Check that something is in the file, actually. Try-catch should not be necessary,</span><br>            <span class="hljs-comment">// but better safe than sorry.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">long</span> size = <span class="hljs-keyword">new</span> File(fileName).length();<br>                <span class="hljs-keyword">if</span> (size &lt; JAVA_DUMP_MINIMUM_SIZE) &#123;<br>                    Slog.w(TAG, <span class="hljs-string">&quot;Successfully created Java ANR file is empty!&quot;</span>);<br>                    javaSuccess = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Unable to get ANR file size&quot;</span>, e);<br>                javaSuccess = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!javaSuccess) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Dumping Java threads failed, initiating native stack dump.&quot;</span>);<br>            <span class="hljs-keyword">if</span> (!Debug.dumpNativeBacktraceToFileTimeout(pid, fileName,<br>                    (NATIVE_DUMP_TIMEOUT_MS / <span class="hljs-number">1000</span>))) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Native stack dump failed!&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> SystemClock.elapsedRealtime() - timeStart;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> jboolean <span class="hljs-title">android_os_Debug_dumpJavaBacktraceToFileTimeout</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jint pid, jstring fileName, jint timeoutSecs)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> ret = <span class="hljs-built_in">dumpTraces</span>(env, pid, fileName, timeoutSecs, kDebuggerdJavaBacktrace);<br>    <span class="hljs-keyword">return</span> ret ? JNI_TRUE : JNI_FALSE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">dumpTraces</span><span class="hljs-params">(JNIEnv* env, jint pid, jstring fileName, jint timeoutSecs,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DebuggerdDumpType dumpType)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> ScopedUtfChars <span class="hljs-title">fileNameChars</span><span class="hljs-params">(env, fileName)</span></span>;<br>    <span class="hljs-keyword">if</span> (fileNameChars.<span class="hljs-built_in">c_str</span>() == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(open(fileNameChars.c_str(),</span></span><br><span class="hljs-params"><span class="hljs-function">                                     O_CREAT | O_WRONLY | O_NOFOLLOW | O_CLOEXEC | O_APPEND,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-number">0666</span>))</span></span>;<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t open &quot;</span> &lt;&lt; fileNameChars.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">dump_backtrace_to_file_timeout</span>(pid, dumpType, timeoutSecs, fd);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdatasync</span>(fd.<span class="hljs-built_in">get</span>()) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed flushing trace.&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dump_backtrace_to_file_timeout</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="hljs-keyword">int</span> timeout_secs,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-keyword">int</span> fd)</span> </span>&#123;<br>  android::<span class="hljs-function">base::unique_fd <span class="hljs-title">copy</span><span class="hljs-params">(dup(fd))</span></span>;<br>  <span class="hljs-keyword">if</span> (copy == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// debuggerd_trigger_dump results in every thread in the process being interrupted</span><br>  <span class="hljs-comment">// by a signal, so we need to fetch the wchan data before calling that.</span><br>  std::string wchan_data = <span class="hljs-built_in">get_wchan_data</span>(fd, tid);<br><br>  <span class="hljs-keyword">int</span> timeout_ms = timeout_secs &gt; <span class="hljs-number">0</span> ? timeout_secs * <span class="hljs-number">1000</span> : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">debuggerd_trigger_dump</span>(tid, dump_type, timeout_ms, std::<span class="hljs-built_in">move</span>(copy)) ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">// Dump wchan data, since only privileged processes (CAP_SYS_ADMIN) can read</span><br>  <span class="hljs-comment">// kernel stack traces (/proc/*/stack).</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteStringToFd</span>(wchan_data, fd)) &#123;<br>    <span class="hljs-built_in">LOG</span>(WARNING) &lt;&lt; TAG <span class="hljs-string">&quot;Failed to dump wchan data for pid: &quot;</span> &lt;&lt; tid;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">debuggerd_trigger_dump</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> timeout_ms,</span></span><br><span class="hljs-params"><span class="hljs-function">                            unique_fd output_fd)</span> </span>&#123;<br>  <span class="hljs-keyword">pid_t</span> pid = tid;<br>  <span class="hljs-keyword">if</span> (dump_type == kDebuggerdJavaBacktrace) &#123;<br>    <span class="hljs-comment">// Java dumps always get sent to the tgid, so we need to resolve our tid to a tgid.</span><br>    android::procinfo::ProcessInfo procinfo;<br>    std::string error;<br>    <span class="hljs-keyword">if</span> (!android::procinfo::<span class="hljs-built_in">GetProcessInfo</span>(tid, &amp;procinfo, &amp;error)) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to get process info: %s&quot;</span>, error.<span class="hljs-built_in">c_str</span>());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    pid = procinfo.pid;<br>  &#125;<br><br>  <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; TAG <span class="hljs-string">&quot;started dumping process &quot;</span> &lt;&lt; pid;<br><br>  <span class="hljs-comment">// Rather than try to deal with poll() all the way through the flow, we update</span><br>  <span class="hljs-comment">// the socket timeout between each step (and only use poll() during the final</span><br>  <span class="hljs-comment">// copy loop).</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">milliseconds</span>(timeout_ms);<br>  <span class="hljs-keyword">auto</span> update_timeout = [timeout_ms, &amp;output_fd](<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">auto</span> end) &#123;<br>    <span class="hljs-keyword">if</span> (timeout_ms &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">auto</span> remaining = end - std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-keyword">decltype</span>(remaining)::<span class="hljs-built_in">zero</span>()) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span><br>    <span class="hljs-built_in">populate_timeval</span>(&amp;timeout, remaining);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(timeout)) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set receive timeout&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(timeout)) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set send timeout&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br><br>  <span class="hljs-function">unique_fd <span class="hljs-title">sockfd</span><span class="hljs-params">(socket(AF_LOCAL, SOCK_SEQPACKET, <span class="hljs-number">0</span>))</span></span>;<br>  <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to create socket&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">socket_local_client_connect</span>(sockfd.<span class="hljs-built_in">get</span>(), kTombstonedInterceptSocketName,<br>                                  ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET) == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to connect to tombstoned&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  InterceptRequest req = &#123;<br>      .dump_type = dump_type,<br>      .pid = pid,<br>  &#125;;<br><br>  <span class="hljs-comment">// Create an intermediate pipe to pass to the other end.</span><br>  unique_fd pipe_read, pipe_write;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Pipe</span>(&amp;pipe_read, &amp;pipe_write)) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to create pipe&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  std::string pipe_size_str;<br>  <span class="hljs-keyword">int</span> pipe_buffer_size = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>  <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/sys/fs/pipe-max-size&quot;</span>, &amp;pipe_size_str)) &#123;<br>    pipe_size_str = android::base::<span class="hljs-built_in">Trim</span>(pipe_size_str);<br><br>    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">ParseInt</span>(pipe_size_str.<span class="hljs-built_in">c_str</span>(), &amp;pipe_buffer_size, <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;failed to parse pipe max size &#x27;&quot;</span> &lt;&lt; pipe_size_str &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(pipe_read.<span class="hljs-built_in">get</span>(), F_SETPIPE_SZ, pipe_buffer_size) != pipe_buffer_size) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set pipe buffer size&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">ssize_t</span> rc = <span class="hljs-built_in">SendFileDescriptors</span>(sockfd, &amp;req, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(req), pipe_write.<span class="hljs-built_in">get</span>());<br>  pipe_write.<span class="hljs-built_in">reset</span>();<br>  <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(req)) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to send output fd to tombstoned&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">auto</span> get_response = [&amp;output_fd](<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* kind, <span class="hljs-keyword">int</span> sockfd, InterceptResponse* response) &#123;<br>    <span class="hljs-keyword">ssize_t</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">recv</span>(sockfd, response, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*response), MSG_TRUNC));<br>    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to read %s response from tombstoned: timeout reached?&quot;</span>, kind);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to read %s response from tombstoned&quot;</span>, kind);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*response)) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>,<br>                <span class="hljs-string">&quot;received packet of unexpected length from tombstoned while reading %s response: &quot;</span><br>                <span class="hljs-string">&quot;expected %zd, received %zd&quot;</span>,<br>                kind, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(response), rc);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// Check to make sure we&#x27;ve successfully registered.</span><br>  InterceptResponse response;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_response</span>(<span class="hljs-string">&quot;initial&quot;</span>, sockfd, &amp;response)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (response.status != InterceptStatus::kRegistered) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;unexpected registration response: %d&quot;</span>,<br>              <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(response.status));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Send the signal.</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> signal = (dump_type == kDebuggerdJavaBacktrace) ? SIGQUIT : BIONIC_SIGNAL_DEBUGGER;<br>  sigval val = &#123;.sival_int = (dump_type == kDebuggerdNativeBacktrace) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigqueue</span>(pid, signal, val) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to send signal to pid %d&quot;</span>, pid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_response</span>(<span class="hljs-string">&quot;status&quot;</span>, sockfd, &amp;response)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (response.status != InterceptStatus::kStarted) &#123;<br>    response.error_message[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(response.error_message) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;tombstoned reported failure: %s&quot;</span>, response.error_message);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Forward output from the pipe to the output fd.</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">auto</span> remaining = end - std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> remaining_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(remaining).<span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">if</span> (timeout_ms &lt;= <span class="hljs-number">0</span>) &#123;<br>      remaining_ms = <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remaining_ms &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pfd</span> =</span> &#123;<br>        .fd = pipe_read.<span class="hljs-built_in">get</span>(), .events = POLLIN, .revents = <span class="hljs-number">0</span>,<br>    &#125;;<br><br>    rc = <span class="hljs-built_in">poll</span>(&amp;pfd, <span class="hljs-number">1</span>, remaining_ms);<br>    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (errno == EINTR) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while polling&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(pipe_read.<span class="hljs-built_in">get</span>(), buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf)));<br>    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Done.</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while reading&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">WriteFully</span>(output_fd.<span class="hljs-built_in">get</span>(), buf, rc)) &#123;<br>      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while writing&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; TAG <span class="hljs-string">&quot;done dumping process &quot;</span> &lt;&lt; pid;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Helper for SendFileDescriptorVector that constructs a std::vector for you, e.g.:</span><br><span class="hljs-comment">//   SendFileDescriptors(sock, &quot;foo&quot;, 3, std::move(fd1), std::move(fd2))</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">SendFileDescriptors</span><span class="hljs-params">(borrowed_fd sock, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">size_t</span> len, Args&amp;&amp;... sent_fds)</span> </span>&#123;<br>  <span class="hljs-comment">// Do not allow implicit conversion to int: people might try to do something along the lines of:</span><br>  <span class="hljs-comment">//   SendFileDescriptors(..., std::move(a_unique_fd))</span><br>  <span class="hljs-comment">// and be surprised when the unique_fd isn&#x27;t closed afterwards.</span><br>  AssertType&lt;<span class="hljs-keyword">int</span>&gt;(std::forward&lt;Args&gt;(sent_fds)...);<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; fds;<br>  <span class="hljs-built_in">Append</span>(fds, std::forward&lt;Args&gt;(sent_fds)...);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">SendFileDescriptorVector</span>(sock, data, len, fds);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">SendFileDescriptorVector</span><span class="hljs-params">(borrowed_fd sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">size_t</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; fds)</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> page_size = <span class="hljs-built_in">sysconf</span>(_SC_PAGE_SIZE);<br>  <span class="hljs-keyword">size_t</span> cmsg_space = <span class="hljs-built_in">CMSG_SPACE</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * fds.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">size_t</span> cmsg_len = <span class="hljs-built_in">CMSG_LEN</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * fds.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">if</span> (cmsg_space &gt;= page_size) &#123;<br>    errno = ENOMEM;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-built_in"><span class="hljs-keyword">alignas</span></span>(struct cmsghdr) <span class="hljs-keyword">char</span> cmsg_buf[cmsg_space];<br>  iovec iov = &#123;.iov_base = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(data), .iov_len = len&#125;;<br>  msghdr msg = &#123;<br>      .msg_name = <span class="hljs-literal">nullptr</span>,<br>      .msg_namelen = <span class="hljs-number">0</span>,<br>      .msg_iov = &amp;iov,<br>      .msg_iovlen = <span class="hljs-number">1</span>,<br>      .msg_control = cmsg_buf,<br>      <span class="hljs-comment">// We can&#x27;t cast to the actual type of the field, because it&#x27;s different across platforms.</span><br>      .msg_controllen = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(cmsg_space),<br>      .msg_flags = <span class="hljs-number">0</span>,<br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmsghdr</span>* <span class="hljs-title">cmsg</span> =</span> <span class="hljs-built_in">CMSG_FIRSTHDR</span>(&amp;msg);<br>  cmsg-&gt;cmsg_level = SOL_SOCKET;<br>  cmsg-&gt;cmsg_type = SCM_RIGHTS;<br>  cmsg-&gt;cmsg_len = cmsg_len;<br><br>  <span class="hljs-keyword">int</span>* cmsg_fds = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(<span class="hljs-built_in">CMSG_DATA</span>(cmsg));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; fds.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    cmsg_fds[i] = fds[i];<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__linux__)</span><br>  <span class="hljs-keyword">int</span> flags = MSG_NOSIGNAL;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">int</span> flags = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">sendmsg</span>(sockfd.<span class="hljs-built_in">get</span>(), &amp;msg, flags));<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Unix-Domain-Socket"><a href="#Unix-Domain-Socket" class="headerlink" title="Unix Domain Socket"></a>Unix Domain Socket</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * man socket.2</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * domain: </span><br><span class="hljs-comment"> *   AF_UNIX/AF_LOCAL Local communication</span><br><span class="hljs-comment"> *   AF_INET          IPv4 Internet protocols</span><br><span class="hljs-comment"> *   AF_INET6         IPv6 Internet protocols</span><br><span class="hljs-comment"> *   ...</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * type: </span><br><span class="hljs-comment"> *   SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams, 网络协议簇上的实现就是 TCP</span><br><span class="hljs-comment"> *   SOCK_DGRAM      connectionless, unreliable messages of a fixed maximum length, 网络协议簇上的实现就是 UDP</span><br><span class="hljs-comment"> *   SOCK_SEQPACKET  Provides a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length</span><br><span class="hljs-comment"> *                   a consumer is required to read an entire packet with each input system call</span><br><span class="hljs-comment"> *                   看起来像是 TCP + UDP</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span><br></code></pre></div></td></tr></table></figure><p>使用 Java/Kotlin 编程 <code>socket</code> 一般就是代表 <a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">网络协议簇</a> 中的传输层协议 TCP 和 UDP，但在 C 里 <a href="https://man7.org/linux/man-pages/man7/socket.7.html">socket</a> 包含一整套 API 如下图：</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/socket.jpg" alt="socket"></p><p><code>Unix Domain Socket</code>，也就是 <code>socket(AF_UNIX/AF_LOCAL, ...)</code> 则是一种 <code>IPC</code> 机制，对标的是 <code>pipe</code>、<code>FIFO</code>、<code>signal</code>，它不走网络协议簇（性能好）却又可以使用上图所示丰富的 API 实现双向的、全双工的、多路复用的 IPC。相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 Unix Domain Socket 通讯的</p><p>Unix Domain Socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 <code>sockaddr_un</code> 表示，网络编程的地址是 <code>ip:port</code> 而 Unix Domain Socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个文件在 <code>bind</code> 调用时创建，如果该文件已存在则 <code>bind</code> 错误返回，<code>close</code> 后需要自己主动删除</p><h3 id="SignalCatcher-amp-SIGQUIT"><a href="#SignalCatcher-amp-SIGQUIT" class="headerlink" title="SignalCatcher &amp; SIGQUIT"></a>SignalCatcher &amp; SIGQUIT</h3><p>如下图所示，<code>zygote</code> fork 出 system server 和 app process 后会创建一个叫 <code>Signal Catcher</code> 的 native thread 并将其绑定到 VM，它的 routine 是 <code> SignalCatcher::Run</code>，main loop 是等待并响应信号 <code>SIGQUIT</code> 和 <code>SIGUSR1</code></p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/signal_catcher_thread.png" alt="signal_catcher_thread"></p><blockquote><p>int sigwait(const sigset_t *set, int *sig)</p><p>The  sigwait()  function  suspends execution of the calling thread until one of the signals specified in the signal set set becomes pending.  The function accepts the signal (removes it from the pending list of signals), and returns the signal number in sig</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/runtime.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::InitNonZygoteOrPostFork</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">bool</span> is_system_server,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// This is true when we are initializing a child-zygote. It requires</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// native bridge initialization to be able to run guest native code in</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// doPreload().</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">bool</span> is_child_zygote,</span></span><br><span class="hljs-params"><span class="hljs-function">    NativeBridgeAction action,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* isa,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">bool</span> profile_system_server)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">StartSignalCatcher</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::StartSignalCatcher</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!is_zygote_) &#123;<br>    signal_catcher_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SignalCatcher</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// art/runtime/signal_catcher.cc</span><br>SignalCatcher::<span class="hljs-built_in">SignalCatcher</span>()<br>    : <span class="hljs-built_in">lock_</span>(<span class="hljs-string">&quot;SignalCatcher lock&quot;</span>),<br>      <span class="hljs-built_in">cond_</span>(<span class="hljs-string">&quot;SignalCatcher::cond_&quot;</span>, lock_),<br>      <span class="hljs-built_in">thread_</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-built_in">SetHaltFlag</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-comment">// Create a raw pthread; its start routine will attach to the runtime.</span><br>  <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_create, (&amp;pthread_, <span class="hljs-literal">nullptr</span>, &amp;Run, <span class="hljs-keyword">this</span>), <span class="hljs-string">&quot;signal catcher thread&quot;</span>);<br><br>  Thread* self = Thread::<span class="hljs-built_in">Current</span>();<br>  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, lock_)</span></span>;<br>  <span class="hljs-keyword">while</span> (thread_ == <span class="hljs-literal">nullptr</span>) &#123;<br>    cond_.<span class="hljs-built_in">Wait</span>(self);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">SignalCatcher::Run</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>&#123;<br>  SignalCatcher* signal_catcher = <span class="hljs-keyword">reinterpret_cast</span>&lt;SignalCatcher*&gt;(arg);<br>  <span class="hljs-built_in">CHECK</span>(signal_catcher != <span class="hljs-literal">nullptr</span>);<br><br>  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>  <span class="hljs-built_in">CHECK</span>(runtime-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(<span class="hljs-string">&quot;Signal Catcher&quot;</span>, <span class="hljs-literal">true</span>, runtime-&gt;<span class="hljs-built_in">GetSystemThreadGroup</span>(),<br>                                     !runtime-&gt;<span class="hljs-built_in">IsAotCompiler</span>()));<br><br>  Thread* self = Thread::<span class="hljs-built_in">Current</span>();<br>  <span class="hljs-built_in">DCHECK_NE</span>(self-&gt;<span class="hljs-built_in">GetState</span>(), kRunnable);<br>  &#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, signal_catcher-&gt;lock_)</span></span>;<br>    signal_catcher-&gt;thread_ = self;<br>    signal_catcher-&gt;cond_.<span class="hljs-built_in">Broadcast</span>(self);<br>  &#125;<br><br>  <span class="hljs-comment">// Set up mask with signals we want to handle.</span><br>  SignalSet signals;<br>  signals.<span class="hljs-built_in">Add</span>(SIGQUIT);<br>  signals.<span class="hljs-built_in">Add</span>(SIGUSR1);<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> signal_number = signal_catcher-&gt;<span class="hljs-built_in">WaitForSignal</span>(self, signals);<br>    <span class="hljs-keyword">if</span> (signal_catcher-&gt;<span class="hljs-built_in">ShouldHalt</span>()) &#123;<br>      runtime-&gt;<span class="hljs-built_in">DetachCurrentThread</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (signal_number) &#123;<br>    <span class="hljs-keyword">case</span> SIGQUIT:<br>      signal_catcher-&gt;<span class="hljs-built_in">HandleSigQuit</span>();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> SIGUSR1:<br>      signal_catcher-&gt;<span class="hljs-built_in">HandleSigUsr1</span>();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unexpected signal %d&quot;</span> &lt;&lt; signal_number;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SignalCatcher::WaitForSignal</span><span class="hljs-params">(Thread* self, SignalSet&amp; signals)</span> </span>&#123;<br>  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(self, kWaitingInMainSignalCatcherLoop)</span></span>;<br><br>  <span class="hljs-comment">// Signals for sigwait() must be blocked but not ignored.  We</span><br>  <span class="hljs-comment">// block signals like SIGQUIT for all threads, so the condition</span><br>  <span class="hljs-comment">// is met.  When the signal hits, we wake up, without any signal</span><br>  <span class="hljs-comment">// handlers being invoked.</span><br>  <span class="hljs-keyword">int</span> signal_number = signals.<span class="hljs-built_in">Wait</span>();<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ShouldHalt</span>()) &#123;<br>    <span class="hljs-comment">// Let the user know we got the signal, just in case the system&#x27;s too screwed for us to</span><br>    <span class="hljs-comment">// actually do what they want us to do...</span><br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; *self &lt;&lt; <span class="hljs-string">&quot;: reacting to signal &quot;</span> &lt;&lt; signal_number;<br><br>    <span class="hljs-comment">// If anyone&#x27;s holding locks (which might prevent us from getting back into state Runnable), say so...</span><br>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">DumpLockHolders</span>(<span class="hljs-built_in">LOG_STREAM</span>(INFO));<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> signal_number;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignalSet</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Sleep in sigwait() until a signal arrives. gdb causes EINTR failures.</span><br>    <span class="hljs-keyword">int</span> signal_number;<br>    <span class="hljs-keyword">int</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">sigwait64</span>(&amp;set_, &amp;signal_number));<br>    <span class="hljs-keyword">if</span> (rc != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;sigwait failed&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> signal_number;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="proces-thread-dump"><a href="#proces-thread-dump" class="headerlink" title="proces/thread dump"></a>proces/thread dump</h3><p>APP 在收到信号 <code>SIGQUIT(3)</code> 后，<code>Signal Catcher</code> 线程会将有关 VM 的信息 dump 出来，如下面的代码所示，是不是跟 ANR Traces 日志里的内容很相似？这样我们就可以看着代码一点点地分析出日志里各段的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">// 以下日志来自 SignalCatcher::HandleSigQuit<br>----- pid 27750(当前进程，也就是被 dump 的进程) at 2021-09-29 16:02:49(输出这段日志的时间) -----<br>Cmd line: com.example.myapplication(来自 /proc/pid/cmdline)<br>Build fingerprint: &#x27;Xiaomi/cepheus/cepheus:11/RKQ1.200826.002/V12.5.4.0.RFACNXM:user/release-keys&#x27;<br>ABI: &#x27;arm64&#x27;<br>Build type: optimized(debug or optimized)<br><br>// ClassLinker::DumpForSigQuit<br>Zygote loaded classes=15972 post zygote classes=782 (为了节省内存 zygote 会加载一些必要的 class，这样 fork 出来的 APP 进程就可以通过父子进程的 Copy-On-Write 机制共享之，15972 是 zygote 加载的 class 数量，782 是 APP 进程额外加载的 class 数量)<br>Dumping registered class loaders (打印 classloader 实例数组)<br>#0 dalvik.system.PathClassLoader: [], parent #1<br>#1 java.lang.BootClassLoader: [], no parent<br>#2 dalvik.system.PathClassLoader: [/system/framework/tcmclient.jar], parent #0<br>#3 dalvik.system.PathClassLoader: [], parent #0<br>#4 dalvik.system.PathClassLoader: [/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes4.dex:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes3.dex:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes2.dex], parent #1<br>#5 dalvik.system.PathClassLoader: [/system/app/MiuiContentCatcher/MiuiContentCatcher.apk], parent #1<br>#6 dalvik.system.PathClassLoader: [/system/app/CatcherPatch/CatcherPatch.apk], parent #1<br>Done dumping class loaders<br>Classes initialized: 371 in 14.764ms<br><br>/* <br> * InternTable::DumpForSigQuit<br> * <br> * Class InternTable used to intern strings.<br> * There are actually two tables: one that holds strong references to its strings, and one that holds weak references. <br> * The former is used for string literals, for which there is an effective reference from the constant pool. <br> * The latter is used for strings interned at runtime via String.intern. <br> * Some code (XML parsers being a prime example) relies on being able to intern arbitrarily many strings for the duration of a parse without permanently increasing the memory footprint.<br> * <br> * 这个 InternTable 其实就是 String.intern() 方法描述里说的那个字符串池（A pool of strings, initially empty, is maintained privately by the class String）<br> * 它包含两个 table，字符串字面量（来自于字符串常量池）的引用保存在 string table，通过 String.intern() 添加进来的字符串引用保存在 weak table<br> * <br> * String.intern() 将搜索 InternTable，如果 InternTable 存在相同的字符串则返回它的引用，否则将当前字符串添加到 InternTable 里，这样的好处是可以降低字符串处理程序的内存波动<br> * <br> */<br>Intern table: 32394 strong; 523 weak<br><br>//  JavaVMExt::DumpForSigQuit (JNI 相关，不太懂)<br>JNI: CheckJNI is on; globals=735 (plus 64 weak)<br>Libraries: /data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!/lib/arm64-v8a/libnative-lib.so libandroid.so libaudioeffect_jni.so libcompiler_rt.so libicu_jni.so libjavacore.so libjavacrypto.so libjnigraphics.so libmedia_jni.so libmiuinative.so libopenjdk.so libqti_performance.so librs_jni.so libsfplugin_ccodec.so libsoundpool.so libstats_jni.so libwebviewchromium_loader.so (17)<br><br>// Heap::DumpForSigQuit<br>Heap: 47% free, 2796KB/5303KB; 71822 objects (VM 堆相关情况，堆申请了 5303KB 的内存，用了 2795KB 剩余 47% 的内存，堆里一共有 71822 个对象)<br><br>// Heap::DumpGcPerformanceInfo (GC 相关信息)<br>Dumping cumulative Gc timings<br>Start Dumping histograms for 1 iterations for concurrent copying<br>ScanImmuneSpaces:Sum: 12.444ms 99% C.I. 12.444ms-12.444ms Avg: 12.444ms Max: 12.444ms<br>ProcessMarkStack:Sum: 12.292ms 99% C.I. 12.292ms-12.292ms Avg: 12.292ms Max: 12.292ms<br>VisitConcurrentRoots:Sum: 6.499ms 99% C.I. 6.499ms-6.499ms Avg: 6.499ms Max: 6.499ms<br>ScanCardsForSpace:Sum: 1.231ms 99% C.I. 1.231ms-1.231ms Avg: 1.231ms Max: 1.231ms<br>SweepSystemWeaks:Sum: 924us 99% C.I. 924us-924us Avg: 924us Max: 924us<br>GrayAllDirtyImmuneObjects:Sum: 792us 99% C.I. 792us-792us Avg: 792us Max: 792us<br>ClearFromSpace:Sum: 777us 99% C.I. 777us-777us Avg: 777us Max: 777us<br>InitializePhase:Sum: 544us 99% C.I. 544us-544us Avg: 544us Max: 544us<br>FlipOtherThreads:Sum: 309us 99% C.I. 309us-309us Avg: 309us Max: 309us<br>VisitNonThreadRoots:Sum: 270us 99% C.I. 270us-270us Avg: 270us Max: 270us<br>RecordFree:Sum: 95us 99% C.I. 95us-95us Avg: 95us Max: 95us<br>CopyingPhase:Sum: 82us 99% C.I. 82us-82us Avg: 82us Max: 82us<br>ForwardSoftReferences:Sum: 77us 99% C.I. 77us-77us Avg: 77us Max: 77us<br>EnqueueFinalizerReferences:Sum: 60us 99% C.I. 60us-60us Avg: 60us Max: 60us<br>MarkZygoteLargeObjects:Sum: 56us 99% C.I. 56us-56us Avg: 56us Max: 56us<br>ProcessReferences:Sum: 55us 99% C.I. 8us-47us Avg: 27.500us Max: 47us<br>(Paused)GrayAllNewlyDirtyImmuneObjects:Sum: 40us 99% C.I. 40us-40us Avg: 40us Max: 40us<br>SweepLargeObjects:Sum: 38us 99% C.I. 38us-38us Avg: 38us Max: 38us<br>SwapBitmaps:Sum: 36us 99% C.I. 36us-36us Avg: 36us Max: 36us<br>ThreadListFlip:Sum: 35us 99% C.I. 35us-35us Avg: 35us Max: 35us<br>SweepAllocSpace:Sum: 26us 99% C.I. 26us-26us Avg: 26us Max: 26us<br>MarkStackAsLive:Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18us<br>ReclaimPhase:Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14us<br>EmptyRBMarkBitStack:Sum: 13us 99% C.I. 13us-13us Avg: 13us Max: 13us<br>(Paused)FlipCallback:Sum: 11us 99% C.I. 11us-11us Avg: 11us Max: 11us<br>ResumeRunnableThreads:Sum: 10us 99% C.I. 10us-10us Avg: 10us Max: 10us<br>(Paused)SetFromSpace:Sum: 8us 99% C.I. 8us-8us Avg: 8us Max: 8us<br>UnBindBitmaps:Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7us<br>FlipThreadRoots:Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6us<br>Sweep:Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5us<br>(Paused)ClearCards:Sum: 3us 99% C.I. 250ns-1000ns Avg: 142ns Max: 1000ns<br>ResumeOtherThreads:Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us<br>Done Dumping histograms<br>concurrent copying paused:Sum: 101us 99% C.I. 101us-101us Avg: 101us Max: 101us<br>concurrent copying freed-bytes: Avg: 138KB Max: 138KB Min: 138KB<br>Freed-bytes histogram: 0:1<br>concurrent copying total time: 36.779ms mean time: 36.779ms<br>concurrent copying freed: 1138 objects with total size 138KB<br>concurrent copying throughput: 31611.1/s / 3844KB/s  per cpu-time: 4429000/s / 4325KB/s<br>Average major GC reclaim bytes ratio 0.841027 over 1 GC cycles<br>Average major GC copied live bytes ratio 0.757154 over 5 major GCs<br>Cumulative bytes moved 13614368<br>Cumulative objects moved 237506<br>Peak regions allocated 35 (8960KB) / 1024 (256MB)<br>Start Dumping histograms for 1 iterations for young concurrent copying<br>ScanImmuneSpaces:Sum: 9.300ms 99% C.I. 9.300ms-9.300ms Avg: 9.300ms Max: 9.300ms<br>ProcessMarkStack:Sum: 2.551ms 99% C.I. 2.551ms-2.551ms Avg: 2.551ms Max: 2.551ms<br>VisitConcurrentRoots:Sum: 1.263ms 99% C.I. 1.263ms-1.263ms Avg: 1.263ms Max: 1.263ms<br>SweepSystemWeaks:Sum: 530us 99% C.I. 530us-530us Avg: 530us Max: 530us<br>ClearFromSpace:Sum: 390us 99% C.I. 390us-390us Avg: 390us Max: 390us<br>InitializePhase:Sum: 289us 99% C.I. 289us-289us Avg: 289us Max: 289us<br>GrayAllDirtyImmuneObjects:Sum: 163us 99% C.I. 163us-163us Avg: 163us Max: 163us<br>ScanCardsForSpace:Sum: 129us 99% C.I. 129us-129us Avg: 129us Max: 129us<br>FlipOtherThreads:Sum: 75us 99% C.I. 75us-75us Avg: 75us Max: 75us<br>VisitNonThreadRoots:Sum: 54us 99% C.I. 54us-54us Avg: 54us Max: 54us<br>EnqueueFinalizerReferences:Sum: 45us 99% C.I. 45us-45us Avg: 45us Max: 45us<br>SweepArray:Sum: 21us 99% C.I. 21us-21us Avg: 21us Max: 21us<br>ProcessReferences:Sum: 20us 99% C.I. 1us-19us Avg: 10us Max: 19us<br>RecordFree:Sum: 19us 99% C.I. 0.250us-19us Avg: 9.500us Max: 19us<br>(Paused)GrayAllNewlyDirtyImmuneObjects:Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18us<br>CopyingPhase:Sum: 15us 99% C.I. 15us-15us Avg: 15us Max: 15us<br>ForwardSoftReferences:Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14us<br>FreeList:Sum: 13us 99% C.I. 13us-13us Avg: 13us Max: 13us<br>ThreadListFlip:Sum: 8us 99% C.I. 8us-8us Avg: 8us Max: 8us<br>SwapBitmaps:Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7us<br>ReclaimPhase:Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6us<br>MarkZygoteLargeObjects:Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5us<br>ResetStack:Sum: 4us 99% C.I. 4us-4us Avg: 4us Max: 4us<br>EmptyRBMarkBitStack:Sum: 3us 99% C.I. 3us-3us Avg: 3us Max: 3us<br>(Paused)FlipCallback:Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us<br>(Paused)SetFromSpace:Sum: 1us 99% C.I. 1us-1us Avg: 1us Max: 1us<br>(Paused)ClearCards:Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0ns<br>Done Dumping histograms<br>young concurrent copying paused:Sum: 33us 99% C.I. 33us-33us Avg: 33us Max: 33us<br>young concurrent copying freed-bytes: Avg: 4116KB Max: 4116KB Min: 4116KB<br>Freed-bytes histogram: 3840:1<br>young concurrent copying total time: 14.952ms mean time: 14.952ms<br>young concurrent copying freed: 48492 objects with total size 4116KB<br>young concurrent copying throughput: 3.46371e+06/s / 287MB/s  per cpu-time: 602219428/s / 574MB/s<br>Average minor GC reclaim bytes ratio 1.88288 over 1 GC cycles<br>Average minor GC copied live bytes ratio 0.126374 over 3 minor GCs<br>Cumulative bytes moved 2004720<br>Cumulative objects moved 28694<br>Peak regions allocated 35 (8960KB) / 1024 (256MB)<br>Total time spent in GC: 51.731ms<br>Mean GC size throughput: 80MB/s per cpu-time: 103MB/s<br>Mean GC object throughput: 959386 objects/s<br>Total number of allocations 121452<br>Total bytes allocated 7051KB<br>Total bytes freed 4255KB<br>Free memory 2506KB<br>Free memory until GC 2506KB<br>Free memory until OOME 253MB<br>Total memory 5303KB<br>Max memory 256MB<br>Zygote space size 3464KB<br>Total mutator paused time: 134us<br>Total time waiting for GC to complete: 11.571ms<br>Total GC count: 2<br>Total GC time: 51.731ms<br>Total blocking GC count: 0<br>Total blocking GC time: 0<br>Histogram of GC count per 10000 ms: 0:16,1:1<br>Histogram of blocking GC count per 10000 ms: 0:17<br>Native bytes total: 21234628 registered: 60540<br>Total native bytes at last GC: 20854836<br><br>// OatFileManager::DumpForSigQuit<br>/data/dalvik-cache/arm64/system@priv-app@RtMiCloudSDK@RtMiCloudSDK.apk@classes.dex: speed<br>/data/dalvik-cache/arm64/system@app@MiuiContentCatcher@MiuiContentCatcher.apk@classes.dex: speed<br>/data/dalvik-cache/arm64/system@app@CatcherPatch@CatcherPatch.apk@classes.dex: speed<br><br>// Jit::DumpForSigQuit (JIT 相关)<br>Current JIT code cache size (used / resident): 5KB / 32KB<br>Current JIT data cache size (used / resident): 10KB / 32KB<br>Zygote JIT code cache size (at point of fork): 60KB / 64KB<br>Zygote JIT data cache size (at point of fork): 54KB / 60KB<br>Current JIT mini-debug-info size: 44KB<br>Current JIT capacity: 64KB<br>Current number of JIT JNI stub entries: 0<br>Current number of JIT code cache entries: 64<br>Total number of JIT compilations: 17<br>Total number of JIT compilations for on stack replacement: 0<br>Total number of JIT code cache collections: 0<br>Memory used for stack maps: Avg: 67B Max: 272B Min: 16B<br>Memory used for compiled code: Avg: 304B Max: 1320B Min: 20B<br>Memory used for profiling info: Avg: 111B Max: 728B Min: 32B<br>Start Dumping histograms for 64 iterations for JIT timings<br>Compiling:Sum: 143.499ms 99% C.I. 0.115ms-18.703ms Avg: 2.242ms Max: 22.565ms<br>TrimMaps:Sum: 4.510ms 99% C.I. 8us-707.999us Avg: 70.468us Max: 864us<br>Done Dumping histograms<br>Memory used for compilation: Avg: 139KB Max: 837KB Min: 15KB<br><br>// ProfileSaver::DumpInstanceInfo<br>ProfileSaver total_bytes_written=2330<br>ProfileSaver total_number_of_writes=1<br>ProfileSaver total_number_of_code_cache_queries=2<br>ProfileSaver total_number_of_skipped_writes=1<br>ProfileSaver total_number_of_failed_writes=0<br>ProfileSaver total_ms_of_sleep=312878<br>ProfileSaver total_ms_of_work=4<br>ProfileSaver total_number_of_hot_spikes=0<br>ProfileSaver total_number_of_wake_ups=1<br><br>// ThreadList::DumpForSigQuit<br>suspend all histogram:Sum: 289us 99% C.I. 2us-164us Avg: 20.642us Max: 164us (应该是中断所有线程的执行耗费的时间)<br><br>// ThreadList::Dump (已绑定到 VM 的线程)<br>DALVIK THREADS (16):<br><br>// Thread::Dump<br>&quot;main&quot;(线程名) [daemon(如果是 daemon thread)] prio=5(优先级) tid=1(线程 ID) Sleeping(可以是：NEW, RUNNABLE, TIMED_WAITTING|SLEEPING, WAITTING, BLOCKED 和 TERMINATED，参考 art::ThreadState)<br>  | group=&quot;main&quot;(线程组) <br>  <br>  /**<br>   * Thread::tls32_::suspend_count, A non-zero value is used to tell the current thread to enter a safe point at the next poll.<br>   * <br>   * save point 是 JVM 里的一个概念，可以认为是一个函数，被 JVM 安插在各个地方：循环末尾、函数执行前/后、抛出异常时... <br>   * 那它有什么用呢？比如 GC/dump 时需要 Stop-The-World 吧，debug 时打断点/单步调试需要中断线程的执行吧，<br>   * 那怎么才能让正在执行 CPU 指令的 java 线程暂停呢？靠的就是安插在各处的 save point 去检查某个指示线程是否可以继续执行的标识<br>   * <br>   * 在 SafePoint 保存了其他位置没有的一些当前线程的运行信息供其他线程读取，包括：线程上下文的任何信息、对象或者非对象的内部指针等等<br>   * 我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息才是确定的，也只有这个时候才知道这个线程用了哪些内存，没有用哪些<br>   * 并且只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到<br>   * 之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候才会感知<br>   * <br>   * 也就是说当 sCount 非零时会进入 save point，非零时会跳过 save point<br>   * 从 ANR Trace 看只有 Signal Catcher 的 sCount 才会为零，猜测 process dump 是需要中断除 Signal Catcher 之外其他线程的执行，只留 Signal Catcher 进行 thread dump 操作<br>   */<br>  sCount=1 <br>  <br>  /**<br>   * Thread::tls32_::debug_suspend_count<br>   * How much of &#x27;suspend_count_&#x27; is by request of the debugger, used to set things right when the debugger detaches. Must be &lt;= suspend_count_.<br>   * debugger 可以修改 suspend_count（打断点？）但在此之前需要把 suspend_count 的值备份在这个字段，以便退出 debug 的时候可以恢复<br>   *<br>   */<br>  dsCount=0 <br>  <br>  /**<br>   * Thread::tls32_::state_and_flags::as_struct::flags, bitmap field<br>   * <br>   * enum ThreadFlag &#123;<br>   *   kSuspendRequest         = 1,  // If set implies that suspend_count_ &gt; 0 and the Thread should enter the safepoint handler.<br>   *   kCheckpointRequest      = 2,  // Request that the thread do some checkpoint work and then continue.<br>   *   kEmptyCheckpointRequest = 4,  // Request that the thread do empty checkpoint and then continue.<br>   *   kActiveSuspendBarrier   = 8,  // Register that at least 1 suspend barrier needs to be passed.<br>   * &#125;;<br>   */<br>  flags=1 <br>  <br>  obj=0x72313478 (Thread::tlsPtr_::opeer, Our managed peer (an instance of java.lang.Thread)，应该是此线程对应的 java thread object 地址)<br>  self=0xb400007f542bbc00 (reinterpret_cast&lt;const void*&gt;(thread), native art::Thread 对象地址)<br>  sysTid=27750 (此线程在宿主系统上的 ID, ps -A -T) <br>  nice=-10 (thread nice value，含义类似于 process nice value，可以动态调整的线程优先级)<br>  cgrp=default (执行此线程的 cpu 的 cpu group，来自于 /proc/self/task/[tid]/cgroup)<br>  <br>  /**<br>   * 左边的数字来自 sched_getscheduler(tid)，cpu scheduling policy，有以下值：<br>   * <br>   * non-real-time<br>   * SCHED_NORMAL/SCHED_OTHER = 0   the standard round-robin time-sharing policy<br>   * SCHED_BATCH              = 3   for &quot;batch&quot; style execution of processes<br>   * SCHED_IDLE               = 5   for running very low priority background jobs<br>   * <br>   * real-time<br>   * SCHED_FIFO               = 1   a first-in, first-out policy<br>   * SCHED_RR                 = 2   a round-robin policy<br>   *<br>   * 右边的数字来自于 sched_getparam, scheduling parameters，跟上面的 scheduling policy 配合使用<br>   *<br>   * 这两个都属于 cpu 调度相关，详见 man sched.7<br>   */<br>  sched=0/0 <br><br>  handle=0x7f559584f8 (Thread::tlsPtr_::pthread_self, 底层的 pthread_t 地址)<br><br>  /**<br>   * 来自 /proc/[pid]/task/[tid]/schedstat，分别是 CPU 上执行的时间、线程的等待时间和线程执行的时间片<br>   */<br>  schedstat=( 439366137 82406360 402 )<br><br>  /**<br>   * 来自 /proc/[pid]/task/[tid]/stat，里面的字段跟 /proc/[pid]/stat 类似<br>   * state=S(SLEEPING) 线程状态为休眠中<br>   * utm(utime) 线程运行在用户态的时间<br>   * stm(stime) 线程运行在内核态的时间<br>   * core(task_cpu) 运行在哪个 CPU 上<br>   */<br>  state=S  utm=36 stm=7 core=0 <br>  HZ=100 (sysconf(_SC_CLK_TCK)，每秒种的内核时钟滴答数)<br><br>  /**<br>   * Thread::tlsPtr_::stack_begin - Thread::tlsPtr_::stack_end<br>   * 方法栈的开始地址、结束地址和栈大小<br>   */<br>  stack=0x7ffd85d000-0x7ffd85f000 stackSize=8192KB<br>  <br>  /**<br>   * 此线程锁持有的锁类型，定义在 art/runtime/base/locks.h，有：<br>   * LockLevel::kLoggingLock, LockLevel::kSwapMutexesLock, ...<br>   */<br>  held mutexes=<br><br>  at java.lang.Thread.sleep(Native method)<br>  - sleeping on &lt;0x0bd69ce3&gt; (a java.lang.Object)<br>  at java.lang.Thread.sleep(Thread.java:442)<br>  - locked &lt;0x0bd69ce3&gt; (a java.lang.Object)<br>  at java.lang.Thread.sleep(Thread.java:358)<br>  at com.example.myapplication.MainActivity.onCreate$lambda-0(MainActivity.kt:20)<br>  at com.example.myapplication.MainActivity.lambda$b-o9DaQhxOUy1smA7kVJfKXtbVM(MainActivity.kt:-1)<br>  at com.example.myapplication.-$$Lambda$MainActivity$b-o9DaQhxOUy1smA7kVJfKXtbVM.onClick(lambda:-1)<br>  at android.view.View.performClick(View.java:7509)<br>  at android.view.View.performClickInternal(View.java:7486)<br>  at android.view.View.access$3600(View.java:841)<br>  at android.view.View$PerformClick.run(View.java:28709)<br>  at android.os.Handler.handleCallback(Handler.java:938)<br>  at android.os.Handler.dispatchMessage(Handler.java:99)<br>  at android.os.Looper.loop(Looper.java:236)<br>  at android.app.ActivityThread.main(ActivityThread.java:8061)<br>  at java.lang.reflect.Method.invoke(Native method)<br>  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)<br><br>&quot;Signal Catcher&quot; daemon prio=10 tid=4 Runnable<br>  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x12d80260 self=0xb400007ebd813800<br>  | sysTid=27771 nice=-20 cgrp=default sched=0/0 handle=0x7ebdf73cc0<br>  | state=R schedstat=( 11436460 2051300 7 ) utm=0 stm=0 core=4 HZ=100<br>  | stack=0x7ebde7c000-0x7ebde7e000 stackSize=995KB<br>  | held mutexes= &quot;mutator lock&quot;(shared held)<br>  native: #00 pc 000000000047c188  /apex/com.android.art/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)<br>  native: #01 pc 0000000000581444  /apex/com.android.art/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, bool, BacktraceMap*, bool) const+380)<br>  native: #02 pc 000000000059e288  /apex/com.android.art/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+924)<br>  native: #03 pc 0000000000597c2c  /apex/com.android.art/lib64/libart.so (art::ThreadList::RunCheckpoint(art::Closure*, art::Closure*)+536)<br>  native: #04 pc 0000000000596cb4  /apex/com.android.art/lib64/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, bool)+1928)<br>  native: #05 pc 000000000059614c  /apex/com.android.art/lib64/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;)+776)<br>  native: #06 pc 0000000000543c68  /apex/com.android.art/lib64/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;)+196)<br>  native: #07 pc 0000000000559810  /apex/com.android.art/lib64/libart.so (art::SignalCatcher::HandleSigQuit()+1400)<br>  native: #08 pc 00000000005587d8  /apex/com.android.art/lib64/libart.so (art::SignalCatcher::Run(void*)+348)<br>  native: #09 pc 00000000000f4204  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+64)<br>  native: #10 pc 000000000008ec64  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)<br>  (no managed stack frames)<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SignalCatcher::HandleSigQuit</span><span class="hljs-params">()</span> </span>&#123;<br>  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>  std::ostringstream os;<br>  os &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>      &lt;&lt; <span class="hljs-string">&quot;----- pid &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; <span class="hljs-built_in">GetIsoDate</span>() &lt;&lt; <span class="hljs-string">&quot; -----\n&quot;</span>;<br><br>  <span class="hljs-built_in">DumpCmdLine</span>(os);<br><br>  <span class="hljs-comment">// Note: The strings &quot;Build fingerprint:&quot; and &quot;ABI:&quot; are chosen to match the format used by</span><br>  <span class="hljs-comment">// debuggerd. This allows, for example, the stack tool to work.</span><br>  std::string fingerprint = runtime-&gt;<span class="hljs-built_in">GetFingerprint</span>();<br>  os &lt;&lt; <span class="hljs-string">&quot;Build fingerprint: &#x27;&quot;</span> &lt;&lt; (fingerprint.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;unknown&quot;</span> : fingerprint) &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;<br>  os &lt;&lt; <span class="hljs-string">&quot;ABI: &#x27;&quot;</span> &lt;&lt; <span class="hljs-built_in">GetInstructionSetString</span>(runtime-&gt;<span class="hljs-built_in">GetInstructionSet</span>()) &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;<br><br>  os &lt;&lt; <span class="hljs-string">&quot;Build type: &quot;</span> &lt;&lt; (kIsDebugBuild ? <span class="hljs-string">&quot;debug&quot;</span> : <span class="hljs-string">&quot;optimized&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>  runtime-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-literal">false</span>)) &#123;<br>    std::string maps;<br>    <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, &amp;maps)) &#123;<br>      os &lt;&lt; <span class="hljs-string">&quot;/proc/self/maps:\n&quot;</span> &lt;&lt; maps;<br>    &#125;<br>  &#125;<br>  os &lt;&lt; <span class="hljs-string">&quot;----- end &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; -----\n&quot;</span>;<br>  <span class="hljs-built_in">Output</span>(os.<span class="hljs-built_in">str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::DumpForSigQuit</span><span class="hljs-params">(std::ostream&amp; os)</span> </span>&#123;<br>  <span class="hljs-built_in">GetClassLinker</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  <span class="hljs-built_in">GetInternTable</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  <span class="hljs-built_in">GetJavaVM</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  <span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  oat_file_manager_-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetJit</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">GetJit</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;Running non JIT\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-built_in">DumpDeoptimizations</span>(os);<br>  TrackedAllocators::<span class="hljs-built_in">Dump</span>(os);<br>  <span class="hljs-built_in">GetMetrics</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  os &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>  thread_list_-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);<br>  BaseMutex::<span class="hljs-built_in">DumpAll</span>(os);<br><br>  <span class="hljs-comment">// Inform anyone else who is interested in SigQuit.</span><br>  &#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(Thread::Current())</span></span>;<br>    callbacks_-&gt;<span class="hljs-built_in">SigQuit</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DumpCmdLine</span><span class="hljs-params">(std::ostream&amp; os)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__linux__)</span><br>  <span class="hljs-comment">// Show the original command line, and the current command line too if it&#x27;s changed.</span><br>  <span class="hljs-comment">// On Android, /proc/self/cmdline will have been rewritten to something like &quot;system_server&quot;.</span><br>  <span class="hljs-comment">// Note: The string &quot;Cmd line:&quot; is chosen to match the format used by debuggerd.</span><br>  std::string current_cmd_line;<br>  <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/self/cmdline&quot;</span>, &amp;current_cmd_line)) &#123;<br>    current_cmd_line.<span class="hljs-built_in">resize</span>(current_cmd_line.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&#x27;\0&#x27;</span>) + <span class="hljs-number">1</span>);  <span class="hljs-comment">// trim trailing &#x27;\0&#x27;s</span><br>    std::<span class="hljs-built_in">replace</span>(current_cmd_line.<span class="hljs-built_in">begin</span>(), current_cmd_line.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br><br>    os &lt;&lt; <span class="hljs-string">&quot;Cmd line: &quot;</span> &lt;&lt; current_cmd_line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* stashed_cmd_line = <span class="hljs-built_in">GetCmdLine</span>();<br>    <span class="hljs-keyword">if</span> (stashed_cmd_line != <span class="hljs-literal">nullptr</span> &amp;&amp; current_cmd_line != stashed_cmd_line<br>            &amp;&amp; <span class="hljs-built_in">strcmp</span>(stashed_cmd_line, <span class="hljs-string">&quot;&lt;unset&gt;&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>      os &lt;&lt; <span class="hljs-string">&quot;Original command line: &quot;</span> &lt;&lt; stashed_cmd_line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  os &lt;&lt; <span class="hljs-string">&quot;Cmd line: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetCmdLine</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="debuggerd-tombstoned"><a href="#debuggerd-tombstoned" class="headerlink" title="debuggerd.tombstoned"></a>debuggerd.tombstoned</h3><p>上一章节构造了 dump 字符串，下面我们来看看它被输出到哪里：</p><ol><li>通过 unix domain socket 连接到 <code>/dev/socket/tombstoned_java_trace</code> (<code>ANDROID_SOCKET_NAMESPACE_RESERVED</code> + <code>kTombstonedJavaTraceSocketName</code>，看名字像是一个叫 <code>debuggerd.tombstoned</code> 的服务)</li><li>将 <code>pid</code>、<code>dumpType</code> 等参数发送过去，返回一个 output fd (这个 fd 其实就是上面介绍过的 <code>debuggerd_trigger_dump</code> 里管道的 write fd，它被注册到 <code>debuggerd.tombstoned</code>)</li><li>把 dump 字符串写入 output fd</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SignalCatcher::Output</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string&amp; s)</span> </span>&#123;<br>  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(Thread::Current(), kWaitingForSignalCatcherOutput)</span></span>;<br>  <span class="hljs-keyword">palette_status_t</span> status = <span class="hljs-built_in">PaletteWriteCrashThreadStacks</span>(s.<span class="hljs-built_in">data</span>(), s.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;<br>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Wrote stack traces to tombstoned&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">CHECK</span>(status == PALETTE_STATUS_FAILED_CHECK_LOG);<br>    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to write stack traces to tombstoned&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// system/libartpalette/palette_android.cc</span><br><span class="hljs-function"><span class="hljs-keyword">palette_status_t</span> <span class="hljs-title">PaletteWriteCrashThreadStacks</span><span class="hljs-params">(<span class="hljs-comment">/*in*/</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* stacks, <span class="hljs-keyword">size_t</span> stacks_len)</span> </span>&#123;<br>    android::base::unique_fd tombstone_fd;<br>    android::base::unique_fd output_fd;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">tombstoned_connect</span>(<span class="hljs-built_in">getpid</span>(), &amp;tombstone_fd, &amp;output_fd, kDebuggerdJavaBacktrace)) &#123;<br>        <span class="hljs-comment">// Failure here could be due to file descriptor resource exhaustion</span><br>        <span class="hljs-comment">// so write the stack trace message to the log in case it helps</span><br>        <span class="hljs-comment">// debug that.</span><br>        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; std::<span class="hljs-built_in">string_view</span>(stacks, stacks_len);<br>        <span class="hljs-comment">// tombstoned_connect() logs failure reason.</span><br>        <span class="hljs-keyword">return</span> PALETTE_STATUS_FAILED_CHECK_LOG;<br>    &#125;<br><br>    <span class="hljs-keyword">palette_status_t</span> status = PALETTE_STATUS_OK;<br>    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">WriteFully</span>(output_fd, stacks, stacks_len)) &#123;<br>        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to write tombstoned output&quot;</span>;<br>        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">ftruncate</span>(output_fd, <span class="hljs-number">0</span>));<br>        status = PALETTE_STATUS_FAILED_CHECK_LOG;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fdatasync</span>(output_fd)) == <span class="hljs-number">-1</span> &amp;&amp; errno != EINVAL) &#123;<br>        <span class="hljs-comment">// Ignore EINVAL so we don&#x27;t report failure if we just tried to flush a pipe</span><br>        <span class="hljs-comment">// or socket.</span><br>        <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;<br>            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to fsync tombstoned output&quot;</span>;<br>            status = PALETTE_STATUS_FAILED_CHECK_LOG;<br>        &#125;<br>        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">ftruncate</span>(output_fd, <span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fdatasync</span>(output_fd));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">close</span>(output_fd.<span class="hljs-built_in">release</span>()) == <span class="hljs-number">-1</span> &amp;&amp; errno != EINTR) &#123;<br>        <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;<br>            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to close tombstoned output&quot;</span>;<br>            status = PALETTE_STATUS_FAILED_CHECK_LOG;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">tombstoned_notify_completion</span>(tombstone_fd)) &#123;<br>        <span class="hljs-comment">// tombstoned_notify_completion() logs failure.</span><br>        status = PALETTE_STATUS_FAILED_CHECK_LOG;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-comment">// system/core/debuggerd/tombstoned/tombstoned_client.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">tombstoned_connect</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, unique_fd* tombstoned_socket, unique_fd* text_output_fd,</span></span><br><span class="hljs-params"><span class="hljs-function">                        unique_fd* proto_output_fd, DebuggerdDumpType dump_type)</span> </span>&#123;<br>  <span class="hljs-function">unique_fd <span class="hljs-title">sockfd</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      socket_local_client((dump_type != kDebuggerdJavaBacktrace ? kTombstonedCrashSocketName</span></span><br><span class="hljs-params"><span class="hljs-function">                                                                : kTombstonedJavaTraceSocketName),</span></span><br><span class="hljs-params"><span class="hljs-function">                          ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET))</span></span>;<br>  <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to connect to tombstoned: %s&quot;</span>,<br>                          <span class="hljs-built_in">strerror</span>(errno));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  TombstonedCrashPacket packet = &#123;&#125;;<br>  packet.packet_type = CrashPacketType::kDumpRequest;<br>  packet.packet.dump_request.pid = pid;<br>  packet.packet.dump_request.dump_type = dump_type;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">write</span>(sockfd, &amp;packet, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(packet))) != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(packet)) &#123;<br>    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to write DumpRequest packet: %s&quot;</span>,<br>                          <span class="hljs-built_in">strerror</span>(errno));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  unique_fd tmp_output_fd, tmp_proto_fd;<br>  <span class="hljs-keyword">ssize_t</span> rc = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span> (dump_type == kDebuggerdTombstoneProto) &#123;<br>    rc = <span class="hljs-built_in">ReceiveFileDescriptors</span>(sockfd, &amp;packet, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(packet), &amp;tmp_output_fd, &amp;tmp_proto_fd);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    rc = <span class="hljs-built_in">ReceiveFileDescriptors</span>(sockfd, &amp;packet, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(packet), &amp;tmp_output_fd);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>,<br>                          <span class="hljs-string">&quot;failed to read response to DumpRequest packet: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(packet)) &#123;<br>    <span class="hljs-built_in">async_safe_format_log</span>(<br>        ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>,<br>        <span class="hljs-string">&quot;received DumpRequest response packet of incorrect length (expected %zu, got %zd)&quot;</span>,<br>        <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(packet), rc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Make the fd O_APPEND so that our output is guaranteed to be at the end of a file.</span><br>  <span class="hljs-comment">// (This also makes selinux rules consistent, because selinux distinguishes between writing to</span><br>  <span class="hljs-comment">// a regular fd, and writing to an fd with O_APPEND).</span><br>  <span class="hljs-keyword">int</span> flags = <span class="hljs-built_in">fcntl</span>(tmp_output_fd.<span class="hljs-built_in">get</span>(), F_GETFL);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(tmp_output_fd.<span class="hljs-built_in">get</span>(), F_SETFL, flags | O_APPEND) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_WARN, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to set output fd flags: %s&quot;</span>,<br>                          <span class="hljs-built_in">strerror</span>(errno));<br>  &#125;<br><br>  *tombstoned_socket = std::<span class="hljs-built_in">move</span>(sockfd);<br>  *text_output_fd = std::<span class="hljs-built_in">move</span>(tmp_output_fd);<br>  <span class="hljs-keyword">if</span> (proto_output_fd) &#123;<br>    *proto_output_fd = std::<span class="hljs-built_in">move</span>(tmp_proto_fd);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="dump-native-traces"><a href="#dump-native-traces" class="headerlink" title="dump native traces"></a>dump native traces</h2><p>最终还是来到 <code>debuggerd_trigger_dump</code>，只不过此时 <code>dump_type</code> 是 <code>kDebuggerdNativeBacktrace</code></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Debug</span>.</span></span>dump<span class="hljs-constructor">NativeBacktraceToFileTimeout(<span class="hljs-params">pid</span>, <span class="hljs-params">file</span>, <span class="hljs-params">timeoutSecs</span>)</span><br>android_os_Debug_dumpNativeBacktraceToFileTimeout<br>dump<span class="hljs-constructor">Traces(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jint</span> <span class="hljs-params">pid</span>, <span class="hljs-params">jstring</span> <span class="hljs-params">fileName</span>, <span class="hljs-params">jint</span> <span class="hljs-params">timeoutSecs</span>, DebuggerdDumpType <span class="hljs-params">dumpType</span>)</span><br>dump<span class="hljs-constructor">_backtrace_to_file_timeout(<span class="hljs-params">pid_t</span> <span class="hljs-params">tid</span>, DebuggerdDumpType <span class="hljs-params">dump_type</span>, <span class="hljs-params">int</span> <span class="hljs-params">timeout_secs</span>, <span class="hljs-params">int</span> <span class="hljs-params">fd</span>)</span><br>debuggerd<span class="hljs-constructor">_trigger_dump(<span class="hljs-params">pid_t</span> <span class="hljs-params">tid</span>, DebuggerdDumpType <span class="hljs-params">dump_type</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">timeout_ms</span>, <span class="hljs-params">unique_fd</span> <span class="hljs-params">output_fd</span>)</span><br></code></pre></div></td></tr></table></figure><h1 id="ANR-Dialog"><a href="#ANR-Dialog" class="headerlink" title="ANR Dialog"></a>ANR Dialog</h1><p>在 <code>ActivityManagerService.mUiHandler</code> 里打开 <code>AppNotRespondingDialog</code>，这个对话框一般会包含两个按钮：等待和关闭，如果选择关闭则会通过 <code>kill(pid, SIGKILL)</code> 杀死 ANR 进程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ProcessRecord.ErrorDialogController.showAnrDialogs<br>ProcessRecord.ErrorDialogController.scheduleForAllDialogs<br>ProcessRecord.ErrorDialogController.forAllDialogs<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppNotRespondingDialog</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>            Intent appErrorIntent = <span class="hljs-keyword">null</span>;<br><br>            MetricsLogger.action(getContext(), MetricsProto.MetricsEvent.ACTION_APP_ANR,<br>                    msg.what);<br><br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> FORCE_CLOSE:<br>                    <span class="hljs-comment">// Kill the application.</span><br>                    mService.killAppAtUsersRequest(mProc);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> WAIT_AND_REPORT:<br>                <span class="hljs-keyword">case</span> WAIT:<br>                    <span class="hljs-comment">// Continue waiting for the application.</span><br>                    <span class="hljs-keyword">synchronized</span> (mService) &#123;<br>                        ProcessRecord app = mProc;<br>                        <span class="hljs-keyword">final</span> ProcessErrorStateRecord errState = app.mErrorState;<br><br>                        <span class="hljs-keyword">if</span> (msg.what == WAIT_AND_REPORT) &#123;<br>                            appErrorIntent = mService.mAppErrors.createAppErrorIntentLOSP(app,<br>                                    System.currentTimeMillis(), <span class="hljs-keyword">null</span>);<br>                        &#125;<br><br>                        <span class="hljs-keyword">synchronized</span> (mService.mProcLock) &#123;<br>                            errState.setNotResponding(<span class="hljs-keyword">false</span>);<br>                            errState.setNotRespondingReport(<span class="hljs-keyword">null</span>);<br>                            errState.getDialogController().clearAnrDialogs();<br>                        &#125;<br>                        mService.mServices.scheduleServiceTimeoutLocked(app);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (appErrorIntent != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    getContext().startActivity(appErrorIntent);<br>                &#125; <span class="hljs-keyword">catch</span> (ActivityNotFoundException e) &#123;<br>                    Slog.w(TAG, <span class="hljs-string">&quot;bug report receiver dissappeared&quot;</span>, e);<br>                &#125;<br>            &#125;<br><br>            dismiss();<br>        &#125;<br>    &#125;;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">killAppAtUsersRequest</span><span class="hljs-params">(ProcessRecord app)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            mAppErrors.killAppAtUserRequestLocked(app);<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppErrors</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">killAppAtUserRequestLocked</span><span class="hljs-params">(ProcessRecord app)</span> </span>&#123;<br>        ErrorDialogController controller = app.mErrorState.getDialogController();<br><br>        <span class="hljs-keyword">int</span> reasonCode = ApplicationExitInfo.REASON_ANR;<br>        <span class="hljs-keyword">int</span> subReason = ApplicationExitInfo.SUBREASON_UNKNOWN;<br>        <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;<br>            <span class="hljs-keyword">if</span> (controller.hasDebugWaitingDialog()) &#123;<br>                reasonCode = ApplicationExitInfo.REASON_OTHER;<br>                subReason = ApplicationExitInfo.SUBREASON_WAIT_FOR_DEBUGGER;<br>            &#125;<br>            controller.clearAllErrorDialogs();<br>            killAppImmediateLSP(app, reasonCode, subReason,<br>                    <span class="hljs-string">&quot;user-terminated&quot;</span>, <span class="hljs-string">&quot;user request after error&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killAppImmediateLSP</span><span class="hljs-params">(ProcessRecord app, <span class="hljs-keyword">int</span> reasonCode, <span class="hljs-keyword">int</span> subReason,</span></span><br><span class="hljs-params"><span class="hljs-function">            String reason, String killReason)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ProcessErrorStateRecord errState = app.mErrorState;<br>        errState.setCrashing(<span class="hljs-keyword">false</span>);<br>        errState.setCrashingReport(<span class="hljs-keyword">null</span>);<br>        errState.setNotResponding(<span class="hljs-keyword">false</span>);<br>        errState.setNotRespondingReport(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pid = errState.mApp.getPid();<br>        <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span> &amp;&amp; pid != MY_PID) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mBadProcessLock) &#123;<br>                handleAppCrashLSPB(app, reason,<br>                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/*shortMsg*/</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/*longMsg*/</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/*stackTrace*/</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/*data*/</span>);<br>            &#125;<br>            app.killLocked(killReason, reasonCode, subReason, <span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;     <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessRecord</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">killLocked</span><span class="hljs-params">(String reason, <span class="hljs-meta">@Reason</span> <span class="hljs-keyword">int</span> reasonCode, <span class="hljs-meta">@SubReason</span> <span class="hljs-keyword">int</span> subReason,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">boolean</span> noisy)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!mKilledByAm) &#123;<br>            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;kill&quot;</span>);<br>            <span class="hljs-keyword">if</span> (mService != <span class="hljs-keyword">null</span> &amp;&amp; (noisy || info.uid == mService.mCurOomAdjUid)) &#123;<br>                mService.reportUidInfoMessageLocked(TAG,<br>                        <span class="hljs-string">&quot;Killing &quot;</span> + toShortString() + <span class="hljs-string">&quot; (adj &quot;</span> + mState.getSetAdj()<br>                        + <span class="hljs-string">&quot;): &quot;</span> + reason, info.uid);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mPid &gt; <span class="hljs-number">0</span>) &#123;<br>                mService.mProcessList.noteAppKill(<span class="hljs-keyword">this</span>, reasonCode, subReason, reason);<br>                EventLog.writeEvent(EventLogTags.AM_KILL,<br>                        userId, mPid, processName, mState.getSetAdj(), reason);<br>                Process.killProcessQuiet(mPid);<br>                ProcessList.killProcessGroup(uid, mPid);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mPendingStart = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mPersistent) &#123;<br>                <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;<br>                    mKilled = <span class="hljs-keyword">true</span>;<br>                    mKilledByAm = <span class="hljs-keyword">true</span>;<br>                    mKillTime = SystemClock.uptimeMillis();<br>                &#125;<br>            &#125;<br>            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Process</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL_KILL = <span class="hljs-number">9</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killProcessQuiet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid)</span> </span>&#123;<br>        sendSignalQuiet(pid, SIGNAL_KILL);<br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">android_os_Process_sendSignalQuiet</span><span class="hljs-params">(JNIEnv* env, jobject clazz, jint pid, jint sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        kill(pid, sig);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/f9b8c139c2ed">Linux对内存的管理, 以及page fault的概念</a></li><li><a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">Understanding page faults and memory swap-in/outs: when should you worry?</a></li><li><a href="https://developer.android.com/topic/performance/vitals/anr">Android Developer ANRs</a></li><li><a href="https://developer.android.com/studio/debug/bug-report">Android Developer Bug Reports</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649288031&idx=1&sn=91c94e16460a4685a9c0c8e1b9c362a6">微信Android客户端的ANR监控方案</a></li><li><a href="https://www.jianshu.com/p/6058e5c6332a">每日一面 - 什么是 Safepoint？</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>anr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MP4 文件结构浅析</title>
    <link href="/2021/07/05/mp4-structure/"/>
    <url>/2021/07/05/mp4-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>mp4</code> 文件由一个个连续的 <code>box</code> 组成</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">mp4 = <span class="hljs-built_in">box</span> + <span class="hljs-built_in">box</span> + <span class="hljs-built_in">box</span> + ...<br></code></pre></div></td></tr></table></figure><p>box 的类型繁多，没必要去死记它们的类型，记住两个关键 box 即可：</p><ol><li><code>moov</code> - 保存了 SPS、PPS、track-chunk-sample 映射等关键信息</li><li><code>mdat</code> - 保存了 H264 NALU</li></ol><p>本文的目的是通过解析各种 box 从而了解 mp4 文件结构的核心概念</p><h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><p>一个 mp4 文件可以包含多个 <code>track</code>（视频、音频和字幕），而每个 track 则由多个 <code>chunk</code> 组成</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">mp4</span> = video track + audio track + subtitle track + ...<br><span class="hljs-attr">track</span> = chunk + chunk + chunk + ...<br></code></pre></div></td></tr></table></figure><p><code>Stco Box</code> 描述了一个 track 有多少个 chunk 以及每个 chunk 在 mp4 文件里的偏移量，这样就具有了快速定位（<code>seek</code>）chunk 的能力</p><p>比如下图说明 track 有 486 个 chunk，每个 chunk 在文件里的偏移量都记录在后面的表里</p><p><img src="../../../../image/2021-07-05-mp4-structure/stco.webp" alt="stco box"></p><h1 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h1><p><code>sample</code>（采样）相当于一帧，解码的过程就是计算出一帧帧的图像，每个 chunk 包含多个 <code>sample</code></p><figure class="highlight glsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs glsl">chunk = <span class="hljs-keyword">sample</span> + <span class="hljs-keyword">sample</span> + <span class="hljs-keyword">sample</span> + ...<br></code></pre></div></td></tr></table></figure><p>具体哪个 chunk 包含哪几个 sample 由 <code>Stsc Box</code> 描述： <code>stsc = entry count + (first chunk + samples per chunk + sample description index)</code>，如下图，它是这么描述的：</p><ol><li>第 1 个 chunk 包含 15 个 sample</li><li>第 2 - 485 个 chunk 包含 14 个 sample</li><li>第 486 个 chunk 包含 5 个 sample</li></ol><p>那么可以计算出这个 track 共有 486 个 chunk（和上面 Stco Box 的描述一致） 和 <code>15 + 485 * 14 + 5 = 4796</code> 个 sample</p><p><img src="../../../../image/2021-07-05-mp4-structure/stsc.webp" alt="stsc box"></p><p>至此我们可以通过 <code>sample id -&gt; chunk id -&gt; chunk offset</code> 这个链条定位某个 sample 所在的 chunk 及其偏移，但 sample 偏移还是没法得知，而 <code>Stsz Box</code> 正是记录了每个 sample 的大小，如下图：</p><ol><li>sample count = 6796，与上面我们计算出的数据一致</li><li>sample size 是一张记录了每个 sample 大小的表（所以 stsz box 会很大）</li></ol><p>那么 sample 在文件里的偏移就可以通过 chunk offset 前进 n 个排在前面的 sample 的长度得出：<code>sample offset = chunk offset + samples before in the chunk</code></p><p><img src="../../../../image/2021-07-05-mp4-structure/stsz.webp" alt="stsz box"></p><h1 id="DTS-和-PTS"><a href="#DTS-和-PTS" class="headerlink" title="DTS 和 PTS"></a>DTS 和 PTS</h1><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>I frame</td><td>帧内编码帧，解码不依赖于任何的其它的帧，通常是每个 GOP 的第一个帧，做为随机访问的参考点</td></tr><tr><td>P frame</td><td>前向预测编码帧，解码则依赖于其前面的 I/P frame</td></tr><tr><td>B frame</td><td>双向预测内插编码帧，解码依赖于其前的最近的一个 I/P frame 及其后的最近的一个 P frame</td></tr><tr><td>GOP</td><td>两个 I frame 之间形成一个 GOP，如果有 B frame 则最后一个一定是 P frame</td></tr><tr><td>PTS</td><td>用于度量解码后的视频帧什么时候被显示出来</td></tr><tr><td>DTS</td><td>标识视频流在什么时候开始送入解码器中进行解码</td></tr></tbody></table><p>在没有 B frame 的情况下 DTS 和 PTS 的输出顺序是一样的，有 B frame 的话就不一样了，如下图：</p><p><img src="../../../../image/2021-07-05-mp4-structure/dts-pts.jpg" alt="dts-pts"></p><p><code>Stts Box</code> 是 sample id 和解码时间 DTS 之间的映射表，通过这个表格我们可以找到任何时间的 sample，如下图：</p><ol><li>sample delta 值一样说明是固定帧率，帧率为 <code>30000 / 1001 = 29.97</code></li><li>可以计算出该 video track 的时长为 <code>6796 * 1001 = 6802796</code>（6796 跟上面我们计算的 sample 数量一致），换算成秒就是 <code>6802796 / 30000 = 226.75s</code>（30000 是 mvhd box 里定义的时间单位）</li></ol><p><img src="../../../../image/2021-07-05-mp4-structure/stts.webp" alt="stts box"></p><p><code>Ctts Box</code> 描述了每个 sample 的 <code>composition time</code> 和 <code>decode time</code> 之间的差值，通过 composition time 就可以计算出 PTS，如下图：</p><ul><li>entry count   - 描述了下面 sample count 和 sample delta 组成的二元组个数</li><li>sample count  - 连续相同 offset 的 sample 个数</li><li>sample offset - CT 和 DT 之间的 offset</li></ul><p><img src="../../../../image/2021-07-05-mp4-structure/ctts.webp" alt="ctts box"></p><p>计算前面 5 个 sample 的 DTS 和 PTS</p><table><thead><tr><th></th><th>0 frame</th><th>1 frame</th><th>2 frame</th><th>3 frame</th><th>4 frame</th></tr></thead><tbody><tr><td>sample detla</td><td>1001</td><td>1001</td><td>1001</td><td>1001</td><td>1001</td></tr><tr><td>sample offset</td><td>2002</td><td>5005</td><td>2002</td><td>0</td><td>1001</td></tr><tr><td>DTS</td><td>0</td><td>1001</td><td>2002</td><td>3003</td><td>4004</td></tr><tr><td>PTS</td><td>2002</td><td>6006</td><td>4004</td><td>3003</td><td>5005</td></tr></tbody></table><p>解码：0 - 1 - 2 - 3 - 4</p><p>显示：0 - 3 - 2 - 4 - 1</p><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p><img src="../../../../image/2021-07-05-mp4-structure/overview.jpg" alt="overview"></p><h1 id="应用之-seek"><a href="#应用之-seek" class="headerlink" title="应用之 seek"></a>应用之 seek</h1><p>拖动视频进度条，进度条对应的应该是 PTS，那么根据 PTS 找到对应的 sample，如果是 P/B frame 还需要往前寻找所在 GOP 的 I frame，然后找到它所在的 chunk 而从定位到它的偏移值，从这个偏移值开始读取整个 GOP 长度的数据流并解码</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NTMxMjA1MQ==&mid=2247483932&idx=1&sn=60d7bc3d4330c362e0e49a287d72a9d7&chksm=e9513d40de26b4569f1d664d026d7f5b3df556f454db9b35d4a2981abbae631ad7fd4746558f&scene=21#wechat_redirect">音视频封装：MP4结构概述和分析工具</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NTMxMjA1MQ==&mid=2247484020&idx=1&sn=e1f99ff04dac96ab31154f66492cbb1c&chksm=e9513d28de26b43e0ac6e2fa88a36840b8c9ff651f4bdd0c343d4cf85a198060182fb57461ab&cur_album_id=1440947813877202945&scene=189#rd">音视频解封装：MP4核心Box详解及H264&amp;AAC打包方案</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mp4</tag>
      
      <tag>pts</tag>
      
      <tag>dts</tag>
      
      <tag>box</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志库 Logan</title>
    <link href="/2021/06/28/logan/"/>
    <url>/2021/06/28/logan/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/Meituan-Dianping/Logan">Logan</a> 是 <a href="https://github.com/meituan">美团点评技术团队</a> 开源的包含前端 SDK 和后端 Server 的一整套日志系统，也是公司日志库 <code>VLog</code> 的基础</p><p>Logan Android SDK 提供了这么几个 API：</p><table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody><tr><td>Logan#w(log, type)</td><td>写日志（严谨地说应该是发送日志请求，因为日志是放在消息队列里等待被处理的）</td></tr><tr><td>Logan#init</td><td>初始化</td></tr><tr><td>Logan#f</td><td>Logan 内部有个内存缓存（memory/mmap），日志首先被写入到缓存里，只有到达一定大小时（1/3）才写入文件，这里请求立刻写入到文件里去</td></tr><tr><td>Logan#s</td><td>根据日期 获取/发送 日志文件</td></tr><tr><td>Logan#getAllFilesInfo</td><td>获取所有的日志文件，key 是日期，value 是日志文件大小</td></tr><tr><td>Logan#setDebug</td><td>设置为 debug 模式后，会有更加详细的 native 日志，但是默认实现只是输出到 stdout 没有写入 android log</td></tr><tr><td>Logan#setOnLoganProtocolStatus</td><td>可以拿到一些 Java 的关键日志</td></tr></tbody></table><p>LoganConfig 是初始化配置参数：</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>path</td><td>存放日志文件的目录，日志是按日期（天）存放的，文件名是当天零时零分零秒的时间戳</td></tr><tr><td>cachePath</td><td>内存缓存对应的 mmap 文件所在的目录</td></tr><tr><td>maxFile</td><td>当日志文件超过此大小时，就不能再继续往 buffer 里写入日志</td></tr><tr><td>day</td><td>只保留 n 天内的日志文件，旧的都删掉</td></tr><tr><td>minSDCard</td><td>当可用的存储容量超过此阈值时才写入日志</td></tr><tr><td>encryptKey16</td><td>AES 加密参数 KEY</td></tr><tr><td>encryptIv16</td><td>AES 加密参数 IV</td></tr></tbody></table><h3 id="日志队列与-生产者-消费者-模型"><a href="#日志队列与-生产者-消费者-模型" class="headerlink" title="日志队列与 生产者-消费者 模型"></a>日志队列与 生产者-消费者 模型</h3><p>调用 <code>Logan.w</code> 的线程是日志的生产者，日志写入请求被放入日志队列（<code>Queue</code>）里等待处理，<code>LoganThread</code> 线程作为消费者不断地执行日志队列里的任务</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logan</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> log  表示日志内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 表示日志类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@brief</span> Logan写入日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">w</span><span class="hljs-params">(String log, <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sLoganControlCenter == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Please initialize Logan first&quot;</span>);<br>        &#125;<br>        sLoganControlCenter.write(log, type);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganControlCenter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;LoganModel&gt; mCacheLogQueue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LoganThread mLoganThread;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String log, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(log)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LoganModel model = <span class="hljs-keyword">new</span> LoganModel();<br>        model.action = LoganModel.Action.WRITE;<br>        WriteAction action = <span class="hljs-keyword">new</span> WriteAction();<br>        String threadName = Thread.currentThread().getName();<br>        <span class="hljs-keyword">long</span> threadLog = Thread.currentThread().getId();<br>        <span class="hljs-keyword">boolean</span> isMain = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;<br>            isMain = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        action.log = log;<br>        action.localTime = System.currentTimeMillis();<br>        action.flag = flag;<br>        action.isMainThread = isMain;<br>        action.threadId = threadLog;<br>        action.threadName = threadName;<br>        model.writeAction = action;<br>        <span class="hljs-keyword">if</span> (mCacheLogQueue.size() &lt; mMaxQueue) &#123;<br>            mCacheLogQueue.add(model);<br>            <span class="hljs-keyword">if</span> (mLoganThread != <span class="hljs-keyword">null</span>) &#123;<br>                mLoganThread.notifyRun();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mLoganThread == <span class="hljs-keyword">null</span>) &#123;<br>            mLoganThread = <span class="hljs-keyword">new</span> LoganThread(mCacheLogQueue, mCachePath, mPath, mSaveTime,<br>                    mMaxLogFile, mMinSDCard, mEncryptKey16, mEncryptIv16);<br>            mLoganThread.setName(<span class="hljs-string">&quot;logan-thread&quot;</span>);<br>            mLoganThread.start();<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.run();<br>        <span class="hljs-keyword">while</span> (mIsRun) &#123;<br>            <span class="hljs-keyword">synchronized</span> (sync) &#123;<br>                mIsWorking = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    LoganModel model = mCacheLogQueue.poll();<br>                    <span class="hljs-keyword">if</span> (model == <span class="hljs-keyword">null</span>) &#123;<br>                        mIsWorking = <span class="hljs-keyword">false</span>;<br>                        sync.wait();<br>                        mIsWorking = <span class="hljs-keyword">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        action(model);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    mIsWorking = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="内存缓存-Buffer"><a href="#内存缓存-Buffer" class="headerlink" title="内存缓存 Buffer"></a>内存缓存 Buffer</h3><p>并不是每次日志请求都立刻写入到日志文件里，而是在内存中开辟一段缓存（默认为 150K）作为 buffer，当 buffer 里的数据积累得足够多时（1/3 buffer 大小）才写入文件</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">LoganThread.doWriteLog2File<br>LoganProtocol.logan_write<br>CLoganProtocol.logan_write<br>CLoganProtocol.<span class="hljs-function">clogan_write</span><br><span class="hljs-function">Java_com_dianping_logan_CLoganProtocol_clogan_1write</span><br><span class="hljs-function">clogan_write</span><br><span class="hljs-function">clogan_write_section</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clogan_write2</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != logan_model &amp;&amp; logan_model-&gt;is_ok) &#123;<br>        <span class="hljs-built_in">clogan_zlib_compress</span>(logan_model, data, length);    <span class="hljs-comment">// 压缩和加密后的数据放在内存 buffer 里</span><br>        <span class="hljs-built_in">update_length_clogan</span>(logan_model);<br>        <span class="hljs-keyword">int</span> is_gzip_end = <span class="hljs-number">0</span>;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_type == LOGAN_MMAP_MMAP &amp;&amp;<br>                   logan_model-&gt;total_len &gt;=<br>                   buffer_length / LOGAN_WRITEPROTOCOL_DEVIDE_VALUE) &#123;  <span class="hljs-comment">// 只有当数据大小到达阈值（1/3 buffer 容量）时才写入文件</span><br>            isWrite = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;clogan_write2 &gt; write type MMAP \n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isWrite) &#123;  <span class="hljs-comment">// 写入文件</span><br>            <span class="hljs-built_in">write_flush_clogan</span>();<br>        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>当 APP 因为崩溃而被 kill 或者被其他进程 kill 时，保存在内存中的日志缓存就会失去回写文件的机会，从而导致日志的丢失</p><p>使用 <code>mmap</code> 可以在虚拟内存中开辟一片内存空间作为 buffer，它对应了一个 file backed，系统会选择合适的机会将 buffer 回写至文件，而且在进程被 kill 时系统可以确保 buffer 被正确地回写，确保进程异常时不会丢失日志</p><p>mmap file 位于 <code>&#123;cacheDir&#125;/logan_cache/logan.mmap2</code>，buffer 和 mmap file 的大小默认为 150K</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LOGAN_MMAP_LENGTH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGAN_MMAP_LENGTH 150 * 1024 <span class="hljs-comment">//150k</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// 创建MMAP缓存buffer或者内存buffer</span><br><span class="hljs-comment">// _filepath: mmap file 地址</span><br><span class="hljs-comment">// buffer: mmap buffer</span><br><span class="hljs-comment">// cache: 如果 mmap 失败则使用内存缓存</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_mmap_file_clogan</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *_filepath, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> **buffer, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> **cache)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> back = LOGAN_MMAP_FAIL;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == _filepath || <span class="hljs-number">0</span> == <span class="hljs-built_in">strnlen</span>(_filepath, <span class="hljs-number">128</span>)) &#123;<br>        back = LOGAN_MMAP_MEMORY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *p_map = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">int</span> size = LOGAN_MMAP_LENGTH;<br>        <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(_filepath, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP); <span class="hljs-comment">//后两个添加权限</span><br>        <span class="hljs-keyword">int</span> isNeedCheck = <span class="hljs-number">0</span>; <span class="hljs-comment">//是否需要检查mmap缓存文件重新检查</span><br>        <span class="hljs-keyword">if</span> (fd != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//保护</span><br>            <span class="hljs-keyword">int</span> isFileOk = <span class="hljs-number">0</span>;<br>            FILE *file = <span class="hljs-built_in">fopen</span>(_filepath, <span class="hljs-string">&quot;rb+&quot;</span>); <span class="hljs-comment">//先判断文件是否有值，再mmap内存映射</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != file) &#123;<br>                <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_END);<br>                <span class="hljs-keyword">long</span> longBytes = <span class="hljs-built_in">ftell</span>(file);<br>                <span class="hljs-keyword">if</span> (longBytes &lt; LOGAN_MMAP_LENGTH) &#123;<br>                    <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_SET);<br>                    <span class="hljs-keyword">char</span> zero_data[size];<br>                    <span class="hljs-built_in">memset</span>(zero_data, <span class="hljs-number">0</span>, size);<br>                    <span class="hljs-keyword">size_t</span> _size = <span class="hljs-number">0</span>;<br>                    _size = <span class="hljs-built_in">fwrite</span>(zero_data, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>), size, file);<br>                    <span class="hljs-built_in">fflush</span>(file);<br>                    <span class="hljs-keyword">if</span> (_size == size) &#123;<br>                        <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;copy data 2 mmap file success\n&quot;</span>);<br>                        isFileOk = <span class="hljs-number">1</span>;<br>                        isNeedCheck = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        isFileOk = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    isFileOk = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-built_in">fclose</span>(file);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                isFileOk = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isNeedCheck) &#123; <span class="hljs-comment">//加强保护，对映射的文件要有一个适合长度的文件</span><br>                FILE *file = <span class="hljs-built_in">fopen</span>(_filepath, <span class="hljs-string">&quot;rb&quot;</span>);<br>                <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">NULL</span>) &#123;<br>                    <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_END);<br>                    <span class="hljs-keyword">long</span> longBytes = <span class="hljs-built_in">ftell</span>(file);<br>                    <span class="hljs-keyword">if</span> (longBytes &gt;= LOGAN_MMAP_LENGTH) &#123;<br>                        isFileOk = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        isFileOk = <span class="hljs-number">0</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">fclose</span>(file);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    isFileOk = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isFileOk) &#123;<br>                p_map = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) <span class="hljs-built_in">mmap</span>(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p_map != MAP_FAILED &amp;&amp; <span class="hljs-literal">NULL</span> != p_map &amp;&amp; isFileOk) &#123;<br>                back = LOGAN_MMAP_MMAP;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                back = LOGAN_MMAP_MEMORY;<br>                <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;open mmap fail , reason : %s \n&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br><br>            &#125;<br>            <span class="hljs-built_in">close</span>(fd);<br><br>            <span class="hljs-keyword">if</span> (back == LOGAN_MMAP_MMAP &amp;&amp;<br>                <span class="hljs-built_in">access</span>(_filepath, F_OK) != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//在返回mmap前,做最后一道判断，如果有mmap文件才用mmap</span><br>                back = LOGAN_MMAP_MMAP;<br>                *buffer = p_map;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                back = LOGAN_MMAP_MEMORY;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != p_map)<br>                    <span class="hljs-built_in">munmap</span>(p_map, size);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;open(%s) fail: %s\n&quot;</span>, _filepath, <span class="hljs-built_in">strerror</span>(errno));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> size = LOGAN_MEMORY_LENGTH;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *tempData = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != tempData) &#123;<br>        <span class="hljs-built_in">memset</span>(tempData, <span class="hljs-number">0</span>, size);<br>        *cache = tempData;<br>        <span class="hljs-keyword">if</span> (back != LOGAN_MMAP_MMAP) &#123;<br>            *buffer = tempData;<br>            back = LOGAN_MMAP_MEMORY; <span class="hljs-comment">//如果文件打开失败、如果mmap映射失败，走内存缓存</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (back != LOGAN_MMAP_MMAP)<br>            back = LOGAN_MMAP_FAIL;<br>    &#125;<br>    <span class="hljs-keyword">return</span> back;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="flush-回写日志文件"><a href="#flush-回写日志文件" class="headerlink" title="flush 回写日志文件"></a>flush 回写日志文件</h3><p>因为有 buffer 的存在，<code>Logan.w(log, type)</code> 先将日志写入内存缓存，只有当缓存超过阈值（50K）时才回写文件系统，<code>Logan.f()</code> 使 buffer 立刻回写至文件系统</p><p>使用 <code>fopen</code>、<code>fseek</code>、<code>ftell</code>、<code>fwrite</code>、<code>fflush</code>、<code>fclose</code> 等高级 IO API，它们是具有缓存的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Logan.<span class="hljs-built_in">f</span>()<br>LoganControlCenter.<span class="hljs-built_in">flush</span>()<br>LoganThread.<span class="hljs-built_in">doFlushLog2File</span>()<br>LoganProtocol.<span class="hljs-built_in">logan_flush</span>()<br>CLoganProtocol.<span class="hljs-built_in">logan_flush</span>()<br>CLoganProtocol.<span class="hljs-built_in">clogan_flush</span>()<br><span class="hljs-function">Java_com_dianping_logan_CLoganProtocol_clogan_1flush</span><br><span class="hljs-function">clogan_flush</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_flush_clogan</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (logan_model-&gt;zlib_type == LOGAN_ZLIB_ING) &#123;<br>        <span class="hljs-built_in">clogan_zlib_end_compress</span>(logan_model);<br>        <span class="hljs-built_in">update_length_clogan</span>(logan_model);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logan_model-&gt;total_len &gt; LOGAN_WRITEPROTOCOL_HEAER_LENGTH) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *point = logan_model-&gt;total_point;<br>        point += LOGAN_MMAP_TOTALLEN;<br>        <span class="hljs-built_in">write_dest_clogan</span>(point, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>), logan_model-&gt;total_len, logan_model);<br>        <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;write_flush_clogan &gt; logan total len : %d \n&quot;</span>, logan_model-&gt;total_len);<br>        <span class="hljs-built_in">clear_clogan</span>(logan_model);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//文件写入磁盘、更新文件大小</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write_dest_clogan</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *point, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> length, cLogan_model *loganModel)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_file_exist_clogan</span>(loganModel-&gt;file_path)) &#123; <span class="hljs-comment">//如果文件被删除,再创建一个文件</span><br>        <span class="hljs-keyword">if</span> (logan_model-&gt;file_stream_type == LOGAN_FILE_OPEN) &#123;<br>            <span class="hljs-built_in">fclose</span>(logan_model-&gt;file);<br>            logan_model-&gt;file_stream_type = LOGAN_FILE_CLOSE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != _dir_path) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_file_exist_clogan</span>(_dir_path)) &#123;<br>                <span class="hljs-built_in">makedir_clogan</span>(_dir_path);<br>            &#125;<br>            <span class="hljs-built_in">init_file_clogan</span>(logan_model);<br>            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;clogan_write &gt; create log file , restore open file stream \n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (CLOGAN_EMPTY_FILE == loganModel-&gt;file_len) &#123; <span class="hljs-comment">//如果是空文件插入一行CLogan的头文件</span><br>        <span class="hljs-built_in">insert_header_file_clogan</span>(loganModel);<br>    &#125;<br>    <span class="hljs-built_in">fwrite</span>(point, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">char</span>), logan_model-&gt;total_len, logan_model-&gt;file);<span class="hljs-comment">//写入到文件中</span><br>    <span class="hljs-built_in">fflush</span>(logan_model-&gt;file);<br>    loganModel-&gt;file_len += loganModel-&gt;total_len; <span class="hljs-comment">//修改文件大小</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>日志文件保存在目录 <code>LoganConfig.Builder.setPath(path)</code>，日志按日期存储，文件名是日期当天零时零分零秒的 <code>时间戳</code></p><p><img src="../../../../image/2021-06-28-logan/files.png" alt="files.png"></p><p>日志经过 gzip 压缩和 AES 加密，其格式是 JSON，每个日志文件的第一条总是 <code>clogan header</code></p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;c&quot;</span>:<span class="hljs-string">&quot;clogan header&quot;</span>,    <span class="hljs-comment">// 日志内容</span><br>    <span class="hljs-attr">&quot;f&quot;</span>:<span class="hljs-number">1</span>,                  <span class="hljs-comment">// flag，Logan.w(log, type) 中的 type 传入</span><br>    <span class="hljs-attr">&quot;l&quot;</span>:<span class="hljs-string">&quot;init&quot;</span>,             <span class="hljs-comment">// local time，本地时间</span><br>    <span class="hljs-attr">&quot;n&quot;</span>:<span class="hljs-string">&quot;clogan&quot;</span>,           <span class="hljs-comment">// thread name，线程名称</span><br>    <span class="hljs-attr">&quot;i&quot;</span>:<span class="hljs-number">1</span>,                  <span class="hljs-comment">// thread id，线程 ID</span><br>    <span class="hljs-attr">&quot;m&quot;</span>:<span class="hljs-literal">true</span>                <span class="hljs-comment">// main thread，是否主线程</span><br>&#125;<br>&#123;<br>    <span class="hljs-attr">&quot;c&quot;</span>:<span class="hljs-string">&quot;I/Fridge-okhttp.OkHttpClient：[ (AndroidLog.kt:84)#androidLog$okhttp ] [ (AndroidLog.kt:39)#publish ] domain: video&quot;</span>,<br>    <span class="hljs-attr">&quot;f&quot;</span>:<span class="hljs-number">4</span>,<br>    <span class="hljs-attr">&quot;l&quot;</span>:<span class="hljs-string">&quot;2021-09-07 00:00:00.000&quot;</span>,<br>    <span class="hljs-attr">&quot;n&quot;</span>:<span class="hljs-string">&quot;RxCachedThreadScheduler-15&quot;</span>,<br>    <span class="hljs-attr">&quot;i&quot;</span>:<span class="hljs-number">174</span>,<br>    <span class="hljs-attr">&quot;m&quot;</span>:<span class="hljs-literal">false</span><br>&#125;<br>&#123;<br>    <span class="hljs-attr">&quot;c&quot;</span>:<span class="hljs-string">&quot;I/Fridge-okhttp.OkHttpClient：[ (AndroidLog.kt:84)#androidLog$okhttp ] [ (AndroidLog.kt:39)#publish ] Authorization_v1: U5xQjeKDh4Dkgx4Z&quot;</span>,<br>    <span class="hljs-attr">&quot;f&quot;</span>:<span class="hljs-number">4</span>,<br>    <span class="hljs-attr">&quot;l&quot;</span>:<span class="hljs-string">&quot;2021-09-07 00:00:00.001&quot;</span>,<br>    <span class="hljs-attr">&quot;n&quot;</span>:<span class="hljs-string">&quot;RxCachedThreadScheduler-15&quot;</span>,<br>    <span class="hljs-attr">&quot;i&quot;</span>:<span class="hljs-number">174</span>,<br>    <span class="hljs-attr">&quot;m&quot;</span>:<span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每次写日志时，都会判断下当前日期是否与日志文件的日期一致；如果不一致说明跨天了，创建当天的日志文件，并删除 <code>LoganConfig.Builder.setDay(long)</code> 前的日志文件</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWriteLog2File</span><span class="hljs-params">(WriteAction action)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Logan.sDebug) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;Logan write start&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mFileDirectory == <span class="hljs-keyword">null</span>) &#123;<br>            mFileDirectory = <span class="hljs-keyword">new</span> File(mPath);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!isDay()) &#123;<br>            <span class="hljs-keyword">long</span> tempCurrentDay = Util.getCurrentTime();<br>            <span class="hljs-comment">//save时间</span><br>            <span class="hljs-keyword">long</span> deleteTime = tempCurrentDay - mSaveTime;<br>            deleteExpiredFile(deleteTime);<br>            mCurrentDay = tempCurrentDay;<br>            mLoganProtocol.logan_open(String.valueOf(mCurrentDay));<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis(); <span class="hljs-comment">//每隔1分钟判断一次</span><br>        <span class="hljs-keyword">if</span> (currentTime - mLastTime &gt; MINUTE) &#123;<br>            mIsSDCard = isCanWriteSDCard();<br>        &#125;<br>        mLastTime = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">if</span> (!mIsSDCard) &#123; <span class="hljs-comment">//如果大于50M 不让再次写入</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mLoganProtocol.logan_write(action.flag, action.log, action.localTime, action.threadName,<br>                action.threadId, action.isMainThread);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="写入失败"><a href="#写入失败" class="headerlink" title="写入失败"></a>写入失败</h3><p>有以下原因会导致日志写入失败：</p><ol><li>日志内容为空</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganControlCenter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String log, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(log)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>任务队列满了</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganControlCenter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> mMaxQueue;     <span class="hljs-comment">// 最大队列数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LoganControlCenter</span><span class="hljs-params">(LoganConfig config)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!config.isValid()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;config&#x27;s param is invalid&quot;</span>);<br>        &#125;<br>        mPath = config.mPathPath;<br>        mCachePath = config.mCachePath;<br>        mSaveTime = config.mDay;<br>        mMinSDCard = config.mMinSDCard;<br>        mMaxLogFile = config.mMaxFile;<br>        mMaxQueue = config.mMaxQueue;<br>        mEncryptKey16 = <span class="hljs-keyword">new</span> String(config.mEncryptKey16);<br>        mEncryptIv16 = <span class="hljs-keyword">new</span> String(config.mEncryptIv16);<br>        init();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String log, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">if</span> (mCacheLogQueue.size() &lt; mMaxQueue) &#123;<br>            mCacheLogQueue.add(model);<br>            <span class="hljs-keyword">if</span> (mLoganThread != <span class="hljs-keyword">null</span>) &#123;<br>                mLoganThread.notifyRun();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_QUEUE = <span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">long</span> mMaxQueue = DEFAULT_QUEUE;     <span class="hljs-comment">// 没有公开 getter/setter</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="3"><li>存储设备容量不足（默认至少 50M）</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> mMinSDCard;<br><br>    LoganThread(<br>            ConcurrentLinkedQueue&lt;LoganModel&gt; cacheLogQueue, String cachePath,<br>            String path, <span class="hljs-keyword">long</span> saveTime, <span class="hljs-keyword">long</span> maxLogFile, <span class="hljs-keyword">long</span> minSDCard, String encryptKey16,<br>            String encryptIv16) &#123;<br>        mCacheLogQueue = cacheLogQueue;<br>        mCachePath = cachePath;<br>        mPath = path;<br>        mSaveTime = saveTime;<br>        mMaxLogFile = maxLogFile;<br>        mMinSDCard = minSDCard;<br>        mEncryptKey16 = encryptKey16;<br>        mEncryptIv16 = encryptIv16;<br>    &#125;    <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWriteLog2File</span><span class="hljs-params">(WriteAction action)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis(); <span class="hljs-comment">//每隔1分钟判断一次</span><br>        <span class="hljs-keyword">if</span> (currentTime - mLastTime &gt; MINUTE) &#123;<br>            mIsSDCard = isCanWriteSDCard();<br>        &#125;<br>        mLastTime = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">if</span> (!mIsSDCard) &#123; <span class="hljs-comment">//如果大于50M 不让再次写入</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mLoganProtocol.logan_write(action.flag, action.log, action.localTime, action.threadName,<br>                action.threadId, action.isMainThread);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCanWriteSDCard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> item = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            StatFs stat = <span class="hljs-keyword">new</span> StatFs(mPath);<br>            <span class="hljs-keyword">long</span> blockSize = stat.getBlockSize();<br>            <span class="hljs-keyword">long</span> availableBlocks = stat.getAvailableBlocks();<br>            <span class="hljs-keyword">long</span> total = availableBlocks * blockSize;<br>            <span class="hljs-keyword">if</span> (total &gt; mMinSDCard) &#123; <span class="hljs-comment">//判断SDK卡</span><br>                item = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> M = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;                  <span class="hljs-comment">// M</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DEFAULT_MIN_SDCARD_SIZE = <span class="hljs-number">50</span> * M; <span class="hljs-comment">// 最小的 SD 卡小于这个大小不写入</span><br><br>    <span class="hljs-keyword">long</span> mMinSDCard = DEFAULT_MIN_SDCARD_SIZE;                  <span class="hljs-comment">// 最小 sd 卡大小，通过 LoganConfig.Builder#setMinSDCard 配置</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="4"><li>日志文件大小超过限制</li></ol><p>默认 10M，<code>LoganConfig</code> 未公开 setter</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoganConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> M = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">//M</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DEFAULT_FILE_SIZE = <span class="hljs-number">10</span> * M;<br><br>    <span class="hljs-keyword">long</span> mMaxFile = DEFAULT_FILE_SIZE; <span class="hljs-comment">// 删除文件最大值（实际并不会删除，只是不再写入）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGAN_LOGFILE_MAXLENGTH 10 * 1024 * 1024</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> max_file_len = LOGAN_LOGFILE_MAXLENGTH;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">clogan_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">char</span> *log, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> local_time, <span class="hljs-keyword">char</span> *thread_name, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> thread_id,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-keyword">int</span> is_main)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_file_exist_clogan</span>(logan_model-&gt;file_path)) &#123;<br>        <span class="hljs-keyword">if</span> (logan_model-&gt;file_len &gt; max_file_len) &#123;<br>            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;clogan_write &gt; beyond max file , cant write log\n&quot;</span>);<br>            back = CLOAGN_WRITE_FAIL_MAXFILE;<br>            <span class="hljs-keyword">return</span> back;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="公司内部日志库-VLog"><a href="#公司内部日志库-VLog" class="headerlink" title="公司内部日志库 VLog"></a>公司内部日志库 VLog</h3><p>VLog 使用 Logan 来持久化 <code>Android.util.Log</code> 的日志输出，以便下发指令远程抓取用户日志，通过 gradle plugin Transform 和 ASM 将 <code>Log.XXX</code> 替换为 <code>VLog.XXX</code>，从而达到透明重定向日志输出的目的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogHandleTransform</span>(<span class="hljs-title">project</span>: <span class="hljs-title">Project</span>, <span class="hljs-title">ext</span>: <span class="hljs-title">LogExtension</span>?) : <span class="hljs-title">Transform</span>() </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> classProcessor: ClassProcessor = ClassProcessor()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> logExtension: LogExtension? = <span class="hljs-function">ext</span><br><span class="hljs-function"></span><br><span class="hljs-function">    override fun <span class="hljs-title">getName</span><span class="hljs-params">()</span>: String </span>&#123;<br>        <span class="hljs-keyword">return</span> NAME<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span>: MutableSet&lt;QualifiedContent.ContentType&gt; </span>&#123;<br>        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">getScopes</span><span class="hljs-params">()</span>: MutableSet&lt;in QualifiedContent.Scope&gt; </span>&#123;<br>        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span>: Boolean </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * NOTCHANGED: 当前文件不需处理，甚至复制操作都不用</span><br><span class="hljs-comment">     * ADDED、CHANGED: 正常处理，输出给下一个任务</span><br><span class="hljs-comment">     * REMOVED: 移除outputProvider获取路径对应的文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">override fun <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: TransformInvocation)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.transform(transformInvocation)<br>        val inputs = transformInvocation.inputs<br>        val outputProvider = transformInvocation.outputProvider<br>        val isIncremental = transformInvocation.isIncremental<br>        <span class="hljs-comment">//如果非增量，则清空旧的输出内容</span><br>        <span class="hljs-keyword">if</span> (!isIncremental) &#123;<br>            outputProvider.deleteAll()<br>        &#125;<br>        Logger.w(<span class="hljs-string">&quot;isIncremental: $isIncremental&quot;</span>)<br>        inputs.stream().forEach &#123; transformInput: TransformInput -&gt;<br>            <span class="hljs-comment">//jar</span><br>            transformInput.jarInputs.stream().forEach &#123; jarInput: JarInput -&gt;<br>                val status = jarInput.status<br>                val src: File = jarInput.file<br>                <span class="hljs-keyword">var</span> destName = src.<span class="hljs-function">name</span><br><span class="hljs-function">                <span class="hljs-title">if</span> <span class="hljs-params">(destName.endsWith(<span class="hljs-string">&quot;.jar&quot;</span>)</span>) </span>&#123;<br>                    destName = destName.substring(<span class="hljs-number">0</span>, destName.length - <span class="hljs-number">4</span>);<br>                &#125;<br>                val hexName = DigestUtils.md5Hex(src.absolutePath)<br>                val dest: File =<br>                    transformInvocation.outputProvider.getContentLocation(<br>                        <span class="hljs-comment">//destName + &quot;_&quot; + hexName,</span><br>                        jarInput.name,<br>                        jarInput.contentTypes,<br>                        jarInput.scopes,<br>                        Format.JAR<br>                    )<br>                Logger.w(<span class="hljs-string">&quot;jar origin path: $&#123;src.absolutePath&#125;, jar output path: $&#123;dest.absolutePath&#125;, jar status $&#123;status.name&#125;&quot;</span>)<br>                <span class="hljs-keyword">if</span> (status == <span class="hljs-keyword">null</span> || !isIncremental) &#123;<br>                    processJar(src, dest)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    when (status) &#123;<br>                        Status.NOTCHANGED -&gt; &#123;<br>                            <span class="hljs-comment">//nothing</span><br>                        &#125;<br>                        Status.ADDED, Status.CHANGED -&gt; &#123;<br>                            processJar(jarInput.file, dest)<br>                        &#125;<br>                        Status.REMOVED -&gt; <span class="hljs-keyword">if</span> (dest.exists()) &#123;<br>                            <span class="hljs-comment">//delete dest</span><br>                            FileUtils.forceDelete(dest)<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//dir</span><br>            transformInput.directoryInputs.stream().forEach &#123; directoryInput: DirectoryInput -&gt;<br>                val src: File = directoryInput.file<br>                val dest: File =<br>                    transformInvocation.outputProvider.getContentLocation(<br>                        directoryInput.name,<br>                        directoryInput.contentTypes,<br>                        directoryInput.scopes,<br>                        Format.DIRECTORY<br>                    )<br>                Logger.w(<span class="hljs-string">&quot;dir origin path: $&#123;src.absolutePath&#125;, dir output path: $&#123;dest.absolutePath&#125;&quot;</span>)<br>                <span class="hljs-keyword">if</span> (isIncremental) &#123;<br>                    val srcDirPath = src.absolutePath<br>                    val destDirPath = dest.absolutePath<br>                    val fileStatusMap = directoryInput.changedFiles<br>                    <span class="hljs-comment">//Logger.w(&quot;dir change file: $fileStatusMap&quot;)</span><br>                    <span class="hljs-keyword">for</span> ((inputFile: File, status: Status) in fileStatusMap) &#123;<br>                        val destFilePath: String =<br>                            inputFile.absolutePath.replace(srcDirPath, destDirPath)<br>                        <span class="hljs-comment">//Logger.w(&quot;incremental dir handle origin file: $&#123;inputFile.absolutePath&#125;, dir output path: $destFilePath&quot;)</span><br>                        val destFile = File(destFilePath)<br>                        when (status) &#123;<br>                            Status.NOTCHANGED -&gt; &#123;<br>                                <span class="hljs-comment">//nothing</span><br>                            &#125;<br>                            Status.REMOVED -&gt; <span class="hljs-keyword">if</span> (destFile.exists()) &#123;<br>                                <span class="hljs-comment">//delete dest</span><br>                                FileUtils.forceDelete(destFile)<br>                            &#125;<br>                            Status.ADDED, Status.CHANGED -&gt; &#123;<br>                                FileUtils.touch(destFile)<br>                                <span class="hljs-comment">//例如/intermediates/transforms/ASMPLUGIN/debug/235/META-INF</span><br>                                <span class="hljs-keyword">if</span> (inputFile.isDirectory) &#123;<br>                                    handleDirectoryInput(<br>                                        inputFile,<br>                                        dest,<br>                                        src.absolutePath<br>                                    )<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-keyword">if</span> (inputFile.name.endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;<br>                                        processClassFile(inputFile, destFile)<br>                                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                                        FileUtils.copyFile(inputFile, destFile)<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    handleDirectoryInput(src, dest, src.absolutePath)<br>                &#125;<br>                <span class="hljs-comment">//直接复制</span><br>                <span class="hljs-comment">//FileUtils.copyDirectory(directoryInput.file, dest)</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> fun <span class="hljs-title">handleDirectoryInput</span><span class="hljs-params">(file: File, targetDirFile: File, relativePath: String)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (file.isDirectory) &#123;<br>            <span class="hljs-keyword">for</span> (f in file.listFiles()) &#123;<br>                handleDirectoryInput(f, targetDirFile, relativePath)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            val targetPath: String =<br>                file.absolutePath.replace(relativePath, targetDirFile.absolutePath)<br>            val targetFile = File(targetPath)<br>            <span class="hljs-comment">//Logger.w(&quot;handleDirectoryInput targetDir: $&#123;targetDirFile.absolutePath&#125;, origin file: $&#123;file.absolutePath&#125;, output file: $targetPath&quot;)</span><br>            <span class="hljs-keyword">if</span> (file.name.endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;<br>                processClassFile(file, targetFile)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                val destFile = File(targetPath)<br>                FileUtils.copyFile(file, destFile)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> fun <span class="hljs-title">processClassFile</span><span class="hljs-params">(src: File, targetFile: File)</span> </span>&#123;<br>        <span class="hljs-keyword">var</span> bytes: ByteArray? = <span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            bytes = classProcessor.process(FileUtils.readFileToByteArray(src))<br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!targetFile.parentFile.exists()) &#123;<br>            targetFile.parentFile.mkdirs()<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileUtils.writeByteArrayToFile(targetFile, bytes)<br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> fun <span class="hljs-title">processJar</span><span class="hljs-params">(zipFile: File, destFile: File)</span> </span>&#123;<br>        val zos = ZipOutputStream(FileOutputStream(destFile))<br>        val zis = JarFile(zipFile)<br>        val enumeration: Enumeration&lt;JarEntry&gt; = zis.entries()<br>        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements()) &#123;<br>            val jarEntry: JarEntry = enumeration.nextElement() as JarEntry<br>            val entryName: String = jarEntry.name<br>            <span class="hljs-comment">//Logger.w(&quot;jar content name: $entryName&quot;)</span><br>            <span class="hljs-keyword">if</span> (jarEntry.isDirectory) <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment">//为新的jar创建zipEntry</span><br>            val zipEntry = ZipEntry(entryName)<br>            zos.putNextEntry(zipEntry)<br>            val inputStream: InputStream = zis.getInputStream(jarEntry)<br>            <span class="hljs-comment">//inputStream to byte，我看bytex也是用的这个</span><br>            val src: ByteArray = ByteStreams.toByteArray(inputStream)<br>            <span class="hljs-comment">//com/viomi/vlog此包下面的类不处理，Logan库里面的Log也不处理</span><br>            <span class="hljs-keyword">if</span> (needHandle(entryName)) &#123;<br>                val bytes: ByteArray = classProcessor.process(src)<br>                zos.write(bytes)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                zos.write(src)<br>            &#125;<br>            zos.closeEntry()<br>            inputStream.close()<br>        &#125;<br>        zis.close()<br>        zos.close()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> fun <span class="hljs-title">needHandle</span><span class="hljs-params">(entryName: String)</span>: Boolean </span>&#123;<br>        <span class="hljs-keyword">if</span> (!entryName.endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (entryName.contains(LOG_LIB_PKG) || entryName.contains(LOGAN_LIB_PKG)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span><br>        &#125;<br>        <span class="hljs-keyword">var</span> handle = <span class="hljs-keyword">true</span><br>        logExtension?.let &#123;<br>            <span class="hljs-keyword">for</span> (name in logExtension!!.whiteList) &#123;<br>                <span class="hljs-keyword">if</span> (entryName.contains(LogExtension.transform(name))) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> handle<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassProcessor</span> </span>&#123;<br>    <span class="hljs-function">fun <span class="hljs-title">process</span><span class="hljs-params">(src: ByteArray)</span>: ByteArray </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            val classReader = ClassReader(src)<br>            val cw = ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)<br>            val monitorClassVisitor = LogClassVisitor(ASM_API, cw)<br>            classReader.accept(monitorClassVisitor, ClassReader.EXPAND_FRAMES)<br>            <span class="hljs-keyword">return</span> cw.toByteArray()<br>        &#125; <span class="hljs-keyword">catch</span> (e: MethodCallOptException) &#123;<br>            <span class="hljs-keyword">return</span> src<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogClassVisitor</span>(<span class="hljs-title">api</span>: <span class="hljs-title">Int</span>, <span class="hljs-title">cv</span>: <span class="hljs-title">ClassVisitor</span>) : <span class="hljs-title">ClassVisitor</span>(<span class="hljs-title">api</span>, <span class="hljs-title">cv</span>) </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> className: String? = <span class="hljs-function"><span class="hljs-keyword">null</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    override fun <span class="hljs-title">visit</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        version: Int,</span></span><br><span class="hljs-params"><span class="hljs-function">        access: Int,</span></span><br><span class="hljs-params"><span class="hljs-function">        name: String?,</span></span><br><span class="hljs-params"><span class="hljs-function">        signature: String?,</span></span><br><span class="hljs-params"><span class="hljs-function">        superName: String?,</span></span><br><span class="hljs-params"><span class="hljs-function">        interfaces: Array&lt;out String&gt;?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.visit(version, access, name, signature, superName, interfaces)<br>        className = name<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">visitMethod</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        access: Int,</span></span><br><span class="hljs-params"><span class="hljs-function">        name: String?,</span></span><br><span class="hljs-params"><span class="hljs-function">        desc: String?,</span></span><br><span class="hljs-params"><span class="hljs-function">        signature: String?,</span></span><br><span class="hljs-params"><span class="hljs-function">        exceptions: Array&lt;out String&gt;?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span>: MethodVisitor </span>&#123;<br>        val methodVisitor: MethodVisitor =<br>            <span class="hljs-keyword">super</span>.visitMethod(access, name, desc, signature, exceptions)<br>        <span class="hljs-keyword">return</span> MethodVisit(methodVisitor, className, ASM_API, access, name, desc)<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodVisit</span>(</span><br><span class="hljs-class">        <span class="hljs-title">methodVisitor</span>: <span class="hljs-title">MethodVisitor</span>,</span><br><span class="hljs-class">        <span class="hljs-title">className</span>: <span class="hljs-title">String</span>?,</span><br><span class="hljs-class">        <span class="hljs-title">api</span>: <span class="hljs-title">Int</span>,</span><br><span class="hljs-class">        <span class="hljs-title">access</span>: <span class="hljs-title">Int</span>,</span><br><span class="hljs-class">        <span class="hljs-title">name</span>: <span class="hljs-title">String</span>?,</span><br><span class="hljs-class">        <span class="hljs-title">desc</span>: <span class="hljs-title">String</span>?</span><br><span class="hljs-class">    ) : <span class="hljs-title">AdviceAdapter</span>(<span class="hljs-title">api</span>, <span class="hljs-title">methodVisitor</span>, <span class="hljs-title">access</span>, <span class="hljs-title">name</span>, <span class="hljs-title">desc</span>) </span>&#123;<br><br>        <span class="hljs-function">override fun <span class="hljs-title">visitMethodInsn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            opcode: Int,</span></span><br><span class="hljs-params"><span class="hljs-function">            owner: String,</span></span><br><span class="hljs-params"><span class="hljs-function">            name: String,</span></span><br><span class="hljs-params"><span class="hljs-function">            descriptor: String,</span></span><br><span class="hljs-params"><span class="hljs-function">            isInterface: Boolean</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span> </span>&#123;<br>            val ext: LogExt? = LogExt.needRep(owner, name, descriptor)<br>            <span class="hljs-keyword">if</span> (ext != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">super</span>.visitMethodInsn(opcode, LOG_LIB_CLASS, name, descriptor, isInterface)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">super</span>.visitMethodInsn(opcode, owner, name, descriptor, isInterface)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>如果需要在没有 server 的情况下解压/解密，可以使用 <a href="https://github.com/Meituan-Dianping/Logan/issues/351#issue-909155178">这个 Python 脚本</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>log</tag>
      
      <tag>logcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>崩溃日志收集库 xCrash 浅析</title>
    <link href="/2021/06/22/xcrash/"/>
    <url>/2021/06/22/xcrash/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/iqiyi/xCrash">xCrash</a> 是爱奇艺团队开源的一款崩溃日志收集库，可以收集 <strong>java crash</strong>、<strong>native crash</strong> 和 <strong>ANR</strong> 日志</p><p>日志格式为专用格式，内容还算丰富：<strong>机器信息</strong>、<strong>崩溃线程和其他线程的方法栈</strong>、<strong>logcat</strong>、<strong>打开的 fd</strong> 等等 …</p><h2 id="Java-Crash"><a href="#Java-Crash" class="headerlink" title="Java Crash"></a>Java Crash</h2><p>捕获 Java Crash 用的是 <code>DefaultUncaughtExceptionHandler</code>，相关的基础知识参考 <a href="../../../../2021/06/18/uncaught-exception-handler/">Uncaught Exception Handling</a></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaCrashHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UncaughtExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread thread, Throwable throwable)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (defaultHandler != <span class="hljs-keyword">null</span>) &#123;<br>            Thread.setDefaultUncaughtExceptionHandler(defaultHandler);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            handleException(thread, throwable);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler handleException failed&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 可以选择重新抛出给上一个 handler，或者杀死 app</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rethrow) &#123;<br>            <span class="hljs-keyword">if</span> (defaultHandler != <span class="hljs-keyword">null</span>) &#123;<br>                defaultHandler.uncaughtException(thread, throwable);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ActivityMonitor.getInstance().finishAllActivities();<br>            Process.killProcess(<span class="hljs-keyword">this</span>.pid);<br>            System.exit(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 收集各种各样的信息，写入到日志文件</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleException</span><span class="hljs-params">(Thread thread, Throwable throwable)</span> </span>&#123;<br>        Date crashTime = <span class="hljs-keyword">new</span> Date();<br><br>        <span class="hljs-comment">//notify the java crash</span><br>        NativeHandler.getInstance().notifyJavaCrashed();<br>        AnrHandler.getInstance().notifyJavaCrashed();<br><br>        <span class="hljs-comment">//create log file</span><br>        File logFile = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String logPath = String.format(Locale.US, <span class="hljs-string">&quot;%s/%s_%020d_%s__%s%s&quot;</span>, logDir, Util.logPrefix, startTime.getTime() * <span class="hljs-number">1000</span>, appVersion, processName, Util.javaLogSuffix);<br>            logFile = FileManager.getInstance().createLogFile(logPath);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler createLogFile failed&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">//get emergency</span><br>        String emergency = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            emergency = getEmergency(crashTime, thread, throwable);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler getEmergency failed&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">//write info to log file</span><br>        <span class="hljs-keyword">if</span> (logFile != <span class="hljs-keyword">null</span>) &#123;<br>            RandomAccessFile raf = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                raf = <span class="hljs-keyword">new</span> RandomAccessFile(logFile, <span class="hljs-string">&quot;rws&quot;</span>);<br><br>                <span class="hljs-comment">//write emergency info</span><br>                <span class="hljs-keyword">if</span> (emergency != <span class="hljs-keyword">null</span>) &#123;<br>                    raf.write(emergency.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125;<br><br>                <span class="hljs-comment">//If we wrote the emergency info successfully, we don&#x27;t need to return it from callback again.</span><br>                emergency = <span class="hljs-keyword">null</span>;<br><br>                <span class="hljs-comment">//write logcat</span><br>                <span class="hljs-keyword">if</span> (logcatMainLines &gt; <span class="hljs-number">0</span> || logcatSystemLines &gt; <span class="hljs-number">0</span> || logcatEventsLines &gt; <span class="hljs-number">0</span>) &#123;<br>                    raf.write(Util.getLogcat(logcatMainLines, logcatSystemLines, logcatEventsLines).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125;<br><br>                <span class="hljs-comment">//write fds</span><br>                <span class="hljs-keyword">if</span> (dumpFds) &#123;<br>                    raf.write(Util.getFds().getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125;<br><br>                <span class="hljs-comment">//write network info</span><br>                <span class="hljs-keyword">if</span> (dumpNetworkInfo) &#123;<br>                    raf.write(Util.getNetworkInfo().getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125;<br><br>                <span class="hljs-comment">//write memory info</span><br>                raf.write(Util.getMemoryInfo().getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>                <span class="hljs-comment">//write background / foreground</span><br>                raf.write((<span class="hljs-string">&quot;foreground:\n&quot;</span> + (ActivityMonitor.getInstance().isApplicationForeground() ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>) + <span class="hljs-string">&quot;\n\n&quot;</span>).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>                <span class="hljs-comment">//write other threads info</span><br>                <span class="hljs-keyword">if</span> (dumpAllThreads) &#123;<br>                    raf.write(getOtherThreadsInfo(thread).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler write log file failed&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (raf != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        raf.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//callback</span><br>        <span class="hljs-keyword">if</span> (callback != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                callback.onCrash(logFile == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : logFile.getAbsolutePath(), emergency);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br>    &#125;        <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getEmergency</span><span class="hljs-params">(Date crashTime, Thread thread, Throwable throwable)</span> </span>&#123;<br>    <span class="hljs-comment">//stack stace</span><br>    StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>    PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(sw);<br>    throwable.printStackTrace(pw);<br>    String stacktrace = sw.toString();<br>    <span class="hljs-keyword">return</span> Util.getLogHeader(startTime, crashTime, Util.javaCrashType, appId, appVersion)<br>            + <span class="hljs-string">&quot;pid: &quot;</span> + pid + <span class="hljs-string">&quot;, tid: &quot;</span> + Process.myTid() + <span class="hljs-string">&quot;, name: &quot;</span> + thread.getName() + <span class="hljs-string">&quot;  &gt;&gt;&gt; &quot;</span> + processName + <span class="hljs-string">&quot; &lt;&lt;&lt;\n&quot;</span><br>            + <span class="hljs-string">&quot;\n&quot;</span><br>            + <span class="hljs-string">&quot;java stacktrace:\n&quot;</span><br>            + stacktrace<br>            + <span class="hljs-string">&quot;\n&quot;</span><br>            + getBuildId(stacktrace);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">getLogHeader</span><span class="hljs-params">(Date startTime, Date crashTime, String crashType, String appId, String appVersion)</span> </span>&#123;<br>    DateFormat timeFormatter = <span class="hljs-keyword">new</span> SimpleDateFormat(Util.timeFormatterStr, Locale.US);<br>    <span class="hljs-keyword">return</span> Util.sepHead + <span class="hljs-string">&quot;\n&quot;</span><br>        + <span class="hljs-string">&quot;Tombstone maker: &#x27;&quot;</span> + Version.fullVersion + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Crash type: &#x27;&quot;</span> + crashType + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Start time: &#x27;&quot;</span> + timeFormatter.format(startTime) + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Crash time: &#x27;&quot;</span> + timeFormatter.format(crashTime) + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;App ID: &#x27;&quot;</span> + appId + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;App version: &#x27;&quot;</span> + appVersion + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Rooted: &#x27;&quot;</span> + (Util.isRoot() ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;API level: &#x27;&quot;</span> + Build.VERSION.SDK_INT + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;OS version: &#x27;&quot;</span> + Build.VERSION.RELEASE + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;ABI list: &#x27;&quot;</span> + Util.getAbiList() + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Manufacturer: &#x27;&quot;</span> + Build.MANUFACTURER + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Brand: &#x27;&quot;</span> + Build.BRAND + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Model: &#x27;&quot;</span> + Util.getMobileModel() + <span class="hljs-string">&quot;&#x27;\n&quot;</span><br>        + <span class="hljs-string">&quot;Build fingerprint: &#x27;&quot;</span> + Build.FINGERPRINT + <span class="hljs-string">&quot;&#x27;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getBuildId</span><span class="hljs-params">(String stktrace)</span> </span>&#123;<br>    String buildId = <span class="hljs-string">&quot;&quot;</span>;<br>    List&lt;String&gt; libPathList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">if</span> (stktrace.contains(<span class="hljs-string">&quot;UnsatisfiedLinkError&quot;</span>)) &#123;<br>        String libInfo = <span class="hljs-keyword">null</span>;<br>        String[] tempLibPathStr;<br>        tempLibPathStr = stktrace.split(<span class="hljs-string">&quot;\&quot;&quot;</span>); <span class="hljs-comment">// &quot; is the delimiter</span><br>        <span class="hljs-keyword">for</span> (String libPathStr :  tempLibPathStr) &#123;<br>            <span class="hljs-keyword">if</span> (libPathStr.isEmpty() || !libPathStr.endsWith(<span class="hljs-string">&quot;.so&quot;</span>)) <span class="hljs-keyword">continue</span>;<br>            libPathList.add(libPathStr);<br>            String libName = libPathStr.substring(libPathStr.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>);<br>            libPathList.add(XCrash.nativeLibDir + <span class="hljs-string">&quot;/&quot;</span> + libName);<br>            libPathList.add(<span class="hljs-string">&quot;/vendor/lib/&quot;</span> + libName);<br>            libPathList.add(<span class="hljs-string">&quot;/vendor/lib64/&quot;</span> + libName);<br>            libPathList.add(<span class="hljs-string">&quot;/system/lib/&quot;</span> + libName);<br>            libPathList.add(<span class="hljs-string">&quot;/system/lib64/&quot;</span> + libName);<br>            libInfo = getLibInfo(libPathList);<br>        &#125;<br>        buildId = <span class="hljs-string">&quot;build id:&quot;</span><br>                + <span class="hljs-string">&quot;\n&quot;</span><br>                + libInfo<br>                + <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buildId;<br>&#125;        <br></code></pre></div></td></tr></table></figure><p>输出的日志内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***<br>Tombstone maker: &#x27;xCrash 2.4.6&#x27;                                                                    // xCrash 把日志叫做 tombstone，这里指的是生成 tombstone 的 xCrash 的版本<br>Crash type: &#x27;java&#x27;                                                                                 // 指明 crash 类型，此日志包含的是 java crash（此外还有 native crash 和 ANR）<br>Start time: &#x27;2019-10-12T03:23:19.580+0800&#x27;                                                         // 初始化 xCrash 的时间，也就是调用 XCrash.init 的时间<br>Crash time: &#x27;2019-10-12T03:23:25.533+0800&#x27;                                                         // 发生崩溃的时间<br>App ID: &#x27;xcrash.sample&#x27;                                                                            // 发生崩溃的 APP 的包名<br>App version: &#x27;1.2.3-beta456-patch789&#x27;                                                              // APP version name<br>Rooted: &#x27;No&#x27;                                                                                       <br>API level: &#x27;29&#x27;<br>OS version: &#x27;10&#x27;<br>ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;<br>Manufacturer: &#x27;Google&#x27;<br>Brand: &#x27;google&#x27;<br>Model: &#x27;Pixel&#x27;<br>Build fingerprint: &#x27;google/sailfish/sailfish:10/QP1A.190711.020/5800535:user/release-keys&#x27;<br>pid: 21356, tid: 21356, name: main  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:                                                                                    // 崩溃线程的调用栈<br>java.lang.IllegalStateException: Could not execute method for android:onClick<br>at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:402)<br>at android.view.View.performClick(View.java:7140)<br>at android.view.View.performClickInternal(View.java:7117)<br>at android.view.View.access$3500(View.java:801)<br>at android.view.View$PerformClick.run(View.java:27351)<br>at android.os.Handler.handleCallback(Handler.java:883)<br>at android.os.Handler.dispatchMessage(Handler.java:100)<br>at android.os.Looper.loop(Looper.java:214)<br>at android.app.ActivityThread.main(ActivityThread.java:7356)<br>at java.lang.reflect.Method.invoke(Native Method)<br>at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)<br>at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)<br>Caused by: java.lang.reflect.InvocationTargetException<br>at java.lang.reflect.Method.invoke(Native Method)<br>at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)<br>... 11 more<br>Caused by: java.lang.RuntimeException: test java exception<br>at xcrash.XCrash.testJavaCrash(XCrash.java:847)<br>at xcrash.sample.MainActivity.testJavaCrashInMainThread_onClick(MainActivity.java:67)<br>... 13 more<br></code></pre></div></td></tr></table></figure><h3 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a>logcat</h3><p>其实就是调用 <code>logcat</code> 命令获取崩溃时的 <code>main</code>、<code>system</code> 和 <code>events</code> 三个 buffer 的日志，如：<code>/system/bin/logcat -b main -d -v threadtime -t 200 --pid 21356 *:D</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">getLogcat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> logcatMainLines, <span class="hljs-keyword">int</span> logcatSystemLines, <span class="hljs-keyword">int</span> logcatEventsLines)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pid = android.os.Process.myPid();<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    sb.append(<span class="hljs-string">&quot;logcat:\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (logcatMainLines &gt; <span class="hljs-number">0</span>) &#123;<br>        getLogcatByBufferName(pid, sb, <span class="hljs-string">&quot;main&quot;</span>, logcatMainLines, <span class="hljs-string">&#x27;D&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logcatSystemLines &gt; <span class="hljs-number">0</span>) &#123;<br>        getLogcatByBufferName(pid, sb, <span class="hljs-string">&quot;system&quot;</span>, logcatSystemLines, <span class="hljs-string">&#x27;W&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logcatEventsLines &gt; <span class="hljs-number">0</span>) &#123;<br>        getLogcatByBufferName(pid, sb, <span class="hljs-string">&quot;events&quot;</span>, logcatSystemLines, <span class="hljs-string">&#x27;I&#x27;</span>);<br>    &#125;<br>    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLogcatByBufferName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, StringBuilder sb, String bufferName, <span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">char</span> priority)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> withPid = (android.os.Build.VERSION.SDK_INT &gt;= <span class="hljs-number">24</span>);<br>    String pidString = Integer.toString(pid);<br>    String pidLabel = <span class="hljs-string">&quot; &quot;</span> + pidString + <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-comment">//command for ProcessBuilder</span><br>    List&lt;String&gt; command = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    command.add(<span class="hljs-string">&quot;/system/bin/logcat&quot;</span>);<br>    command.add(<span class="hljs-string">&quot;-b&quot;</span>);<br>    command.add(bufferName);<br>    command.add(<span class="hljs-string">&quot;-d&quot;</span>);<br>    command.add(<span class="hljs-string">&quot;-v&quot;</span>);<br>    command.add(<span class="hljs-string">&quot;threadtime&quot;</span>);<br>    command.add(<span class="hljs-string">&quot;-t&quot;</span>);<br>    command.add(Integer.toString(withPid ? lines : (<span class="hljs-keyword">int</span>) (lines * <span class="hljs-number">1.2</span>)));<br>    <span class="hljs-keyword">if</span> (withPid) &#123;<br>        command.add(<span class="hljs-string">&quot;--pid&quot;</span>);<br>        command.add(pidString);<br>    &#125;<br>    command.add(<span class="hljs-string">&quot;*:&quot;</span> + priority);<br>    <span class="hljs-comment">//append the command line</span><br>    Object[] commandArray = command.toArray();<br>    sb.append(<span class="hljs-string">&quot;--------- tail end of log &quot;</span>).append(bufferName);<br>    sb.append(<span class="hljs-string">&quot; (&quot;</span>).append(android.text.TextUtils.join(<span class="hljs-string">&quot; &quot;</span>, commandArray)).append(<span class="hljs-string">&quot;)\n&quot;</span>);<br>    <span class="hljs-comment">//append logs</span><br>    BufferedReader br = <span class="hljs-keyword">null</span>;<br>    String line;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Process process = <span class="hljs-keyword">new</span> ProcessBuilder().command(command).start();<br>        br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(process.getInputStream()));<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (withPid || line.contains(pidLabel)) &#123;<br>                sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        XCrash.getLogger().w(Util.TAG, <span class="hljs-string">&quot;Util run logcat command failed&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (br != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                br.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;    <br></code></pre></div></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">logcat:<br>--------- tail end of log main (/system/bin/logcat -b main -d -v threadtime -t 200 --pid 21356 *:D)<br>10-12 03:23:19.356 21356 21356 I xcrash.sample: Late-enabling -Xcheck:jni<br>10-12 03:23:19.398 21356 21356 E xcrash.sample: Unknown bits set in runtime_flags: 0x8000<br>10-12 03:23:19.571 21356 21356 D xcrash_sample: xCrash SDK init: start<br>10-12 03:23:19.586 21356 21356 D xcrash_sample: xCrash SDK init: end<br>10-12 03:23:19.757 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (greylist, reflection, allowed)<br>10-12 03:23:19.758 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/ViewGroup;-&gt;makeOptionalFitsSystemWindows()V (greylist, reflection, allowed)<br>10-12 03:23:19.829 21356 21356 I WebViewFactory: Loading com.google.android.webview version 77.0.3865.92 (code 386509238)<br>10-12 03:23:19.874 21356 21356 I cr_LibraryLoader: Time to load native libraries: 4 ms (timestamps 1922-1926)<br>10-12 03:23:19.920 21356 21356 I chromium: [INFO:library_loader_hooks.cc(51)] Chromium logging enabled: level = 0, default verbosity = 0<br>10-12 03:23:19.921 21356 21356 I cr_LibraryLoader: Expected native library version number &quot;77.0.3865.92&quot;, actual native library version number &quot;77.0.3865.92&quot;<br>10-12 03:23:19.926 21356 21402 W cr_ChildProcLH: Create a new ChildConnectionAllocator with package name = com.google.android.webview, sandboxed = true<br>10-12 03:23:19.930 21356 21402 W xcrash.sample: Accessing hidden method Landroid/content/Context;-&gt;bindServiceAsUser(Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/Handler;Landroid/os/UserHandle;)Z (greylist, reflection, allowed)<br>10-12 03:23:19.934 21356 21356 I cr_BrowserStartup: Initializing chromium process, singleProcess=false<br>10-12 03:23:19.979 21356 21430 W chromium: [WARNING:dns_config_service_posix.cc(339)] Failed to read DnsConfig.<br>10-12 03:23:20.031 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker;-&gt;&lt;init&gt;(Landroid/content/Context;I)V (greylist, reflection, allowed)<br>10-12 03:23:20.031 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker;-&gt;logEvent(Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;)V (greylist, reflection, allowed)<br>10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionStarted(I)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)<br>10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionModified(II)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)<br>10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionModified(IILandroid/view/textclassifier/TextClassification;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)<br>10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionModified(IILandroid/view/textclassifier/TextSelection;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)<br>10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionAction(III)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)<br>10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionAction(IIILandroid/view/textclassifier/TextClassification;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)<br>10-12 03:23:20.143 21356 21395 I Adreno  : QUALCOMM build                   : 4a00b69, I4e7e888065<br>10-12 03:23:20.143 21356 21395 I Adreno  : Build Date                       : 04/09/19<br>10-12 03:23:20.143 21356 21395 I Adreno  : OpenGL ES Shader Compiler Version: EV031.26.06.00<br>10-12 03:23:20.143 21356 21395 I Adreno  : Local Branch                     : mybranche95ae4c8-d77f-f18d-a9ef-1458d0b52ae8<br>10-12 03:23:20.143 21356 21395 I Adreno  : Remote Branch                    : quic/gfx-adreno.lnx.1.0<br>10-12 03:23:20.143 21356 21395 I Adreno  : Remote Branch                    : NONE<br>10-12 03:23:20.143 21356 21395 I Adreno  : Reconstruct Branch               : NOTHING<br>10-12 03:23:20.143 21356 21395 I Adreno  : Build Config                     : S L 8.0.5 AArch64<br>10-12 03:23:20.146 21356 21395 I Adreno  : PFP: 0x005ff110, ME: 0x005ff066<br>10-12 03:23:20.198 21356 21395 W Gralloc3: mapper 3.x is not supported<br>10-12 03:23:25.531 21356 21356 D AndroidRuntime: Shutting down VM<br>--------- tail end of log system (/system/bin/logcat -b system -d -v threadtime -t 50 --pid 21356 *:W)<br>--------- tail end of log events (/system/bin/logcat -b events -d -v threadtime -t 50 --pid 21356 *:I)<br>10-12 03:23:20.046 21356 21356 I am_on_create_called: [0,xcrash.sample.MainActivity,performCreate]<br>10-12 03:23:20.053 21356 21356 I am_on_start_called: [0,xcrash.sample.MainActivity,handleStartActivity]<br>10-12 03:23:20.056 21356 21356 I am_on_resume_called: [0,xcrash.sample.MainActivity,RESUME_ACTIVITY]<br>10-12 03:23:20.083 21356 21356 I am_on_top_resumed_gained_called: [0,xcrash.sample.MainActivity,topStateChangedWhenResumed]<br></code></pre></div></td></tr></table></figure><h3 id="Opened-FD"><a href="#Opened-FD" class="headerlink" title="Opened FD"></a>Opened FD</h3><p>打印已打开的 FD 及其路径，已打开的 FD 在目录 <code>/proc/self/fd</code> 下</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">getFds</span><span class="hljs-params">()</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;open files:\n&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/proc/self/fd&quot;</span>);<br>        File[] fds = dir.listFiles(<span class="hljs-keyword">new</span> FilenameFilter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File dir, String name)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> TextUtils.isDigitsOnly(name);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (fds != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (File fd : fds) &#123;<br>                String path = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>) &#123;<br>                        path = Os.readlink(fd.getAbsolutePath());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        path = fd.getCanonicalPath();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                &#125;<br>                sb.append(<span class="hljs-string">&quot;    fd &quot;</span>).append(fd.getName()).append(<span class="hljs-string">&quot;: &quot;</span>)<br>                    .append(TextUtils.isEmpty(path) ? <span class="hljs-string">&quot;???&quot;</span> : path.trim()).append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>                count++;<br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1024</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fds.length &gt; <span class="hljs-number">1024</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot;    ......\n&quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;    (number of FDs: &quot;</span>).append(fds.length).append(<span class="hljs-string">&quot;)\n&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>    &#125;<br>    sb.append(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">open files:<br>    fd 0: /dev/null<br>    fd 1: /dev/null<br>    fd 2: /dev/null<br>    fd 3: /proc/21356/fd/3<br>    fd 4: /proc/21356/fd/4<br>    fd 5: /proc/21356/fd/5<br>    fd 6: /dev/null<br>    fd 7: /dev/null<br>    fd 8: /dev/null<br>    fd 9: /apex/com.android.runtime/javalib/core-oj.jar<br>    fd 10: /apex/com.android.runtime/javalib/core-libart.jar<br>    fd 11: /apex/com.android.runtime/javalib/okhttp.jar<br>    fd 12: /apex/com.android.runtime/javalib/bouncycastle.jar<br>    fd 13: /apex/com.android.runtime/javalib/apache-xml.jar<br>    fd 14: /system/framework/framework.jar<br>    fd 15: /system/framework/ext.jar<br>    fd 16: /system/framework/telephony-common.jar<br>    fd 17: /system/framework/voip-common.jar<br>    fd 18: /system/framework/ims-common.jar<br>    fd 19: /dev/null<br>    fd 20: /dev/null<br>    fd 21: /system/framework/android.test.base.jar<br>    fd 22: /apex/com.android.conscrypt/javalib/conscrypt.jar<br>    fd 23: /apex/com.android.media/javalib/updatable-media.jar<br>    fd 24: /system/framework/framework-res.apk<br>    fd 25: /system/product/overlay/GoogleConfigOverlay.apk<br>    fd 26: /system/product/overlay/GoogleWebViewOverlay.apk<br>    fd 27: /vendor/overlay/framework-res__auto_generated_rro_vendor.apk<br>    fd 28: /system/product/overlay/PixelConfigOverlayCommon.apk<br>    fd 29: /system/product/overlay/framework-res__auto_generated_rro_product.apk<br>    fd 30: /dev/null<br>    fd 31: /dev/binder<br>    fd 32: /proc/21356/fd/32<br>    fd 33: /proc/21356/fd/33<br>    fd 34: /proc/21356/fd/34<br>    fd 35: /proc/21356/fd/35<br>    fd 36: /proc/21356/fd/36<br>    fd 37: /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/base.apk<br>    fd 38: /proc/21356/fd/38<br>    fd 39: /proc/21356/fd/39<br>    fd 40: /system/product/overlay/NavigationBarModeGestural/NavigationBarModeGesturalOverlay.apk<br>    fd 41: /dev/null<br>    fd 42: /dev/null<br>    fd 43: /dev/null<br>    fd 44: /dev/null<br>    fd 45: /proc/21356/fd/45<br>    fd 46: /proc/21356/fd/46<br>    fd 47: /proc/21356/fd/47<br>    fd 48: /proc/21356/fd/48<br>    fd 49: /dev/ashmem<br>    fd 50: /proc/21356/fd/50<br>    fd 51: /proc/21356/fd/51<br>    fd 52: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk<br>    fd 53: /proc/21356/fd/53<br>    fd 54: /data/data/xcrash.sample/files/tombstones/tombstone_00001570821799580000_1.2.3-beta456-patch789__xcrash.sample.java.xcrash<br>    fd 55: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk<br>    fd 56: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk<br>    fd 57: /data/data/xcrash.sample/app_webview/webview_data.lock<br>    fd 58: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk<br>    fd 59: /system/product/overlay/NavigationBarModeGestural/NavigationBarModeGesturalOverlay.apk<br>    fd 60: /proc/21356/fd/60<br>    fd 61: /proc/21356/fd/61<br>    fd 62: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk<br>    fd 63: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk<br>    fd 64: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk<br>    fd 65: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk<br>    fd 66: /dev/urandom<br>    fd 67: /proc/21356/fd/67<br>    fd 68: /proc/21356/fd/68<br>    fd 69: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk<br>    fd 70: /proc/21356/fd/70<br>    fd 71: /proc/21356/fd/71<br>    fd 72: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk<br>    fd 73: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk<br>    fd 74: /proc/21356/fd/74<br>    fd 75: /proc/21356/fd/75<br>    fd 76: /proc/21356/fd/76<br>    fd 77: /proc/21356/fd/77<br>    fd 78: /proc/21356/fd/78<br>    fd 79: /proc/21356/fd/79<br>    fd 80: /proc/21356/fd/80<br>    fd 81: /proc/21356/fd/81<br>    fd 82: /proc/21356/fd/82<br>    fd 83: /proc/21356/fd/83<br>    fd 84: /proc/21356/fd/84<br>    fd 85: /proc/21356/fd/85<br>    fd 86: /proc/21356/fd/86<br>    fd 87: /proc/21356/fd/87<br>    fd 88: /proc/21356/fd/88<br>    fd 89: /proc/21356/fd/89<br>    fd 90: /proc/21356/fd/90<br>    fd 91: /dev/ashmem<br>    fd 92: /dev/ashmem<br>    fd 93: /dev/ashmem<br>    fd 94: /data/data/xcrash.sample/app_webview/Web Data<br>    fd 95: /proc/21356/fd/95<br>    fd 96: /proc/21356/fd/96<br>    fd 97: /dev/ashmem<br>    fd 98: /dev/ion<br>    fd 99: /proc/21356/fd/99<br>    fd 100: /proc/21356/fd/100<br>    fd 101: /proc/21356/fd/101<br>    fd 102: /dev/ashmem<br>    fd 103: /dev/kgsl-3d0<br>    fd 104: /dev/ion<br>    fd 105: /dev/hwbinder<br>    fd 106: /proc/21356/fd/106<br>    fd 107: /proc/21356/fd/107<br>    fd 110: /proc/21356/fd/110<br>    fd 111: /proc/21356/fd/111<br>    fd 113: /proc/21356/fd/113<br>    fd 114: /proc/21356/fd/114<br>    fd 115: /proc/21356/fd/115<br>    fd 116: /proc/21356/fd/116<br>    fd 117: /proc/21356/fd/117<br>    (number of FDs: 115)<br></code></pre></div></td></tr></table></figure><h3 id="System-Memory-Summary"><a href="#System-Memory-Summary" class="headerlink" title="System Memory Summary"></a>System Memory Summary</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">System Summary (From: /proc/meminfo)<br> MemTotal:        3855796 kB<br> MemFree:           90124 kB<br> MemAvailable:    1452636 kB<br> Buffers:           77420 kB<br> Cached:          1461900 kB<br> SwapCached:        10232 kB<br> Active:          1771504 kB<br> Inactive:        1014432 kB<br> Active(anon):    1046604 kB<br> Inactive(anon):   368348 kB<br> Active(file):     724900 kB<br> Inactive(file):   646084 kB<br> Unevictable:      151672 kB<br> Mlocked:          151672 kB<br> SwapTotal:        524284 kB<br> SwapFree:         271320 kB<br> Dirty:               136 kB<br> Writeback:             0 kB<br> AnonPages:       1391280 kB<br> Mapped:           620988 kB<br> Shmem:             16660 kB<br> Slab:             231556 kB<br> SReclaimable:      92700 kB<br> SUnreclaim:       138856 kB<br> KernelStack:       44448 kB<br> PageTables:        57544 kB<br> NFS_Unstable:          0 kB<br> Bounce:                0 kB<br> WritebackTmp:          0 kB<br> CommitLimit:     2452180 kB<br> Committed_AS:   67847232 kB<br> VmallocTotal:   258998208 kB<br> VmallocUsed:      223632 kB<br> VmallocChunk:   258675172 kB<br></code></pre></div></td></tr></table></figure><h3 id="APP-Process-Summary"><a href="#APP-Process-Summary" class="headerlink" title="APP Process Summary"></a>APP Process Summary</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Process Status (From: /proc/PID/status)<br> Name:xcrash.sample<br> State:R (running)<br> Tgid:21356<br> Pid:21356<br> PPid:626<br> TracerPid:0<br> Uid:10180101801018010180<br> Gid:10180101801018010180<br> Ngid:0<br> FDSize:128<br> Groups:9997 20180 50180<br> VmPeak: 5659228 kB<br> VmSize: 5542192 kB<br> VmLck:       0 kB<br> VmPin:       0 kB<br> VmHWM:   94624 kB<br> VmRSS:   94396 kB<br> VmData: 5051840 kB<br> VmStk:    8192 kB<br> VmExe:      28 kB<br> VmLib:  166580 kB<br> VmPTE:    1068 kB<br> VmSwap:    6476 kB<br> Threads:37<br> SigQ:0/13891<br> SigPnd:0000000000000000<br> ShdPnd:0000000000000000<br> SigBlk:0000000080001200<br> SigIgn:0000000000000001<br> SigCgt:0000000e400084fc<br> CapInh:0000000000000000<br> CapPrm:0000000000000000<br> CapEff:0000000000000000<br> CapBnd:0000000000000000<br> CapAmb:0000000000000000<br> Seccomp:2<br> Cpus_allowed:f<br> Cpus_allowed_list:0-3<br> Mems_allowed:1<br> Mems_allowed_list:0<br> voluntary_ctxt_switches:343<br> nonvoluntary_ctxt_switches:301<br></code></pre></div></td></tr></table></figure><h3 id="APP-Process-Limits"><a href="#APP-Process-Limits" class="headerlink" title="APP Process Limits"></a>APP Process Limits</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Process Limits (From: /proc/PID/limits)<br> Limit                     Soft Limit           Hard Limit           Units<br> Max cpu time              unlimited            unlimited            seconds<br> Max file size             unlimited            unlimited            bytes<br> Max data size             unlimited            unlimited            bytes<br> Max stack size            8388608              unlimited            bytes<br> Max core file size        0                    unlimited            bytes<br> Max resident set          unlimited            unlimited            bytes<br> Max processes             13891                13891                processes<br> Max open files            32768                32768                files<br> Max locked memory         65536                65536                bytes<br> Max address space         unlimited            unlimited            bytes<br> Max file locks            unlimited            unlimited            locks<br> Max pending signals       13891                13891                signals<br> Max msgqueue size         819200               819200               bytes<br> Max nice priority         40                   40<br> Max realtime priority     0                    0<br> Max realtime timeout      unlimited            unlimited            us<br></code></pre></div></td></tr></table></figure><h3 id="APP-Memory-Summary"><a href="#APP-Memory-Summary" class="headerlink" title="APP Memory Summary"></a>APP Memory Summary</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Process Summary (From: android.os.Debug.MemoryInfo)<br>                       Pss(KB)<br>                        ------<br>           Java Heap:     7632<br>         Native Heap:    10932<br>                Code:    19064<br>               Stack:       56<br>            Graphics:     1104<br>       Private Other:     3448<br>              System:     4414<br>               TOTAL:    46650           TOTAL SWAP:     6460<br><br></code></pre></div></td></tr></table></figure><h3 id="Other-StackTraces"><a href="#Other-StackTraces" class="headerlink" title="Other StackTraces"></a>Other StackTraces</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getOtherThreadsInfo</span><span class="hljs-params">(Thread crashedThread)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 其他线程可能有很多，所以有“白名单”机制</span><br>    <span class="hljs-keyword">int</span> thdMatchedRegex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> thdIgnoredByLimit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> thdDumped = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//build whitelist regex list</span><br>    ArrayList&lt;Pattern&gt; whiteList = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (dumpAllThreadsWhiteList != <span class="hljs-keyword">null</span>) &#123;<br>        whiteList = <span class="hljs-keyword">new</span> ArrayList&lt;Pattern&gt;();<br>        <span class="hljs-keyword">for</span> (String s : dumpAllThreadsWhiteList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                whiteList.add(Pattern.compile(s));<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                XCrash.getLogger().w(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler pattern compile failed&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// dump trace</span><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Thread, StackTraceElement[]&gt; entry : map.entrySet()) &#123;<br>        Thread thd = entry.getKey();<br>        StackTraceElement[] stacktrace = entry.getValue();<br>        <span class="hljs-comment">//skip the crashed thread</span><br>        <span class="hljs-keyword">if</span> (thd.getName().equals(crashedThread.getName())) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//check regex for thread name</span><br>        <span class="hljs-keyword">if</span> (whiteList != <span class="hljs-keyword">null</span> &amp;&amp; !matchThreadName(whiteList, thd.getName())) <span class="hljs-keyword">continue</span>;<br>        thdMatchedRegex++;<br>        <span class="hljs-comment">//check dump count limit</span><br>        <span class="hljs-keyword">if</span> (dumpAllThreadsCountMax &gt; <span class="hljs-number">0</span> &amp;&amp; thdDumped &gt;= dumpAllThreadsCountMax) &#123;<br>            thdIgnoredByLimit++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        sb.append(Util.sepOtherThreads + <span class="hljs-string">&quot;\n&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;pid: &quot;</span>).append(pid).append(<span class="hljs-string">&quot;, tid: &quot;</span>).append(thd.getId()).append(<span class="hljs-string">&quot;, name: &quot;</span>).append(thd.getName()).append(<span class="hljs-string">&quot;  &gt;&gt;&gt; &quot;</span>).append(processName).append(<span class="hljs-string">&quot; &lt;&lt;&lt;\n&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;java stacktrace:\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (StackTraceElement element : stacktrace) &#123;<br>            sb.append(<span class="hljs-string">&quot;    at &quot;</span>).append(element.toString()).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        thdDumped++;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计</span><br>    <span class="hljs-keyword">if</span> (map.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (thdDumped == <span class="hljs-number">0</span>) &#123;<br>            sb.append(Util.sepOtherThreads + <span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;total JVM threads (exclude the crashed thread): &quot;</span>).append(map.size() - <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (whiteList != <span class="hljs-keyword">null</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;JVM threads matched whitelist: &quot;</span>).append(thdMatchedRegex).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dumpAllThreadsCountMax &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;JVM threads ignored by max count limit: &quot;</span>).append(thdIgnoredByLimit).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;dumped JVM threads:&quot;</span>).append(thdDumped).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        sb.append(Util.sepOtherThreadsEnding + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4364, name: RenderThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4349, name: Jit thread pool worker thread 0  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4357, name: Binder:21356_2  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4374, name: NetworkService  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4353, name: ReferenceQueueDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at java.lang.Object.wait(Native Method)<br>    at java.lang.Object.wait(Object.java:442)<br>    at java.lang.Object.wait(Object.java:568)<br>    at java.lang.Daemons$ReferenceQueueDaemon.runInternal(Daemons.java:215)<br>    at java.lang.Daemons$Daemon.run(Daemons.java:137)<br>    at java.lang.Thread.run(Thread.java:919)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4359, name: Profile Saver  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4371, name: GoogleApiHandler  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at android.os.MessageQueue.nativePollOnce(Native Method)<br>    at android.os.MessageQueue.next(MessageQueue.java:336)<br>    at android.os.Looper.loop(Looper.java:174)<br>    at android.os.HandlerThread.run(HandlerThread.java:67)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4362, name: xcrash_trace_dp  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4361, name: xcrash_crash_cb  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4352, name: HeapTaskDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4354, name: FinalizerDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at java.lang.Object.wait(Native Method)<br>    at java.lang.Object.wait(Object.java:442)<br>    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:190)<br>    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:211)<br>    at java.lang.Daemons$FinalizerDaemon.runInternal(Daemons.java:271)<br>    at java.lang.Daemons$Daemon.run(Daemons.java:137)<br>    at java.lang.Thread.run(Thread.java:919)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4372, name: Chrome_IOThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4370, name: CrAsyncTask #2  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at sun.misc.Unsafe.park(Native Method)<br>    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)<br>    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2109)<br>    at java.util.concurrent.ArrayBlockingQueue.poll(ArrayBlockingQueue.java:402)<br>    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)<br>    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)<br>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)<br>    at Js.run(PG:2)<br>    at java.lang.Thread.run(Thread.java:919)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4375, name: PlatformServiceBridgeHandlerThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at android.os.MessageQueue.nativePollOnce(Native Method)<br>    at android.os.MessageQueue.next(MessageQueue.java:336)<br>    at android.os.Looper.loop(Looper.java:174)<br>    at android.os.HandlerThread.run(HandlerThread.java:67)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4355, name: FinalizerWatchdogDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at java.lang.Thread.sleep(Native Method)<br>    at java.lang.Thread.sleep(Thread.java:440)<br>    at java.lang.Thread.sleep(Thread.java:356)<br>    at java.lang.Daemons$FinalizerWatchdogDaemon.sleepForMillis(Daemons.java:383)<br>    at java.lang.Daemons$FinalizerWatchdogDaemon.waitForFinalization(Daemons.java:411)<br>    at java.lang.Daemons$FinalizerWatchdogDaemon.runInternal(Daemons.java:323)<br>    at java.lang.Daemons$Daemon.run(Daemons.java:137)<br>    at java.lang.Thread.run(Thread.java:919)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4378, name: process reaper  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at sun.misc.Unsafe.park(Native Method)<br>    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)<br>    at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:461)<br>    at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)<br>    at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:937)<br>    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)<br>    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)<br>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)<br>    at java.lang.Thread.run(Thread.java:919)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4377, name: CleanupReference  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at java.lang.Object.wait(Native Method)<br>    at java.lang.Object.wait(Object.java:442)<br>    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:190)<br>    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:211)<br>    at Po.run(PG:2)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4350, name: Signal Catcher  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4373, name: ThreadPoolForeg  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4369, name: Chrome_ProcessLauncherThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at android.os.MessageQueue.nativePollOnce(Native Method)<br>    at android.os.MessageQueue.next(MessageQueue.java:336)<br>    at android.os.Looper.loop(Looper.java:174)<br>    at android.os.HandlerThread.run(HandlerThread.java:67)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4358, name: Binder:21356_3  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4366, name: CrAsyncTask #1  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br>    at sun.misc.Unsafe.park(Native Method)<br>    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)<br>    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2109)<br>    at java.util.concurrent.ArrayBlockingQueue.poll(ArrayBlockingQueue.java:402)<br>    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)<br>    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)<br>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)<br>    at Js.run(PG:2)<br>    at java.lang.Thread.run(Thread.java:919)<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4376, name: ThreadPoolForeg  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---<br>pid: 21356, tid: 4356, name: Binder:21356_1  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;<br><br>java stacktrace:<br><br>total JVM threads (exclude the crashed thread): 24<br>dumped JVM threads:24<br></code></pre></div></td></tr></table></figure><h2 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h2><p>捕获 Native Crash 靠的是信号处理器（<code>sigaction</code>），比如说访问非法地址时，APP 进程会收到 <code>SIGSEGV</code>，对应的信号处理器就可以在这个时间点收集堆栈信息</p><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>signal 产生后会处于几种状态中：<br>    1. blocked，让内核先持有信号不要分发（deliver），在 unblocked 之前都不会被分发出去；被 blocked 的信号集合叫做 singal mask，每个线程都有自己的 signal mask<br>    2. pending，内核正在分发信号给指定的进程/线程（但还没分发出去）</p><p>signal 可以是进程范围的，比如内核产生的信号、kill 和 sigqueue；也可以是线程范围的，比如因执行机器指令而导致的硬件异常（SIGSEGV、SIGFPE）、通过 tgkill 或者 pthread_kill 指定目标线程</p><p>进程范围的信号会随机选择一个 signal unblocked 的线程来消费（deliver）</p><p><code>sigaction</code> 用来注册信号处理器，是升级版的 <code>signal</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果 act != null，它被注册为新的信号处理器；如果 oldact != null，上一个信号处理器将被保存在此</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signum, <span class="hljs-keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> &#123;</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>     (*sa_handler)(<span class="hljs-keyword">int</span>);                        <span class="hljs-comment">// 只收到 signal 作为参数的处理器</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>     (*sa_sigaction)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">siginfo_t</span> *, <span class="hljs-keyword">void</span> *); <span class="hljs-comment">// 当指定 SA_SIGINFO 时，替代 sa_handler 作为处理器（能收到三个参数）</span><br>    <span class="hljs-keyword">sigset_t</span>   sa_mask;                                 <span class="hljs-comment">// 处理器运行时，暂时屏蔽指定信号（将它们加到线程的 signal mask）</span><br>    <span class="hljs-keyword">int</span>        sa_flags;<br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>     (*sa_restorer)(<span class="hljs-keyword">void</span>);                      <span class="hljs-comment">// not for app</span><br>&#125;;<br><br><span class="hljs-comment">// sa_flags:</span><br><span class="hljs-comment">//     SA_SIGINFO 使用 sa_sigaction 作为处理器</span><br><span class="hljs-comment">//     SA_RESTART 当线程阻塞在系统调用/库函数上，因为信号的到来转而进入信号处理器，退出信号处理器后如何恢复上一个系统调用/库函数；</span><br><span class="hljs-comment">//                默认是使其返回失败码，此 flag 指示重新执行系统调用/库函数</span><br><span class="hljs-comment">//     SA_ONSTACK 用另一个方法调用栈来执行处理器函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sa_sigaction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">siginfo_t</span> *info, <span class="hljs-keyword">void</span> *ucontext)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">siginfo_t</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>      si_signo;     <span class="hljs-comment">/* Signal number */</span><br>    <span class="hljs-keyword">int</span>      si_errno;     <span class="hljs-comment">/* An errno value */</span><br>    <span class="hljs-keyword">int</span>      si_code;      <span class="hljs-comment">/* Signal code */</span><br>    <span class="hljs-keyword">int</span>      si_trapno;    <span class="hljs-comment">/* Trap number that caused</span><br><span class="hljs-comment">                              hardware-generated signal</span><br><span class="hljs-comment">                              (unused on most architectures) */</span><br>    <span class="hljs-keyword">pid_t</span>    si_pid;       <span class="hljs-comment">/* Sending process ID */</span><br>    <span class="hljs-keyword">uid_t</span>    si_uid;       <span class="hljs-comment">/* Real user ID of sending process */</span><br>    <span class="hljs-keyword">int</span>      si_status;    <span class="hljs-comment">/* Exit value or signal */</span><br>    <span class="hljs-keyword">clock_t</span>  si_utime;     <span class="hljs-comment">/* User time consumed */</span><br>    <span class="hljs-keyword">clock_t</span>  si_stime;     <span class="hljs-comment">/* System time consumed */</span><br>    <span class="hljs-keyword">sigval_t</span> si_value;     <span class="hljs-comment">/* Signal value */</span><br>    <span class="hljs-keyword">int</span>      si_int;       <span class="hljs-comment">/* POSIX.1b signal */</span><br>    <span class="hljs-keyword">void</span>    *si_ptr;       <span class="hljs-comment">/* POSIX.1b signal */</span><br>    <span class="hljs-keyword">int</span>      si_overrun;   <span class="hljs-comment">/* Timer overrun count;</span><br><span class="hljs-comment">                              POSIX.1b timers */</span><br>    <span class="hljs-keyword">int</span>      si_timerid;   <span class="hljs-comment">/* Timer ID; POSIX.1b timers */</span><br>    <span class="hljs-keyword">void</span>    *si_addr;      <span class="hljs-comment">/* Memory location which caused fault */</span><br>    <span class="hljs-keyword">long</span>     si_band;      <span class="hljs-comment">/* Band event (was int in</span><br><span class="hljs-comment">                              glibc 2.3.2 and earlier) */</span><br>    <span class="hljs-keyword">int</span>      si_fd;        <span class="hljs-comment">/* File descriptor */</span><br>    <span class="hljs-keyword">short</span>    si_addr_lsb;  <span class="hljs-comment">/* Least significant bit of address</span><br><span class="hljs-comment">                              (since Linux 2.6.32) */</span><br>    <span class="hljs-keyword">void</span>    *si_lower;     <span class="hljs-comment">/* Lower bound when address violation</span><br><span class="hljs-comment">                              occurred (since Linux 3.19) */</span><br>    <span class="hljs-keyword">void</span>    *si_upper;     <span class="hljs-comment">/* Upper bound when address violation</span><br><span class="hljs-comment">                              occurred (since Linux 3.19) */</span><br>    <span class="hljs-keyword">int</span>      si_pkey;      <span class="hljs-comment">/* Protection key on PTE that caused</span><br><span class="hljs-comment">                              fault (since Linux 4.6) */</span><br>    <span class="hljs-keyword">void</span>    *si_call_addr; <span class="hljs-comment">/* Address of system call instruction</span><br><span class="hljs-comment">                              (since Linux 3.5) */</span><br>    <span class="hljs-keyword">int</span>      si_syscall;   <span class="hljs-comment">/* Number of attempted system call</span><br><span class="hljs-comment">                              (since Linux 3.5) */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> si_arch;  <span class="hljs-comment">/* Architecture of attempted system call</span><br><span class="hljs-comment">                              (since Linux 3.5) */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="sigaltstack"><a href="#sigaltstack" class="headerlink" title="sigaltstack"></a>sigaltstack</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 为当前进程设置一个新的（获取上一个）信号处理器调用栈，其实就是为信号处理器预先分配一块内存，作为其调用栈</span><br><span class="hljs-comment"> * The most common usage of an alternate signal stack is to handle the SIGSEGV signal </span><br><span class="hljs-comment"> * that is generated if the space available for the normal process stack is exhausted: </span><br><span class="hljs-comment"> * in this case, a signal handler for SIGSEGV cannot be invoked on the process stack; </span><br><span class="hljs-comment"> * if we wish to handle it, we must use an alternate signal stack</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigaltstack</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">stack_t</span> *ss, <span class="hljs-keyword">stack_t</span> *old_ss)</span></span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-keyword">void</span>  *ss_sp;     <span class="hljs-comment">/* Base address of stack */</span><br>    <span class="hljs-keyword">int</span>    ss_flags;  <span class="hljs-comment">/* Flags */</span><br>    <span class="hljs-keyword">size_t</span> ss_size;   <span class="hljs-comment">/* Number of bytes in stack */</span><br>&#125; <span class="hljs-keyword">stack_t</span>;<br></code></pre></div></td></tr></table></figure><h3 id="xc-crash-signal-handler"><a href="#xc-crash-signal-handler" class="headerlink" title="xc_crash_signal_handler"></a>xc_crash_signal_handler</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// XCrash.init</span><br><span class="hljs-comment">// NativeHandler.initialize</span><br><span class="hljs-comment">// NativeHandler.nativeInit</span><br><span class="hljs-comment">// xc_jni_init</span><br><span class="hljs-comment">// xc_crash_init</span><br><br><span class="hljs-comment">// 需要捕获的信号</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">xcc_signal_crash_info_t</span> xcc_signal_crash_info[] =<br>&#123;<br>    &#123;.signum = SIGABRT&#125;,<br>    &#123;.signum = SIGBUS&#125;,<br>    &#123;.signum = SIGFPE&#125;,<br>    &#123;.signum = SIGILL&#125;,<br>    &#123;.signum = SIGSEGV&#125;,<br>    &#123;.signum = SIGTRAP&#125;,<br>    &#123;.signum = SIGSYS&#125;,<br>    &#123;.signum = SIGSTKFLT&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xcc_signal_crash_register</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*handler)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">siginfo_t</span> *, <span class="hljs-keyword">void</span> *))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 预先为处理器分配一块内存</span><br>    <span class="hljs-keyword">stack_t</span> ss;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (ss.ss_sp = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, XCC_SIGNAL_CRASH_STACK_SIZE))) <span class="hljs-keyword">return</span> XCC_ERRNO_NOMEM;<br>    ss.ss_size  = XCC_SIGNAL_CRASH_STACK_SIZE;<br>    ss.ss_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">sigaltstack</span>(&amp;ss, <span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;act, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(act));<br>    <span class="hljs-built_in">sigfillset</span>(&amp;act.sa_mask);<br>    act.sa_sigaction = handler;<br>    act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;<br>    <br>    <span class="hljs-comment">// 为上述信号注册处理器</span><br>    <span class="hljs-keyword">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(xcc_signal_crash_info) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(xcc_signal_crash_info[<span class="hljs-number">0</span>]); i++)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">sigaction</span>(xcc_signal_crash_info[i].signum, &amp;act, &amp;(xcc_signal_crash_info[i].oldact)))<br>            <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 信号处理器，跟上面的 JavaCrashHandler 一样，主要是收集各种信息，写入 tombstone 文件</span><br><span class="hljs-comment">// 比较复杂，下一章节进行分析</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">xc_crash_signal_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">siginfo_t</span> *si, <span class="hljs-keyword">void</span> *uc)</span></span><br></code></pre></div></td></tr></table></figure><h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ol><li>信号处理器（<code>xc_crash_signal_handler</code>，在 APP 进程）收集相关的信息到 <code>xc_crash_spot</code></li><li><code>fork</code> 出子进程 dumper，子进程继承了父进程的内存布局，也就捕获到了 APP 进程 crash 时刻的内存布局</li><li>dumper 进程的入口点是 <code>xc_crash_exec_dumper</code>，signal handler 线程通过 <code>waitpid</code> 阻塞直到 dumper 进程完成工作</li><li>dumper 将 signal 和调用堆栈等信息写入管道，然后加载程序 <code>libxcrash_dumper.so</code> 替换当前的内存空间（旧的内存空间的所有信息将被清空）</li><li><code>xcd_core.c</code> 里的 main 函数从管道里读取 <code>xc_crash_spot</code> 并写入 tombstone 日志文件，退出</li><li>signal handler 线程从阻塞中恢复，退出 APP 进程</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// APP 进程，signal hander 线程，dump 开始的地方</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">xc_crash_signal_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">siginfo_t</span> *si, <span class="hljs-keyword">void</span> *uc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set crash spot info</span><br>    xc_crash_spot.crash_time = xc_crash_time;<br>    xc_crash_spot.crash_tid = xc_crash_tid;<br>    <span class="hljs-built_in">memcpy</span>(&amp;(xc_crash_spot.siginfo), si, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">siginfo_t</span>));<br>    <span class="hljs-built_in">memcpy</span>(&amp;(xc_crash_spot.ucontext), uc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">ucontext_t</span>));<br>    xc_crash_spot.log_pathname_len = <span class="hljs-built_in">strlen</span>(xc_crash_log_pathname);<br><br>    <span class="hljs-comment">// spawn crash dumper process</span><br>    <span class="hljs-keyword">pid_t</span> dumper_pid = <span class="hljs-built_in">xc_crash_fork</span>(xc_crash_exec_dumper);<br><br>    <span class="hljs-comment">// wait the crash dumper process terminated</span><br>    <span class="hljs-keyword">int</span> wait_r = <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">waitpid</span>(dumper_pid, &amp;status, __WALL));<br><br>    <span class="hljs-comment">// exit</span><br>&#125;<br><br><span class="hljs-comment">// dumper 进程的入口</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">xc_crash_exec_dumper</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个管道，第一个用来读，第二个用来写</span><br>    <span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">pipe2</span>(pipefd, O_CLOEXEC))<br><br>    <span class="hljs-comment">// 将 xc_crash_spot 写入管道</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iovs</span>[12] =</span> &#123;<br>        &#123;.iov_base = &amp;xc_crash_spot,                      .iov_len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">xcc_spot_t</span>)&#125;,<br>        &#123;.iov_base = xc_crash_log_pathname,               .iov_len = xc_crash_spot.log_pathname_len&#125;,<br>        &#123;.iov_base = xc_common_os_version,                .iov_len = xc_crash_spot.os_version_len&#125;,<br>        &#123;.iov_base = xc_common_kernel_version,            .iov_len = xc_crash_spot.kernel_version_len&#125;,<br>        &#123;.iov_base = xc_common_abi_list,                  .iov_len = xc_crash_spot.abi_list_len&#125;,<br>        &#123;.iov_base = xc_common_manufacturer,              .iov_len = xc_crash_spot.manufacturer_len&#125;,<br>        &#123;.iov_base = xc_common_brand,                     .iov_len = xc_crash_spot.brand_len&#125;,<br>        &#123;.iov_base = xc_common_model,                     .iov_len = xc_crash_spot.model_len&#125;,<br>        &#123;.iov_base = xc_common_build_fingerprint,         .iov_len = xc_crash_spot.build_fingerprint_len&#125;,<br>        &#123;.iov_base = xc_common_app_id,                    .iov_len = xc_crash_spot.app_id_len&#125;,<br>        &#123;.iov_base = xc_common_app_version,               .iov_len = xc_crash_spot.app_version_len&#125;,<br>        &#123;.iov_base = xc_crash_dump_all_threads_whitelist, .iov_len = xc_crash_spot.dump_all_threads_whitelist_len&#125;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> iovs_cnt = (<span class="hljs-number">0</span> == xc_crash_spot.dump_all_threads_whitelist_len ? <span class="hljs-number">11</span> : <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">ssize_t</span> ret = <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">writev</span>(pipefd[<span class="hljs-number">1</span>], iovs, iovs_cnt));<br><br>    <span class="hljs-comment">// 将 stdin (fd 0) 指向管道的读端口</span><br>    <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">dup2</span>(pipefd[<span class="hljs-number">0</span>], STDIN_FILENO));<br>    <br>    <span class="hljs-built_in">syscall</span>(SYS_close, pipefd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">syscall</span>(SYS_close, pipefd[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 加载程序 libxcrash_dumper.so 替换当前的内存空间</span><br>    <span class="hljs-built_in">execl</span>(xc_crash_dumper_pathname, XCC_UTIL_XCRASH_DUMPER_FILENAME, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> + errno;<br>&#125;<br><br><span class="hljs-comment">// libxcrash_dumper.so 的入口点，在 xcd_core.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从 stdin 读取 xc_crash_spot</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_core_read_args</span>()) <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//open log file</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &gt; (xcd_core_log_fd = <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">open</span>(xcd_core_log_pathname, O_WRONLY | O_CLOEXEC)))) <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">//create process object</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_process_create</span>(&amp;xcd_core_proc,<br>                               xcd_core_spot.crash_pid,<br>                               xcd_core_spot.crash_tid,<br>                               &amp;(xcd_core_spot.siginfo),<br>                               &amp;(xcd_core_spot.ucontext))) <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">//suspend all threads in the process</span><br>    <span class="hljs-built_in">xcd_process_suspend_threads</span>(xcd_core_proc);<br><br>    <span class="hljs-comment">//load process info</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_process_load_info</span>(xcd_core_proc)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">//record system info</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_sys_record</span>(xcd_core_log_fd,<br>                           xcd_core_spot.time_zone,<br>                           xcd_core_spot.start_time,<br>                           xcd_core_spot.crash_time,<br>                           xcd_core_app_id,<br>                           xcd_core_app_version,<br>                           xcd_core_spot.api_level,<br>                           xcd_core_os_version,<br>                           xcd_core_kernel_version,<br>                           xcd_core_abi_list,<br>                           xcd_core_manufacturer,<br>                           xcd_core_brand,<br>                           xcd_core_model,<br>                           xcd_core_build_fingerprint)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">//record process info</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_process_record</span>(xcd_core_proc,<br>                               xcd_core_log_fd,<br>                               xcd_core_spot.logcat_system_lines,<br>                               xcd_core_spot.logcat_events_lines,<br>                               xcd_core_spot.logcat_main_lines,<br>                               xcd_core_spot.dump_elf_hash,<br>                               xcd_core_spot.dump_map,<br>                               xcd_core_spot.dump_fds,<br>                               xcd_core_spot.dump_network_info,<br>                               xcd_core_spot.dump_all_threads,<br>                               xcd_core_spot.dump_all_threads_count_max,<br>                               xcd_core_dump_all_threads_whitelist,<br>                               xcd_core_spot.api_level)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">//resume all threads in the process</span><br>    <span class="hljs-built_in">xcd_process_resume_threads</span>(xcd_core_proc);<br><br>    <span class="hljs-comment">// exit</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Signal-Info"><a href="#Signal-Info" class="headerlink" title="Signal Info"></a>Signal Info</h3><p>打印导致 Native Crash 的 Signal 的基本信息，可以从 <code>sigaction</code> 的信号处理器（<code>xc_crash_signal_handler</code>）的参数列表里拿到（<code>siginfo_t</code>）</p><ul><li>信号码（<code>siginfo_t.si_signo</code>），比如：SIGKILL(9)、SIGSEGV(11)，更多参考 <code>man signal.7</code></li><li>信号错误码（<code>siginfo_t.si_code</code>），描述此信号的更详细的信息，比如对于 SIGSEGV 有以下错误码：<ul><li>SEGV_MAPERR Address not mapped to object.</li><li>SEGV_ACCERR Invalid permissions for mapped object.</li><li>SEGV_BNDERR (since Linux 3.19) Failed address bound checks.</li><li>SEGV_PKUERR (since Linux 4.6) Access was denied by memory protection keys.  See pkeys(7).  The protection key which applied to this access is available via si_pkey.</li></ul></li><li>SIGSEGV 会将错误地址写入 <code>siginfo_t.si_addr</code></li><li>有关 <code>siginfo_t</code> 的更详细信息请参考 <code>man sigaction.2</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">xcd_process_record_signal_info</span><span class="hljs-params">(<span class="hljs-keyword">xcd_process_t</span> *self, <span class="hljs-keyword">int</span> log_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//fault addr</span><br>    <span class="hljs-keyword">char</span> addr_desc[<span class="hljs-number">64</span>];<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">xcc_util_signal_has_si_addr</span>(self-&gt;si))<br>    &#123;<br>        <span class="hljs-keyword">void</span> *addr = self-&gt;si-&gt;si_addr;<br>        <span class="hljs-keyword">if</span>(self-&gt;si-&gt;si_signo == SIGILL)<br>        &#123;<br>            <span class="hljs-keyword">uint32_t</span> instruction = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">xcd_util_ptrace_read</span>(self-&gt;pid, (<span class="hljs-keyword">uintptr_t</span>)addr, &amp;instruction, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(instruction));<br>            <span class="hljs-built_in">snprintf</span>(addr_desc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr_desc), <span class="hljs-string">&quot;%p (*pc=%#08x)&quot;</span>, addr, instruction);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">snprintf</span>(addr_desc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr_desc), <span class="hljs-string">&quot;%p&quot;</span>, addr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">snprintf</span>(addr_desc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr_desc), <span class="hljs-string">&quot;--------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//from</span><br>    <span class="hljs-keyword">char</span> sender_desc[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">xcc_util_signal_has_sender</span>(self-&gt;si, self-&gt;pid))<br>    &#123;<br>        <span class="hljs-built_in">snprintf</span>(sender_desc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sender_desc), <span class="hljs-string">&quot; from pid %d, uid %d&quot;</span>, self-&gt;si-&gt;si_pid, self-&gt;si-&gt;si_uid);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">xcc_util_write_format</span>(log_fd, <span class="hljs-string">&quot;signal %d (%s), code %d (%s%s), fault addr %s\n&quot;</span>,<br>                                 self-&gt;si-&gt;si_signo, <span class="hljs-built_in">xcc_util_get_signame</span>(self-&gt;si),<br>                                 self-&gt;si-&gt;si_code, <span class="hljs-built_in">xcc_util_get_sigcodename</span>(self-&gt;si),<br>                                 sender_desc, addr_desc);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0<br></code></pre></div></td></tr></table></figure><h3 id="Registers-Info"><a href="#Registers-Info" class="headerlink" title="Registers Info"></a>Registers Info</h3><p>打印寄存器（<code>Register</code>）的值，下面是 ARM64 的例子，它有 30 个通用寄存器</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>x0</td><td>一般表示返回值</td></tr><tr><td>x1 ~ x7</td><td>般是函数的参数，大于 8 个的会通过堆传参</td></tr><tr><td>lr</td><td>链接寄存器，存放着函数的返回地址</td></tr><tr><td>sp</td><td>堆栈顶寄存器，用于指向每个函数调用栈的栈顶</td></tr><tr><td>pc</td><td>表示当前执行的指令的地址</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">x0  0000000000000003  x1  0000000000000000  x2  000000751128fd60  x3  0000007511290020<br>x4  000000751128fd60  x5  00000075a26c1708  x6  000000751128fd50  x7  00000075200a59dc<br>x8  0000000000000000  x9  79fc7e30c0ff4d9e  x10 00000000000003e8  x11 0000000000000000<br>x12 0000000000004100  x13 0000000000000001  x14 0000000000080100  x15 0000000000000000<br>x16 00000074b9be4d20  x17 00000074b9bcc86c  x18 00000075a57fa000  x19 00000075a4f52000<br>x20 0000000000000000  x21 00000075a4f52000  x22 0000007fe0ef23a0  x23 00000074bb1b62fe<br>x24 0000000000000004  x25 00000075a5107020  x26 00000075a4f520b0  x27 0000000000000001<br>x28 0000007fe0ef2130  x29 0000007fe0ef2090<br>sp  0000007fe0ef2070  lr  00000074b9bcc8cc  pc  00000074b9bcc884<br></code></pre></div></td></tr></table></figure><p>通过 <code>ptrace</code>，一个线程（<code>tracer</code>）可以观察并控制另一线程（<code>tracee</code>）的执行、读取/修改它的内存和寄存器，比如单步调试（debugger）；tracer 和 tracee 都是线程，而不是进程（虽然 ptrace 的参数里写的是 pid）；它的一般用法是这样的：</p><ul><li><code>PTRACE_ATTACH</code>：使当前线程成为 tracer，pid 指定的线程成为 tracee</li><li><code>waitpid</code>：PTRACE_ATTACH 发送 SIGSTOP 给 tracee 但它不一定立刻 stop，所以需要 tracer 等待 tracee</li><li><code>PTRACE_PEEKDATA</code>（读内存）、 <code>PTRACE_POKEDATA</code>（写内存）、<code>PTRACE_GETREGS</code>（读寄存器）、<code>PTRACE_SETREGS</code>（写寄存器）…</li><li><code>PTRACE_DETACH</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">ptrace</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> __ptrace_request request, <span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">void</span> *data)</span></span>;<br><br><span class="hljs-comment">// 通过 ptrace 获取寄存器的值并保存到 xcd_thread_t.regs</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xcd_thread_load_regs</span><span class="hljs-params">(<span class="hljs-keyword">xcd_thread_t</span> *self)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uintptr_t</span> regs[<span class="hljs-number">64</span>]; <span class="hljs-comment">//big enough for all architectures</span><br>    <span class="hljs-keyword">size_t</span>    regs_len;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">ptrace</span>(PTRACE_GETREGS, self-&gt;tid, <span class="hljs-literal">NULL</span>, &amp;regs))<br>    &#123;<br>        <span class="hljs-built_in">XCD_LOG_ERROR</span>(<span class="hljs-string">&quot;THREAD: ptrace GETREGS failed, errno=%d&quot;</span>, errno);<br>        self-&gt;status = XCD_THREAD_STATUS_REGS;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    regs_len = XCD_REGS_USER_NUM;<br>    <span class="hljs-built_in">xcd_regs_load_from_ptregs</span>(&amp;(self-&gt;regs), regs, regs_len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">xcd_regs_load_from_ptregs</span><span class="hljs-params">(<span class="hljs-keyword">xcd_regs_t</span> *self, <span class="hljs-keyword">uintptr_t</span> *regs, <span class="hljs-keyword">size_t</span> regs_len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(regs_len &gt; XCD_REGS_USER_NUM) regs_len = XCD_REGS_USER_NUM;<br>    <span class="hljs-built_in">memcpy</span>(&amp;(self-&gt;r), regs, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uintptr_t</span>) * regs_len);<br>&#125;<br><br><span class="hljs-comment">// 打印寄存器的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xcd_regs_record</span><span class="hljs-params">(<span class="hljs-keyword">xcd_regs_t</span> *self, <span class="hljs-keyword">int</span> log_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">xcc_util_write_format</span>(log_fd,<br>                                 <span class="hljs-string">&quot;    x0  %016lx  x1  %016lx  x2  %016lx  x3  %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x4  %016lx  x5  %016lx  x6  %016lx  x7  %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x8  %016lx  x9  %016lx  x10 %016lx  x11 %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x12 %016lx  x13 %016lx  x14 %016lx  x15 %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x16 %016lx  x17 %016lx  x18 %016lx  x19 %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x20 %016lx  x21 %016lx  x22 %016lx  x23 %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x24 %016lx  x25 %016lx  x26 %016lx  x27 %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    x28 %016lx  x29 %016lx\n&quot;</span><br>                                 <span class="hljs-string">&quot;    sp  %016lx  lr  %016lx  pc  %016lx\n\n&quot;</span>,<br>                                 self-&gt;r[XCD_REGS_X0],  self-&gt;r[XCD_REGS_X1],  self-&gt;r[XCD_REGS_X2],  self-&gt;r[XCD_REGS_X3],<br>                                 self-&gt;r[XCD_REGS_X4],  self-&gt;r[XCD_REGS_X5],  self-&gt;r[XCD_REGS_X6],  self-&gt;r[XCD_REGS_X7],<br>                                 self-&gt;r[XCD_REGS_X8],  self-&gt;r[XCD_REGS_X9],  self-&gt;r[XCD_REGS_X10], self-&gt;r[XCD_REGS_X11],<br>                                 self-&gt;r[XCD_REGS_X12], self-&gt;r[XCD_REGS_X13], self-&gt;r[XCD_REGS_X14], self-&gt;r[XCD_REGS_X15],<br>                                 self-&gt;r[XCD_REGS_X16], self-&gt;r[XCD_REGS_X17], self-&gt;r[XCD_REGS_X18], self-&gt;r[XCD_REGS_X19],<br>                                 self-&gt;r[XCD_REGS_X20], self-&gt;r[XCD_REGS_X21], self-&gt;r[XCD_REGS_X22], self-&gt;r[XCD_REGS_X23],<br>                                 self-&gt;r[XCD_REGS_X24], self-&gt;r[XCD_REGS_X25], self-&gt;r[XCD_REGS_X26], self-&gt;r[XCD_REGS_X27],<br>                                 self-&gt;r[XCD_REGS_X28], self-&gt;r[XCD_REGS_X29],<br>                                 self-&gt;r[XCD_REGS_SP],  self-&gt;r[XCD_REGS_LR],  self-&gt;r[XCD_REGS_PC]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><h4 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/pid/maps"></a>/proc/pid/maps</h4><p><code>/proc/pid/maps</code> 包含了进程所有的内存映射（<code>mmap</code>）信息，后续的步骤需要用它来查找 <strong>函数名</strong> 及其所在的 <strong>文件路径</strong>，它的内容大概是这样的（参考 <code>man mmap.2</code> &amp; <code>man proc.5</code>）：</p><table><thead><tr><th>列</th><th>描述</th></tr></thead><tbody><tr><td>address</td><td>内存映射所在的进程的虚拟地址空间（开始地址 - 结束地址）</td></tr><tr><td>perms</td><td>这块内存的读写权限：r = read，w = write，x = execute，s = shared，p = private (copy on write)</td></tr><tr><td>offset</td><td>映射至内存的文件（或者其他东西）的起始偏移</td></tr><tr><td>dev</td><td>文件所在的设备（major:minor）</td></tr><tr><td>inode</td><td>文件的 inode</td></tr><tr><td>path</td><td>文件的路径</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">address                perms  offset    dev     inode     pathname<br>12c00000-32c00000      rw-p   00000000  00:00   0         [anon:dalvik-main space (region space)]<br>70fb9000-71248000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot.art]<br>71248000-712a3000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-core-libart.art]<br>712a3000-7136f000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-core-icu4j.art]<br>7136f000-713a6000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-okhttp.art]<br>713a6000-713ea000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-bouncycastle.art]<br>713ea000-713f9000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-apache-xml.art]<br>713f9000-71479000      r--p   00000000  fc:00   150       /apex/com.android.art/javalib/arm64/boot.oat<br>...                                                       <br>7e1f72d000-7e1f778000  r--s   00000000  fc:00   2605      /system/fonts/Roboto-Medium.ttf<br>7e1f778000-7e1f779000  r--p   00000000  fc:00   6422      /system/system_ext/lib64/libqti-at.so<br>7e1f779000-7e1f77a000  r-xp   00001000  fc:00   6422      /system/system_ext/lib64/libqti-at.so<br>7e1f77a000-7e1f77b000  r--p   00002000  fc:00   6422      /system/system_ext/lib64/libqti-at.so<br>7e1f7a0000-7e1f7ab000  r--p   00000000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so<br>7e1f7ab000-7e1f7b5000  r-xp   0000b000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so<br>7e1f7b5000-7e1f7b7000  r--p   00015000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so<br>7e1f7b7000-7e1f7b8000  rw-p   00016000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so<br>7e1f86b000-7e1fb0e000  r--p   00000000  103:0f  5128711   /data/data/xcrash.sample/code_cache/.overlay/base.apk/classes.dex<br>7e1fb0e000-7e1fbd4000  r-xp   00000000  103:0f  5096166   /data/data/xcrash.sample/code_cache/startup_agents/e4ee8c59-agent.so<br>7e1fbd4000-7e1fbe3000  ---p   00000000  00:00   0         <br>7e1fbe3000-7e1fbec000  rw-p   000c5000  103:0f  5096166   /data/data/xcrash.sample/code_cache/startup_agents/e4ee8c59-agent.so<br>...                                                       <br>7e24946000-7e24987000  r--s   0001d000  103:0f  180482    /data/app/~~jln4G3nGOa7-pv4aJFN6jg==/xcrash.sample-icj_DCtDvU5ZX6MZSDcn4Q==/base.apk<br>...                                                        <br>7e347f9000-7e34800000  r--s   001be000  103:0f  180482    /data/app/~~jln4G3nGOa7-pv4aJFN6jg==/xcrash.sample-icj_DCtDvU5ZX6MZSDcn4Q==/base.apk<br>...                                                 <br></code></pre></div></td></tr></table></figure><h4 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h4><p><img src="../../../../image/2021-06-22-xcrash/elf.png" alt="ELF Format"></p><p>Linux 下的可执行文件（<code>executable</code>）和共享库文件（<code>so - Shared Object</code>）都是 ELF 格式（<code>Executable and Linking Format</code>）</p><p><code>ELF Header</code> 里的 <code>e_type</code> 指明这是一个什么类型的文件：</p><table><thead><tr><th>e_type</th><th>desc</th></tr></thead><tbody><tr><td>ET_NONE</td><td>An unknown type</td></tr><tr><td>ET_REL</td><td>A relocatable file</td></tr><tr><td>ET_EXEC</td><td>An executable file</td></tr><tr><td>ET_DYN</td><td>A shared object</td></tr><tr><td>ET_CORE</td><td>A core file</td></tr></tbody></table><p>ELF 里有很多 <code>Section</code>，每个 Section 都是一段连续的地址保存了相同类型的数据，具体到哪个 Section 在哪里有多大定义在 <code>Section Header</code> 里，它的一些重要成员属性有：</p><table><thead><tr><th>Fields</th><th>Desc</th></tr></thead><tbody><tr><td>sh_name</td><td>name of the section. Its value is an index into the string section</td></tr><tr><td>sh_type</td><td>SHT_SYMTAB（符号表）、SHT_STRTAB（字符串表）等等</td></tr><tr><td>sh_offset</td><td>Section 在文件里的位置</td></tr><tr><td>sh_size</td><td>Section 的大小</td></tr></tbody></table><p>所有的 Section Header 组成一个数组 <code>Section Header Table</code>，它的位置和大小则是在 ELF Header 里定义的：</p><table><thead><tr><th>Fields</th><th>desc</th></tr></thead><tbody><tr><td>e_shoff</td><td>SHT 所在的位置</td></tr><tr><td>e_shsize</td><td>SHT 的大小</td></tr><tr><td>e_shentsize</td><td>每个 Section Header 的大小</td></tr><tr><td>e_shnum</td><td>Section Header 的数量</td></tr><tr><td>e_shstrndx</td><td>Name Section 在 SHT 的索引（所谓的 Name Section 其实就是专门保存字符串的 Section，类似于 dex 里的字符串池）</td></tr></tbody></table><p><code>Symbol Table</code> 是一个很重要的 Section，它的结构如下：</p><table><thead><tr><th>Fields</th><th>Desc</th></tr></thead><tbody><tr><td>st_name</td><td>symbol name (index of string section)</td></tr><tr><td>st_value</td><td>symbol value</td></tr><tr><td>st_size</td><td>This member holds zero if the symbol has no size or an unknown size</td></tr><tr><td>st_info</td><td>type and binding attributes <br> STT_FUNC (a function or other executable code) <br> STT_OBJECT (data object) <br> STB_LOCAL (Local symbols are not visible outside the object file) <br> STB_GLOBAL (Global symbols are visible to all object files being combined)…</td></tr><tr><td>st_other</td><td>symbol visibility <br> STV_DEFAULT (Global and weak symbols are available to other modules; references in the local module can be interposed by definitions in other modules) <br> STV_HIDDEN (Symbol is unavailable to other modules) <br> STV_PROTECTED (Symbol is available to other modules)</td></tr></tbody></table><p>可以用 <code>readelf</code> 命令查看 ELF 文件的结构，以 <code>/apex/com.android.art/lib64/libart.so</code> 为例，<code>readelf -S -W libart.so</code> 输出 Section Header Table</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">There are 28 section headers, starting at offset 0x7d8af8:<br><br>Section Headers:<br>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al<br>  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0<br>  [ 1] .note.android.ident NOTE            0000000000000270 000270 000018 00   A  0   0  4<br>  [ 2] .note.gnu.build-id NOTE            0000000000000288 000288 000020 00   A  0   0  4<br>  [ 3] .dynsym           DYNSYM          00000000000002a8 0002a8 021d50 18   A  7   1  8<br>  [ 4] .gnu.version      VERSYM          0000000000021ff8 021ff8 002d1c 02   A  3   0  2<br>  [ 5] .gnu.version_r    VERNEED         0000000000024d14 024d14 000100 00   A  7   7  4<br>  [ 6] .gnu.hash         GNU_HASH        0000000000024e18 024e18 0085d4 00   A  3   0  8<br>  [ 7] .dynstr           STRTAB          000000000002d3ec 02d3ec 05c8eb 00   A  0   0  1<br>  [ 8] .rela.dyn         LOOS+0x2        0000000000089cd8 089cd8 0005f9 01   A  3   0  8<br>  [ 9] .relr.dyn         LOOS+0xfffff00  000000000008a2d8 08a2d8 000490 08   A  0   0  8<br>  [10] .rela.plt         RELA            000000000008a768 08a768 002fb8 18   A  3  21  8<br>  [11] .rodata           PROGBITS        000000000008d720 08d720 03cec6 00 AMS  0   0 16<br>  [12] .eh_frame_hdr     PROGBITS        00000000000ca5e8 0ca5e8 01083c 00   A  0   0  4<br>  [13] .eh_frame         PROGBITS        00000000000dae28 0dae28 04de74 00   A  0   0  8<br>  [14] .text             PROGBITS        0000000000129000 129000 51c160 00  AX  0   0 512<br>  [15] .plt              PROGBITS        0000000000645160 645160 001ff0 00  AX  0   0 16<br>  [16] .data.rel.ro      PROGBITS        0000000000648000 648000 00e808 00  WA  0   0  8<br>  [17] .fini_array       FINI_ARRAY      0000000000656808 656808 000010 00  WA  0   0  8<br>  [18] .init_array       INIT_ARRAY      0000000000656818 656818 000060 00  WA  0   0  8<br>  [19] .dynamic          DYNAMIC         0000000000656878 656878 0002b0 10  WA  7   0  8<br>  [20] .got              PROGBITS        0000000000656b28 656b28 000978 00  WA  0   0  8<br>  [21] .got.plt          PROGBITS        00000000006574a0 6574a0 001000 00  WA  0   0  8<br>  [22] .data             PROGBITS        00000000006594a0 6584a0 002879 00  WA  0   0  8<br>  [23] .bss              NOBITS          000000000065bd20 65ad19 002c90 00  WA  0   0  8<br>  [24] .comment          PROGBITS        0000000000000000 65ad19 00016b 01  MS  0   0  1<br>  [25] .symtab           SYMTAB          0000000000000000 65ae88 08d678 18     27 18360  8<br>  [26] .shstrtab         STRTAB          0000000000000000 6e8500 00010c 00      0   0  1<br>  [27] .strtab           STRTAB          0000000000000000 6e860c 0f04e7 00      0   0  1<br>Key to Flags:<br>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>  L (link order), O (extra OS processing required), G (group), T (TLS),<br>  C (compressed), x (unknown), o (OS specific), E (exclude),<br>  p (processor specific)<br></code></pre></div></td></tr></table></figure><p><code>readelf -p .dynstr libart.so</code> 输出字符串表：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">String dump of section &#x27;.dynstr&#x27;:<br>  [     1]  __cxa_atexit<br>  [     e]  __cxa_finalize<br>  [    1d]  _ZN3art14AotClassLinkerC2EPNS_11InternTableE<br>  [    4a]  _ZN3art11ClassLinkerC2EPNS_11InternTableEb<br>  [    75]  _ZN3art14AotClassLinkerD2Ev<br>  [    91]  _ZN3art11ClassLinkerD2Ev<br>  [    aa]  _ZN3art14AotClassLinkerD0Ev<br>  [    c6]  _ZdlPv<br>  [    cd]  _ZN3art14AotClassLinker13CanAllocClassEv<br>  [    f6]  _ZNK3art7Runtime19IsActiveTransactionEv<br>  [   11e]  _ZN3art7Runtime34AbortTransactionAndThrowAbortErrorEPNS_6ThreadERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE<br>  [   1a1]  _ZN3art14AotClassLinker15InitializeClassEPNS_6ThreadENS_6HandleINS_6mirror5ClassEEEbb<br>  [   1f7]  _ZNK3art7Runtime29IsActiveStrictTransactionModeEv<br>  [   229]  _ZN3art11ClassLinker15InitializeClassEPNS_6ThreadENS_6HandleINS_6mirror5ClassEEEbb<br>  [   27c]  _ZNK3art2gc4Heap24ObjectIsInBootImageSpaceENS_6ObjPtrINS_6mirror6ObjectEEE<br>  [   2c7]  _ZN3art6mirror6Object12PrettyTypeOfEv<br>  [   2ed]  _ZN3art6mirror5Class16IsThrowableClassEv<br>  [   316]  _ZN7android4base10LogMessageC1EPKcjNS0_11LogSeverityES3_i<br></code></pre></div></td></tr></table></figure><p><code>readelf -s libart.so</code> 输出符号表：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Symbol table &#x27;.dynsym&#x27; contains 5774 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND <br>     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)<br>     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)<br>     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZdlPv<br>     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN7android4base10LogMess<br>   ...<br>   809: 0000000000132340   620 FUNC    LOCAL  HIDDEN    14 art_quick_invoke_stub<br>   810: 00000000001325b0   640 FUNC    LOCAL  HIDDEN    14 art_quick_invoke_static_s<br>   811: 000000000013ba10   292 FUNC    LOCAL  HIDDEN    14 art_quick_proxy_invoke_ha<br>   812: 000000000013c100   256 FUNC    LOCAL  HIDDEN    14 art_quick_instrumentation<br>   813: 000000000013be40   336 FUNC    LOCAL  HIDDEN    14 art_quick_generic_jni_tra<br>   814: 000000000013bfa0   248 FUNC    LOCAL  HIDDEN    14 art_quick_to_interpreter_<br>   815: 000000000013c210   480 FUNC    LOCAL  HIDDEN    14 art_quick_instrumentation<br>   816: 000000000013bd00   304 FUNC    LOCAL  HIDDEN    14 art_quick_resolution_tram<br>   817: 000000000013bb40   432 FUNC    LOCAL  HIDDEN    14 art_quick_imt_conflict_tr<br>   818: 000000000013c0a0    80 FUNC    LOCAL  HIDDEN    14 art_invoke_obsolete_metho<br>   819: 000000000013c400   164 FUNC    LOCAL  HIDDEN    14 art_quick_deoptimize<br>   ...<br></code></pre></div></td></tr></table></figure><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>通过 <code>ptrace</code> 可以拿到 PC 寄存器的值，它指向正在执行的代码的地址；拿 pc 去 <code>/proc/pid/maps</code> 里找，看 pc 落在哪块 <code>mmap</code> 上，从而得知这段代码在哪个 so 文件里；so 文件是 ELF 结构，解析出它里面的符号表及其偏移，pc - mmap.start 就是这段代码在这块 mmap 上的偏移，再加上 mmap.offset 内存映射的偏移就是这段代码在 so 文件里的偏移，从而得知这段代码在哪个符号/函数里（函数名）</p><blockquote><p>但是怎么从 pc 回溯整个函数调用栈我还没有想明白</p></blockquote><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>打印调用栈，别看代码这么长，其实关键就是这么几个：</p><table><thead><tr><th>Fields</th><th>Desc</th></tr></thead><tbody><tr><td>xcd_frame.rel_pc</td><td>函数在它所在的内存映射的偏移</td></tr><tr><td>xcd_frame.map.name</td><td>函数所在 so 文件路径</td></tr><tr><td>xcd_frame.func_name</td><td>函数名</td></tr><tr><td>xcd_frame.func_offset</td><td>函数与 pc 的偏移</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xcd_thread_record_backtrace</span><span class="hljs-params">(<span class="hljs-keyword">xcd_thread_t</span> *self, <span class="hljs-keyword">int</span> log_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(XCD_THREAD_STATUS_OK != self-&gt;status) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//ignore</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">xcd_frames_record_backtrace</span>(self-&gt;frames, log_fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xcd_frames_record_backtrace</span><span class="hljs-params">(<span class="hljs-keyword">xcd_frames_t</span> *self, <span class="hljs-keyword">int</span> log_fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">xcd_frame_t</span> *frame;<br>    <span class="hljs-keyword">xcd_elf_t</span>   *elf;<br>    <span class="hljs-keyword">char</span>        *name;<br>    <span class="hljs-keyword">char</span>         name_buf[<span class="hljs-number">512</span>];<br>    <span class="hljs-keyword">char</span>        *name_embedded;<br>    <span class="hljs-keyword">char</span>        *offset;<br>    <span class="hljs-keyword">char</span>         offset_buf[<span class="hljs-number">64</span>];<br>    <span class="hljs-keyword">char</span>        *func;<br>    <span class="hljs-keyword">char</span>         func_buf[<span class="hljs-number">512</span>];<br>    <span class="hljs-keyword">int</span>          r;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_util_write_str</span>(log_fd, <span class="hljs-string">&quot;backtrace:\n&quot;</span>))) <span class="hljs-keyword">return</span> r;<br>    <br>    <span class="hljs-built_in">TAILQ_FOREACH</span>(frame, &amp;(self-&gt;frames), link)<br>    &#123;<br>        <span class="hljs-comment">//name</span><br>        name = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == frame-&gt;map)<br>        &#123;<br>            name = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == frame-&gt;map-&gt;name || <span class="hljs-string">&#x27;\0&#x27;</span> == frame-&gt;map-&gt;name[<span class="hljs-number">0</span>])<br>        &#123;<br>            <span class="hljs-built_in">snprintf</span>(name_buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(name_buf), <span class="hljs-string">&quot;&lt;anonymous:%&quot;</span>XCC_UTIL_FMT_ADDR<span class="hljs-string">&quot;&gt;&quot;</span>, frame-&gt;map-&gt;start);<br>            name = name_buf;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != frame-&gt;map-&gt;elf_start_offset)<br>            &#123;<br>                elf = <span class="hljs-built_in">xcd_map_get_elf</span>(frame-&gt;map, self-&gt;pid, (<span class="hljs-keyword">void</span> *)self-&gt;maps);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != elf)<br>                &#123;<br>                    name_embedded = <span class="hljs-built_in">xcd_elf_get_so_name</span>(elf);<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != name_embedded &amp;&amp; <span class="hljs-built_in">strlen</span>(name_embedded) &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">snprintf</span>(name_buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(name_buf), <span class="hljs-string">&quot;%s!%s&quot;</span>, frame-&gt;map-&gt;name, name_embedded);<br>                        name = name_buf;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == name) name = frame-&gt;map-&gt;name;<br>        &#125;<br><br>        <span class="hljs-comment">//offset</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != frame-&gt;map &amp;&amp; <span class="hljs-number">0</span> != frame-&gt;map-&gt;elf_start_offset)<br>        &#123;<br>            <span class="hljs-built_in">snprintf</span>(offset_buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(offset_buf), <span class="hljs-string">&quot; (offset 0x%&quot;</span>PRIxPTR<span class="hljs-string">&quot;)&quot;</span>, frame-&gt;map-&gt;elf_start_offset);<br>            offset = offset_buf;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            offset = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//func</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != frame-&gt;func_name)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(frame-&gt;func_offset &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">snprintf</span>(func_buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(func_buf), <span class="hljs-string">&quot; (%s+%zu)&quot;</span>, frame-&gt;func_name, frame-&gt;func_offset);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">snprintf</span>(func_buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(func_buf), <span class="hljs-string">&quot; (%s)&quot;</span>, frame-&gt;func_name);<br>            func = func_buf;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            func = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_util_write_format</span>(log_fd, <span class="hljs-string">&quot;    #%02zu pc %0&quot;</span>XCC_UTIL_FMT_ADDR<span class="hljs-string">&quot;  %s%s%s\n&quot;</span>,<br>                                           frame-&gt;num, frame-&gt;rel_pc, name, offset, func))) <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_util_write_str</span>(log_fd, <span class="hljs-string">&quot;\n&quot;</span>))) <span class="hljs-keyword">return</span> r;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">backtrace:<br>    #00 pc 000000000000b884  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_4+24)<br>    #01 pc 000000000000b8c8  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_3+24)<br>    #02 pc 000000000000b8f8  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_2+24)<br>    #03 pc 000000000000b920  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_1+16)<br>    #04 pc 000000000000b9b4  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_crash+124)<br>    #05 pc 000000000013f350  /apex/com.android.runtime/lib64/libart.so (art_quick_generic_jni_trampoline+144)<br>    #06 pc 00000000001365b8  /apex/com.android.runtime/lib64/libart.so (art_quick_invoke_static_stub+568)<br>    #07 pc 0000000000145084  /apex/com.android.runtime/lib64/libart.so (_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc+276)<br>    #08 pc 00000000002e3bc0  /apex/com.android.runtime/lib64/libart.so (_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPNS_11ShadowFrameEtPNS_6JValueE+384)<br>    #09 pc 00000000002deab8  /apex/com.android.runtime/lib64/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+928)<br>    #10 pc 00000000005a4e3c  /apex/com.android.runtime/lib64/libart.so (MterpInvokeStatic+368)<br>    #11 pc 0000000000130994  /apex/com.android.runtime/lib64/libart.so (mterp_op_invoke_static+20)<br>    #12 pc 00000000005a2564  /apex/com.android.runtime/lib64/libart.so (MterpInvokeVirtual+1456)<br>    #13 pc 0000000000130814  /apex/com.android.runtime/lib64/libart.so (mterp_op_invoke_virtual+20)<br>    #14 pc 00000000005a5154  /apex/com.android.runtime/lib64/libart.so (MterpInvokeStatic+1160)<br>    #15 pc 0000000000130994  /apex/com.android.runtime/lib64/libart.so (mterp_op_invoke_static+20)<br>    ...<br></code></pre></div></td></tr></table></figure><h3 id="Stack-Per-Frame"><a href="#Stack-Per-Frame" class="headerlink" title="Stack (Per Frame)"></a>Stack (Per Frame)</h3><p>这里打印的是上个章节 <code>Backtrace</code> 描述的函数调用栈里，每一帧（<code>Frame</code>）对应的栈内存，sp 寄存器指向栈顶</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">stack:<br>         0000007fe0ef1ff0  0000000be0ef2260<br>         0000007fe0ef1ff8  00000075a5107020<br>         0000007fe0ef2000  0000007fe0ef2001  [stack]<br>         0000007fe0ef2008  0000007511197000<br>         0000007fe0ef2010  00000000000fd000<br>         0000007fe0ef2018  0000007511290018<br>         0000007fe0ef2020  0000007511197000<br>         0000007fe0ef2028  0000007511290018<br>         0000007fe0ef2030  0000007f00000000<br>         0000007fe0ef2038  0000007511197000<br>         0000007fe0ef2040  00000000000f8d50<br>         0000007fe0ef2048  0000000000001000<br>         0000007fe0ef2050  0000000000000000<br>         0000007fe0ef2058  0000000000000000<br>         0000007fe0ef2060  00000075a4ff8000  [anon:libc_malloc]<br>         0000007fe0ef2068  000000006f5df020  /system/framework/arm64/boot-framework.art<br>    #00  0000007fe0ef2070  0000000000000000<br>         0000007fe0ef2078  000000030000ddd5<br>    #01  0000007fe0ef2080  0000007fe0ef2130  [stack]<br>         0000007fe0ef2088  0000000200000001<br>         0000007fe0ef2090  0000007fe0ef20b0  [stack]<br>         0000007fe0ef2098  00000074b9bcc8fc  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_2+28)<br>    #02  0000007fe0ef20a0  0000000000000004<br>         0000007fe0ef20a8  0000000100000000<br>         0000007fe0ef20b0  0000007fe0ef20d0  [stack]<br></code></pre></div></td></tr></table></figure><h3 id="Memory-Near-XX"><a href="#Memory-Near-XX" class="headerlink" title="Memory Near XX"></a>Memory Near XX</h3><p>打印所有寄存器地址附近的内存，寄存器的值可以通过 <code>ptrace</code> 拿到</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">memory near x2:<br>    000000751128fd40 0000000000000000 0000000000000000  ................<br>    000000751128fd50 000000751138cd50 0000000000000000  P.8.u...........<br>    000000751128fd60 00005015000050c4 0000007f00000000  .P...P..........<br>    000000751128fd70 0000007511197000 00000000000f8d50  .p..u...P.......<br>    000000751128fd80 0000000000001000 0000000000000000  ................<br>    000000751128fd90 0000000000000000 00000075a4ff8000  ............u...<br>    000000751128fda0 0000000000000003 0000000000000000  ................<br>    000000751128fdb0 00000074b9bcc9dc 0000000000000000  ....t...........<br>    000000751128fdc0 0000000000000000 00000075a4e67000  .........p..u...<br>    000000751128fdd0 00000074c5b3b000 0000000000000001  ....t...........<br>    000000751128fde0 0000007511197000 00000000000fd000  .p..u...........<br>    000000751128fdf0 0000000000000000 0000000000000000  ................<br>    000000751128fe00 0000000000000000 0000000000000000  ................<br>    000000751128fe10 0000000000000000 0000000000000000  ................<br>    000000751128fe20 0000000000000000 0000000000000000  ................<br>    000000751128fe30 0000000000000000 0000000000000000  ................<br><br>memory near x3:<br>    0000007511290000 0000007511290060 0000000000000000  `.).u...........<br>    0000007511290010 0000000000000000 0000007511290060  ........`.).u...<br>    0000007511290020 00000075a2606c90 000000751128fd50  .l`.u...P.(.u...<br>    0000007511290030 0000000000000000 0000000000000000  ................<br>    0000007511290040 0000000000000000 79fc7e30c0ff4d9e  .........M..0~.y<br>    0000007511290050 0000000000000000 0000000000000000  ................<br>    0000007511290060 0000000000000000 0000000000000000  ................<br>    0000007511290070 0000000000000000 0000000000000000  ................<br>    0000007511290080 0000000000000000 0000000000000000  ................<br>    0000007511290090 0000000000000000 0000000000000000  ................<br>    00000075112900a0 0000000000000000 0000000000000000  ................<br>    00000075112900b0 0000000000000000 0000000000000000  ................<br>    00000075112900c0 0000000000000000 0000000000000000  ................<br>    00000075112900d0 0000000000000000 0000000000000000  ................<br>    00000075112900e0 0000000000000000 0000000000000000  ................<br>    00000075112900f0 0000000000000000 0000000000000000  ................<br></code></pre></div></td></tr></table></figure><h3 id="Memory-Map"><a href="#Memory-Map" class="headerlink" title="Memory Map"></a>Memory Map</h3><p>也就是 <code>/proc/pid/maps</code> 内存映射</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">memory map:<br>    0000000012c00000-00000000133c0000 rw-        0   7c0000 [anon:dalvik-main space (region space)]<br>    00000000133c0000-0000000013dc0000 ---        0   a00000 &gt;<br>    0000000013dc0000-0000000013f80000 ---        0   1c0000 &gt;<br>    0000000013f80000-0000000013fc0000 rw-        0    40000 &gt;<br>    0000000013fc0000-0000000014100000 ---        0   140000 &gt;<br>    0000000014100000-0000000014140000 rw-        0    40000 &gt;<br>    0000000014140000-0000000014200000 ---        0    c0000 &gt;<br>    0000000014200000-0000000014280000 ---        0    80000 &gt;<br>    0000000014280000-00000000163c0000 ---        0  2140000 &gt;<br>    00000000163c0000-0000000032c00000 rw-        0 1c840000 &gt;<br>    000000006f1a9000-000000006f430000 rw-        0   287000 /system/framework/arm64/boot.art<br>    000000006f430000-000000006f51f000 rw-        0    ef000 /system/framework/arm64/boot-core-libart.art<br>    000000006f51f000-000000006f555000 rw-        0    36000 /system/framework/arm64/boot-okhttp.art<br>    000000006f555000-000000006f596000 rw-        0    41000 /system/framework/arm64/boot-bouncycastle.art<br>    000000006f596000-000000006f5a6000 rw-        0    10000 /system/framework/arm64/boot-apache-xml.art<br>    000000006f5a6000-000000006fe62000 rw-        0   8bc000 /system/framework/arm64/boot-framework.art<br>    000000006fe62000-000000006fe95000 rw-        0    33000 /system/framework/arm64/boot-ext.art<br>    000000006fe95000-000000006ff8c000 rw-        0    f7000 /system/framework/arm64/boot-telephony-common.art<br>    000000006ff8c000-000000006ff9a000 rw-        0     e000 /system/framework/arm64/boot-voip-common.art<br>    000000006ff9a000-000000006ffaf000 rw-        0    15000 /system/framework/arm64/boot-ims-common.art<br>    000000006ffaf000-000000006ffb2000 rw-        0     3000 /system/framework/arm64/boot-android.test.base.art<br>    000000006ffb2000-000000007006b000 r--        0    b9000 /system/framework/arm64/boot.oat<br>    000000007006b000-0000000070300000 r-x    b9000   295000 &gt;<br>    0000000070300000-0000000070301000 rw-        0     1000 [anon:.bss]<br>    0000000070301000-0000000070303000 r--        0     2000 /system/framework/boot.vdex<br>    0000000070303000-0000000070304000 r--   34e000     1000 /system/framework/arm64/boot.oat<br>    0000000070304000-0000000070305000 rw-   34f000     1000 &gt;<br>    0000000070305000-000000007034e000 r--        0    49000 /system/framework/arm64/boot-core-libart.oat<br>    000000007034e000-0000000070453000 r-x    49000   105000 &gt;<br>    0000000070453000-0000000070454000 rw-        0     1000 [anon:.bss]<br>    0000000070454000-0000000070455000 r--        0     1000 /system/framework/boot-core-libart.vdex<br>    0000000070455000-0000000070456000 r--   14e000     1000 /system/framework/arm64/boot-core-libart.oat<br>    0000000070456000-0000000070457000 rw-   14f000     1000 &gt;<br>    0000000070457000-0000000070466000 r--        0     f000 /system/framework/arm64/boot-okhttp.oat<br></code></pre></div></td></tr></table></figure><h2 id="ANR-Trace"><a href="#ANR-Trace" class="headerlink" title="ANR Trace"></a>ANR Trace</h2><ol><li>给主线程注册 <code>SIGQUIT</code> 的信号处理器 <code>xc_trace_handler</code>，当主线程收到 SIGQUIT 信号时，恢复 <code>xc_trace_dumper</code>（dumper 线程），也就是说发生 ANR 时主线程是被 SIGQUIT 中断的而不是 SIGKILL (?)</li><li>启动 xc_trace_dumper（dumper 线程），挂起等待被主线程唤醒</li><li>在内存里找到生成 ANR 报告的函数符号：<code>_ZN3art7Runtime14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE</code></li><li>将 <code>STDERR_FILENO</code> 指向日志文件，调用 ANR 报告函数（它会把 ANR 日志写入 <code>STDERR_FILENO</code>），这样就捕获了 ANR 日志</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// XCrash.init</span><br><span class="hljs-comment">// NativeHandler.initialize</span><br><span class="hljs-comment">// NativeHandler.nativeInit</span><br><span class="hljs-comment">// xc_jni_init</span><br><br><span class="hljs-comment">// 起 dumper 线程，注册 SIGQUIT 处理器</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xc_trace_init</span><span class="hljs-params">(JNIEnv *env,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">int</span> rethrow,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> logcat_system_lines,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> logcat_events_lines,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> logcat_main_lines,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">int</span> dump_fds,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">int</span> dump_network_info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> r;<br>    <span class="hljs-keyword">pthread_t</span> thd;<br><br>    <span class="hljs-comment">//capture SIGQUIT only for ART</span><br>    <span class="hljs-keyword">if</span>(xc_common_api_level &lt; <span class="hljs-number">21</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//is Android Lollipop (5.x)?</span><br>    xc_trace_is_lollipop = ((<span class="hljs-number">21</span> == xc_common_api_level || <span class="hljs-number">22</span> == xc_common_api_level) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    xc_trace_dump_status = XC_TRACE_DUMP_NOT_START;<br>    xc_trace_rethrow = rethrow;<br>    xc_trace_logcat_system_lines = logcat_system_lines;<br>    xc_trace_logcat_events_lines = logcat_events_lines;<br>    xc_trace_logcat_main_lines = logcat_main_lines;<br>    xc_trace_dump_fds = dump_fds;<br>    xc_trace_dump_network_info = dump_network_info;<br><br>    <span class="hljs-comment">//init for JNI callback</span><br>    <span class="hljs-built_in">xc_trace_init_callback</span>(env);<br><br>    <span class="hljs-comment">//create event FD</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &gt; (xc_trace_notifier = <span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_CLOEXEC))) <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;<br><br>    <span class="hljs-comment">//register signal handler</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_signal_trace_register</span>(xc_trace_handler))) <span class="hljs-keyword">goto</span> err2;<br><br>    <span class="hljs-comment">//create thread for dump trace</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">pthread_create</span>(&amp;thd, <span class="hljs-literal">NULL</span>, xc_trace_dumper, <span class="hljs-literal">NULL</span>))) <span class="hljs-keyword">goto</span> err1;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err1:<br>    <span class="hljs-built_in">xcc_signal_trace_unregister</span>();<br> err2:<br>    <span class="hljs-built_in">close</span>(xc_trace_notifier);<br>    xc_trace_notifier = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-comment">// ANR 发生时，收到 SIGQUIT，此 dumper 线程唤醒，调用 ANR 报告函数</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xc_trace_dumper</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    JNIEnv         *env = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">uint64_t</span>        data;<br>    <span class="hljs-keyword">uint64_t</span>        trace_time;<br>    <span class="hljs-keyword">int</span>             fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>  <span class="hljs-title">tv</span>;</span><br>    <span class="hljs-keyword">char</span>            pathname[<span class="hljs-number">1024</span>];<br>    jstring         j_pathname;<br>    <br>    (<span class="hljs-keyword">void</span>)arg;<br>    <br>    <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br><br>    JavaVMAttachArgs attach_args = &#123;<br>        .version = XC_JNI_VERSION,<br>        .name    = <span class="hljs-string">&quot;xcrash_trace_dp&quot;</span>,<br>        .group   = <span class="hljs-literal">NULL</span><br>    &#125;;<br>    <span class="hljs-keyword">if</span>(JNI_OK != (*xc_common_vm)-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(xc_common_vm, &amp;env, &amp;attach_args)) <span class="hljs-keyword">goto</span> exit;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//block here, waiting for sigquit</span><br>        <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(xc_trace_notifier, &amp;data, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(data)));<br>        <br>        <span class="hljs-comment">//check if process already crashed</span><br>        <span class="hljs-keyword">if</span>(xc_common_native_crashed || xc_common_java_crashed) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">//trace time</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">gettimeofday</span>(&amp;tv, <span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">break</span>;<br>        trace_time = (<span class="hljs-keyword">uint64_t</span>)(tv.tv_sec) * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> + (<span class="hljs-keyword">uint64_t</span>)tv.tv_usec;<br><br>        <span class="hljs-comment">//Keep only one current trace.</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_logs_clean</span>()) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">//create and open log file</span><br>        <span class="hljs-keyword">if</span>((fd = <span class="hljs-built_in">xc_common_open_trace_log</span>(pathname, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pathname), trace_time)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">//write header info</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_write_header</span>(fd, trace_time)) <span class="hljs-keyword">goto</span> end;<br><br>        <span class="hljs-comment">//write trace info from ART runtime</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_format</span>(fd, XCC_UTIL_THREAD_SEP<span class="hljs-string">&quot;Cmd line: %s\n&quot;</span>, xc_common_process_name)) <span class="hljs-keyword">goto</span> end;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Mode: ART DumpForSigQuit\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_load_symbols</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to load symbols.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;<br>            <span class="hljs-keyword">goto</span> skip;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_check_address_valid</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to check runtime address.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;<br>            <span class="hljs-keyword">goto</span> skip;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dup2</span>(fd, STDERR_FILENO) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to duplicate FD.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;<br>            <span class="hljs-keyword">goto</span> skip;<br>        &#125;<br><br>        xc_trace_dump_status = XC_TRACE_DUMP_ON_GOING;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sigsetjmp</span>(jmpenv, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)<br>                <span class="hljs-built_in">xc_trace_libart_dbg_suspend</span>();<br>            <span class="hljs-built_in">xc_trace_libart_runtime_dump</span>(*xc_trace_libart_runtime_instance, xc_trace_libcpp_cerr);<br>            <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)<br>                <span class="hljs-built_in">xc_trace_libart_dbg_resume</span>();<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-built_in">fflush</span>(<span class="hljs-literal">NULL</span>);<br>            <span class="hljs-built_in">XCD_LOG_WARN</span>(<span class="hljs-string">&quot;longjmp to skip dumping trace\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">dup2</span>(xc_common_fd_null, STDERR_FILENO);<br>                            <br>    skip:<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;\n&quot;</span>XCC_UTIL_THREAD_END<span class="hljs-string">&quot;\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;<br><br>        <span class="hljs-comment">//write other info</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_logcat</span>(fd, xc_common_process_id, xc_common_api_level, xc_trace_logcat_system_lines, xc_trace_logcat_events_lines, xc_trace_logcat_main_lines)) <span class="hljs-keyword">goto</span> end;<br>        <span class="hljs-keyword">if</span>(xc_trace_dump_fds)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_fds</span>(fd, xc_common_process_id)) <span class="hljs-keyword">goto</span> end;<br>        <span class="hljs-keyword">if</span>(xc_trace_dump_network_info)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_network_info</span>(fd, xc_common_process_id, xc_common_api_level)) <span class="hljs-keyword">goto</span> end;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_meminfo_record</span>(fd, xc_common_process_id)) <span class="hljs-keyword">goto</span> end;<br><br>    end:<br>        <span class="hljs-comment">//close log file</span><br>        <span class="hljs-built_in">xc_common_close_trace_log</span>(fd);<br><br>        <span class="hljs-comment">//rethrow SIGQUIT to ART Signal Catcher</span><br>        <span class="hljs-keyword">if</span>(xc_trace_rethrow &amp;&amp; (XC_TRACE_DUMP_ART_CRASH != xc_trace_dump_status)) <span class="hljs-built_in">xc_trace_send_sigquit</span>();<br>        xc_trace_dump_status = XC_TRACE_DUMP_END;<br><br>        <span class="hljs-comment">//JNI callback</span><br>        <span class="hljs-comment">//Do we need to implement an emergency buffer for disk exhausted?</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == xc_trace_cb_method) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (j_pathname = (*env)-&gt;<span class="hljs-built_in">NewStringUTF</span>(env, pathname))) <span class="hljs-keyword">continue</span>;<br>        (*env)-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(env, xc_common_cb_class, xc_trace_cb_method, j_pathname, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">XC_JNI_IGNORE_PENDING_EXCEPTION</span>();<br>        (*env)-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(env, j_pathname);<br>    &#125;<br>    <br>    (*xc_common_vm)-&gt;<span class="hljs-built_in">DetachCurrentThread</span>(xc_common_vm);<br><br> exit:<br>    xc_trace_notifier = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">close</span>(xc_trace_notifier);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>uncaught exception</tag>
      
      <tag>exception</tag>
      
      <tag>崩溃</tag>
      
      <tag>崩溃日志</tag>
      
      <tag>crash</tag>
      
      <tag>xcrash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>killProcess 和 exit 的区别</title>
    <link href="/2021/06/20/kill-exit/"/>
    <url>/2021/06/20/kill-exit/</url>
    
    <content type="html"><![CDATA[<h2 id="Process-killProcess-pid"><a href="#Process-killProcess-pid" class="headerlink" title="Process.killProcess(pid)"></a>Process.killProcess(pid)</h2><p>最终执行系统调用 <code>kill</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Process</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL_KILL = <span class="hljs-number">9</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">killProcess</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid)</span> </span>&#123;<br>        sendSignal(pid, SIGNAL_KILL);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pid, <span class="hljs-keyword">int</span> signal)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// android_util_Process.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">android_os_Process_sendSignal</span><span class="hljs-params">(JNIEnv* env, jobject clazz, jint pid, jint sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;Sending signal. PID: %&quot;</span> PRId32 <span class="hljs-string">&quot; SIG: %&quot;</span> PRId32, pid, sig);<br>        <span class="hljs-built_in">kill</span>(pid, sig);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="signal（信号）"><a href="#signal（信号）" class="headerlink" title="signal（信号）"></a>signal（信号）</h3><p><strong>信号</strong> 是一个古老的、异步的 IPC 机制，一个进程可以给另一个进程发送信号（<code>kill</code>），收到信号（<code>SIGxxx</code>）的进程会暂停并进入相应的信号处理程序（<code>Signal Handlers</code>），信号处理程序是可以配置的</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kill -s sig pid<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">kill</span>(pid, sig)<br><br><span class="hljs-comment">// 自定义信号处理程序</span><br><span class="hljs-comment">// handler 可以是：SIG_IGN 忽略此信号，SIG_DFL 设置默认的信号处理程序，函数地址</span><br><span class="hljs-comment">// SIGKILL 和 SIGSTOP 是不可以忽略和自定义的</span><br><span class="hljs-built_in">signal</span>(signum, handler)<br></code></pre></div></td></tr></table></figure><h4 id="常见的信号"><a href="#常见的信号" class="headerlink" title="常见的信号"></a>常见的信号</h4><table><thead><tr><th>Singal</th><th>Number</th><th>Default Action</th><th>Desc</th></tr></thead><tbody><tr><td>SIGKILL</td><td>9</td><td>Terminate (core dump)</td><td>Kill (cannot be caught or ignored)</td></tr><tr><td>SIGSEGV</td><td>11</td><td>Terminate (core dump)</td><td>Invalid memory reference</td></tr><tr><td>SIGINT</td><td>2</td><td>Terminate</td><td>Terminal interrupt signal，常见于在控制台由 Ctrl-C 触发</td></tr><tr><td>SIGSTOP</td><td></td><td>Stop</td><td>Stop executing (cannot be caught or ignored)，常见于在控制台由 Ctrl-Z 触发</td></tr></tbody></table><h2 id="System-exit-status"><a href="#System-exit-status" class="headerlink" title="System.exit(status)"></a>System.exit(status)</h2><p>退出 VM 回到 native 代码，能够保证 shutdown hook 执行完，native 代码甚至可以重新进入 VM 或者做其他的事，进程没有被杀死，其他 native thread 也在正常运行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">System</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;<br>        Runtime.getRuntime().exit(status);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;<br>        <span class="hljs-comment">// Make sure we don&#x27;t try this several times</span><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!shuttingDown) &#123;<br>                shuttingDown = <span class="hljs-keyword">true</span>;<br><br>                Thread[] hooks;<br>                <span class="hljs-keyword">synchronized</span> (shutdownHooks) &#123;<br>                    <span class="hljs-comment">// create a copy of the hooks</span><br>                    hooks = <span class="hljs-keyword">new</span> Thread[shutdownHooks.size()];<br>                    shutdownHooks.toArray(hooks);<br>                &#125;<br><br>                <span class="hljs-comment">// Start all shutdown hooks concurrently</span><br>                <span class="hljs-keyword">for</span> (Thread hook : hooks) &#123;<br>                    hook.start();<br>                &#125;<br><br>                <span class="hljs-comment">// Wait for all shutdown hooks to finish</span><br>                <span class="hljs-keyword">for</span> (Thread hook : hooks) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        hook.join();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                        <span class="hljs-comment">// Ignore, since we are at VM shutdown.</span><br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// Ensure finalization on exit, if requested</span><br>                <span class="hljs-keyword">if</span> (finalizeOnExit) &#123;<br>                    runFinalization();<br>                &#125;<br><br>                <span class="hljs-comment">// Get out of here finally...</span><br>                nativeExit(status);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="shutdown-hook"><a href="#shutdown-hook" class="headerlink" title="shutdown hook"></a>shutdown hook</h3><p>通过 <code>Runtime.addShutdownHook(Thread)</code> 添加的任务确实可以在 <code>System.exit(status)</code> 时被执行，但就像 <a href="../../../../2021/06/18/uncaught-exception-handler/">Uncaught Exception Handling</a> 里描述的那样，主线程退出 VM 后虽然没有结束（在等待 shutdown hook 执行完毕），但它也不再消费分发过来的 input 事件导致出现 ANR 对话框，然后被用户杀死 app process，当然在进程被杀死前 shutdown hook 也有跟 uncaught exception handler 差不多长的生存时间</p>]]></content>
    
    
    
    <tags>
      
      <tag>kill</tag>
      
      <tag>exit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uncaught Exception Handling</title>
    <link href="/2021/06/18/uncaught-exception-handler/"/>
    <url>/2021/06/18/uncaught-exception-handler/</url>
    
    <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>根据 <code>Thread.setDefaultUncaughtExceptionHandler</code> 的方法文档</p><blockquote><p>Uncaught exception handling is controlled first by the thread, then by the thread’s ThreadGroup object and finally by the default uncaught exception handler. If the thread does not have an explicit uncaught exception handler set, and the thread’s thread group (including parent thread groups) does not specialize its uncaughtException method, then the default handler’s uncaughtException method will be invoked.</p></blockquote><p>当发生 <code>Uncaught Exception</code> 时，将会按照 <code>Thread.uncaughtExceptionHandler -&gt; ThreadGroup.uncaughtException -&gt; Thread.defaultUncaughtExceptionHandler</code> 的优先级次序去寻找异常处理器</p><p>而 <code>ThreadGroup.uncaughtException</code> 的默认实现仅仅是像事件冒泡那样把异常往上传递，跑到 root ThreadGroup 后中止冒泡并交由 <code>DefaultUncaughtExceptionHandler</code> 处理 or 打印至标准错误流，所以可以把 <code>ThreadGroup.uncaughtException</code> 当作透明的层忽略之</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        parent.uncaughtException(t, e);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Thread.UncaughtExceptionHandler ueh =<br>            Thread.getDefaultUncaughtExceptionHandler();<br>        <span class="hljs-keyword">if</span> (ueh != <span class="hljs-keyword">null</span>) &#123;<br>            ueh.uncaughtException(t, e);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> ThreadDeath)) &#123;<br>            System.err.print(<span class="hljs-string">&quot;Exception in thread \&quot;&quot;</span><br>                             + t.getName() + <span class="hljs-string">&quot;\&quot; &quot;</span>);<br>            e.printStackTrace(System.err);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面仅考虑 <code>Thread.uncaughtExceptionHandler</code>、<code>DefaultUncaughtExceptionHandler</code> 和 <code>主线程</code> 三个因素</p><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>Thread.uncaughtExceptionHandler/DefaultUncaughtExceptionHandler 可以捕获异常，但无法改变 app 被 blocked 住，然后出现 ANR（即使点击 <code>等待</code> 依然被 blocked 住），点击 <code>确定</code> 后被 kill 的命运</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">2021-06-12 11:13:29.464 28055-28055/com.example.myapplication D/AndroidRuntime: Shutting down VM<br><br>    --------- beginning of crash<br>2021-06-12 11:13:29.465 28055-28055/com.example.myapplication E/AndroidRuntime: FATAL EXCEPTION: main<br>    Process: com.example.myapplication, PID: 28055<br>    java.lang.RuntimeException: Test Exception<br>        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:58)<br>        at com.example.myapplication.MainActivity.onCreate$lambda-2(MainActivity.kt:30)<br>        at com.example.myapplication.MainActivity.lambda$hUPUYmntOngyO5ji3KzmjKQ19D4(Unknown Source:0)<br>        at com.example.myapplication.-$$Lambda$MainActivity$hUPUYmntOngyO5ji3KzmjKQ19D4.onClick(Unknown Source:0)<br>        at android.view.View.performClick(View.java:7509)<br>        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)<br>        at android.view.View.performClickInternal(View.java:7486)<br>        at android.view.View.access$3600(View.java:841)<br>        at android.view.View$PerformClick.run(View.java:28709)<br>        at android.os.Handler.handleCallback(Handler.java:938)<br>        at android.os.Handler.dispatchMessage(Handler.java:99)<br>        at android.os.Looper.loop(Looper.java:236)<br>        at android.app.ActivityThread.main(ActivityThread.java:8061)<br>        at java.lang.reflect.Method.invoke(Native Method)<br>        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)<br>        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)<br><br>// 如果 Thread.uncaughtExceptionHandler != null or DefaultUncaughtExceptionHandler != null 则能够在自己的 UncaughtExceptionHandler 里捕获异常<br>2021-06-12 11:13:29.471 28055-28055/com.example.myapplication E/cyrus: main-2 UncaughtExceptionHandler: Test Exception<br>    java.lang.RuntimeException: Test Exception<br>        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:58)<br>        at com.example.myapplication.MainActivity.onCreate$lambda-2(MainActivity.kt:30)<br>        at com.example.myapplication.MainActivity.lambda$hUPUYmntOngyO5ji3KzmjKQ19D4(Unknown Source:0)<br>        at com.example.myapplication.-$$Lambda$MainActivity$hUPUYmntOngyO5ji3KzmjKQ19D4.onClick(Unknown Source:0)<br>        at android.view.View.performClick(View.java:7509)<br>        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)<br>        at android.view.View.performClickInternal(View.java:7486)<br>        at android.view.View.access$3600(View.java:841)<br>        at android.view.View$PerformClick.run(View.java:28709)<br>        at android.os.Handler.handleCallback(Handler.java:938)<br>        at android.os.Handler.dispatchMessage(Handler.java:99)<br>        at android.os.Looper.loop(Looper.java:236)<br>        at android.app.ActivityThread.main(ActivityThread.java:8061)<br>        at java.lang.reflect.Method.invoke(Native Method)<br>        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)<br>        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)        <br><br>// app 没有立刻崩溃，但是进入 blocked 状态，点击 app 没响应然后触发 ANR<br>2021-06-12 11:17:10.449 1764-28190/? I/ActivityManager: Collecting stacks for pid 28055<br>2021-06-12 11:17:10.449 1764-28190/? I/system_server: libdebuggerd_client: started dumping process 28055<br>2021-06-12 11:17:10.450 697-697/? I/tombstoned: registered intercept for pid 28055 and type kDebuggerdJavaBacktrace<br>2021-06-12 11:17:10.450 28055-28065/com.example.myapplication I/e.myapplicatio: Thread[6,tid=28065,WaitingInMainSignalCatcherLoop,Thread*=0xb400007271841000,peer=0x13780260,&quot;Signal Catcher&quot;]: reacting to signal 3<br>2021-06-12 11:17:10.528 697-697/? I/tombstoned: received crash request for pid 28055<br>2021-06-12 11:17:10.528 697-697/? I/tombstoned: found intercept fd 512 for pid 28055 and type kDebuggerdJavaBacktrace<br>2021-06-12 11:17:10.528 28055-28065/com.example.myapplication I/e.myapplicatio: Wrote stack traces to tombstoned<br>2021-06-12 11:17:10.529 1764-28190/? I/system_server: libdebuggerd_client: done dumping process 28055<br><br>// 需要一段时间来 dump ANR 信息<br>2021-06-12 11:17:15.839 1764-28190/? E/ActivityManager: ANR in com.example.myapplication (com.example.myapplication/.MainActivity)<br>    PID: 28055<br>    Reason: Input dispatching timed out (com.example.myapplication/com.example.myapplication.MainActivity, 7fc1f1 com.example.myapplication/com.example.myapplication.MainActivity (server) is not responding. Waited 8001ms for MotionEvent(action=DOWN))<br>    Parent: com.example.myapplication/.MainActivity<br>    Load: 0.13 / 0.47 / 0.83<br>    ----- Output from /proc/pressure/memory -----<br>    some avg10=0.00 avg60=0.00 avg300=0.00 total=15206960<br>    full avg10=0.00 avg60=0.00 avg300=0.00 total=5127529<br>    ----- End output from /proc/pressure/memory -----<br>    <br>    CPU usage from 0ms to 5796ms later (2021-06-12 11:17:09.982 to 2021-06-12 11:17:15.778):<br>      0.1% 1465/media.codec: 0% user + 0% kernel / faults: 38284 minor<br>      18% 1764/system_server: 8.2% user + 10% kernel / faults: 4408 minor<br>      0% 1509/media.swcodec: 0% user + 0% kernel / faults: 21804 minor<br>      0% 899/media.hwcodec: 0% user + 0% kernel / faults: 7313 minor<br>      0.1% 5899/com.sohu.inputmethod.sogou: 0.1% user + 0% kernel / faults: 1684 minor<br>      2% 895/kworker/u16:16: 0% user + 2% kernel<br>      2% 2930/com.android.phone: 1.2% user + 0.8% kernel / faults: 1835 minor<br>      1.8% 1284/adbd: 0.5% user + 1.3% kernel<br>      0% 1426/media.extractor: 0% user + 0% kernel / faults: 3197 minor<br>      1.8% 25102/kworker/u16:5: 0% user + 1.8% kernel<br>      1.5% 982/surfaceflinger: 0.1% user + 1.3% kernel / faults: 41 minor<br>      0% 7493/kworker/u16:14: 0% user + 0% kernel<br>      0% 28055/com.example.myapplication: 0% user + 0% kernel / faults: 1974 minor<br>      1.2% 5242/com.android.nfc: 1% user + 0.1% kernel / faults: 796 minor<br>      1% 18959/com.viomi.fridge.vertical: 0.8% user + 0.1% kernel / faults: 17 minor<br>      1% 28105/kworker/u16:0: 0% user + 1% kernel<br>      0.8% 584/logd: 0.3% user + 0.5% kernel<br>      0.8% 836/android.hardware.sensors@1.0-service: 0.3% user + 0.5% kernel / faults: 115 minor<br>      0.8% 1359/cnss_diag: 0.6% user + 0.1% kernel<br>      0.8% 25780/com.xiaomi.market: 0.6% user + 0.1% kernel / faults: 736 minor 2 major<br>      0.6% 806/android.hardware.graphics.composer@2.4-service: 0% user + 0.6% kernel / faults: 238 minor 2 major<br>      0.6% 873/vendor.qti.hardware.perf@2.2-service: 0.3% user + 0.3% kernel / faults: 33 minor<br>      0% 1443/mediaserver: 0% user + 0% kernel / faults: 70 minor<br>      0.6% 16518/com.miui.player: 0.1% user + 0.5% kernel<br>      0% 1/init: 0% user + 0% kernel<br>      0% 697/tombstoned: 0% user + 0% kernel<br>      0% 799/android.hardware.camera.provider@2.4-service_64: 0% user + 0% kernel / faults: 26 minor<br>      0% 949/audioserver: 0% user + 0% kernel / faults: 56 minor<br>      0.5% 20092/kworker/u17:0: 0% user + 0.5% kernel<br>      0.5% 28100/logcat: 0% user + 0.5% kernel<br>      0.3% 9/rcu_preempt: 0% user + 0.3% kernel<br>      0.3% 495/crtc_commit:131: 0% user + 0.3% kernel<br>      0.3% 534/irq/303-fts: 0% user + 0.3% kernel<br>      0.3% 704/statsd: 0.1% user + 0.1% kernel / faults: 27 minor<br>      0.3% 705/netd: 0.1% user + 0.1% kernel / faults: 62 minor<br>      0% 1367/drmserver: 0% user + 0% kernel / faults: 16 minor<br>      0.3% 2635/com.android.systemui: 0.3% user + 0% kernel / faults: 27 minor<br>      0.3% 3547/irq/32-90b6400.: 0% user + 0.3% kernel<br>      0.3% 6938/kworker/u17:2: 0% user + 0.3% kernel<br>      0.3% 8546/com.tencent.mm:toolsmp: 0.1% user + 0.1% kernel / faults: 5 minor<br>      0.3% 13715/com.tencent.mm: 0.1% user + 0.1% kernel / faults: 5 minor<br>      0.1% 10/rcu_sched: 0% user + 0.1% kernel<br>      0.1% 12/rcuop/0: 0% user + 0.1% kernel<br>      0% 13/rcuos/0: 0% user + 0% kernel<br>      0.1% 30/rcuop/2: 0% user + 0.1% kernel<br>      0% 31/rcuos/2: 0% user + 0% kernel<br>      0.1% 38/rcuop/3: 0% user + 0.1% kernel<br>      0% 66/migration/7: 0% user + 0% kernel<br>      0.1% 586/servicemanager: 0.1% user + 0% kernel<br>      0.1% 598/android.hardware.keymaster@4.0-service-qti: 0% user + 0.1% kernel / faults: 11 minor<br>      0.1% 628/vold: 0% user + 0.1% kernel / faults: 29 minor<br>      0.1% 664/ipacm: 0% user + 0.1% kernel<br>      0.1% 676/jbd2/sda31-8: 0% user + 0.1% kernel<br>      0% 793/android.hardware.audio.service: 0% user + 0% kernel / faults: 39 minor<br>      0% 798/android.hardware.bluetooth@1.0-service-qti: 0% user + 0% kernel / faults: 11 minor<br>2021-06-12 11:17:15.839 1764-28190/? E/ActivityManager:   0.1% 807/android.hardware.health@2.1-service: 0% user + 0.1% kernel / faults: 9 minor<br>      0% 828/android.hardware.neuralnetworks@1.3-service-qti: 0% user + 0% kernel / faults: 65 minor<br>      0.1% 851/android.hardware.wifi@1.0-service: 0.1% user + 0% kernel<br>      0% 1365/cameraserver: 0% user + 0% kernel / faults: 70 minor<br>      0% 1440/media.metrics: 0% user + 0% kernel / faults: 36 minor 1 major<br>      0% 1572/gatekeeperd: 0% user + 0% kernel / faults: 28 minor 7 major<br>      0% 1605/android.hardware.biometrics.fingerprint@2.1-service: 0% user + 0% kernel / faults: 16 minor<br>      0.1% 2251/cds_ol_rx_threa: 0% user + 0.1% kernel<br>      0.1% 2884/com.qualcomm.qti.devicestatisticsservice: 0.1% user + 0% kernel / faults: 1 minor<br>      0.1% 3549/irq/33-90cd000.: 0% user + 0.1% kernel<br>      0.1% 6156/com.xiaomi.xmsf: 0.1% user + 0% kernel / faults: 27 minor<br>      0.1% 8036/com.tencent.mm:appbrand0: 0.1% user + 0% kernel / faults: 6 minor<br>      0.1% 8047/com.tencent.mm:appbrand1: 0% user + 0.1% kernel / faults: 6 minor<br>      0.1% 8864/com.xiaomi.joyose: 0.1% user + 0% kernel<br>      0.1% 14440/com.tencent.mm:push: 0% user + 0.1% kernel / faults: 8 minor<br>      0.1% 15807/com.miui.personalassistant: 0% user + 0.1% kernel / faults: 9 minor<br>      0.1% 27963/kworker/2:3: 0% user + 0.1% kernel<br>      0.1% 28106/kworker/u16:3: 0% user + 0.1% kernel<br>      0.1% 28171/kworker/0:1: 0% user + 0.1% kernel<br>    14% TOTAL: 7.1% user + 6.5% kernel + 0.1% iowait + 0.5% irq + 0.2% softirq<br>    CPU usage from 41ms to 439ms later (2021-06-12 11:17:10.023 to 2021-06-12 11:17:10.422) with 99% awake:<br>      51% 1764/system_server: 18% user + 33% kernel / faults: 929 minor<br>        39% 28190/AnrConsumer: 9% user + 30% kernel<br>        6% 1789/android.ui: 3% user + 3% kernel<br>        3% 2347/InputDispatcher: 3% user + 0% kernel<br>      2.5% 66/migration/7: 0% user + 2.5% kernel<br>      2.6% 534/irq/303-fts: 0% user + 2.6% kernel<br>      2.6% 584/logd: 2.6% user + 0% kernel<br>      2.7% 873/vendor.qti.hardware.perf@2.2-service: 0% user + 2.7% kernel / faults: 6 minor<br>        2.7% 873/perf@2.2-servic: 0% user + 2.7% kernel<br>       +0% 28191/POSIX timer 269: 0% user + 0% kernel<br>       +0% 28192/POSIX timer 269: 0% user + 0% kernel<br>      2.7% 895/kworker/u16:16: 0% user + 2.7% kernel<br>      2.8% 982/surfaceflinger: 2.8% user + 0% kernel<br>      2.8% 1284/adbd: 0% user + 2.8% kernel<br>    8.9% TOTAL: 2.8% user + 5.7% kernel + 0.3% irq<br><br>// 点击 ANR 对话框的确定按钮杀死 app<br>2021-06-12 11:18:58.935 1764-1789/? I/ActivityManager: Killing 28055:com.example.myapplication/u0a161 (adj 0): user request after error<br>2021-06-12 11:18:58.937 1764-1789/? I/Process: PerfMonitor : current process sending signal quiet. PID: 28055 SIG: 9<br>2021-06-12 11:18:58.938 1764-1802/? I/Process: PerfMonitor : current process killing process group. PID: 28055<br>2021-06-12 11:18:58.965 706-706/? I/Zygote: Process 28055 exited due to signal 9 (Killed)<br>2021-06-12 11:18:58.966 1764-1802/? I/libprocessgroup: Successfully killed process cgroup uid 10161 pid 28055 in 28ms<br>2021-06-12 11:18:58.970 882-882/? I/vendor.qti.hardware.servicetracker@1.2-service: killProcess is called for pid : 28055<br>2021-06-12 11:18:58.970 1764-5448/? W/ANRStateManager: clear state, but process isn&#x27;t exist. hash=92035998 uid=10161 pid=28055 state=16<br></code></pre></div></td></tr></table></figure><h3 id="子线程且-UEH-null"><a href="#子线程且-UEH-null" class="headerlink" title="子线程且 UEH != null"></a>子线程且 UEH != null</h3><p>app 没有发生 ANR 也没有崩溃，且无论 <code>DefaultUncaughtExceptionHandler</code> 是否为 null，<code>Thread.uncaughtExceptionHandler</code> 都能够有限捕获异常，说明线程的 UncaughtExceptionHandler 比默认的 UncaughtExceptionHandler 优先级要高</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">2021-06-12 17:20:41.503 20615-22015/com.example.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-10<br>    Process: com.example.myapplication, PID: 20615<br>    java.lang.RuntimeException: Test Exception<br>        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)<br>        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:38)<br>        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:36)<br>        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)<br><br>2021-06-12 17:20:41.509 20615-22015/com.example.myapplication E/cyrus: Thread-10-3890 UncaughtExceptionHandler: Test Exception<br>    java.lang.RuntimeException: Test Exception<br>        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)<br>        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:38)<br>        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:36)<br>        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)<br></code></pre></div></td></tr></table></figure><h3 id="两个UEH都置空-or-DUEH-null"><a href="#两个UEH都置空-or-DUEH-null" class="headerlink" title="两个UEH都置空 or DUEH != null"></a>两个UEH都置空 or DUEH != null</h3><p>app 没有发生 ANR 也没有崩溃</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">    --------- beginning of crash<br>2021-06-12 11:06:58.817 27816-27929/com.example.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-3<br>    Process: com.example.myapplication, PID: 27816<br>    java.lang.RuntimeException: Test Exception<br>        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:58)<br>        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:24)<br>        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:22)<br>        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)<br><br>// DefaultUncaughtExceptionHandler != null 则能够捕获异常<br>2021-06-12 17:03:51.701 20615-20884/com.example.myapplication E/cyrus: Thread-2-3882 DefaultUncaughtExceptionHandler: Test Exception<br>    java.lang.RuntimeException: Test Exception<br>        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)<br>        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:24)<br>        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:22)<br>        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)        <br><br>// 当 DefaultUncaughtExceptionHandler == null 时异常被输出到标准异常流<br>2021-06-12 17:13:54.170 20615-21405/com.example.myapplication W/System.err: Exception in thread &quot;Thread-8&quot; java.lang.RuntimeException: Test Exception<br>2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)<br>2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at com.example.myapplication.MainActivity$onCreate$1$1.invoke(MainActivity.kt:17)<br>2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at com.example.myapplication.MainActivity$onCreate$1$1.invoke(MainActivity.kt:15)<br>2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)   <br></code></pre></div></td></tr></table></figure><h3 id="子线程且为默认-DUEH"><a href="#子线程且为默认-DUEH" class="headerlink" title="子线程且为默认 DUEH"></a>子线程且为默认 DUEH</h3><p>默认的 DefaultUncaughtExceptionHandler 是 KillApplicationHandler，它会杀死 app</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs log">// 除了有上一节的日志外，还会有以下日志并且 app 被 kill<br>// app process 收到信号 SIGKILL(9) 被迫退出，app 立刻崩溃掉<br>2021-06-12 11:06:58.870 27816-27929/com.example.myapplication I/Process: Sending signal. PID: 27816 SIG: 9<br>2021-06-12 11:06:58.910 1764-1802/? I/Process: PerfMonitor : current process killing process group. PID: 27816<br>2021-06-12 11:06:58.911 1764-2936/? I/ActivityManager: Process com.example.myapplication (pid 27816) has died: prcp CRE <br>2021-06-12 11:06:58.911 706-706/? I/Zygote: Process 27816 exited due to signal 9 (Killed)<br>2021-06-12 11:06:58.912 1764-1802/? I/libprocessgroup: Successfully killed process cgroup uid 10161 pid 27816 in 0ms<br>2021-06-12 11:06:58.917 1764-2936/? W/ANRStateManager: clear state, but process isn&#x27;t exist. hash=224220282 uid=10161 pid=27816 state=16<br>2021-06-12 11:06:58.919 882-8554/? I/vendor.qti.hardware.servicetracker@1.2-service: killProcess is called for pid : 27816<br></code></pre></div></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>所在线程</th><th>子条件</th><th>结果</th></tr></thead><tbody><tr><td>主线程</td><td></td><td>始终会被 blocked 住，然后发生 ANR，最后被杀死</td></tr><tr><td>子线程</td><td>两个 UncaughtExceptionHandler 都置空 <br> 有任意一个自定义的 UncaughtExceptionHandler</td><td>app 没事</td></tr><tr><td></td><td>默认</td><td>KillApplicationHandler 捕获到异常并杀死 app</td></tr></tbody></table><h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><h3 id="抛出-UE-时发生了什么"><a href="#抛出-UE-时发生了什么" class="headerlink" title="抛出 UE 时发生了什么"></a>抛出 UE 时发生了什么</h3><p>有一个 API 可以抛出异常：<code>JNIEnv-&gt;Throw</code>，所以我猜当 java 层发生 uncaught exception 时相当于调用了它</p><p>这个方法的实现很简单，就是把 exception 记录在 Thread::tlsPtr_::exception</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/jni/jni_internal.cc</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jint <span class="hljs-title">Throw</span><span class="hljs-params">(JNIEnv* env, jthrowable java_exception)</span> </span>&#123;<br>  <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>  ObjPtr&lt;mirror::Throwable&gt; exception = soa.Decode&lt;mirror::Throwable&gt;(java_exception);<br>  <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> JNI_ERR;<br>  &#125;<br>  soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">SetException</span>(exception);<br>  <span class="hljs-keyword">return</span> JNI_OK;<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::SetException</span><span class="hljs-params">(ObjPtr&lt;mirror::Throwable&gt; new_exception)</span> </span>&#123;<br>  <span class="hljs-built_in">CHECK</span>(new_exception != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> DCHECK(!IsExceptionPending());</span><br>  tlsPtr_.exception = new_exception.<span class="hljs-built_in">Ptr</span>();<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread.h</span><br>mirror::Throwable* exception;   <span class="hljs-comment">// The pending exception or null.</span><br></code></pre></div></td></tr></table></figure><p>接下来我猜想埋点在代码里的异常检查流程在发现 pending exception != null 后，会中断字节码的执行（<code>Thread.run()</code>）从而回到 native 代码</p><p>让我们从开启一个线程 <code>Thread.start()</code> 看看这个流程</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Thread.<span class="hljs-built_in">start</span>()<br>Thread.<span class="hljs-built_in">nativeCreate</span>()<br><br><span class="hljs-comment">// java_lang_Thread.cc</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Thread_nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass, jobject java_thread, jlong stack_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                                jboolean daemon)</span> </span>&#123;<br>  <span class="hljs-comment">// There are sections in the zygote that forbid thread creation.</span><br>  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>  <span class="hljs-keyword">if</span> (runtime-&gt;<span class="hljs-built_in">IsZygote</span>() &amp;&amp; runtime-&gt;<span class="hljs-built_in">IsZygoteNoThreadSection</span>()) &#123;<br>    jclass internal_error = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/InternalError&quot;</span>);<br>    <span class="hljs-built_in">CHECK</span>(internal_error != <span class="hljs-literal">nullptr</span>);<br>    env-&gt;<span class="hljs-built_in">ThrowNew</span>(internal_error, <span class="hljs-string">&quot;Cannot create threads in zygote&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  Thread::<span class="hljs-built_in">CreateNativeThread</span>(env, java_thread, stack_size, daemon == JNI_TRUE);<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread.cc</span><br><span class="hljs-comment">// 最终调用 pthread_create 创建线程，新线程的入口是 Thread::CreateCallback</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::CreateNativeThread</span><span class="hljs-params">(JNIEnv* env, jobject java_peer, <span class="hljs-keyword">size_t</span> stack_size, <span class="hljs-keyword">bool</span> is_daemon)</span> </span>&#123;<br>  <span class="hljs-built_in">CHECK</span>(java_peer != <span class="hljs-literal">nullptr</span>);<br>  Thread* self = <span class="hljs-keyword">static_cast</span>&lt;JNIEnvExt*&gt;(env)-&gt;<span class="hljs-built_in">GetSelf</span>();<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VLOG_IS_ON</span>(threads)) &#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br><br>    ArtField* f = jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_name);<br>    ObjPtr&lt;mirror::String&gt; java_name =<br>        f-&gt;<span class="hljs-built_in">GetObject</span>(soa.Decode&lt;mirror::Object&gt;(java_peer))-&gt;<span class="hljs-built_in">AsString</span>();<br>    std::string thread_name;<br>    <span class="hljs-keyword">if</span> (java_name != <span class="hljs-literal">nullptr</span>) &#123;<br>      thread_name = java_name-&gt;<span class="hljs-built_in">ToModifiedUtf8</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      thread_name = <span class="hljs-string">&quot;(Unnamed)&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">VLOG</span>(threads) &lt;&lt; <span class="hljs-string">&quot;Creating native thread for &quot;</span> &lt;&lt; thread_name;<br>    self-&gt;<span class="hljs-built_in">Dump</span>(<span class="hljs-built_in">LOG_STREAM</span>(INFO));<br>  &#125;<br><br>  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br><br>  <span class="hljs-comment">// Atomically start the birth of the thread ensuring the runtime isn&#x27;t shutting down.</span><br>  <span class="hljs-keyword">bool</span> thread_start_during_shutdown = <span class="hljs-literal">false</span>;<br>  &#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::runtime_shutdown_lock_)</span></span>;<br>    <span class="hljs-keyword">if</span> (runtime-&gt;<span class="hljs-built_in">IsShuttingDownLocked</span>()) &#123;<br>      thread_start_during_shutdown = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      runtime-&gt;<span class="hljs-built_in">StartThreadBirth</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (thread_start_during_shutdown) &#123;<br>    <span class="hljs-function">ScopedLocalRef&lt;jclass&gt; <span class="hljs-title">error_class</span><span class="hljs-params">(env, env-&gt;FindClass(<span class="hljs-string">&quot;java/lang/InternalError&quot;</span>))</span></span>;<br>    env-&gt;<span class="hljs-built_in">ThrowNew</span>(error_class.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;Thread starting during runtime shutdown&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  Thread* child_thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(is_daemon);<br>  <span class="hljs-comment">// Use global JNI ref to hold peer live while child thread starts.</span><br>  child_thread-&gt;tlsPtr_.jpeer = env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(java_peer);<br>  stack_size = <span class="hljs-built_in">FixStackSize</span>(stack_size);<br><br>  <span class="hljs-comment">// Thread.start is synchronized, so we know that nativePeer is 0, and know that we&#x27;re not racing</span><br>  <span class="hljs-comment">// to assign it.</span><br>  env-&gt;<span class="hljs-built_in">SetLongField</span>(java_peer, WellKnownClasses::java_lang_Thread_nativePeer,<br>                    <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(child_thread));<br><br>  <span class="hljs-comment">// Try to allocate a JNIEnvExt for the thread. We do this here as we might be out of memory and</span><br>  <span class="hljs-comment">// do not have a good way to report this on the child&#x27;s side.</span><br>  std::string error_msg;<br>  <span class="hljs-function">std::unique_ptr&lt;JNIEnvExt&gt; <span class="hljs-title">child_jni_env_ext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      JNIEnvExt::Create(child_thread, Runtime::Current()-&gt;GetJavaVM(), &amp;error_msg))</span></span>;<br><br>  <span class="hljs-keyword">int</span> pthread_create_result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (child_jni_env_ext.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">pthread_t</span> new_pthread;<br>    <span class="hljs-keyword">pthread_attr_t</span> attr;<br>    child_thread-&gt;tlsPtr_.tmp_jni_env = child_jni_env_ext.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_init, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setdetachstate, (&amp;attr, PTHREAD_CREATE_DETACHED),<br>                       <span class="hljs-string">&quot;PTHREAD_CREATE_DETACHED&quot;</span>);<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setstacksize, (&amp;attr, stack_size), stack_size);<br>    pthread_create_result = <span class="hljs-built_in">pthread_create</span>(&amp;new_pthread,<br>                                           &amp;attr,<br>                                           Thread::CreateCallback,<br>                                           child_thread);<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_destroy, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (pthread_create_result == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// pthread_create started the new thread. The child is now responsible for managing the</span><br>      <span class="hljs-comment">// JNIEnvExt we created.</span><br>      <span class="hljs-comment">// Note: we can&#x27;t check for tmp_jni_env == nullptr, as that would require synchronization</span><br>      <span class="hljs-comment">//       between the threads.</span><br>      child_jni_env_ext.<span class="hljs-built_in">release</span>();  <span class="hljs-comment">// NOLINT pthreads API.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Either JNIEnvExt::Create or pthread_create(3) failed, so clean up.</span><br>  &#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::runtime_shutdown_lock_)</span></span>;<br>    runtime-&gt;<span class="hljs-built_in">EndThreadBirth</span>();<br>  &#125;<br>  <span class="hljs-comment">// Manually delete the global reference since Thread::Init will not have been run. Make sure</span><br>  <span class="hljs-comment">// nothing can observe both opeer and jpeer set at the same time.</span><br>  child_thread-&gt;<span class="hljs-built_in">DeleteJPeer</span>(env);<br>  <span class="hljs-keyword">delete</span> child_thread;<br>  child_thread = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove from thread group?</span><br>  env-&gt;<span class="hljs-built_in">SetLongField</span>(java_peer, WellKnownClasses::java_lang_Thread_nativePeer, <span class="hljs-number">0</span>);<br>  &#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">msg</span><span class="hljs-params">(child_jni_env_ext.get() == <span class="hljs-literal">nullptr</span> ?</span></span><br><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;Could not allocate JNI Env: %s&quot;</span>, error_msg.c_str()) :</span></span><br><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;pthread_create (%s stack) failed: %s&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 PrettySize(stack_size).c_str(), strerror(pthread_create_result)))</span></span>;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>    soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(msg.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">Thread::CreateCallback</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>&#123;<br>  Thread* self = <span class="hljs-keyword">reinterpret_cast</span>&lt;Thread*&gt;(arg);<br>  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>  <span class="hljs-keyword">if</span> (runtime == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Thread attaching to non-existent runtime: &quot;</span> &lt;&lt; *self;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass self to MutexLock - requires self to equal Thread::Current(), which is only true</span><br>    <span class="hljs-comment">//       after self-&gt;Init().</span><br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, *Locks::runtime_shutdown_lock_)</span></span>;<br>    <span class="hljs-comment">// Check that if we got here we cannot be shutting down (as shutdown should never have started</span><br>    <span class="hljs-comment">// while threads are being born).</span><br>    <span class="hljs-built_in">CHECK</span>(!runtime-&gt;<span class="hljs-built_in">IsShuttingDownLocked</span>());<br>    <span class="hljs-comment">// Note: given that the JNIEnv is created in the parent thread, the only failure point here is</span><br>    <span class="hljs-comment">//       a mess in InitStackHwm. We do not have a reasonable way to recover from that, so abort</span><br>    <span class="hljs-comment">//       the runtime in such a case. In case this ever changes, we need to make sure here to</span><br>    <span class="hljs-comment">//       delete the tmp_jni_env, as we own it at this point.</span><br>    <span class="hljs-built_in">CHECK</span>(self-&gt;<span class="hljs-built_in">Init</span>(runtime-&gt;<span class="hljs-built_in">GetThreadList</span>(), runtime-&gt;<span class="hljs-built_in">GetJavaVM</span>(), self-&gt;tlsPtr_.tmp_jni_env));<br>    self-&gt;tlsPtr_.tmp_jni_env = <span class="hljs-literal">nullptr</span>;<br>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">EndThreadBirth</span>();<br>  &#125;<br>  &#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;<br>    self-&gt;<span class="hljs-built_in">InitStringEntryPoints</span>();<br><br>    <span class="hljs-comment">// Copy peer into self, deleting global reference when done.</span><br>    <span class="hljs-built_in">CHECK</span>(self-&gt;tlsPtr_.jpeer != <span class="hljs-literal">nullptr</span>);<br>    self-&gt;tlsPtr_.opeer = soa.Decode&lt;mirror::Object&gt;(self-&gt;tlsPtr_.jpeer).<span class="hljs-built_in">Ptr</span>();<br>    <span class="hljs-comment">// Make sure nothing can observe both opeer and jpeer set at the same time.</span><br>    self-&gt;<span class="hljs-built_in">DeleteJPeer</span>(self-&gt;<span class="hljs-built_in">GetJniEnv</span>());<br>    self-&gt;<span class="hljs-built_in">SetThreadName</span>(self-&gt;<span class="hljs-built_in">GetThreadName</span>()-&gt;<span class="hljs-built_in">ToModifiedUtf8</span>().<span class="hljs-built_in">c_str</span>());<br><br>    ArtField* priorityField = jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_priority);<br>    self-&gt;<span class="hljs-built_in">SetNativePriority</span>(priorityField-&gt;<span class="hljs-built_in">GetInt</span>(self-&gt;tlsPtr_.opeer));<br><br>    runtime-&gt;<span class="hljs-built_in">GetRuntimeCallbacks</span>()-&gt;<span class="hljs-built_in">ThreadStart</span>(self);<br><br>    <span class="hljs-comment">// Unpark ourselves if the java peer was unparked before it started (see</span><br>    <span class="hljs-comment">// b/28845097#comment49 for more information)</span><br><br>    ArtField* unparkedField = jni::<span class="hljs-built_in">DecodeArtField</span>(<br>        WellKnownClasses::java_lang_Thread_unparkedBeforeStart);<br>    <span class="hljs-keyword">bool</span> should_unpark = <span class="hljs-literal">false</span>;<br>    &#123;<br>      <span class="hljs-comment">// Hold the lock here, so that if another thread calls unpark before the thread starts</span><br>      <span class="hljs-comment">// we don&#x27;t observe the unparkedBeforeStart field before the unparker writes to it,</span><br>      <span class="hljs-comment">// which could cause a lost unpark.</span><br>      <span class="hljs-function">art::MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(soa.Self(), *art::Locks::thread_list_lock_)</span></span>;<br>      should_unpark = unparkedField-&gt;<span class="hljs-built_in">GetBoolean</span>(self-&gt;tlsPtr_.opeer) == JNI_TRUE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (should_unpark) &#123;<br>      self-&gt;<span class="hljs-built_in">Unpark</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 重点在这里，执行 Thread.run()</span><br>    <span class="hljs-comment">// Invoke the &#x27;run&#x27; method of our java.lang.Thread.</span><br>    ObjPtr&lt;mirror::Object&gt; receiver = self-&gt;tlsPtr_.opeer;<br>    jmethodID mid = WellKnownClasses::java_lang_Thread_run;<br>    <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">ref</span><span class="hljs-params">(soa.Env(), soa.AddLocalReference&lt;jobject&gt;(receiver))</span></span>;<br>    <span class="hljs-built_in">InvokeVirtualOrInterfaceWithJValues</span>(soa, ref.<span class="hljs-built_in">get</span>(), mid, <span class="hljs-literal">nullptr</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Thread.run() 返回后就销毁此线程</span><br>  <span class="hljs-comment">// Detach and delete self.</span><br>  Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetThreadList</span>()-&gt;<span class="hljs-built_in">Unregister</span>(self);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread_list.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadList::Unregister</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(self, Thread::<span class="hljs-built_in">Current</span>());<br>  <span class="hljs-built_in">CHECK_NE</span>(self-&gt;<span class="hljs-built_in">GetState</span>(), kRunnable);<br>  Locks::mutator_lock_-&gt;<span class="hljs-built_in">AssertNotHeld</span>(self);<br><br>  <span class="hljs-built_in">VLOG</span>(threads) &lt;&lt; <span class="hljs-string">&quot;ThreadList::Unregister() &quot;</span> &lt;&lt; *self;<br><br>  &#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;<br>    ++unregistering_count_;<br>  &#125;<br><br>  <span class="hljs-comment">// Any time-consuming destruction, plus anything that can call back into managed code or</span><br>  <span class="hljs-comment">// suspend and so on, must happen at this point, and not in ~Thread. The self-&gt;Destroy is what</span><br>  <span class="hljs-comment">// causes the threads to join. It is important to do this after incrementing unregistering_count_</span><br>  <span class="hljs-comment">// since we want the runtime to wait for the daemon threads to exit before deleting the thread</span><br>  <span class="hljs-comment">// list.</span><br>  self-&gt;<span class="hljs-built_in">Destroy</span>();<br><br>  <span class="hljs-comment">// If tracing, remember thread id and name before thread exits.</span><br>  Trace::<span class="hljs-built_in">StoreExitingThreadInfo</span>(self);<br><br>  <span class="hljs-keyword">uint32_t</span> thin_lock_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// Remove and delete the Thread* while holding the thread_list_lock_ and</span><br>    <span class="hljs-comment">// thread_suspend_count_lock_ so that the unregistering thread cannot be suspended.</span><br>    <span class="hljs-comment">// Note: deliberately not using MutexLock that could hold a stale self pointer.</span><br>    &#123;<br>      <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Contains</span>(self)) &#123;<br>        std::string thread_name;<br>        self-&gt;<span class="hljs-built_in">GetThreadName</span>(thread_name);<br>        std::ostringstream os;<br>        <span class="hljs-built_in">DumpNativeStack</span>(os, <span class="hljs-built_in">GetTid</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;  native: &quot;</span>, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Request to unregister unattached thread &quot;</span> &lt;&lt; thread_name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; os.<span class="hljs-built_in">str</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        MutexLock <span class="hljs-built_in">mu2</span>(self, *Locks::thread_suspend_count_lock_);<br>        <span class="hljs-keyword">if</span> (!self-&gt;<span class="hljs-built_in">IsSuspended</span>()) &#123;<br>          list_.<span class="hljs-built_in">remove</span>(self);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// In the case where we are not suspended yet, sleep to leave other threads time to execute.</span><br>    <span class="hljs-comment">// This is important if there are realtime threads. b/111277984</span><br>    <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// We failed to remove the thread due to a suspend request, loop and try again.</span><br>  &#125;<br>  <span class="hljs-keyword">delete</span> self;<br><br>  <span class="hljs-comment">// Release the thread ID after the thread is finished and deleted to avoid cases where we can</span><br>  <span class="hljs-comment">// temporarily have multiple threads with the same thread id. When this occurs, it causes</span><br>  <span class="hljs-comment">// problems in FindThreadByThreadId / SuspendThreadByThreadId.</span><br>  <span class="hljs-built_in">ReleaseThreadId</span>(<span class="hljs-literal">nullptr</span>, thin_lock_id);<br><br>  <span class="hljs-comment">// Clear the TLS data, so that the underlying native thread is recognizably detached.</span><br>  <span class="hljs-comment">// (It may wish to reattach later.)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __BIONIC__</span><br>  __get_tls()[TLS_SLOT_ART_THREAD_SELF] = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_setspecific, (Thread::pthread_key_self_, <span class="hljs-literal">nullptr</span>), <span class="hljs-string">&quot;detach self&quot;</span>);<br>  Thread::self_tls_ = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-comment">// Signal that a thread just detached.</span><br>  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, *Locks::thread_list_lock_)</span></span>;<br>  --unregistering_count_;<br>  Locks::thread_exit_cond_-&gt;<span class="hljs-built_in">Broadcast</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::Destroy</span><span class="hljs-params">()</span> </span>&#123;<br>  Thread* self = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-built_in">DCHECK_EQ</span>(self, Thread::<span class="hljs-built_in">Current</span>());<br><br>  <span class="hljs-keyword">if</span> (tlsPtr_.jni_env != <span class="hljs-literal">nullptr</span>) &#123;<br>    &#123;<br>      <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;<br>      <span class="hljs-function">MonitorExitVisitor <span class="hljs-title">visitor</span><span class="hljs-params">(self)</span></span>;<br>      <span class="hljs-comment">// On thread detach, all monitors entered with JNI MonitorEnter are automatically exited.</span><br>      tlsPtr_.jni_env-&gt;monitors_.<span class="hljs-built_in">VisitRoots</span>(&amp;visitor, <span class="hljs-built_in">RootInfo</span>(kRootVMInternal));<br>    &#125;<br>    <span class="hljs-comment">// Release locally held global references which releasing may require the mutator lock.</span><br>    <span class="hljs-keyword">if</span> (tlsPtr_.jpeer != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// If pthread_create fails we don&#x27;t have a jni env here.</span><br>      tlsPtr_.jni_env-&gt;<span class="hljs-built_in">DeleteGlobalRef</span>(tlsPtr_.jpeer);<br>      tlsPtr_.jpeer = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tlsPtr_.class_loader_override != <span class="hljs-literal">nullptr</span>) &#123;<br>      tlsPtr_.jni_env-&gt;<span class="hljs-built_in">DeleteGlobalRef</span>(tlsPtr_.class_loader_override);<br>      tlsPtr_.class_loader_override = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (tlsPtr_.opeer != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;<br><br>    <span class="hljs-comment">// 销毁线程的时候会检查一下有没 pending exception，也就是此线程在执行代码过程中发生的 uncaught exception</span><br>    <span class="hljs-comment">// We may need to call user-supplied managed code, do this before final clean-up.</span><br>    <span class="hljs-built_in">HandleUncaughtExceptions</span>(soa);<br>    <span class="hljs-built_in">RemoveFromThreadGroup</span>(soa);<br>    Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>    <span class="hljs-keyword">if</span> (runtime != <span class="hljs-literal">nullptr</span>) &#123;<br>      runtime-&gt;<span class="hljs-built_in">GetRuntimeCallbacks</span>()-&gt;<span class="hljs-built_in">ThreadDeath</span>(self);<br>    &#125;<br><br>    <span class="hljs-comment">// this.nativePeer = 0;</span><br>    <span class="hljs-keyword">if</span> (Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">IsActiveTransaction</span>()) &#123;<br>      jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_nativePeer)<br>          -&gt;SetLong&lt;<span class="hljs-literal">true</span>&gt;(tlsPtr_.opeer, <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_nativePeer)<br>          -&gt;SetLong&lt;<span class="hljs-literal">false</span>&gt;(tlsPtr_.opeer, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Thread.join() is implemented as an Object.wait() on the Thread.lock object. Signal anyone</span><br>    <span class="hljs-comment">// who is waiting.</span><br>    ObjPtr&lt;mirror::Object&gt; lock =<br>        jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_lock)-&gt;<span class="hljs-built_in">GetObject</span>(tlsPtr_.opeer);<br>    <span class="hljs-comment">// (This conditional is only needed for tests, where Thread.lock won&#x27;t have been set.)</span><br>    <span class="hljs-keyword">if</span> (lock != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;<br>      <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(lock))</span></span>;<br>      <span class="hljs-function">ObjectLock&lt;mirror::Object&gt; <span class="hljs-title">locker</span><span class="hljs-params">(self, h_obj)</span></span>;<br>      locker.<span class="hljs-built_in">NotifyAll</span>();<br>    &#125;<br>    tlsPtr_.opeer = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  &#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;<br>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">RevokeThreadLocalBuffers</span>(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  <span class="hljs-comment">// Mark-stack revocation must be performed at the very end. No</span><br>  <span class="hljs-comment">// checkpoint/flip-function or read-barrier should be called after this.</span><br>  <span class="hljs-keyword">if</span> (kUseReadBarrier) &#123;<br>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">ConcurrentCopyingCollector</span>()-&gt;<span class="hljs-built_in">RevokeThreadLocalMarkStack</span>(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// art/runtime/thread.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::HandleUncaughtExceptions</span><span class="hljs-params">(ScopedObjectAccessAlreadyRunnable&amp; soa)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsExceptionPending</span>()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">peer</span><span class="hljs-params">(tlsPtr_.jni_env, soa.AddLocalReference&lt;jobject&gt;(tlsPtr_.opeer))</span></span>;<br>  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, kNative)</span></span>;<br><br>  <span class="hljs-comment">// Get and clear the exception.</span><br>  <span class="hljs-function">ScopedLocalRef&lt;jthrowable&gt; <span class="hljs-title">exception</span><span class="hljs-params">(tlsPtr_.jni_env, tlsPtr_.jni_env-&gt;ExceptionOccurred())</span></span>;<br>  tlsPtr_.jni_env-&gt;<span class="hljs-built_in">ExceptionClear</span>();<br><br>  <span class="hljs-comment">// 如果存在 pending exception/uncaught exception，则执行 Thread.dispatchUncaughtException()</span><br>  <span class="hljs-comment">// Call the Thread instance&#x27;s dispatchUncaughtException(Throwable)</span><br>  tlsPtr_.jni_env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(peer.<span class="hljs-built_in">get</span>(),<br>      WellKnownClasses::java_lang_Thread_dispatchUncaughtException,<br>      exception.<span class="hljs-built_in">get</span>());<br><br>  <span class="hljs-comment">// If the dispatchUncaughtException threw, clear that exception too.</span><br>  tlsPtr_.jni_env-&gt;<span class="hljs-built_in">ExceptionClear</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>线程进入 VM 的入口点是 <code>Thread.run()</code>，执行完毕（或者发生 uncaught exception 被中断字节码的执行）退出 VM 回到 native 代码后，就执行销毁线程的流程：<code>ThreadList::Unregister</code> -&gt; <code>Thread::Destroy</code>，其中 <code>HandleUncaughtExceptions</code> 会检查是否有 uncaught exception/pending exception，有的话再次进入 VM 执行 <code>Thread.dispatchUncaughtException</code></p><h4 id="UEH-的入口点"><a href="#UEH-的入口点" class="headerlink" title="UEH 的入口点"></a>UEH 的入口点</h4><p>如果有 <code>Thread.uncaughtExceptionHandler</code> 则直接给它处理，否则事件冒泡给到 ThreadGroup，ThreadGroup 会把异常一直冒泡到 root ThreadGroup，然后交由 <code>DefaultUncaughtExceptionHandler</code> 处理</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchUncaughtException</span><span class="hljs-params">(Throwable e)</span> </span>&#123;<br>        <span class="hljs-comment">// BEGIN Android-added: uncaughtExceptionPreHandler for use by platform.</span><br>        Thread.UncaughtExceptionHandler initialUeh =<br>                Thread.getUncaughtExceptionPreHandler();<br>        <span class="hljs-keyword">if</span> (initialUeh != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                initialUeh.uncaughtException(<span class="hljs-keyword">this</span>, e);<br>            &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error ignored) &#123;<br>                <span class="hljs-comment">// Throwables thrown by the initial handler are ignored</span><br>            &#125;<br>        <br>        <span class="hljs-comment">// END Android-added: uncaughtExceptionPreHandler for use by platform.</span><br>        getUncaughtExceptionHandler().uncaughtException(<span class="hljs-keyword">this</span>, e);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UncaughtExceptionHandler <span class="hljs-title">getUncaughtExceptionHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> uncaughtExceptionHandler != <span class="hljs-keyword">null</span> ?<br>            uncaughtExceptionHandler : group;<br>    &#125;        <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGroup</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            parent.uncaughtException(t, e);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Thread.UncaughtExceptionHandler ueh =<br>                Thread.getDefaultUncaughtExceptionHandler();<br>            <span class="hljs-keyword">if</span> (ueh != <span class="hljs-keyword">null</span>) &#123;<br>                ueh.uncaughtException(t, e);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> ThreadDeath)) &#123;<br>                System.err.print(<span class="hljs-string">&quot;Exception in thread \&quot;&quot;</span><br>                                 + t.getName() + <span class="hljs-string">&quot;\&quot; &quot;</span>);<br>                e.printStackTrace(System.err);<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="谁打印了-FATAL-EXCEPTION"><a href="#谁打印了-FATAL-EXCEPTION" class="headerlink" title="谁打印了 FATAL EXCEPTION"></a>谁打印了 FATAL EXCEPTION</h2><p>在上面的代码块里 dispatchUncaughtException 还调用了 <code>Thread.uncaughtExceptionPreHandler</code>，这个 handler 是在 app 进程初始化时配置的，而且没有暴露给用户，就是它打印了 <code>AndroidRuntime: FATAL EXCEPTION</code> 的日志</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeInit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commonInit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">&quot;Entered RuntimeInit!&quot;</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * set handlers; these apply to all threads in the VM. Apps can replace</span><br><span class="hljs-comment">         * the default handler, but not the pre handler.</span><br><span class="hljs-comment">         */</span><br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler();<br>        RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);<br>        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> KillApplicationHandler(loggingHandler));<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Install a time zone supplier that uses the Android persistent time zone system property.</span><br><span class="hljs-comment">         */</span><br>        RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="hljs-string">&quot;persist.sys.timezone&quot;</span>));<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Sets handler for java.util.logging to use Android log facilities.</span><br><span class="hljs-comment">         * The odd &quot;new instance-and-then-throw-away&quot; is a mirror of how</span><br><span class="hljs-comment">         * the &quot;java.util.logging.config.class&quot; system property works. We</span><br><span class="hljs-comment">         * can&#x27;t use the system property here since the logger has almost</span><br><span class="hljs-comment">         * certainly already been initialized.</span><br><span class="hljs-comment">         */</span><br>        LogManager.getLogManager().reset();<br>        <span class="hljs-keyword">new</span> AndroidConfig();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Sets the default HTTP User-Agent used by HttpURLConnection.</span><br><span class="hljs-comment">         */</span><br>        String userAgent = getDefaultUserAgent();<br>        System.setProperty(<span class="hljs-string">&quot;http.agent&quot;</span>, userAgent);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Wire socket tagging to traffic stats.</span><br><span class="hljs-comment">         */</span><br>        NetworkManagementSocketTagger.install();<br><br>        initialized = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Thread</span>.<span class="hljs-title">UncaughtExceptionHandler</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> mTriggered = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>            mTriggered = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-comment">// Don&#x27;t re-enter if KillApplicationHandler has already run</span><br>            <span class="hljs-keyword">if</span> (mCrashing) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// mApplicationObject is null for non-zygote java programs (e.g. &quot;am&quot;)</span><br>            <span class="hljs-comment">// There are also apps running with the system UID. We don&#x27;t want the</span><br>            <span class="hljs-comment">// first clause in either of these two cases, only for system_server.</span><br>            <span class="hljs-keyword">if</span> (mApplicationObject == <span class="hljs-keyword">null</span> &amp;&amp; (Process.SYSTEM_UID == Process.myUid())) &#123;<br>                Clog_e(TAG, <span class="hljs-string">&quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot;</span> + t.getName(), e);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logUncaught(t.getName(), ActivityThread.currentProcessName(), Process.myPid(), e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logUncaught</span><span class="hljs-params">(String threadName, String processName, <span class="hljs-keyword">int</span> pid, Throwable e)</span> </span>&#123;<br>        StringBuilder message = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-comment">// The &quot;FATAL EXCEPTION&quot; string is still used on Android even though</span><br>        <span class="hljs-comment">// apps can set a custom UncaughtExceptionHandler that renders uncaught</span><br>        <span class="hljs-comment">// exceptions non-fatal.</span><br>        message.append(<span class="hljs-string">&quot;FATAL EXCEPTION: &quot;</span>).append(threadName).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (processName != <span class="hljs-keyword">null</span>) &#123;<br>            message.append(<span class="hljs-string">&quot;Process: &quot;</span>).append(processName).append(<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>        message.append(<span class="hljs-string">&quot;PID: &quot;</span>).append(pid);<br>        Clog_e(TAG, message.toString(), e);<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="KillApplicationHandler"><a href="#KillApplicationHandler" class="headerlink" title="KillApplicationHandler"></a>KillApplicationHandler</h2><p>如上面的代码所示，app 进程初始化时 <code>DefaultUncaughtExceptionHandler</code> 被设置为 <code>KillApplicationHandler</code>，如果新线程没有设置 UncaughtExceptionHandler 或者没有替换 DefaultUncaughtExceptionHandler，那么子线程的 Uncaught Exception 也会导致 app 被 killed</p><p>KillApplicationHandler 主要干了两件事：</p><ol><li>弹出 <code>异常退出</code> 对话框，可以让用户选择重启 app</li><li>退出 app 进程</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KillApplicationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Thread</span>.<span class="hljs-title">UncaughtExceptionHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoggingHandler mLoggingHandler;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create a new KillApplicationHandler that follows the given LoggingHandler.</span><br><span class="hljs-comment">     * If &#123;<span class="hljs-doctag">@link</span> #uncaughtException(Thread, Throwable) uncaughtException&#125; is called</span><br><span class="hljs-comment">     * on the created instance without &#123;<span class="hljs-doctag">@code</span> loggingHandler&#125; having been triggered,</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> LoggingHandler#uncaughtException(Thread, Throwable)</span><br><span class="hljs-comment">     * loggingHandler.uncaughtException&#125; will be called first.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loggingHandler the &#123;<span class="hljs-doctag">@link</span> LoggingHandler&#125; expected to have run before</span><br><span class="hljs-comment">     *     this instance&#x27;s &#123;<span class="hljs-doctag">@link</span> #uncaughtException(Thread, Throwable) uncaughtException&#125;</span><br><span class="hljs-comment">     *     is being called.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KillApplicationHandler</span><span class="hljs-params">(LoggingHandler loggingHandler)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mLoggingHandler = Objects.requireNonNull(loggingHandler);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ensureLogging(t, e);<br>            <span class="hljs-comment">// Don&#x27;t re-enter -- avoid infinite loops if crash-reporting crashes.</span><br>            <span class="hljs-keyword">if</span> (mCrashing) <span class="hljs-keyword">return</span>;<br>            mCrashing = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// Try to end profiling. If a profiler is running at this point, and we kill the</span><br>            <span class="hljs-comment">// process (below), the in-memory buffer will be lost. So try to stop, which will</span><br>            <span class="hljs-comment">// flush the buffer. (This makes method trace profiling useful to debug crashes.)</span><br>            <span class="hljs-keyword">if</span> (ActivityThread.currentActivityThread() != <span class="hljs-keyword">null</span>) &#123;<br>                ActivityThread.currentActivityThread().stopProfiling();<br>            &#125;<br>            <span class="hljs-comment">// Bring up crash dialog, wait for it to be dismissed</span><br>            ActivityManager.getService().handleApplicationCrash(<br>                    mApplicationObject, <span class="hljs-keyword">new</span> ApplicationErrorReport.ParcelableCrashInfo(e));<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>            <span class="hljs-keyword">if</span> (t2 <span class="hljs-keyword">instanceof</span> DeadObjectException) &#123;<br>                <span class="hljs-comment">// System process is dead; ignore</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Clog_e(TAG, <span class="hljs-string">&quot;Error reporting crash&quot;</span>, t2);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t3) &#123;<br>                    <span class="hljs-comment">// Even Clog_e() fails!  Oh well.</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Try everything to make sure this process goes away.</span><br>            Process.killProcess(Process.myPid());<br>            System.exit(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Ensures that the logging handler has been triggered.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * See b/73380984. This reinstates the pre-O behavior of</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *   &#123;<span class="hljs-doctag">@code</span> thread.getUncaughtExceptionHandler().uncaughtException(thread, e);&#125;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * logging the exception (in addition to killing the app). This behavior</span><br><span class="hljs-comment">     * was never documented / guaranteed but helps in diagnostics of apps</span><br><span class="hljs-comment">     * using the pattern.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * If this KillApplicationHandler is invoked the &quot;regular&quot; way (by</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Thread#dispatchUncaughtException(Throwable)</span><br><span class="hljs-comment">     * Thread.dispatchUncaughtException&#125; in case of an uncaught exception)</span><br><span class="hljs-comment">     * then the pre-handler (expected to be &#123;<span class="hljs-doctag">@link</span> #mLoggingHandler&#125;) will already</span><br><span class="hljs-comment">     * have run. Otherwise, we manually invoke it here.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureLogging</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!mLoggingHandler.mTriggered) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mLoggingHandler.uncaughtException(t, e);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable loggingThrowable) &#123;<br>                <span class="hljs-comment">// Ignored.</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="主线程遇到-UE-时发生了什么"><a href="#主线程遇到-UE-时发生了什么" class="headerlink" title="主线程遇到 UE 时发生了什么"></a>主线程遇到 UE 时发生了什么</h2><p>上面在研究子线程时已经发现：Uncaught Exception 会中断字节码的执行流程从而回到 native 代码，主线程在回到 native 代码后选择依次执行 <code>DetachCurrentThread</code> 和 <code>DestroyJavaVM</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// zygote 进程的 native 层入口点，app 进程是由 zygote fork 出来的，所以这也算是 app 进程的入口点</span><br><span class="hljs-comment">// frameworks/base/cmds/app_process/app_main.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> argv[])</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 启动 VM，首次进入 java 层，入口点是 ZygoteInit.main(args)</span></span><br><span class="hljs-function"><span class="hljs-comment">// frameworks/base/core/jni/AndroidRuntime.cpp </span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AndroidRuntime::start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* className, <span class="hljs-keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="hljs-keyword">bool</span> zygote)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 启动 VM 后此线程就成为 VM 的主线程，直到 VM 退出后此线程才会结束生命</span><br>    <span class="hljs-comment">// Start VM.  This thread becomes the main thread of the VM, and will not return until the VM exits.</span><br>    JNIEnv* env;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// ZygoteInit.main(args)</span><br>    env-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 还记得上面出现过的这行日志吗：D/AndroidRuntime: Shutting down VM</span><br>    <span class="hljs-comment">// 就是在这里打印出来的，此时主线程已经退出了 VM 并准备销毁 VM</span><br>    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;Shutting down VM\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;<span class="hljs-built_in">DetachCurrentThread</span>() != JNI_OK)<br>        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Warning: unable to detach main thread\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;<span class="hljs-built_in">DestroyJavaVM</span>() != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>DetachCurrentThread 会调用 <code>HandleUncaughtExceptions</code>，这个方法也在上面介绍过了，它会检查是否有 uncaught exception/pending exception，有的话则再次进入 VM 执行 <code>Thread.dispatchUncaughtException()</code>，所以主线程的 uncaught exception 也是能够被捕获的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/jni/java_vm_ext.cc</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jint <span class="hljs-title">DetachCurrentThread</span><span class="hljs-params">(JavaVM* vm)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vm == <span class="hljs-literal">nullptr</span> || Thread::<span class="hljs-built_in">Current</span>() == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> JNI_ERR;<br>  &#125;<br>  JavaVMExt* raw_vm = <span class="hljs-keyword">reinterpret_cast</span>&lt;JavaVMExt*&gt;(vm);<br>  Runtime* runtime = raw_vm-&gt;<span class="hljs-built_in">GetRuntime</span>();<br>  runtime-&gt;<span class="hljs-built_in">DetachCurrentThread</span>();<br>  <span class="hljs-keyword">return</span> JNI_OK;<br>&#125;<br><br><span class="hljs-comment">// art/runtime/runtime.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Runtime::DetachCurrentThread</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">ScopedTrace <span class="hljs-title">trace</span><span class="hljs-params">(__FUNCTION__)</span></span>;<br>  Thread* self = Thread::<span class="hljs-built_in">Current</span>();<br>  <span class="hljs-keyword">if</span> (self == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;attempting to detach thread that is not attached&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">HasManagedStack</span>()) &#123;<br>    <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; *Thread::<span class="hljs-built_in">Current</span>() &lt;&lt; <span class="hljs-string">&quot; attempting to detach while still running code&quot;</span>;<br>  &#125;<br>  thread_list_-&gt;<span class="hljs-built_in">Unregister</span>(self);<br>&#125;<br><br>ThreadList::Unregister<br>Thread::Destroy<br>HandleUncaughtExceptions<br></code></pre></div></td></tr></table></figure><p>然后主线程就会把 VM 销毁掉并结束自己的生命周期，但 app 进程并没有结束，还有其他 native thread 的存在，从系统申请的资源如 Surface 也没有释放，所以 app 页面依然存在并没有出现 <strong>崩溃/闪退</strong> 的现象</p><p>归属于 app 的窗口没有被回收，那么 input 事件依然会分发给 app，input 事件是需要主线程来消费的，但此时主线程已退出，很明显会阻塞住，所以会触发 ANR</p><p>如果用户选择继续等待，app 就变成一个没有 VM 没有主线程的僵尸进程但还没退出，选择确定会发送 SIGKILL 信号杀死 app 进程</p><h2 id="收集崩溃日志"><a href="#收集崩溃日志" class="headerlink" title="收集崩溃日志"></a>收集崩溃日志</h2><ul><li>DefaultUncaughtExceptionHandler 可以收集到 app 的崩溃日志，也就是主线程的 Uncaught Exception</li><li>当然它也可以收集到子线程的 Uncaught Exception</li><li>它可以提高 app 的稳定性，防止 KillApplicationHandler 粗暴地把 app 杀死</li><li>理论上来说，把崩溃日志写入文件，甚至于即刻上传至服务器都是可以做到的，因为触发 ANR 需要 5s，然后弹出 ANR 对话框直到用户选择杀死 app 也需要几秒钟的时间</li><li><a href="../../../../2021/06/20/kill-exit/">Shutdown Hook</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>uncaught exception</tag>
      
      <tag>exception</tag>
      
      <tag>崩溃</tag>
      
      <tag>崩溃日志</tag>
      
      <tag>crash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 IO 框架：Okio</title>
    <link href="/2021/06/12/okio/"/>
    <url>/2021/06/12/okio/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><table><thead><tr><th>Okio</th><th>java.io</th></tr></thead><tbody><tr><td>ByteString</td><td>String</td></tr><tr><td>Buffer</td><td>ByteArray</td></tr><tr><td>Source</td><td>InputStream</td></tr><tr><td>Sink</td><td>OutputStream</td></tr><tr><td>Segment</td><td></td></tr><tr><td>SegmentPool</td><td></td></tr></tbody></table><h3 id="ByteString"><a href="#ByteString" class="headerlink" title="ByteString"></a>ByteString</h3><p>虽然 <code>okio.ByteString</code> 对标的是 <code>java.lang.String</code>，但是它操作的对象却是 String 内部的 ByteArray，相较于 String 的 <strong>字符数据</strong> 更贴近于 <strong>字节数据</strong> 的概念</p><table><thead><tr><th>类别</th><th>API</th></tr></thead><tbody><tr><td>字符编码（charset）</td><td>utf8()</td></tr><tr><td></td><td>string(charset)</td></tr><tr><td>消息摘要（message digest）</td><td><code>md5()</code> 128-bit</td></tr><tr><td></td><td><code>hmacSha1(key)</code> 160-bit, <code>hmacSha256(key)</code> 256-bit, <code>hmacSha512(key)</code> 512-bit <br> hmac 是额外添加了一个秘钥作为影响因子的 sha</td></tr><tr><td></td><td><code>sha1()</code> 160-bit, <code>sha256()</code> 256-bit, <code>sha512()</code> 512-bit</td></tr><tr><td></td><td>digest(algorithm)</td></tr><tr><td>基于字节的匹配和查找（而不是字符）</td><td>rangeEquals(offset, other ByteString/ByteArray, otherOffset, byteCount)</td></tr><tr><td></td><td>startsWith(ByteString/ByteArray)</td></tr><tr><td></td><td>endsWith(ByteString/ByteArray)</td></tr><tr><td></td><td>indexOf(other ByteString/ByteArray, fromIndex)</td></tr><tr><td></td><td>lastIndexOf(other ByteString/ByteArray, fromIndex)</td></tr><tr><td>其他</td><td>hex()</td></tr><tr><td></td><td>toAsciiLowercase()</td></tr><tr><td></td><td>toAsciiUppercase()</td></tr></tbody></table><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul><li>Buffer 对其内部的内存（ByteArray）进行分段管理（Segment），就像内存分页一样</li><li>分段管理可以逐步回收已读的 Segment 而不必始终占用一大块的内存（Buffer 属于 <strong>流式</strong> API，不能重复读，那么已读的数据就可以及时释放掉）</li><li>分段管理还可以很方便地与另一个 Buffer 共享某一段数据（或是构造出共享数据的 clone，或是以共享替代传输的 copyTo，或是共享某几段的 ByteString），只需要让别的段（Segment）引用同一块内存（ByteArray）即可，别的 Buffer 不能往共享数据的 Segment 里写数据，只能自己往环里新插入一个段来写入</li><li>小块的段还很方便回收和复用，用一个池即可（<code>SegmentPool</code>），段太大容易造成内存浪费</li><li>Buffer 内部的 <code>Segment</code> 通过 <code>Segment.prev</code> 和 <code>Segment.next</code> 形成一个环（头尾相连的链表）</li><li><code>Segment.limit</code> 是下一次写操作写入的位置，<code>Segment.pos</code> 是下一次读操作读取的位置，正常情况下 <code>0 &lt;= pos &lt;= limit &lt;= max</code></li><li>写入（write）的节点总是 tail 节点（head.prev），如果当前的 tail 不满足写入条件（Segment 不够容量 or 是个共享的 Segment），会插入一个新的 Segment 到 head.prev 作为当前 tail 来使用</li><li>读操作（read）总是从 head 开始，读操作会使 pos 逐步增长（往前走），当 pos 与 limit 相遇时（pos == limit），说明此节点的数据已读完，会从环里删除此节点，并将 next 作为新的 head</li><li>初始环是空的（null），第一次写操作会初始化第一个节点 head，此时 head.prev 和 head.next 都指向它自己</li></ul><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>read/write</td><td>读写各种类型的数据类型</td></tr><tr><td>copy()/clone()</td><td>返回一个共享数据的 Buffer <br> 这个就比较有意思了，我们知道 Buffer 用 Segment 对数据进行分片管理（类似于内存的分页），这里并没有真正将数据拷贝一份到另一个 Buffer（要节约内存嘛），而是让另一个 Buffer 里的 Segment 与当前 Buffer 里的 Segment 共享用一个 ByteArray <br> 新的 Segment 可以有自己的 pos 和 limit，可以读但不能写（Segment.owner == false，写入的数据会放到新创建的/自己的 Segment 里去），不然会把别人的数据搞乱，当然 Segment 的持有者是可以写的（Segment.owner == true） <br> 共享了数据的 Segment 不能被 SegmentPool 回收（因为可能别人还在用，而且内部没有计算器指示被多少人持有），它的 Segment.share == true</td></tr><tr><td>copyTo(Buffer)</td><td>使另一个 Buffer 与当前 Buffer 共享某一段数据</td></tr><tr><td>peek()</td><td>返回一个可以重复读的 Source（一般的 Source 跟 InputStream 一样是单向/流式的，不能重复读），但是这个 Buffer 作为 Source 的 backend，已读的数据 Source 也是无法读取的</td></tr><tr><td>snapshot(byteCount)</td><td>返回一个 ByteString（上面说过 Okio ByteString 对标 java.lang.String），特别的是它与 Buffer 是共享底层 ByteArray 的（不是共享 Segment，但会使 Segment.shared 置真） <br> ByteString 是不可变的所以它不会修改共享的 ByteArray</td></tr><tr><td>skip(byteCount)</td><td>跳过 byteCount 字节的数据，使读指针 pos 前进 byteCount 位（已读完的 Segment 将被回收）</td></tr><tr><td>inputStream()</td><td>把 Buffer 作为输入流的源</td></tr><tr><td>outputStream()</td><td>把 Buffer 作为输出流的目的地</td></tr><tr><td>copyTo(OutputStream)</td><td>将 Buffer 里的数据拷贝一份到 OutputStream，不移动 Segment.pos（也即不会释放已读数据）</td></tr><tr><td>writeTo(OutputStream)</td><td>将 Buffer 里的数据写入到 OutputStream，会移动 Segment.pos</td></tr><tr><td>readFrom(InputStream)</td><td>将 InputStream 里的数据读到 Buffer 里</td></tr></tbody></table><h3 id="SegmentPool"><a href="#SegmentPool" class="headerlink" title="SegmentPool"></a>SegmentPool</h3><ul><li>当需要新的 Segment 时总是会从池里拿（<code>Segment.take()</code>），当一个 Segment 从环里移除不再需要时总是会放回到池里去（<code>Segment.recycle(Segment)</code>）</li><li><code>SegmentPool</code> 是全局的，内部结构类似于 HashMap（数组 + 链表），只不过数组容量是固定的，通过 tid 决定用哪个链表</li><li>回收时（recycle）插入链表头部，复用时（take）取链表头</li><li>为了适应多线程环境链表的节点是 <code>AtomicReference&lt;Segment?&gt;</code>，回收和复用都使用 CAS 操作整个 SegmentPool 使用 CAS 替代锁（lock-free），竞争失败则放弃相关操作</li></ul><h3 id="各种各样的装饰器（Decorators）"><a href="#各种各样的装饰器（Decorators）" class="headerlink" title="各种各样的装饰器（Decorators）"></a>各种各样的装饰器（Decorators）</h3><p>跟 <code>java.io</code> 一样，Okio 为 Source/Sink 提供了各种各样的装饰器</p><table><thead><tr><th>class</th><th>作用</th></tr></thead><tbody><tr><td>HashingSource/HashingSink</td><td>提供成员属性 <code>hash</code>，在 read/write 时实时更新</td></tr><tr><td>GzipSource/GzipSink</td><td>类似于 GzipInputStream/GzipOutputStream，对 write 进行压缩，对 read 进行解压缩</td></tr><tr><td>BufferSource/BufferSink</td><td>具有一段 buffer 的输入流/输出流，默认实现就是 Buffer</td></tr><tr><td>CipherSource/CipherSink</td><td>实时对输入流/输出流进行加解密</td></tr><tr><td>Throttler</td><td>给输入流/输出流装一个节流阀，模拟限流/弱网的情况</td></tr><tr><td>Pipe</td><td>顾名思义它是一段管道，管道两端连着 Source 和 Sink，流向 Sink 的数据即是 Source 的输出，管道及其 Source 和 Sink 是线程安全的</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>okio</tag>
      
      <tag>io</tag>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入探索 java.io 和 nio</title>
    <link href="/2021/06/05/io-and-nio/"/>
    <url>/2021/06/05/io-and-nio/</url>
    
    <content type="html"><![CDATA[<h3 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream/FileOutputStream"></a>FileInputStream/FileOutputStream</h3><p><code>FileInputStream</code> 和 <code>FileOutputStream</code> 都属于“流式” API，就像流水（<code>Stream</code>）一样只能朝着一个方向读写，不能后退</p><p><code>FileInputStream</code> 相当于以只读模式读文件：open(O_RDONLY) -&gt; read -&gt; close(fd)</p><p><code>FileOutputStream</code> 相当于以只写模式写文件：open(O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC)) -&gt; write -&gt; close(fd)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// open</span><br>FileInputStream(File file)<br>IoBridge.open(name, O_RDONLY)<br>Libcore.os.open(path, flags, <span class="hljs-number">0666</span>)<br>Linux.open(String path, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> mode)<br>Linux_open(JNIEnv* env, jobject, jstring javaPath, jint flags, jint mode)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><br><span class="hljs-comment">// 系统调用 open 的参数 flags 必须包含三个访问模式（access modes）其中之一：</span><br><span class="hljs-comment">// O_CREAT： 如果文件不存在则创建之</span><br><span class="hljs-comment">// O_APPEND：以 APPEND 的模式打开文件（附加）</span><br><span class="hljs-comment">// O_TRUNC： 如果文件存在且以写模式打开，则把文件长度置为 0</span><br>open(pathname, flags, modes)<br><br><br><span class="hljs-comment">// read</span><br>FileInputStream.read(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)<br>IoBridge.read(FileDescriptor fd, <span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">int</span> byteOffset, <span class="hljs-keyword">int</span> byteCount)<br>Libcore.os.read(FileDescriptor fd, <span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">int</span> byteOffset, <span class="hljs-keyword">int</span> byteCount)<br>Linux.readBytes(FileDescriptor fd, <span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">int</span> byteOffset, <span class="hljs-keyword">int</span> byteCount)<br>Linux_readBytes(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><br><span class="hljs-comment">// 系统调用，fd 有个成员属性 offset，read 从 offset 开始读取 count 个字节的数据到 buf，offset 也会随着增长 count</span><br>read(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, size_t count)<br><br><br><span class="hljs-comment">// write</span><br>FileOutputStream.write(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)<br>IoBridge.write(FileDescriptor fd, <span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">int</span> byteOffset, <span class="hljs-keyword">int</span> byteCount)<br>Libcore.os.write(FileDescriptor fd, <span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">int</span> byteOffset, <span class="hljs-keyword">int</span> byteCount)<br>Linux.writeBytes(FileDescriptor fd, Object buffer, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> byteCount)<br>Linux_writeBytes(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><br>write(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* buf, size_t count)    <span class="hljs-comment">// 系统调用</span><br><br><br><span class="hljs-comment">// close</span><br>FileInputStream.close()<br>IoBridge.closeAndSignalBlockedThreads(fd)<br>Libcore.os.close(fd)<br>Linux.close(fd)<br>Linux_close(JNIEnv* env, jobject, jobject javaFd)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><br>close(fd)    <span class="hljs-comment">// 系统调用</span><br></code></pre></div></td></tr></table></figure><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p><code>RandomAccessFile</code> 提供了读写操作，相当于 <code>FileInputStream</code> 和 <code>FileOutputStream</code> 的组合</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// open，其中 mode 与 imode 之间的映射关系为 </span><br><span class="hljs-comment">// r  - O_RDONLY         - 只读</span><br><span class="hljs-comment">// rw - O_RDWR | O_CREAT - 读写</span><br>RandomAccessFile(File file, String mode)<br>IoBridge.open(name, imode)<br>Libcore.os.open(path, flags, <span class="hljs-number">0666</span>)<br>Linux.open(String path, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> mode)<br>Linux_open(JNIEnv* env, jobject, jstring javaPath, jint flags, jint mode)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><br><span class="hljs-comment">// 系统调用 open 的参数 flags 必须包含三个访问模式（access modes）其中之一：</span><br><span class="hljs-comment">// O_CREAT： 如果文件不存在则创建之</span><br><span class="hljs-comment">// O_APPEND：以 APPEND 的模式打开文件（附加）</span><br><span class="hljs-comment">// O_TRUNC： 如果文件存在且以写模式打开，则把文件长度置为 0</span><br>open(pathname, flags, modes)<br><br><br><span class="hljs-comment">// read &amp; write</span><br>read(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len) -&gt; 系统调用 <span class="hljs-function">read</span><br><span class="hljs-function"><span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> -&gt; 系统调用 write</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// seek</span></span><br><span class="hljs-function">RandomAccessFile.<span class="hljs-title">seek</span><span class="hljs-params">(<span class="hljs-keyword">long</span> pos)</span></span><br><span class="hljs-function">Libcore.os.<span class="hljs-title">lseek</span><span class="hljs-params">(fd, pos, SEEK_SET)</span></span><br><span class="hljs-function">Linux.<span class="hljs-title">lseek</span><span class="hljs-params">(FileDescriptor fd, <span class="hljs-keyword">long</span> offset, <span class="hljs-keyword">int</span> whence)</span></span><br><span class="hljs-function"><span class="hljs-title">Linux_lseek</span><span class="hljs-params">(JNIEnv* env, jobject, jobject javaFd, jlong offset, jint whence)</span>    <span class="hljs-comment">// libcore_io_Linux.cpp</span></span><br><span class="hljs-function"><span class="hljs-comment">// 系统调用，改变已打开的文件描述的文件偏移（fd.offset，指示下一次读写的位置），其中 whence 的取值有：</span></span><br><span class="hljs-function"><span class="hljs-comment">// SEEK_SET - fd.offset = offset</span></span><br><span class="hljs-function"><span class="hljs-comment">// SEEK_CUR - fd.offset += offset</span></span><br><span class="hljs-function"><span class="hljs-comment">// SEEK_END - fd.offset = fd.end + offset</span></span><br><span class="hljs-function"><span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, off_t offset, <span class="hljs-keyword">int</span> whence)</span></span><br></code></pre></div></td></tr></table></figure><p>总之，传统的 <code>java.io</code> 都是基于系统调用 <code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code> 和 <code>close</code></p><ul><li><code>FileInputStream</code> 包装了 <code>read</code></li><li><code>FileOutputStream</code> 包装了 <code>write</code></li><li><code>RandomAccessFile</code> 包装了 <code>read</code> 和 <code>write</code></li></ul><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p><code>FileChannel</code> 的读写操作最终是执行系统调用 <code>pread/pwrite</code>（区别于 <code>read/write</code> 的是它们不改变 <code>fd.offset</code>）</p><blockquote><p><code>pread()</code> reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buffer starting at buf.  The file offset is not changed.</p><p><code>pwrite()</code> writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset.  The file offset is not changed.</p><p><code>read()</code> attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On  files  that  support seeking, the read operation commences at the file offset, and the file offset is incremented by the number of bytes read.</p><p><code>read()</code> attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On  files  that  support seeking, the read operation commences at the file offset, and the file offset is incremented by the number of bytes read.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// read</span><br>FileChannel.read(ByteBuffer dst, <span class="hljs-keyword">long</span> position)<br>FileChannelImpl.read(ByteBuffer dst, <span class="hljs-keyword">long</span> position)<br>IOUtil.read(FileDescriptor fd, ByteBuffer dst, <span class="hljs-keyword">long</span> position, NativeDispatcher nd)<br>IOUtil.readIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb, <span class="hljs-keyword">long</span> position, NativeDispatcher nd)<br>FileDispatcherImpl.pread0(FileDescriptor fd, <span class="hljs-keyword">long</span> address, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">long</span> position)<br>FileDispatcherImpl_pread0(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jlong offset)    <span class="hljs-comment">// FileDispatcherImpl.c</span><br>pread64(fd, buf, len, offset)    <span class="hljs-comment">// 系统调用</span><br><br><br><span class="hljs-comment">// write</span><br>FileChannel.write(ByteBuffer src, <span class="hljs-keyword">long</span> position)<br>FileChannelImpl.write(ByteBuffer src, <span class="hljs-keyword">long</span> position)<br>IOUtil.write(FileDescriptor fd, ByteBuffer src, <span class="hljs-keyword">long</span> position, NativeDispatcher nd)<br>IOUtil.writeFromNativeBuffer(FileDescriptor fd, ByteBuffer bb, <span class="hljs-keyword">long</span> position, NativeDispatcher nd)<br>FileDispatcherImpl.pwrite0(FileDescriptor fd, <span class="hljs-keyword">long</span> address, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">long</span> position)<br>FileDispatcherImpl_pwrite0(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jlong offset)    <span class="hljs-comment">// FileDispatcherImpl.c</span><br>pwrite64(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* __buf, size_t __count, off64_t __offset)    <span class="hljs-comment">// 系统调用</span><br></code></pre></div></td></tr></table></figure><h3 id="数组的两次复制"><a href="#数组的两次复制" class="headerlink" title="数组的两次复制"></a>数组的两次复制</h3><p>咋一看，<code>FileInputStream/FileOutputStream</code> 和 <code>FileChannel</code> 最终都是通过系统调用 <code>read/write</code> 完成文件的读写操作，那 NIO 的优势体现在哪呢？</p><p>其实在 C 层的入口点就可以看出来了，看下面的读操作，<code>Byte[]</code> 是作为 java object 传给 C 层的，对它的读写操作需要包裹在 <code>GetByteArrayElements/ReleaseByteArrayElements</code> 之间（通过 <code>ScopedBytesRW</code> 的构造函数和析构函数），<code>GetByteArrayElements</code> 会从 <code>Byte[]</code> 复制一份数据出来，<code>ReleaseByteArrayElements</code> 会回写数据到 <code>Byte[]</code>，也就是说 <code>Byte[]</code> 在 C 层走一圈会有两次额外的复制操作，数组越大越耗资源</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> jint <span class="hljs-title">Linux_readBytes</span><span class="hljs-params">(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount)</span> </span>&#123;<br>    <span class="hljs-function">ScopedBytesRW <span class="hljs-title">bytes</span><span class="hljs-params">(env, javaBytes)</span></span>;<br>    <span class="hljs-keyword">if</span> (bytes.<span class="hljs-built_in">get</span>() == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IO_FAILURE_RETRY</span>(env, <span class="hljs-keyword">ssize_t</span>, read, javaFd, bytes.<span class="hljs-built_in">get</span>() + byteOffset, byteCount);<br>&#125;<br><br><span class="hljs-comment">// 看下 ScopedBytesRW 是什么</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopedBytesRW</span> :</span> <span class="hljs-keyword">public</span> ScopedBytes&lt;<span class="hljs-literal">false</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ScopedBytesRW</span>(JNIEnv* env, jobject object) : ScopedBytes&lt;<span class="hljs-literal">false</span>&gt;(env, object) &#123;&#125;<br>    <span class="hljs-function">jbyte* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mPtr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 貌似在 ScopedBytes 的构造函数和析构函数里做了些手脚</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> readOnly&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopedBytes</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ScopedBytes</span>(JNIEnv* env, jobject object)<br>    : <span class="hljs-built_in">mEnv</span>(env), <span class="hljs-built_in">mObject</span>(object), <span class="hljs-built_in">mByteArray</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">mPtr</span>(<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mObject == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">jniThrowNullPointerException</span>(mEnv);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            jclass byteArrayClass = JniConstants::<span class="hljs-built_in">GetPrimitiveByteArrayClass</span>(env);<br>            <span class="hljs-keyword">if</span> (mEnv-&gt;<span class="hljs-built_in">IsInstanceOf</span>(mObject, byteArrayClass)) &#123;<br>                mByteArray = <span class="hljs-keyword">reinterpret_cast</span>&lt;jbyteArray&gt;(mObject);<br>                mPtr = mEnv-&gt;<span class="hljs-built_in">GetByteArrayElements</span>(mByteArray, <span class="hljs-literal">nullptr</span>);                 <span class="hljs-comment">// 字节数组</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mPtr = <span class="hljs-keyword">reinterpret_cast</span>&lt;jbyte*&gt;(mEnv-&gt;<span class="hljs-built_in">GetDirectBufferAddress</span>(mObject)); <span class="hljs-comment">// DirectBuffer</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ScopedBytes</span>() &#123;<br>        <span class="hljs-keyword">if</span> (mByteArray != <span class="hljs-literal">nullptr</span>) &#123;<br>            mEnv-&gt;<span class="hljs-built_in">ReleaseByteArrayElements</span>(mByteArray, mPtr, readOnly ? JNI_ABORT : <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html">JNI Functions</a></p><blockquote><p><code>Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy)</code></p><p>A family of functions that returns the body of the primitive array. The result is valid until the corresponding Release<PrimitiveType>ArrayElements() function is called. Since the returned array may be a copy of the Java array, changes made to the returned array will not necessarily be reflected in the original array until Release<PrimitiveType>ArrayElements() is called.</p><p>If isCopy is not NULL, then *isCopy is set to JNI_TRUE if a copy is made; or it is set to JNI_FALSE if no copy is made.</p></blockquote><blockquote><p><code>Release&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, NativeType *elems, jint mode)</code></p><p>A family of functions that informs the VM that the native code no longer needs access to elems. The elems argument is a pointer derived from array using the corresponding Get<PrimitiveType>ArrayElements() function. If necessary, this function copies back all changes made to elems to the original array.</p><p>The mode argument provides information on how the array buffer should be released. mode has no effect if elems is not a copy of the elements in array.</p><p>0 - copy back the content and free the elems buffer</p><p>JNI_COMMIT - copy back the content but do not free the elems buffer</p><p>JNI_ABORT - free the buffer without copying back the possible changes</p><p>In most cases, programmers pass “0” to the mode argument to ensure consistent behavior for both pinned and copied arrays. The other options give the programmer more control over memory management and should be used with extreme care.</p></blockquote><p><a href="https://stackoverflow.com/questions/21691356/ndk-does-getbytearrayelements-copy-data-from-java-to-c/21693632">NDK: Does GetByteArrayElements copy data from Java to C++?</a></p><blockquote><p>Get<Primitive>ArrayElements may or may not copy the data as it sees fit. The isCopy output parameter will tell you whether it has been copied. If data is not copied, then you have obtained a pointer to the data directly in the Dalvik heap. Read more here.</p><p>You always need to call the corresponding Release<Primitive>ArrayElements, regardless of whether a copy was made. Copying data back to the VM array isn’t the only cleanup that might need to be done, although (according to the JNI documentation already linked) it is feasible that changes can be seen on the Java side before Release… has been called (iff data has not been copied).</p><p>I don’t believe the VM is going to allow you to make the conversions that would be necessary to do what you are thinking. As I see it, either way you go, you will need to convert a byte array to a float or a float to a byte array in Java, which you cannot accomplish by type casting. The data is going to be copied at some point.</p></blockquote><p>为啥会有数组的复制和回写？参考 <a href="../../../../2021/05/28/dalvik-art-heap-gc/">老罗的 Android 之旅阅读笔记（Dalvik/ART 虚拟机篇）</a> 我猜有两个原因：</p><ol><li>GC 在标记阶段需要 <code>Stop The World</code> 以标记需要回收的对象，但很明显 VM 没法中断 native thread</li><li>还有 <code>Compacting GC</code> 会通过两个 <code>Bump Pointer Space</code> 来回捣鼓堆上的对象以实现内存的整理和压缩，释放小块的内存碎片，这会导致堆上对象的地址发生变动，VM 可以找到堆上所有对此对象的引用并修改它们的地址，但 VM 没法修改 native 代码对此对象的引用</li></ol><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>看 <code>FileChannel</code> 读操作的 C 层入口，不再是 <code>Byte[]</code> 对象而是 C 代码可以直接操作的虚拟地址 <code>address</code>，系统调用 <code>pread64</code> 可以直接把数据写到 <code>address</code> 上，省去了两次复制数据的操作</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">FileDispatcherImpl_pread0</span>(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jlong offset)<br>&#123;<br>    jint fd = <span class="hljs-built_in">fdval</span>(env, fdo);<br>    <span class="hljs-keyword">void</span> *buf = (<span class="hljs-keyword">void</span> *)<span class="hljs-built_in">jlong_to_ptr</span>(address);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">convertReturnVal</span>(env, <span class="hljs-built_in">pread64</span>(fd, buf, len, offset), JNI_TRUE);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为啥 <code>FileChannel</code> 可以直接拿到并操作虚拟地址呢？那还得由 <code>ByteBuffer</code> 说起</p><p>ByteBuffer 有两种：</p><ol><li>ByteBuffer.allocateDirect           - <code>DirectByteBuffer</code></li><li>ByteBuffer.allocate/ByteBuffer.wrap - <code>HeapByteBuffer</code></li></ol><p><code>HeapByteBuffer</code> 就是对 <code>Byte[]</code> 的包装，主要看下 <code>DirectByteBuffer</code></p><p><code>DirectByteBuffer</code> 其实也持有一个字节数组 <code>DirectByteBuffer.MemoryRef.buffer</code>，不同于普通的 <code>Byte[]</code> 它是直接在 non_moving_space 上分配的，也就说它不会被 GC 整理和移动所以它的地址是固定不变的，native 代码可以直接在这块内存上进行读写操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ByteBuffer.allocateDirect(<span class="hljs-keyword">int</span> capacity)<br>DirectByteBuffer.MemoryRef(capacity)<br>VMRuntime.newNonMovableArray(componentType, length)<br>VMRuntime_newNonMovableArray(env, jobject, javaElementClass, length)<br>Array::Alloc(Thread* self, ObjPtr&lt;Class&gt; array_class, int32_t component_count, size_t component_size_shift, gc::AllocatorType allocator_type)<br>Heap::AllocObjectWithAllocator(Thread* self, ObjPtr&lt;mirror::Class&gt; klass, size_t byte_count, AllocatorType allocator, <span class="hljs-keyword">const</span> PreFenceVisitor&amp; pre_fence_visitor)<br>Heap::TryToAllocate(Thread* self, AllocatorType allocator_type, size_t alloc_size, size_t* bytes_allocated, size_t* usable_size, size_t* bytes_tl_bulk_allocated)<br>Heap-&gt;non_moving_space-&gt;Alloc(Thread* self, size_t num_bytes, size_t* bytes_allocated, size_t* usable_size, size_t* bytes_tl_bulk_allocated)<br></code></pre></div></td></tr></table></figure><p>看下文档 <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#nio_support">NIO Support</a> 是怎么说的</p><blockquote><p>The NIO-related entry points allow native code to access java.nio direct buffers. The contents of a direct buffer can, potentially, reside in native memory outside of the ordinary garbage-collected heap. </p><p><code>jobject NewDirectByteBuffer(JNIEnv* env, void* address, jlong capacity)</code></p><p>Allocates and returns a direct java.nio.ByteBuffer referring to the block of memory starting at the memory address address and extending capacity bytes.</p><p>Native code that calls this function and returns the resulting byte-buffer object to Java-level code should ensure that the buffer refers to a valid region of memory that is accessible for reading and, if appropriate, writing. An attempt to access an invalid memory location from Java code will either return an arbitrary value, have no visible effect, or cause an unspecified exception to be thrown.</p><p><code>void* GetDirectBufferAddress(JNIEnv* env, jobject buf)</code></p><p>Fetches and returns the starting address of the memory region referenced by the given direct java.nio.Buffer.</p><p>This function allows native code to access the same memory region that is accessible to Java code via the buffer object.</p></blockquote><p><code>FileChannel</code> 在进行读写操作时，也即 java 层和 native 层之间进行数据传递时，总是会使用 <code>DirectByteBuffer</code> 避免数组的两次拷贝</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">FileChannelImpl.read(FileDescriptor fd, ByteBuffer dst, <span class="hljs-keyword">long</span> position, NativeDispatcher nd) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (dst.isReadOnly())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Read-only buffer&quot;</span>);<br>    <span class="hljs-keyword">if</span> (dst <span class="hljs-keyword">instanceof</span> DirectBuffer)<br>        <span class="hljs-keyword">return</span> readIntoNativeBuffer(fd, dst, position, nd);<br>    <span class="hljs-comment">// Substitute a native buffer</span><br>    ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> n = readIntoNativeBuffer(fd, bb, position, nd);<br>        bb.flip();<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>            dst.put(bb);<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Util.offerFirstTemporaryDirectBuffer(bb);<br>    &#125;<br>&#125;<br><br>FileChannelImpl.write(FileDescriptor fd, ByteBuffer src, <span class="hljs-keyword">long</span> position, NativeDispatcher nd) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (src <span class="hljs-keyword">instanceof</span> DirectBuffer)<br>        <span class="hljs-keyword">return</span> writeFromNativeBuffer(fd, src, position, nd);<br>    <span class="hljs-comment">// Substitute a native buffer</span><br>    <span class="hljs-keyword">int</span> pos = src.position();<br>    <span class="hljs-keyword">int</span> lim = src.limit();<br>    <span class="hljs-keyword">assert</span> (pos &lt;= lim);<br>    <span class="hljs-keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="hljs-number">0</span>);<br>    ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);<br>    <span class="hljs-keyword">try</span> &#123;<br>        bb.put(src);<br>        bb.flip();<br>        <span class="hljs-comment">// Do not update src until we see how many bytes were written</span><br>        src.position(pos);<br>        <span class="hljs-keyword">int</span> n = writeFromNativeBuffer(fd, bb, position, nd);<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// now update src</span><br>            src.position(pos + n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Util.offerFirstTemporaryDirectBuffer(bb);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a temporary buffer of at least the given size</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">getTemporaryDirectBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">// If a buffer of this size is too large for the cache, there</span><br>    <span class="hljs-comment">// should not be a buffer in the cache that is at least as</span><br>    <span class="hljs-comment">// large. So we&#x27;ll just create a new one. Also, we don&#x27;t have</span><br>    <span class="hljs-comment">// to remove the buffer from the cache (as this method does</span><br>    <span class="hljs-comment">// below) given that we won&#x27;t put the new buffer in the cache.</span><br>    <span class="hljs-keyword">if</span> (isBufferTooLarge(size)) &#123;<br>        <span class="hljs-keyword">return</span> ByteBuffer.allocateDirect(size);<br>    &#125;<br>    BufferCache cache = bufferCache.get();<br>    ByteBuffer buf = cache.get(size);<br>    <span class="hljs-keyword">if</span> (buf != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No suitable buffer in the cache so we need to allocate a new</span><br>        <span class="hljs-comment">// one. To avoid the cache growing then we remove the first</span><br>        <span class="hljs-comment">// buffer from the cache and free it.</span><br>        <span class="hljs-keyword">if</span> (!cache.isEmpty()) &#123;<br>            buf = cache.removeFirst();<br>            free(buf);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ByteBuffer.allocateDirect(size);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="File-Lock-Supporting"><a href="#File-Lock-Supporting" class="headerlink" title="File Lock Supporting"></a>File Lock Supporting</h3><p><code>FileChannel.lock</code> 通过 <code>fcntl(F_SETLKW)</code> 获得一个文件锁（阻塞，<code>tryLock</code> 是 <code>fcntl(F_SETLK)</code> 非阻塞），<code>FileLock.release</code> 则通过 <code>F_UNLCK</code> 释放锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得锁</span><br>FileChannel.lock()<br>FileChannel.lock(<span class="hljs-number">0</span>, Long.MAX_VALUE, <span class="hljs-keyword">false</span>)<br>FileChannelImpl.lock(<span class="hljs-keyword">long</span> position, <span class="hljs-keyword">long</span> size, <span class="hljs-keyword">boolean</span> shared)<br>FileDispatcherImpl.lock(FileDescriptor fd, <span class="hljs-keyword">boolean</span> blocking, <span class="hljs-keyword">long</span> pos, <span class="hljs-keyword">long</span> size, <span class="hljs-keyword">boolean</span> shared)<br>FileDispatcherImpl.lock0(FileDescriptor fd, <span class="hljs-keyword">boolean</span> blocking, <span class="hljs-keyword">long</span> pos, <span class="hljs-keyword">long</span> size, <span class="hljs-keyword">boolean</span> shared)<br>FileDispatcherImpl_lock0(JNIEnv *env, jobject <span class="hljs-keyword">this</span>, jobject fdo, jboolean block, jlong pos, jlong size, jboolean shared)<br>fcntl(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )    <span class="hljs-comment">// 系统调用</span><br><br><span class="hljs-comment">// 释放锁</span><br>FileLock.release()<br>FileLockImpl.release()<br>FileChannelImpl.release(FileLockImpl fli)<br>FileDispatcherImpl.release(FileDescriptor fd, <span class="hljs-keyword">long</span> pos, <span class="hljs-keyword">long</span> size)<br>FileDispatcherImpl_release0(JNIEnv *env, jobject <span class="hljs-keyword">this</span>, jobject fdo, jlong pos, jlong size)<br>fcntl(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">int</span> __cmd, ...)    <span class="hljs-comment">// 系统调用</span><br></code></pre></div></td></tr></table></figure><blockquote><p>fcntl - manipulate file descriptor</p><p><code>int fcntl(int fd, int cmd, ... /* arg */ )</code></p><p>Linux implements traditional (“process-associated”) UNIX record locks, as standardized by POSIX.  For a Linux-specific alternative with better semantics, see the discussion of open file description locks below.</p><p>F_SETLK, F_SETLKW, and F_GETLK are used to acquire, release, and test for the existence of record locks (also known as byte-range, file-segment, or file-region locks).  The third argument, lock, is a pointer to a structure that has at least the following fields (in unspecified order).</p><div class="hljs code-wrapper"><pre><code>struct flock &#123;    ...    short l_type;    /* Type of lock: F_RDLCK,                        F_WRLCK, F_UNLCK */    short l_whence;  /* How to interpret l_start:                        SEEK_SET, SEEK_CUR, SEEK_END */    off_t l_start;   /* Starting offset for lock */    off_t l_len;     /* Number of bytes to lock */    pid_t l_pid;     /* PID of process blocking our lock                        (set by F_GETLK and F_OFD_GETLK) */    ...&#125;;</code></pre></div></blockquote><p>如果锁已被别的进程持有，<code>F_SETLK</code> 返回 -1 而 <code>F_SETLKW</code> 会阻塞直到锁被释放</p><ol><li><p>F_RDLCK 读锁，共享锁，可以被多个进程持有</p></li><li><p>F_WRLCK 写锁，排它锁（包括读锁），只能被一个进程持有</p></li><li><p>F_UNLCK 释放锁</p></li><li><p>SEEK_SET 锁的 offset 由 l_start 决定</p></li><li><p>SEEK_CUR 锁的 offset = fd.offset + l_start</p></li><li><p>SEEK_END 锁的 offset = fd.end + l_start</p></li></ol><h3 id="Buffer-的基本概念"><a href="#Buffer-的基本概念" class="headerlink" title="Buffer 的基本概念"></a>Buffer 的基本概念</h3><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>capacity</td><td>容量，固定不变的，在构造的时候就确定了</td></tr><tr><td>position</td><td>指示器的位置，指示下一次读/写的位置</td></tr><tr><td>limit</td><td>读模式表示 Buffer 里内容的大小（正常情况下 position &lt;= limit &lt;= capacity），写模式表示 Buffer 的容量（正常情况下 limit == capacity）</td></tr><tr><td>remaining</td><td>limit - position</td></tr><tr><td>read mode</td><td>position - 下一次读的位置，limit - Buffer 内的数据量，capacity - Buffer 容量</td></tr><tr><td>write mode</td><td>position - 下一次写的位置，limit/capacity - Buffer 容量</td></tr><tr><td>flip</td><td>limit, position = position, 0，用来把 Buffer 从写模式切换为读模式</td></tr><tr><td>rewind</td><td>position = 0</td></tr><tr><td>clear</td><td>position, limit = 0, capacity</td></tr><tr><td>compat</td><td>将 [position, limit] 这一块数据拷贝到 [0, limit - position]，然后 position, limit = limit - positon, capacity</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>nio</tag>
      
      <tag>ART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>老罗的 Android 之旅阅读笔记（Dalvik/ART 虚拟机篇）</title>
    <link href="/2021/05/28/dalvik-art-heap-gc/"/>
    <url>/2021/05/28/dalvik-art-heap-gc/</url>
    
    <content type="html"><![CDATA[<h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><h3 id="Dalvik-Heap"><a href="#Dalvik-Heap" class="headerlink" title="Dalvik Heap"></a>Dalvik Heap</h3><p>Dalvik 的堆空间分为 <code>Zygote Heap</code> 和 <code>Active Heap</code></p><p>Android 系统的第一个 Dalvik 虚拟机是由 Zygote 进程创建的。应用程序进程是由 Zygote 进程 <code>fork</code> 出来的。也就是说应用程序进程使用了一种 <strong>写时拷贝技术</strong>（<code>COW</code>）来复制了 Zygote 进程的地址空间。这意味着一开始的时候，应用程序进程和 Zygote 进程共享了同一个用来分配对象的堆。然而，当 Zygote 进程或者应用程序进程对该堆进行写操作时，内核就会执行真正的拷贝操作，使得 Zygote 进程和应用程序进程分别拥有自己的一份拷贝。</p><p>拷贝是一件费时费力的事情。因此，为了尽量地避免拷贝，Dalvik 虚拟机将自己的堆划分为两部分。事实上，Dalvik 虚拟机的堆最初是只有一个的。也就是 Zygote 进程在启动过程中创建 Dalvik 虚拟机的时候，只有一个堆。但是当 Zygote 进程在 <code>fork</code> 第一个应用程序进程之前，会将已经使用了的那部分堆内存划分为一部分，还没有使用的堆内存划分为另外一部分。前者就称为 <strong>Zygote 堆</strong>，后者就称为 <strong>Active 堆</strong>。以后无论是 Zygote 进程，还是应用程序进程，当它们需要分配对象的时候，都在 <code>Active 堆</code> 上进行。这样就可以使得 <code>Zygote 堆</code> 尽可能少地被执行写操作，因而就可以减少执行写时拷贝的操作。在 <code>Zygote 堆</code> 里面分配的对象其实主要就是 Zygote 进程在启动过程中预加载的类、资源和对象了。这意味着这些预加载的类、资源和对象可以在 Zygote 进程和应用程序进程中做到长期共享。这样既能减少拷贝操作，还能减少对内存的需求。</p><h3 id="堆的一些重要参数"><a href="#堆的一些重要参数" class="headerlink" title="堆的一些重要参数"></a>堆的一些重要参数</h3><table><thead><tr><th>中文名</th><th>英文名</th><th>VM 参数</th></tr></thead><tbody><tr><td>起始大小</td><td>Starting Size</td><td>-Xms</td></tr><tr><td>最大值</td><td>Maximum Size</td><td>-Xmx</td></tr><tr><td>增长上限值</td><td>Growth Limit</td><td>-XX:HeapGrowthLimit</td></tr><tr><td>最小空闲值</td><td>Min Free</td><td>-XX:HeapMinFree</td></tr><tr><td>最大空闲值</td><td>Max Free</td><td>-XX:HeapMaxFree</td></tr><tr><td>目标利用率</td><td>Target Utilization</td><td>-XX:HeapTargetUtilization</td></tr></tbody></table><p>堆 <strong>起始大小</strong> 指定了 Davlik 虚拟机在启动的时候向系统申请的物理内存的大小。后面再根据需要逐渐向系统申请更多的物理内存，直到达到 <strong>最大值</strong> 为止。这是一种按需要分配策略，可以避免内存浪费，厂商会通过 <code>dalvik.vm.heapstartsize</code> 和 <code>dalvik.vm.heapsize</code> 这两个属性将它们设置为合适设备的值的</p><p>注意，虽然堆使用的 <strong>物理内存</strong> 是按需要分配的，但是它使用的 <strong>虚拟内存</strong> 的总大小却是需要在 Dalvik 启动的时候就确定的。这个虚拟内存的大小就等于堆的最大值</p><p>想象一下，如果不这样做的话，会出现什么情况。假设开始时创建的虚拟内存小于堆的最大值，由于实际情况是允许虚拟内存达到堆的最大值的，因此当开始时创建的虚拟内存无法满足需求时，那么就需要重新创建另外一块更大的虚拟内存。这样就需要将之前的虚拟内存的内容拷贝到新创建的更大的虚拟内存去，并且还要相应地修改各种辅助数据结构。这样太麻烦了，而且效率也太低了。因此就在一开始的时候，就创建一块与堆的最大值相等的虚拟内存</p><p>但是 Dalvik 虚拟机又希望能够动态地调整堆的可用最大值，于是就出现了一个称为 <strong>增长上限</strong> 的值，我们可以认为它是堆大小的 <strong>软限制</strong>，而前面所描述的最大值是堆大小的 <strong>硬限制</strong>。它主要是用来限制 <code>Active Heap</code> 无节制地增长到最大值的，而是要根据预先设定的 <code>堆目标利用率</code> 来控制 <code>Active Heap</code> 有节奏地增长到最大值。这样可以更有效地使用堆内存。想象一下，如果我们一开始 <code>Active Heap</code> 的大小设置为最大值，那么就很有可能造成已分配的内存分布在一个很大的范围。这样随着 Dalvik 虚拟机不断地运行，<code>Active Heap</code> 的内存碎片就会越来越来重。相反，如果我们施加一个 <code>Soft Limit</code>，那可以尽量地控制已分配的内存都位于较紧凑的范围内，可以有效地减少碎片</p><p>后三个用来确保每次 GC 之后，堆已用内存和空闲内存有一个合适的比例，这样可以尽量地减少 GC 的次数。举个例子说，堆的利用率为 <code>U</code>，最小空闲值为 <code>MinFree</code> 字节，最大空闲值为 <code>MaxFree</code> 字节。假设在某一次 GC 之后，存活对象占用内存的大小为 <code>LiveSize</code>。那么这时候堆的理想大小应该为 <code>(LiveSize / U)</code>，且 <code>(LiveSize + MinFree)</code> &lt;= <code>(LiveSize / U)</code> &lt;= <code>(LiveSize + MaxFree)</code></p><h3 id="4-Type-Of-GC"><a href="#4-Type-Of-GC" class="headerlink" title="4 Type Of GC"></a>4 Type Of GC</h3><p>Davlik 虚拟机定义了四种类型的 GC</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* Not enough space for an &quot;ordinary&quot; Object to be allocated. */</span>  <br><span class="hljs-comment">/* 在堆上分配对象时内存不足 */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> GcSpec *GC_FOR_MALLOC;  <br>  <br><span class="hljs-comment">/* Automatic GC triggered by exceeding a heap occupancy threshold. */</span>  <br><span class="hljs-comment">/* 在已分配内存达到一定量之后触发 */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> GcSpec *GC_CONCURRENT;  <br>  <br><span class="hljs-comment">/* Explicit GC via Runtime.gc(), VMRuntime.gc(), or SIGUSR1. */</span>  <br><span class="hljs-comment">/* 应用程序调用 System.gc、VMRuntime.gc接口或者收到 SIGUSR1 信号时触发 */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> GcSpec *GC_EXPLICIT;  <br>  <br><span class="hljs-comment">/* Final attempt to reclaim memory before throwing an OOM. */</span>  <br><span class="hljs-comment">/* 在准备抛 OOM 异常之前进行的最后努力而触发的 GC */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> GcSpec *GC_BEFORE_OOM;  <br></code></pre></div></td></tr></table></figure><p>每种 GC 通过成员属性控制 GC 细节</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GcSpec</span> &#123;</span>  <br>  <span class="hljs-comment">/* If true, only the application heap is threatened. */</span>  <br>  <span class="hljs-comment">/* true - 仅仅回收 Active Heap，false - 同时回收 Active Heap 和 Zygote Heap */</span><br>  <span class="hljs-keyword">bool</span> isPartial;  <br>  <span class="hljs-comment">/* If true, the trace is run concurrently with the mutator. */</span>  <br>  <span class="hljs-comment">/* true - 执行并行 GC，false - 执行非并行 GC */</span><br>  <span class="hljs-keyword">bool</span> isConcurrent;  <br>  <span class="hljs-comment">/* Toggles for the soft reference clearing policy. */</span>  <br>  <span class="hljs-comment">/* true - 不回收软引用，false - 回收软引用引 */</span><br>  <span class="hljs-keyword">bool</span> doPreserve;  <br>  <span class="hljs-comment">/* A name for this garbage collection mode. */</span>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *reason;  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>GC_FOR_MALLOC</code>、<code>GC_CONCURRENT</code> 和 <code>GC_BEFORE_OOM</code> 三种类型的 GC 都是在分配对象的过程触发的：</p><ol><li>Dalvik 虚拟机在堆上分配对象的时候，如果分配失败会首先尝试 <code>GC_FOR_MALLOC</code></li><li>GC 后再次进行对象的分配，如果失败这时候就得考虑先将堆的当前大小设置为 Dalvik 虚拟机启动时指定的堆最大值，再进行内存分配了（不应该是逐步增长？）</li><li>如果上一步内存分配还是失败，这时候就得出狠招 <code>GC_BEFORE_OOM</code> 将 <strong>软引用</strong> 也回收掉</li><li>这是最后一次努力了，如果还是分配失败就抛出 <code>OOM</code></li><li>成功地在堆上分配到一个对象之后，就会检查 <code>Active Heap</code> 当前已经分配的内存，如果大于阀值就会唤醒 GC 线程进行 <code>GC_CONCURRENT</code>。这个阀值是一个比指定的 <strong>堆最小空闲内存</strong> 小 128K 的数值，也就是说当堆的 <strong>空闲内不足</strong> 时就会触发 <code>GC_CONCURRENT</code></li></ol><h3 id="Mark-Sweep（标记-清理-GC-算法）"><a href="#Mark-Sweep（标记-清理-GC-算法）" class="headerlink" title="Mark-Sweep（标记-清理 GC 算法）"></a>Mark-Sweep（标记-清理 GC 算法）</h3><p>顾名思义，<code>Mark-Sweep</code> （标记-回收）算法就是分为 <code>Mark</code> 和 <code>Sweep</code>两个阶段进行垃圾回收：</p><ol><li><code>Mark</code> 阶段从 <code>GC ROOT</code>开始递归地标记出当前所有被引用的对象</li><li><code>Sweep</code> 阶段负责回收那些没有被引用的对象</li></ol><p><img src="../../../../image/2021-05-28-dalvik-art-heap-gc/mark_sweep.jpg" alt="Mark - Sweep"></p><h4 id="挂起其他线程"><a href="#挂起其他线程" class="headerlink" title="挂起其他线程"></a>挂起其他线程</h4><p>函数 <code>lockThreadSuspend</code> 尝试获取 <code>gDvm._threadSuspendLock</code> 锁。如果获取失败，就表明有其它线程也正在请求挂起 Dalvik 虚拟机中的线程，包括当前线程。每一个 Dalvik 虚拟机线程都有一个 <code>Suspend Count</code> 计数，每当它们都挂起的时候，对应的 <code>Suspend Count</code> 计数就会加 <code>1</code>，而当被唤醒时，对应的 <code>Suspend Count</code> 计数就会减 <code>1</code>。在获取 <code>gDvm._threadSuspendLock</code> 锁失败的情况下，当前线程按照一定的时间间隔检查自己的 <code>Suspend Count</code>，直到自己的 <code>Suspend Count</code> 等于 <code>0</code>，并且能成功获取 <code>gDvm._threadSuspendLock</code> 锁为止。这样就可以保证每一个挂起 Dalvik 虚拟机线程的请求都能够得到顺序执行。</p><p>从函数 <code>lockThreadSuspend</code> 返回之后，就表明当前线程可以执行挂起其它线程的操作了。它首先要做的第一件事情是遍历 Dalvik 虚拟机线程列表，并且调用函数 <code>dvmAddToSuspendCounts</code> 将列表里面的每一个线程对应的 <code>Suspend Count</code> 都增加1，但是除了当前线程之外。注意，在增加被挂起线程的 <code>Suspend Count</code> 计数之前，必须要获取 <code>gDvm.threadSuspendCountLock</code> 锁。这个锁的获取和释放可以通过函数 <code>lockThreadSuspendCount</code> 和 <code>unlockThreadSuspendCount</code> 完成</p><p>将被挂起线程的 <code>Suspend Count</code> 计数都增加 <code>1</code> 之后，接下来就是等待被挂起线程自愿将自己挂起来了。这是通过函数 <code>waitForThreadSuspend</code> 来实现。当一个线程自愿将自己挂起来的时候，会将自己的状态设置为非运行状态（<code>THREAD_RUNNING</code>），这样函数 <code>waitForThreadSuspend</code> 通过不断地检查一个线程的状态是否处于非运行状态就可以知道它是否已经挂起来了</p><p>那么，一个线程在什么情况才会自愿将自己挂起来呢？一个线程在执行的过程中，会在合适的时候检查自己的 <code>Suspend Count</code> 计数。一旦该计数值不等于 <code>0</code>，那么它就知道有线程请求挂起自己，因此它就会很配合地将自己的状态设置为非运行的，并且将自己挂起来。例如，当一个线程通过解释器执行代码时，就会周期性地检查自己的 <code>Suspend Count</code> 是否等于 <code>0</code>。这里说的周期性，实际上就是碰到 <code>IF</code> 指令、<code>GOTO</code> 指令、<code>SWITCH</code> 指令、<code>RETURN</code> 指令和 <code>THROW</code> 指令等时。</p><h3 id="Heap-Bitmap"><a href="#Heap-Bitmap" class="headerlink" title="Heap Bitmap"></a>Heap Bitmap</h3><p>堆的起始地址为 <code>base</code>，大小为 <code>maxSize</code>，由此我们就知道在堆上创建的对象的地址范围为 <code>[base, maxSize)</code>。 但是通过 C 库提供的 <code>mspace_malloc</code> 在堆分配内存时，得到的内存地址是以 8 bits 对齐的。这意味着我们只需要 <code>(maxSize / 8)</code> bits 来描述堆对象。结构体 <code>HeapBitmap</code> 的成员变量 <code>bits</code> 是一个类型为 <code>unsigned long</code> 的数组，也就是说数组中的每一个元素都可以描述 <code>sizeof(unsigned long)</code> 个对象的存活。在 32 位设备上，一个 <code>unsigned long</code> 占用 32 bits，这意味着需要一个大小为 <code>(maxSize / 8 / 32)</code> 的 <code>unsigned long</code> 数组来描述堆对象的存活。如果换成字节数来描述的话，就是说我们需要一块大小为 <code>(maxSize / 8 / 32) × 4</code> 的内存块来描述一个大小为 <code>maxSize</code> 的堆对象。</p><p><code>Live Bitmap</code> 用来标记上一次 GC 时被引用的对象（也就是没有被回收的对象），<code>Mark Bitmap</code> 用来标记当前 GC Mark 阶段发现的被引用对象，那么在 <code>Live Bitmap</code> 标记为 1，但是在 <code>Mark Bitmap</code> 中标记为 0 的即为需要回收的对象</p><p>假设我们知道了一个对象的地址为 <code>ptr</code>，堆的起始地址为 <code>base</code>，那么就可以计算得到一个偏移值 <code>offset</code>。有了这个偏移值之后，可以计算得到用来描述该对象存活的 bit 位于 <code>HeapBitmap-&gt;bits</code> 的 <code>unsigned long</code> 数组的索引 <code>index</code>。有了这个 <code>index</code> 之后，我们就可以得到一个 <code>unsigned long</code> 值。接着再通过对象地址 <code>ptr</code> 的第 4 到第 8 位表示的数值为索引，在前面找到的 <code>unsigned long</code> 值取出相应的位，就可以得到该对象是否存活了。</p><p>相反，给出一个 <code>HeapBitmap-&gt;bits</code> 描述的 <code>unsigned long</code> 数组的索引 <code>index</code>，我们可以找到一个偏移值 <code>offset</code>，将这个偏移值加上堆的起始地址 <code>base</code>，就可以得到一个对象的地址 <code>ptr</code></p><h3 id="Mark-Stack"><a href="#Mark-Stack" class="headerlink" title="Mark Stack"></a>Mark Stack</h3><p>在 GC Mark 阶段，Dalvik 虚拟机能过 <strong>递归方式</strong> 来标记对象。但是这不是通过函数的递归调用来实现的，而是借助一个称为 <code>Mark Stack</code> 的栈来实现的。具体来说，当我们标记完 <code>GC ROOT</code> 之后，就按照它们的地址从小到大的顺序标记它们所引用的其它对象。</p><p>假设有 A、B、C 和 D 四个对象，它的地址大小关系为 A &lt; B &lt; C &lt; D，其中 B 和 D 是 <code>GC ROOT</code>，A 被 D 引用，C 没有被 B 和 D 引用。那么我们将依次遍历 B 和 D，当遍历到 B 的时候没有发现它引用其它对象，然后就继续向前遍历 D 对象，发现它引用了 A 对象。按照递归的算法，这时候除了标记 A 对象是正在使用之外，还应该去检查 A 对象有没有引用其它对象，然后又再检查它引用的对象有没有又引用其它的对象，一直这样遍历下去，这样就跟函数递归一样。（树的 <strong>深度优先</strong> 遍历算法）</p><p>更好的做法是将对象 A 记录在一个 <code>Mark Stack</code> 中，然后继续检查地址值比对象 D 大的其它对象。对于地址值比对象 D 大的其它对象，如果它们引用了一个地址值比它们小的其它对象，那么这些其它对象同样要记录在 <code>Mark Stack</code> 中。等到该轮检查结束之后，再回过头来检查记录在 <code>Mark Stack</code>里面的对象。然后又重复上述过程，直到 <code>Mark Stack</code>等于空为止。（树的 <strong>广度优先</strong> 遍历算法）</p><h3 id="Concurrent-GC"><a href="#Concurrent-GC" class="headerlink" title="Concurrent GC"></a>Concurrent GC</h3><p>在 GC Mark 阶段，要求除了 GC 线程之外其它的线程都停止，否则的话就会可能导致不能正确地标记每一个对象。这种现象在 GC 中称为 <code>Stop The World</code>，会导致程序中止执行，造成停顿的现象。为了尽可能地减少停顿，我们必须要允许在 Mark 阶段有条件地允许程序的其它线程执行。这种 GC 称为 <strong>并行垃圾收集算法</strong>（<code>Concurrent GC</code>）。</p><p>为了实现 <code>Concurrent GC</code>，Mark 阶段又划分两个子阶段：</p><ol><li>第一个子阶段只负责标记根集对象（<code>GC ROOT</code>）。所谓的根集对象，就是指在 GC 开始的瞬间，被全局变量、栈变量和寄存器等引用的对象</li><li>有了这些根集变量之后，我们就可以顺着它们找到其余的被引用变量。例如，一个栈变量引了一个对象，而这个对象又通过成员变量引用了另外一个对象，那该被引用的对象也会同时标记为正在使用。这个 <strong>标记被根集对象引用的对象</strong> 的过程就是第二个子阶段</li></ol><h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><h3 id="odex"><a href="#odex" class="headerlink" title="odex"></a>odex</h3><p>Davik 实现在 <code>libdvm.so</code> 中，ART 实现在 <code>libart.so</code> 中。Android 提供了一个系统属性 <code>persist.sys.dalvik.vm.lib</code>，如果等于 <code>libdvm.so</code> 就表示当前用的是 Dalvik，如果等于 <code>libart.so</code> 表示当前用的是 ART</p><p>Dalvik 执行的是 dex 字节码，ART 执行的是本地机器码</p><p>Dalvik 包含一个解释器用来执行 dex 字节码，而且从 Android 2.2 开始也包含有 <code>JIT</code>（Just-In-Time），用来在运行时动态地将执行频率很高的 dex 字节码翻译成本地机器码再执行。通过 <code>JIT</code> 就可以有效地提高 Dalvik 的执行效率。但是将 dex 字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候都要做重做这个翻译工作的。因此即使用采用了 <code>JIT</code>，Dalvik 的总体性能还是不能与直接执行本地机器码的 ART 相比（ART 是 <code>AOT</code>）</p><p><code>PackageManagerService</code> 在安装 APK 的过程中会通过 <code>Installer.dexopt</code> 对 dex 字节码进行优化，<code>Installer</code> 通过 socket 向守护进程 <code>installd</code> 发送一个 <code>dexopt</code> 请求，这个请求是由 <code>installd</code> 里面的函数 <code>dexopt</code> 来处理的</p><p><code>dexopt</code> 首先是读取系统属性 <code>persist.sys.dalvik.vm.lib</code>，接着在 <code>/data/dalvik-cache</code> 创建一个 <code>odex</code> 文件。这个 <code>odex</code> 文件就是作为 dex 优化后的输出文件。再接下来，函数 <code>dexopt</code> 通过 <code>fork</code> 来创建一个子进程：</p><ol><li>如果系统属性 <code>persist.sys.dalvik.vm.lib</code> 的值等于 <code>libdvm.so</code>，那么该子进程就会调用函数 <code>run_dexopt</code>（最终调用命令 <code>/system/bin/dexopt</code>）来将 dex 文件优化成 <code>odex</code> 文件</li><li>如果系统属性 <code>persist.sys.dalvik.vm.lib</code> 的值等于 <code>libart.so</code>，那么该子进程就会调用函数 <code>run_dex2oat</code>（最终调用命令 <code>/system/bin/dex2oat</code>）来将 dex 文件翻译成 <code>oat</code> 文件，实际上就是将 dex 字节码翻译成本地机器码，并且保存在一个 <code>oat</code> 文件中</li></ol><p>无论是对 dex 字节码进行优化，还是将 dex 字节码翻译成本地机器码，最终得到的结果都是保存在相同名称的一个 <code>odex</code> 文件里面的，但是前者对应的是一个 <code>dey</code> 文件（表示这是一个优化过的 dex），后者对应的是一个 <code>oat</code> 文件（实际上是一个自定义的 elf 文件，里面包含的都是本地机器指令）</p><h3 id="ART-Heap"><a href="#ART-Heap" class="headerlink" title="ART Heap"></a>ART Heap</h3><p><code>ART</code> 的堆分为四个部分：<code>Image Space</code>、<code>Zygote Space</code>、<code>Allocation Space</code> 和 <code>Large Object Space</code></p><p>其中 <code>Image Space</code>、<code>Zygote Space</code> 和 <code>Allocation Space</code> 是在地址上连续的空间，称为 <code>Continuous Space</code>，而 <code>Large Object Space</code> 是一些离散地址的集合，用来分配一些大对象，称为 <code>Discontinuous Space</code></p><p>Space 还可以划分为 <code>Allocable</code> 和 <code>Non-Allocable</code> 两种。例如，<code>Image Space</code> 是不能分配新对象的（它是 boot oat 的文件映射），而 <code>Zygote Space</code>、<code>Allocation Space</code> 和 <code>Large Object Space</code> 是可以分配对象</p><p><code>Continuous Space</code> 内部使用的内存块都是通过内存映射得到的，不过这块内存有可能是通过不同方式映射得到的。例如，<code>Image Space</code> 内部使用的内存块是通过内存映射 Image 文件得到的，而 <code>Zygote Space</code> 和 <code>Allocation Space</code> 内部使用的内存块是通过内存映射匿名共享内存得到</p><p><code>Image Space</code> 空间包含了那些需要预加载的系统类对象，是对 <code>/system/framework/boot.art</code> 或者 <code>/data/dalvik-cache/system@framework@boot.art@classes.dex</code> 的内存映射</p><p><code>Zygote Space</code> 和 <code>Allocation Space</code> 与 Dalvik 虚拟机垃圾收集机制中的 Zygote 堆和 Active 堆的作用是一样的。<code>Zygote Space</code> 在 Zygote 进程和应用程序进程之间共享的，而 <code>Allocation Space</code> 则是每个进程独占的。同样的，Zygote 进程一开始只有一个 <code>Image Space</code> 和一个 <code>Zygote Space</code>。在 Zygote 进程 <code>fork</code> 第一个子进程之前，就会把 <code>Zygote Space</code> 一分为二，原来的已经被使用的那部分堆还叫 <code>Zygote Space</code>，而未使用的那部分堆就叫 <code>Allocation Space</code>。以后的对象都在 <code>Allocation Space</code> 上分配。</p><p>只要满足以下三个条件，就在 <code>Large Object Space</code> 上分配，否则就在 <code>Zygote Space</code> 或者 <code>Allocation Space</code> 上分配：</p><ol><li>请求分配的内存大于等于 <code>Heap-&gt;large_object_threshold_</code>，它等于 <code>3 * kPageSize</code> 即 3 个页面的大小</li><li>已经从 <code>Zygote Space</code> 划分出 <code>Allocation Space</code>，即 <code>Heap-&gt;have_zygote_space_ == true</code></li><li>被分配的对象是一个原子类型数组，即 byte 数组、int 数组和 boolean 数组等</li></ol><p>ART 运行时的堆 <code>Heap</code> 有以下重要的成员变量</p><table><thead><tr><th>name</th><th>desc</th></tr></thead><tbody><tr><td>mark_sweep_collectors_</td><td>保存了六种 <code>Mark-Sweep</code> 垃圾收集器的向量</td></tr><tr><td>continuous_spaces_</td><td>保存了三个在地址空间上连续的 <code>Image Space</code>、<code>Zygote Space</code> 和 <code>Allocation Space</code></td></tr><tr><td>concurrent_gc_</td><td>bool，描述是否支持并行 GC，可以通过 <code>-Xgc</code> 来指定</td></tr><tr><td>parallel_gc_threads_</td><td>指定在 GC 暂停阶段用来同时执行 GC 任务的线程数，通过 <code>-XX:ParallelGCThreads</code>指定。默认 CPU 核心数减 1</td></tr><tr><td>conc_gc_threads_</td><td>非 GC 暂停阶段用来同时执行 GC 任务的线程数，通过 <code>-XX:ConcGCThreads</code> 指定</td></tr><tr><td>discontinuous_spaces_</td><td>向量，保存了在地址空间上不连续的 <code>Large Object Space</code></td></tr><tr><td>alloc_space_</td><td>指向 <code>Allocation Space</code></td></tr><tr><td>large_object_space_</td><td>指向 <code>Large Object Space</code></td></tr><tr><td>card_table_</td><td><code>Card Table</code></td></tr><tr><td>image_mod_union_table_</td><td>记录 GC 并行阶段在 <code>Image Space</code> 的对象对在 <code>Zygote Space</code> 和 <code>Allocation Space</code> 上分配的对象的引用</td></tr><tr><td>zygote_mod_union_table_</td><td>记录 GC 并行阶段在 <code>Zygote Space</code> 的对象对在 <code>Allocation Space</code> 上分配的对象的引用</td></tr><tr><td>mark_stack_</td><td><code>Mark Stack</code>，用来在 GC 过程中实现递归对象标记</td></tr><tr><td>allocation_stack_</td><td><code>Allocation Stack</code>，用来记录上一次 GC 后分配的对象，用来实现类型为 <code>Sticky</code> 的 <code>Mark Sweep Collector</code></td></tr><tr><td>live_stack_</td><td><code>Live Stack</code>，配合 <code>allocation_stack_</code> 一起使用，用来实现类型为 <code>Sticky</code> 的 <code>Mark Sweep Collector</code></td></tr><tr><td>mark_bitmap_</td><td>与 Dalvik Mark Bitmap 作用是一样的，用来标记当前 GC 之后还存活的对象</td></tr><tr><td>live_bitmap_</td><td>与 Dalvik Live Bitmap 作用是一样的，用来标记上一次 GC 之后还存活的对象</td></tr></tbody></table><p>Space 有以下三种回收策略</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// See Space::GetGcRetentionPolicy.  </span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">GcRetentionPolicy</span> &#123;</span>  <br>  <span class="hljs-comment">// Objects are retained forever with this policy for a space.  </span><br>  <span class="hljs-comment">// 永远不会进行垃圾回收的 Space，例如 Image Space</span><br>  kGcRetentionPolicyNeverCollect,  <br>  <span class="hljs-comment">// Every GC cycle will attempt to collect objects in this space.  </span><br>  <span class="hljs-comment">// 每一次 GC 都会尝试回收垃圾的 Space，例如 Allocation Space</span><br>  kGcRetentionPolicyAlwaysCollect,  <br>  <span class="hljs-comment">// Objects will be considered for collection only in &quot;full&quot; GC cycles, ie faster partial  </span><br>  <span class="hljs-comment">// collections won&#x27;t scan these areas such as the Zygote.  </span><br>  <span class="hljs-comment">// 只有执行类型为 kGcTypeFull 的 GC 才会进行垃圾回收的 Space，例如 Zygote Space</span><br>  kGcRetentionPolicyFullCollect,  <br>&#125;;  <br></code></pre></div></td></tr></table></figure><h3 id="在堆上分配对象"><a href="#在堆上分配对象" class="headerlink" title="在堆上分配对象"></a>在堆上分配对象</h3><p>流程跟 Dalvik 差不多：</p><ol><li>Dalvik 虚拟机在堆上分配对象的时候，如果分配失败会首先尝试 <code>GC_FOR_MALLOC</code></li><li>GC 后再次进行对象的分配，如果失败这时候就得考虑先将堆的当前大小设置为 Dalvik 虚拟机启动时指定的堆最大值，再进行内存分配了（不应该是逐步增长？）</li><li>如果上一步内存分配还是失败，这时候就得出狠招 <code>GC_BEFORE_OOM</code> 将 <strong>软引用</strong> 也回收掉</li><li>这是最后一次努力了，如果还是分配失败就抛出 <code>OOM</code></li><li>成功地在堆上分配到一个对象之后，就会检查 <code>Active Heap</code> 当前已经分配的内存，如果大于阀值（<code>Heap-&gt;concurrent_start_bytes_</code>）就会唤醒 GC 线程进行 <code>GC_CONCURRENT</code>。这个阀值是一个比指定的 <strong>堆最小空闲内存</strong> 小 128K 的数值，也就是说当堆的 <strong>空闲内不足</strong> 时就会触发 <code>GC_CONCURRENT</code></li></ol><h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><p>ART 有以下三种 GC Collector </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// The type of collection to be performed. The ordering of the enum matters, it is used to  </span><br><span class="hljs-comment">// determine which GCs are run first.  </span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">GcType</span> &#123;</span>  <br>  <span class="hljs-comment">// Placeholder for when no GC has been performed.  </span><br>  kGcTypeNone,  <br>  <span class="hljs-comment">// Sticky mark bits GC that attempts to only free objects allocated since the last GC.  </span><br>  <span class="hljs-comment">// StickyMarkSweep 类型的垃圾收集器，用来收集上次 GC 以来分配的对象</span><br>  kGcTypeSticky,  <br>  <span class="hljs-comment">// Partial GC that marks the application heap but not the Zygote.  </span><br>  <span class="hljs-comment">// PartialMarkSweep 类型的垃圾收集器，用来收集在 Allocation Space 上分配的对象</span><br>  kGcTypePartial,  <br>  <span class="hljs-comment">// Full GC that marks and frees in both the application and Zygote heap.  </span><br>  <span class="hljs-comment">// MarkSweep 类型的垃圾收集器，用来收集在 Zygote Space 和 Allocation Space 上分配的对象</span><br>  kGcTypeFull,  <br>  <span class="hljs-comment">// Number of different GC types.  </span><br>  kGcTypeMax,  <br>&#125;;  <br></code></pre></div></td></tr></table></figure><p>ART 比 Dalvik 多了一个称 <code>Mod Union Table</code> 的概念。<code>Mod Union Table</code> 是与 <code>Card Table</code> 配合使用的，用来记录在一次 GC 过程中，不会被回收的 Space 对象对会被回收的 Space 对象引用。例如，<code>Image Space</code> 对象对 <code>Zygote Space</code> 和 <code>Allocation Space</code> 对象的引用，以及 <code>Zygote Space</code> 对象对 <code>Allocation Space</code> 对象的引用。</p><h3 id="五个守护线程"><a href="#五个守护线程" class="headerlink" title="五个守护线程"></a>五个守护线程</h3><p><code>java.lang.Daemons</code> 类在加载的时候，会启动五个与堆或者 GC 相关的守护线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Daemons</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;  <br>        ReferenceQueueDaemon.INSTANCE.start();  <br>        FinalizerDaemon.INSTANCE.start();  <br>        FinalizerWatchdogDaemon.INSTANCE.start();  <br>        HeapTrimmerDaemon.INSTANCE.start();  <br>        GCDaemon.INSTANCE.start();  <br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><table><thead><tr><th>英文</th><th>中文</th><th>描述</th></tr></thead><tbody><tr><td>ReferenceQueueDaemon</td><td>引用队列守护线程</td><td>在创建 <code>Reference</code> 时可以关联一个 <code>ReferenceQueue</code>，当引用对象被 GC 回收的时候，<code>Reference</code> 就会被加入到 <code>ReferenceQueue</code>。这个入队操作就是由 <code>ReferenceQueueDaemon</code> 来完成的。这样应用程序就可以知道那些被引用对象引用的对象已经被回收了</td></tr><tr><td>FinalizerDaemon</td><td>析构守护线程</td><td>对于重写了成员函数 <code>finalize</code> 的对象，它们被 GC 决定回收时并没有马上被回收，而是被放入到一个队列中，等待 <code>FinalizerDaemon</code> 守护线程去调用它们的成员函数 <code>finalize</code> 然后再被回收</td></tr><tr><td>FinalizerWatchdogDaemon</td><td>析构监护守护线程</td><td>用来监控 <code>FinalizerDaemon</code> 线程的执行。一旦检测到在执行成员函数 <code>finalize</code> 时超出一定的时间限制，那么就会退出 VM</td></tr><tr><td>HeapTrimmerDaemon</td><td>堆裁剪守护线程</td><td>用来执行裁剪堆的操作，也就是用来将那些空闲的堆内存归还给系统（<code>compacting</code>）</td></tr><tr><td>GCDaemon</td><td>并行 GC 线程</td><td>用来执行并行 GC</td></tr></tbody></table><h3 id="Compacting-GC"><a href="#Compacting-GC" class="headerlink" title="Compacting GC"></a>Compacting GC</h3><p>Android 4.4 支持 <code>Mark-Sweep GC</code>，到了 Android 5.0 增加了对 <code>Compacting GC</code> 的支持。所谓 <code>Compacting GC</code>，就是在进行 GC 的时候同时对堆空间进行 <strong>压缩</strong> 以消除碎片，因此它的堆空间利用率就更高。但是也正因为要对堆空间进行压缩，导致它的效率不如 <code>Mark-Sweep GC</code>，而且会导致对象的地址发生变化</p><p>在以往的 <code>Mark-Sweep GC</code> 时由于碎片而产生的内存不足问题是解决不了的，只能让应用程序 OOM。但是有了 <code>Compacting GC</code> 之后就可以在应用程序 OOM 之前再作一次努力，那就是对原来的堆空间进行压缩一下，再尝试进行分配，这样就可以提高成功分配内存的概率</p><p><code>Compacting GC</code> 增加了一些额外的参数：</p><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>-XX:NonMovingSpaceCapacity</td><td><code>Non-Moving Space</code> 的大小，默认大小为 <code>kDefaultNonMovingSpaceCapacity</code>（64MB）</td></tr><tr><td>-Xgc</td><td><code>Foreground GC</code> 的类型，可选：<code>Concurrent Mark-Sweep GC</code>、<code>Semi-Space GC</code> 或者 <code>Generational Semi-Space GC</code></td></tr><tr><td>-XX:BackgroundGC</td><td><code>Background GC</code> 的类型，比 <code>Foreground GC</code> 多了 <code>Homogeneous-Space-Compact</code>，默认就与 <code>Foreground GC</code> 一样</td></tr><tr><td>-XX:EnableHSpaceCompactForOOM / -XX:DisableHSpaceCompactForOOM</td><td>是否在 OOM 时执行 <code>Homogeneous-Space-Compact</code></td></tr></tbody></table><p><code>Compacting GC</code> 通过移动和整理对象以实现压缩：把散乱的对象逐个移动到一块空闲的内存空间，因为整块空间都是空闲的，所以可以紧凑地将它们放在一起，这个空间叫 <code>Bump Pointer Space</code></p><h4 id="Generational-Semi-Space-GC"><a href="#Generational-Semi-Space-GC" class="headerlink" title="(Generational) Semi-Space GC"></a>(Generational) Semi-Space GC</h4><p><code>Semi-Space GC</code> 由两个 <code>Bump Pointer Space</code> 组成，分别叫做 <code>From Space</code> 和 <code>To Space</code>，其中对象的分配发生在 <code>From Space</code>中。<code>Bump Pointer Space</code> 有一个指针 <code>end_</code> 始终指向下一次要分配的内存块的起始地址，因此在 <code>Bump Pointer Space</code> 上分配内存的逻辑是很简单的，只要指针 <code>end_</code> 向前移动指定的大小即可，这也是 <code>Bump Pointer</code> 的由来</p><p>当 <code>From Space</code> 不能满足内存分配要求时，就会触发一次 <code>Semi-Space GC</code>，结果就是 <code>From Space</code> 和 <code>To Space</code> 互换了位置，并且原来在 <code>From Space</code> 上的 Live Object 按地址值 <strong>从小到大</strong> 的顺序移动到了原来的<code>To Space</code>上去（这不就是 JVM Young Generation 里的 Survivor 嘛）</p><p><code>Generational Semi-Space GC</code> 涉及到三个 Space，其中两个是 <code>Bump Pointer Space</code>，另外一个是 <code>Promote Space</code></p><p><code>Generational Semi-Space GC</code> 与 <code>Semi-Space GC</code> 基本相同，只不过会考虑到 <strong>对象的年龄</strong>。如果一个对象在多次 GC 中都能存活下来，那么就会将它移动到一个 <code>Promote Space</code> 中去。这相当于是简单地将对象划分为 <strong>新生代</strong> 和 <strong>老生代</strong>，即在上一次 GC 之前分配的对象属于老生代，而在上一次 GC 之后分配的对象属于新生代。由于 <code>Promote Space</code> 是一个 <code>Non-Moving Space</code>，以后在这个 Space 上的对象不会再被移动。通过这种方式就可以有效地减少在 <code>Generational Semi-Space GC</code> 中要移动的对象的个数，从而提高 GC 效率（这不就是 JVM Old Generation）</p><p><code>Semi-Space GC</code> 和 <code>Generational Semi-Space GC</code> 使用的是同一个垃圾收集器，保存在 <code>Heap-&gt;semi_space_collector_</code>，From Space 和 To Space 分别是 <code>Heap-&gt;bump_pointer_space_</code> 和 <code>Heap-&gt;temp_space_</code>（它们都是 <code>Bump Pointer Space</code>），当 GC 执行完毕交换 From Space 和 To Space</p><p>只能执行类型为 <code>kGcTypeFull</code> 的 GC</p><h4 id="Mark-Compact-GC"><a href="#Mark-Compact-GC" class="headerlink" title="Mark-Compact GC"></a>Mark-Compact GC</h4><ol><li>只需一个 <code>Bump Pointer Space</code> 来压缩内存，当 GC 执行完成之后，原来位于 <code>Bump Pointer Space</code> 上的仍然存活的对象会被依次移动至左侧，并且按地址从小到大紧凑地排列在一起</li><li>执行过程分为 <strong>初始化</strong>、<strong>标记</strong>、<strong>回收</strong> 和 <strong>结束</strong> 四个阶段，对应的函数分别为 <code>MarkCompact</code> 的 <code>InitializePhase</code>、<code>MarkingPhase</code>、<code>ReclaimPhase</code> 和 <code>FinishPhase</code>，其中标记和回收阶段是在挂起其它线程的前提下进行的</li><li><code>Image Space</code> 和 <code>Zygote Space</code> 是不进行垃圾回收的，同时也意味着 <code>Non Moving Space</code>、<code>Bump Pointer Space</code> 和 <code>Large Object Space</code> 需要进行垃圾回收</li><li>标记阶段并没有对 <code>Bump Pointer Space</code> 的存活对象进行移动，而是在接下来的回收阶段再执行此操作</li><li>能够执行 <code>kGcTypeSticky</code>、<code>kGcTypePartial</code> 和 <code>kGcTypeFull</code> 三种类型的 GC</li></ol><h4 id="Homogeneous-Space-Compact"><a href="#Homogeneous-Space-Compact" class="headerlink" title="Homogeneous Space Compact"></a>Homogeneous Space Compact</h4><p>所谓的 <strong>同构空间压缩特性（Homogeneous Space Compact）</strong>，是针对 <code>Mark-Sweep GC</code> 而言的。一个 Space 需要有 Main 和 Backup 之分。执行同构空间压缩时，将 Main Space 的对象移动至 Backup Space 中去，再将 Main Space 和 Backup Space 进行交换，这样就达到压缩空间，即减少内存碎片的作用。</p><h4 id="Non-Moving-Space"><a href="#Non-Moving-Space" class="headerlink" title="Non-Moving Space"></a>Non-Moving Space</h4><p>在 <code>Compacting GC</code> 中涉及到对象的移动，但是有些对象例如类对象（Class）、类方法对象（ArtMethod）和类成员变量对象（ArtField），它们一经加载后基本上就会一直存在。因此频繁对此类对象进行移动是无益的，我们需要将它们分配在一个不能移动的 Space 中以减少在 <code>Compacting GC</code> 需要处理的对象的数量</p><h3 id="Foreground-GC-和-Background-GC"><a href="#Foreground-GC-和-Background-GC" class="headerlink" title="Foreground GC 和 Background GC"></a>Foreground GC 和 Background GC</h3><p>ART 既支持 <code>Mark-Sweep GC</code> 又支持 <code>Compacting GC</code>。其中 <code>Mark-Sweep GC</code> 执行效率更高但是存在内存碎片问题，而 <code>Compacting GC</code> 执行效率较低但是不存在内存碎片问题。ART 通过引入 <code>Foreground GC</code> 和 <code>Background GC</code> 的概念来对这两种 GC 进行扬长避短，分别用 <code>-Xgc</code> 和 <code>-XX:BackgroundGC</code> 指定</p><p>顾名思义，<code>Foreground GC</code> 就是应用程序在前台运行时执行的 GC，<code>Background GC</code> 就是应用程序在后台运行时执行的 GC。应用程序在前台运行时，响应性是最重要的，因此也要求执行的GC是高效的。相反，应用程序在后台运行时，响应性不是最重要的，这时候就适合用来解决堆的内存碎片问题。因此，<code>Mark-Sweep GC</code> 适合作为 <code>Foreground GC</code> 而 <code>Compacting GC</code> 适合作为 <code>Background GC</code></p><p><code>AMS</code> 清楚地知道应用程序当前是在前台运行还是后台运行，所以由它负责触发切换前后台 GC 的操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationThread.scheduleLaunchActivity<br><br>ApplicationThread.updateProcessState(<span class="hljs-keyword">int</span> processState, <span class="hljs-keyword">boolean</span> fromIpc) &#123;  <br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;  <br>        <span class="hljs-keyword">if</span> (mLastProcessState != processState) &#123;  <br>            mLastProcessState = processState;  <br>            <span class="hljs-comment">// 用户可感知/用户不可感知</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DALVIK_PROCESS_STATE_JANK_PERCEPTIBLE = <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DALVIK_PROCESS_STATE_JANK_IMPERCEPTIBLE = <span class="hljs-number">1</span>;  <br>            <span class="hljs-keyword">int</span> dalvikProcessState = DALVIK_PROCESS_STATE_JANK_IMPERCEPTIBLE;  <br>            <br>            <span class="hljs-comment">// &lt;= PROCESS_STATE_IMPORTANT_FOREGROUND 表示前台进程，用户可见可交互</span><br>            <span class="hljs-keyword">if</span> (processState &lt;= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123;  <br>                dalvikProcessState = DALVIK_PROCESS_STATE_JANK_PERCEPTIBLE;  <br>            &#125;  <br>            VMRuntime.getRuntime().updateProcessState(dalvikProcessState);  <br>            ......  <br>        &#125;  <br>    &#125;  <br>&#125; <br><br><span class="hljs-comment">// AMS 定义了 14 种进程的状态，越小越重要</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManager</span> </span>&#123;  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is a persistent system process. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_PERSISTENT = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is a persistent system process and is doing UI. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_PERSISTENT_UI = <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is hosting the current top activities.  Note that this covers </span><br><span class="hljs-comment">     * all activities that are visible to the user. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_TOP = <span class="hljs-number">2</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is important to the user, and something they are aware of. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_IMPORTANT_FOREGROUND = <span class="hljs-number">3</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is important to the user, but not something they are aware of. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_IMPORTANT_BACKGROUND = <span class="hljs-number">4</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background running a backup/restore operation. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_BACKUP = <span class="hljs-number">5</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background, but it can&#x27;t restore its state so we want </span><br><span class="hljs-comment">     * to try to avoid killing it. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_HEAVY_WEIGHT = <span class="hljs-number">6</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background running a service.  Unlike oom_adj, this level </span><br><span class="hljs-comment">     * is used for both the normal running in background state and the executing </span><br><span class="hljs-comment">     * operations state. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_SERVICE = <span class="hljs-number">7</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background running a receiver.   Note that from the </span><br><span class="hljs-comment">     * perspective of oom_adj receivers run at a higher foreground level, but for our </span><br><span class="hljs-comment">     * prioritization here that is not necessary and putting them below services means </span><br><span class="hljs-comment">     * many fewer changes in some process states as they receive broadcasts. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_RECEIVER = <span class="hljs-number">8</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background but hosts the home activity. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_HOME = <span class="hljs-number">9</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background but hosts the last shown activity. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_LAST_ACTIVITY = <span class="hljs-number">10</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is being cached for later use and contains activities. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_CACHED_ACTIVITY = <span class="hljs-number">11</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is being cached for later use and is a client of another cached </span><br><span class="hljs-comment">     * process that contains activities. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_CACHED_ACTIVITY_CLIENT = <span class="hljs-number">12</span>;  <br>  <br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is being cached for later use and is empty. */</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROCESS_STATE_CACHED_EMPTY = <span class="hljs-number">13</span>;  <br>&#125;  <br><br>VMRuntime.updateProcessState(<span class="hljs-keyword">int</span> state)<br><br>VMRuntime_updateProcessState(JNIEnv* env, jobject, jint process_state)<br><br>Heap::UpdateProcessState(ProcessState process_state)<br><br>Heap::RequestCollectorTransition(CollectorType desired_collector_type, uint64_t delta_time)<br><br>Heap::SignalHeapTrimDaemon(Thread* self)<br><br>Daemons.requestHeapTrim()<br></code></pre></div></td></tr></table></figure><p>上面说过 ART 启动后加载 <code>java.lang.Daemons</code> 时，会启动五个守护线程，其中有一个是 <code>HeapTrimmerDaemon</code> 负责压缩堆内存，其实它也负责切换 GC，并且在过程中根据情况有可能在切换 GC 前执行一次 <code>compacting</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Daemons</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestHeapTrim</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">synchronized</span> (HeapTrimmerDaemon.INSTANCE) &#123;  <br>            HeapTrimmerDaemon.INSTANCE.notify();  <br>        &#125;  <br>    &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><h4 id="切换至-Semi-Space-GC"><a href="#切换至-Semi-Space-GC" class="headerlink" title="切换至 Semi-Space GC"></a>切换至 Semi-Space GC</h4><p>这时候原来的 GC 只能为 <code>Mark-Sweep GC</code> 或者 <code>Concurrent Mark-Sweep GC</code>，此时 ART 堆由 <code>Image Space</code>、<code>Zygote Space</code>、<code>Non Moving Space</code>、<code>Main Space</code>、<code>Main Backup Space</code> 和 <code>Large Object Space</code> 组成。要做的是将 <code>Main Space</code> 上的存活对象移动至一个新创建的 <code>Bump Pointer Space</code> 上去，也就是说这时候的 Source Space 为 <code>Main Space</code>，而 Target Space 为 <code>Bump Pointer Space</code>。</p><p><code>Main Space</code> 就保存在 <code>Heap-&gt;main_space_</code>，因此就很容易可以获得。但是这时候是没有现成的 <code>Bump Pointer Space</code> 的，因此就需要创建一个。由于这时候的 <code>Main Backup Space</code> 是闲置的，并且当 GC 切换完毕它也用不上了，因此我们就可以将 <code>Main Backup Space</code> 底层使用的内存块获取回来，然后再封装成一个 <code>Bump Pointer Space</code>。注意这时候创建的 <code>Bump Pointer Space</code> 也是作为 GC 切换完成后的 From Space 使用的，因此除了要将它保存在 <code>Heap-&gt;bump_pointer_space_</code> 之外，还要将它添加到 ART 的 Space 列表中去</p><p>这时候 Source Space 和 Target Space 均已准备完毕，因此就可以执行 <code>Heap-&gt;Compact</code> 了。执行完毕还需要做一系列的清理工作，包括：</p><ol><li>删除 <code>Main Space</code></li><li>删除 <code>Main Backup Space</code></li><li>创建一个 <code>Bump Pointer Space</code> 保存在 <code>Heap-&gt;temp_space_</code>，作为 GC 切换完成后的 To Space 使用（注意这个 To Space 底层使用的内存块是来自于原来的 Main Space）</li></ol><p>这意味着将从 <code>(Concurrent)Mark-Sweep GC</code> 切换为 <code>Semi-Space GC</code> 之后，原来的 <code>Main Space</code> 和 <code>Main Backup Space</code> 就消失了，并且多了两个 <code>Bump Pointer Space</code>，其中一个作为 From Space，另外一个作为 To Space，并且 From Space 上的对象来自于原来的 <code>Main Space</code> 的存活对象</p><h4 id="切换至-Concurrent-Mark-Sweep-GC"><a href="#切换至-Concurrent-Mark-Sweep-GC" class="headerlink" title="切换至 (Concurrent)Mark-Sweep GC"></a>切换至 (Concurrent)Mark-Sweep GC</h4><p>这时候原来的 GC 只能为 <code>Semi-Space GC</code>、<code>Generational Semi-Space GC</code> 或者 <code>Mark-Compact GC</code>，ART 堆由 <code>Image Space</code>、<code>Zygote Space</code>、<code>Non Moving Space</code>、<code>Bump Pointer Space</code>、<code>Temp Space</code> 和 <code>Large Object Space</code> 组成。要做的是将 <code>Bump Pointer Space</code> 上的存活对象移动至一个新创建的 <code>Main Space</code> 上去，也就是说这时候的 Source Space 为 <code>Bump Pointer Space</code>，而 Target Space 为 <code>Main Space</code></p><p><code>Bump Pointer Space</code> 就保存在 <code>Heap-&gt;bump_pointer_space_</code>，因此就很容易可以获得。但是这时候是没有现成的 <code>Main Space</code> 的，因此就需要创建一个。由于这时候的 <code>Temp Space</code> 是闲置的，并且当 GC 切换完毕它也用不上了，因此我们就可以将 <code>Temp Space</code> 底层使用的内存块获取回来，然后再封装成一个 <code>Main Space</code>，这是通过调用 <code>Heap-&gt;CreateMainMallocSpace</code> 来实现的。注意，它在执行的过程中会将创建的 <code>Main Space</code> 保存在 <code>Heap-&gt;main_space_</code>，并且作为 GC 切换完成后 <code>(Concurrent)Mark-Sweep GC</code> 的 <code>Main Space</code>使用的，因此就还要将它添加到 ART 堆的 Space 列表中去</p><p>这时候 Source Space 和 Target Space 均已准备完毕，可以执行 <code>Heap-&gt;Compact</code>了。执行完毕还需要做一系列的清理工作，包括：</p><ol><li>删除 <code>Bump Pointer Space</code></li><li>删除 <code>Temp Space</code></li><li>创建一个 <code>Main Backup Space</code> 保存在 <code>Heap-&gt;main_space_backup_</code>，这是通过调用 <code>Heap-&gt;CreateMallocSpaceFromMemMap</code> 实现的，并且该 <code>Main Backup Space</code> 底层使用的内存块是来自于原来的 <code>Bump Pointer Space</code> 的</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/Luoshengyang/article/details/41338251">Dalvik虚拟机垃圾收集机制简要介绍和学习计划</a></li><li><a href="https://blog.csdn.net/luoshengyang/article/details/42072975">ART运行时垃圾收集机制简要介绍和学习计划</a></li><li><a href="https://www.kancloud.cn/alex_wsc/androids/472173">Dalvik虚拟机和ART虚拟机</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ART</tag>
      
      <tag>Dalvik</tag>
      
      <tag>JVM</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】mmap 和零拷贝</title>
    <link href="/2021/05/21/mmap/"/>
    <url>/2021/05/21/mmap/</url>
    
    <content type="html"><![CDATA[<p>平时在面试中你肯定会经常碰见的问题就是：<code>RocketMQ</code> 为什么快？<code>Kafka</code> 为什么快？什么是 <code>mmap</code>？</p><p>这一类的问题都逃不过的一个点就是 <strong>零拷贝</strong>，虽然还有一些其他的原因，但是今天我们的话题主要就是零拷贝。</p><h2 id="传统-IO"><a href="#传统-IO" class="headerlink" title="传统 IO"></a>传统 IO</h2><p>在开始谈零拷贝之前，首先要对传统的 IO 方式有一个概念。基于传统的 IO 方式，底层实际上通过调用 <code>read()</code> 和 <code>write()</code> 来实现。</p><p>通过 <code>read()</code> 把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过 <code>write()</code> 写入到 socket 缓冲区，最后写入网卡设备。</p><p><img src="../../../../image/2021-05-21-mmap/read_write.jpg" alt="read_write"></p><p>整个过程发生了 <strong>4</strong> 次用户态和内核态的上下文切换和 <strong>4</strong> 次拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>read()</code> 方法向操作系统发起调用，此时上下文从用户态转向内核态</li><li>DMA 控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU 把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，<code>read()</code> 返回</li><li>用户进程通过 <code>write()</code> 方法发起调用，上下文从用户态转为内核态</li><li>CPU 将应用缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code> 返回</li></ol><p><img src="../../../../image/2021-05-21-mmap/read_write_swimlane.jpg" alt="read_write_swimlane"></p><p>那么，这里指的 <strong>用户态</strong>、<strong>内核态</strong> 指的是什么？<strong>上下文切换</strong> 又是什么？</p><p>简单来说，<strong>用户空间</strong> 指的就是用户进程的运行空间，<strong>内核空间</strong> 就是内核的运行空间。如果进程运行在内核空间就是内核态，运行在用户空间就是用户态。为了安全起见，他们之间是互相隔离的，而在用户态和内核态之间的上下文切换也是比较耗时的。从上面我们可以看到，一次简单的 IO 过程产生了 4 次上下文切换，这个无疑在高并发场景下会对性能产生较大的影响。</p><p>那么什么又是 DMA 拷贝呢？</p><p>因为对于一个 IO 操作而言，都是通过 CPU 发出对应的指令来完成，但是相比 CPU 来说，IO 的速度太慢了，CPU 有大量的时间处于等待 IO 的状态。因此就产生了 DMA（Direct Memory Access）直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和 IO 设备的数据传输，从而减少 CPU 的等待时间。但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。</p><p><strong>零拷贝</strong> 是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省 CPU 周期和内存带宽。那么对于零拷贝而言，并非真的是完全没有数据拷贝的过程，只不过是减少用户态和内核态的切换次数以及 CPU 拷贝的次数。</p><p>这里，仅仅有针对性的来谈谈几种常见的零拷贝技术。</p><h2 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a><code>mmap</code> + <code>write</code></h2><p><code>mmap</code> + <code>write</code> 简单来说就是使用 <code>mmap</code> 替换了 <code>read</code> + <code>write</code> 中的 <code>read</code> 操作，减少了一次 CPU 的拷贝。</p><p><code>mmap</code> 主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次 CPU 拷贝。</p><p><img src="../../../../image/2021-05-21-mmap/mmap_write_swimlane.jpg" alt="mmap_write_swimlane"></p><p>整个过程发生了 <strong>4</strong> 次用户态和内核态的上下文切换和 <strong>3</strong> 次拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>mmap</code> 向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA 控制器把数据从硬盘中拷贝到读缓冲区</li><li>上下文从内核态转为用户态，<code>mmap</code> 调用返回</li><li>用户进程通过 <code>write()</code> 方法发起调用，上下文从用户态转为内核态</li><li>CPU 将读缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code> 返回</li></ol><p><code>mmap</code> 的方式节省了一次 CPU 拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a><code>sendfile</code></h2><p>相比 <code>mmap</code> 来说，<code>sendfile</code> 同样减少了一次 CPU 拷贝，而且还减少了 <strong>2</strong> 次上下文切换。</p><p><img src="../../../../image/2021-05-21-mmap/sendfile.jpg" alt="sendfile"></p><p><code>sendfile</code> 是 Linux 2.1 内核版本后引入的一个系统调用函数，通过使用 <code>sendfile</code> 数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用 <code>sendfile</code> 替代了 <code>read</code> + <code>write</code> 从而节省了一次系统调用，也就是 <strong>2</strong> 次上下文切换。</p><p><img src="../../../../image/2021-05-21-mmap/sendfile_swimlane.jpg" alt="sendfile_swimlane"></p><p>整个过程发生了 <strong>2</strong> 次用户态和内核态的上下文切换和 <strong>3</strong> 次拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>sendfile()</code> 方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA 控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU 将读缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>sendfile</code> 调用返回</li><li><code>sendfile</code> 方法 IO 数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</li></ol><h2 id="sendfile-DMA-Scatter-Gather"><a href="#sendfile-DMA-Scatter-Gather" class="headerlink" title="sendfile + DMA Scatter/Gather"></a><code>sendfile</code> + DMA Scatter/Gather</h2><p>Linux 2.4 内核版本之后对 <code>sendfile</code> 做了进一步优化，通过引入新的硬件支持，这个方式叫做 DMA Scatter/Gather。它将读缓冲区中的数据描述信息（内存地址和偏移量）记录到 socket 缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次 CPU 拷贝的过程</p><p><img src="../../../../image/2021-05-21-mmap/gather_swimlane.jpg" alt="gather_swimlane"></p><p>整个过程发生了 <strong>2</strong> 次用户态和内核态的上下文切换和 <strong>2</strong> 次拷贝，其中更重要的是完全没有 CPU 拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>sendfile()</code> 方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA 控制器利用 scatter 把数据从硬盘中拷贝到读缓冲区离散存储</li><li>CPU 把读缓冲区中的文件描述符和数据长度发送到 socket 缓冲区</li><li>DMA 控制器根据文件描述符和数据长度，使用 scatter/gather 把数据从内核缓冲区拷贝到网卡</li><li><code>sendfile()</code> 调用返回，上下文从内核态切换回用户态</li></ol><p>DMA gather 和 <code>sendfile</code> 一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有 CPU 拷贝过程，极大提升了性能。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>对于文章开头说的两个场景：<code>RocketMQ</code> 和 <code>Kafka</code> 都使用到了零拷贝的技术。</p><p>对于 <code>MQ</code> 而言，无非就是生产者发送数据到 <code>MQ</code> 然后持久化到磁盘，之后消费者从 <code>MQ</code> 读取数据。</p><p>对于 <code>RocketMQ</code> 来说这两个步骤使用的是 <code>mmap</code> + <code>write</code>，而 <code>Kafka</code> 则是使用 <code>mmap</code> + <code>write</code> 持久化数据，发送数据使用 <code>sendfile</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于 CPU 和 IO 速度的差异问题，产生了 DMA 技术，通过 DMA 搬运来减少 CPU 的等待时间。</p><p>传统的 IO <code>read</code> + <code>write</code> 方式会产生 <strong>2</strong> 次 DMA 拷贝 + <strong>2</strong> 次 CPU 拷贝，同时有 <strong>4</strong> 次上下文切换。</p><p>而通过 <code>mmap</code> + <code>write</code> 方式则产生 <strong>2</strong> 次 DMA 拷贝 + <strong>1</strong> 次 CPU 拷贝，<strong>4</strong> 次上下文切换，通过内存映射减少了一次 CPU 拷贝，可以减少内存使用，适合大文件的传输。</p><p><code>sendfile</code> 方式是新增的一个系统调用函数，产生 <strong>2</strong> 次 DMA 拷贝 + <strong>1</strong> 次 CPU 拷贝，但是只有 <strong>2</strong> 次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对 IO 数据不可见，适用于静态文件服务器。</p><p><code>sendfile</code> + DMA gather 方式产生 <strong>2</strong> 次 DMA 拷贝，没有 CPU 拷贝，而且也只有 <strong>2</strong> 次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.cn/post/6844903949359644680">深入剖析Linux IO原理和几种零拷贝机制的实现</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/p/13719610.html">原来 8 张图，就可以搞懂「零拷贝」了</a></li><li><a href="https://www.toutiao.com/i6898240850917114380/">腾讯游戏工程师：Linux Zero-copy技术全面揭秘</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mmap</tag>
      
      <tag>内存，虚拟地址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】网络 IO 演变发展过程和模型介绍</title>
    <link href="/2021/05/11/nonblocking-io/"/>
    <url>/2021/05/11/nonblocking-io/</url>
    
    <content type="html"><![CDATA[<p>在互联网中提起网络，我们都会避免不了讨论高并发、百万连接。而此处的百万连接的实现，脱离不了网络 IO 的选择，因此本文作为一篇个人学习的笔记，特此进行记录一下整个网络 IO 的发展演变过程。以及目前广泛使用的网络模型。</p><h2 id="网络-IO-的发展"><a href="#网络-IO-的发展" class="headerlink" title="网络 IO 的发展"></a>网络 IO 的发展</h2><p>在本节内容中，我们将一步一步介绍网络 IO 的演变发展过程。介绍完发展过程后，再对网络 IO 中几组容易混淆的概念进行对比、分析。</p><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/159e46c0950a4f2899729cb1ac78921b"></p><h3 id="网络-IO-的各个发展阶段"><a href="#网络-IO-的各个发展阶段" class="headerlink" title="网络 IO 的各个发展阶段"></a>网络 IO 的各个发展阶段</h3><p>通常，我们在此讨论的网络 IO 一般都是针对 linux 操作系统而言。网络 IO 的发展过程是随着 linux 的内核演变而变化，因此网络 IO 大致可以分为如下几个阶段：</p><ol><li>阻塞 IO(<code>BIO</code>)</li><li>非阻塞 IO(<code>NIO</code>)</li><li>IO 多路复用第一版(<code>select</code>/<code>poll</code>)</li><li>IO 多路复用第二版(<code>epoll</code>)</li><li>异步 IO(<code>AIO</code>)</li></ol><p>而每一个阶段，都是因为当前的网络有一些缺陷，因此又在不断改进该缺陷。这是网络 IO 一直演变过程中的本质。下面将对上述几个阶段进行介绍，并对每个阶段的网络 IO 解决了哪些问题、优点、缺点进行剖析。</p><h3 id="网络的两个阶段"><a href="#网络的两个阶段" class="headerlink" title="网络的两个阶段"></a>网络的两个阶段</h3><p>在网络中，我们通常可以将其广义上划分为以下两个阶段：</p><p>第一阶段：硬件接口到内核态<br>第二阶段：内核态到用户态</p><p>本人理解：我们通常上网，大部分数据都是通过网线传递的。因此对于两台计算机而言，要进行网络通信，其数据都是先从应用程序传递到传输层(TCP/UDP)到达内核态，然后再到网络层、数据链路层、物理层，接着数据传递到硬件网卡，最后通过网络传输介质传递到对端机器的网卡，然后再一步一步数据从网卡传递到内核态，最后再拷贝到用户态。</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/83594a2704d3449aa87f9a5d7cb07c16"></p><h3 id="阻塞-IO-和非阻塞-IO-的区别"><a href="#阻塞-IO-和非阻塞-IO-的区别" class="headerlink" title="阻塞 IO 和非阻塞 IO 的区别"></a>阻塞 IO 和非阻塞 IO 的区别</h3><p>根据 1.2 节的内容，我们可以知道，网络中的数据传输从网络传输介质到达目的机器，需要如上两个阶段。此处我们把从硬件到内核态这一阶段，是否发生阻塞等待，可以将网络分为阻塞 IO和非阻塞 IO。如果用户发起了读写请求，但内核态数据还未准备就绪，该阶段不会阻塞用户操作，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。</p><p>因此，区分阻塞 IO 和非阻塞 IO 主要看第一阶段是否阻塞用户操作。</p><h3 id="同步-IO-和异步-IO-的区别"><a href="#同步-IO-和异步-IO-的区别" class="headerlink" title="同步 IO 和异步 IO 的区别"></a>同步 IO 和异步 IO 的区别</h3><p>从前面我们知道了，数据的传递需要两个阶段，在此处只要任何一个阶段会阻塞用户请求，都将其称为同步 IO，两个阶段都不阻塞，则称为异步 IO。</p><p>在目前所有的操作系统中，linux 中的 <code>epoll</code>、mac 的 <code>kqueue</code> 都属于同步 IO，因为其在第二阶段(数据从内核态到用户态)都会发生拷贝阻塞。而只有 windows 中的 <code>IOCP</code> 才真正属于异步 IO，即 <code>AIO</code>。</p><h2 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h2><p>在本节，我们将介绍最初的阻塞 IO，阻塞 IO 英文为 <code>blocking IO</code>，又称为 <code>BIO</code>。根据前面的介绍，阻塞 IO 主要指的是第一阶段(硬件网卡到内核态)。</p><h3 id="阻塞-IO-的概念"><a href="#阻塞-IO-的概念" class="headerlink" title="阻塞 IO 的概念"></a>阻塞 IO 的概念</h3><p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。具体过程可以参考 2.2 的图示。</p><h3 id="阻塞-IO-的过程"><a href="#阻塞-IO-的过程" class="headerlink" title="阻塞 IO 的过程"></a>阻塞 IO 的过程</h3><p>​<img src="https://p6-tt.byteimg.com/origin/pgc-image/71c28eaee6a8417cbe636c7c883f6c02"></p><h3 id="阻塞-IO-的缺点"><a href="#阻塞-IO-的缺点" class="headerlink" title="阻塞 IO 的缺点"></a>阻塞 IO 的缺点</h3><p>在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是阻塞 IO + 多线程，每个连接一个单独的线程进行处理。</p><p>我们知道，一般一个程序可以开辟的线程是有限的，而且开辟线程的开销也是比较大的。也正是这种方式，会导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理。</p><p>既然发现了问题，分析了问题，那就得解决问题。既然阻塞 IO 有问题，本质是由于其阻塞导致的，因此自然而然引出了下面即将介绍的主角：非阻塞 IO</p><h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>非阻塞 IO 是为了解决前面提到的阻塞 IO 的缺陷而引出的，下面我们将介绍非阻塞 IO 的过程。</p><h3 id="非阻塞-IO-的概念"><a href="#非阻塞-IO-的概念" class="headerlink" title="非阻塞 IO 的概念"></a>非阻塞 IO 的概念</h3><p>非阻塞 IO：见名知意，就是在第一阶段(网卡-内核态)数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据好了没，好了没。</p><h3 id="非阻塞-IO-的过程"><a href="#非阻塞-IO-的过程" class="headerlink" title="非阻塞 IO 的过程"></a>非阻塞 IO 的过程</h3><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/12149fcdc97a493fa54248ad8da64bfa"></p><p>非阻塞 IO 是需要系统内核支持的，在创建了连接后，可以调用 <code>setsockop</code> 设置 <code>noblocking</code></p><h3 id="非阻塞-IO-的优点"><a href="#非阻塞-IO-的优点" class="headerlink" title="非阻塞 IO 的优点"></a>非阻塞 IO 的优点</h3><p>正如前面提到的，非阻塞 IO 解决了阻塞 IO 每个连接一个线程处理的问题，所以其最大的优点就是 一个线程可以处理多个连接，这也是其非阻塞决定的。</p><h3 id="非阻塞-IO-的缺点"><a href="#非阻塞-IO-的缺点" class="headerlink" title="非阻塞 IO 的缺点"></a>非阻塞 IO 的缺点</h3><p>但这种模式，也有一个问题，就是需要用户多次发起系统调用。频繁的系统调用是比较消耗系统资源的。</p><p>因此，既然存在这样的问题，那么自然而然我们就需要解决该问题：保留非阻塞 IO 的优点的前提下，减少系统调用</p><h2 id="IO-多路复用第一版"><a href="#IO-多路复用第一版" class="headerlink" title="IO 多路复用第一版"></a>IO 多路复用第一版</h2><p>为了解决非阻塞 IO 存在的频繁的系统调用这个问题，随着内核的发展，出现了 IO 多路复用模型。那么我们就需要搞懂几个问题：</p><ol><li>IO 多路复用到底复用什么？</li><li>IO 多路复用如何复用？</li></ol><p>IO 多路复用： 很多人都说，IO 多路复用是用一个线程来管理多个网络连接，但本人不太认可，因为在非阻塞 IO 时，就已经可以实现一个线程处理多个网络连接了，这个是由于其非阻塞而决定的。</p><p>在此处，个人观点，多路复用主要复用的是通过有限次的系统调用来实现管理多个网络连接。最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。因此，IO 多路复用，复用的是系统调用。通过有限次系统调用判断海量连接是否数据准备好了</p><p>无论下面的 <code>select</code>、<code>poll</code>、<code>epoll</code>，其都是这种思想实现的，不过在实现上，<code>select</code>/<code>poll</code> 可以看做是第一版，而 <code>epoll</code> 是第二版</p><h3 id="IO-多路复用第一版的概念"><a href="#IO-多路复用第一版的概念" class="headerlink" title="IO 多路复用第一版的概念"></a>IO 多路复用第一版的概念</h3><p>IO 多路复用第一版，这个概念是本人想出来的，主要是方便将 <code>select</code>/<code>poll</code> 和 <code>epoll</code> 进行区分</p><p>所以此处 IO 多路复用第一版，主要特指 <code>select</code> 和 <code>poll</code> 这两个。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;<br></code></pre></div></td></tr></table></figure><p><code>select</code> 函数监视的文件描述符分 3 类，分别是 <code>writefds</code>、<code>readfds</code> 和 <code>exceptfds</code>。调用后 <code>select</code> 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 <code>select</code> 函数返回后，可以通过遍历 <code>fdset</code>，来找到就绪的描述符。</p><p><code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<code>select</code> 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span> <span class="hljs-params">(struct pollfd *fds, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>    <span class="hljs-keyword">int</span> fd; <span class="hljs-comment">/* file descriptor */</span><br>    <span class="hljs-keyword">short</span> events; <span class="hljs-comment">/* requested events to watch */</span><br>    <span class="hljs-keyword">short</span> revents; <span class="hljs-comment">/* returned events witnessed */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>pollfd</code> 结构包含了要监视的 <code>event</code> 和发生的 <code>event</code>，不再使用 <code>select</code> “参数-值” 传递的方式。同时，<code>pollfd</code> 并没有最大数量限制（但是数量过大后性能也是会下降）。和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 <code>pollfd</code> 来获取就绪的描述符。</p><p>从上面看，<code>select</code> 和 <code>poll</code> 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><p>从本质来说：IO 多路复用中，<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code> 这几个函数对应第一阶段；<code>read()</code>/<code>recvfrom()</code> 对应第二阶段</p><h3 id="IO-多路复用第一版的过程"><a href="#IO-多路复用第一版的过程" class="headerlink" title="IO 多路复用第一版的过程"></a>IO 多路复用第一版的过程</h3><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/fce10fab6ff645e082796b8fa275527b"></p><h3 id="IO-多路复用第一版的优点"><a href="#IO-多路复用第一版的优点" class="headerlink" title="IO 多路复用第一版的优点"></a>IO 多路复用第一版的优点</h3><p>IO 多路复用，主要在于复用，通过 <code>select()</code> 或者 <code>poll()</code> 将多个 <code>socket fds</code> 批量通过系统调用传递给内核，由内核进行循环遍历判断哪些 <code>fd</code> 上数据就绪了，然后将就绪的 <code>readyfds</code> 返回给用户。再由用户进行挨个遍历就绪好的 <code>fd</code>，读取或者写入数据。</p><p>所以通过 IO 多路复用 + 非阻塞 IO，一方面降低了系统调用次数，另一方面可以用极少的线程来处理多个网络连接。</p><h3 id="IO-多路复用第一版的缺点"><a href="#IO-多路复用第一版的缺点" class="headerlink" title="IO 多路复用第一版的缺点"></a>IO 多路复用第一版的缺点</h3><p>虽然第一版 IO 多路复用解决了之前提到的频繁的系统调用次数，但同时引入了新的问题：用户需要每次将海量的 <code>socket fds</code> 集合从用户态传递到内核态，让内核态去检测哪些网络连接数据就绪了</p><p>但这个地方会出现频繁的将海量 <code>fd</code> 集合从用户态传递到内核态，再从内核态拷贝到用户态。所以，这个地方开销也挺大。</p><p>既然还有这个问题，那我们继续开始解决这个问题，因此就引出了第二版的 IO 多路复用。</p><p>其实思路也挺简单，既然需要拷贝，那就想办法，不拷贝。既然不拷贝，那就在内核开辟一段区域咯</p><h3 id="IO-多路复用第一版的区别"><a href="#IO-多路复用第一版的区别" class="headerlink" title="IO 多路复用第一版的区别"></a>IO 多路复用第一版的区别</h3><p><code>select</code> 和 <code>poll</code> 的区别</p><ol><li><code>select</code> 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 <code>poll</code> 理论上可以支持无限个</li><li><code>select</code> 和 <code>poll</code> 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源。</li></ol><h2 id="IO-多路复用第二版"><a href="#IO-多路复用第二版" class="headerlink" title="IO 多路复用第二版"></a>IO 多路复用第二版</h2><p>IO 多路复用第二版主要指 <code>epoll</code>，<code>epoll</code> 的出现也是随着内核版本迭代才诞生的，在网上到处看到，<code>epoll</code> 是内核 2.6 以后开始支持的</p><p><code>epoll</code> 的出现是为了解决前面提到的 IO 多路复用第一版的问题</p><h3 id="IO-多路复用第二版的概念"><a href="#IO-多路复用第二版的概念" class="headerlink" title="IO 多路复用第二版的概念"></a>IO 多路复用第二版的概念</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span>；<span class="hljs-comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//往红黑树中增加、删除、更新管理的socket fd</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd, struct epoll_event *event)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//这个api是用来在第一阶段阻塞，等待就绪的fd。</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure><p><code>int epoll_create(int size);</code></p><p>创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select()</code> 中的第一个参数，给出最大监听的 fd+1 的值，参数 <code>size</code> 并不是限制了 <code>epoll</code> 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p><p>当创建好 <code>epoll</code> 句柄后，它就会占用一个 <code>fd</code> 值，在 linux 下如果查看 <code>/proc/进程id/fd/</code>，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></p><p>函数是对指定描述符 <code>fd</code> 执行 <code>op</code> 操作:</p><ul><li><code>epfd</code>：是 <code>epoll_create()</code> 的返回值。</li><li><code>op</code>：表示 <code>op</code> 操作，用三个宏来表示：添加 <code>EPOLL_CTL_ADD</code>，删除 <code>EPOLL_CTL_DEL</code>，修改 <code>EPOLL_CTL_MOD</code>。分别添加、删除和修改对 <code>fd</code> 的监听事件。</li><li><code>fd</code>：是需要监听的 <code>fd</code>（文件描述符）</li><li><code>epoll_event</code>：是告诉内核需要监听什么事，<code>struct epoll_event</code> 结构如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>  <span class="hljs-keyword">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-keyword">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><br><span class="hljs-comment">// events可以是以下几个宏的集合：</span><br><span class="hljs-comment">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="hljs-comment">// EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="hljs-comment">// EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="hljs-comment">// EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="hljs-comment">// EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="hljs-comment">// EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="hljs-comment">// EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></code></pre></div></td></tr></table></figure><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code></p><p>等待 <code>epfd</code> 上的 <code>io</code> 事件，最多返回 <code>maxevents</code> 个事件。</p><p>参数 <code>events</code> 用来从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code>，参数 <code>timeout</code> 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p><code>epoll</code> 对文件描述符的操作有两种模式：<code>LT（level trigger）</code> 和 <code>ET（edge trigger）</code>。<code>LT</code> 模式是默认模式，<code>LT</code> 模式与 <code>ET</code> 模式的区别如下：</p><ol><li><code>LT</code> 模式当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件。</li><li><code>ET</code> 模式当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li></ol><h4 id="LT-模式"><a href="#LT-模式" class="headerlink" title="LT 模式"></a>LT 模式</h4><p><code>LT(level triggered)</code> 是缺省的工作方式，并且同时支持 <code>block</code> 和 <code>no-block socket</code>.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 <code>fd</code> 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p><h4 id="ET-模式"><a href="#ET-模式" class="headerlink" title="ET 模式"></a>ET 模式</h4><p><code>ET(edge-triggered)</code> 是高速工作方式，只支持<code> no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过 <code>epoll</code> 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 <code>EWOULDBLOCK</code> 错误）。但是请注意，如果一直不对这个 <code>fd</code> 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p><code>ET</code> 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 <code>LT</code> 模式高。<code>epoll</code> 工作在 <code>ET</code> 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h3 id="IO-多路复用第二版的过程"><a href="#IO-多路复用第二版的过程" class="headerlink" title="IO 多路复用第二版的过程"></a>IO 多路复用第二版的过程</h3><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/ddb4604a40fa4dd1a6cefc3f0799a03e"></p><p>当 <code>epoll_wait()</code> 调用后会阻塞，然后完了当返回时，会返回了哪些 <code>fd</code> 的数据就绪了，用户只需要遍历就绪的 <code>fd</code> 进行读写即可。</p><h3 id="IO-多路复用第二版的优点"><a href="#IO-多路复用第二版的优点" class="headerlink" title="IO 多路复用第二版的优点"></a>IO 多路复用第二版的优点</h3><p>IO 多路复用第二版 epoll 的优点在于一开始就在内核态分配了一段空间，来存放管理的 fd,所以在每次连接建立后，交给 <code>epoll</code> 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。所以现在的 IO 多路复用主要指 <code>epoll</code></p><h3 id="IO-多路复用第二版的缺点"><a href="#IO-多路复用第二版的缺点" class="headerlink" title="IO 多路复用第二版的缺点"></a>IO 多路复用第二版的缺点</h3><p>个人猜想： 如何降低占用的空间</p><h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><h3 id="异步-IO-的过程"><a href="#异步-IO-的过程" class="headerlink" title="异步 IO 的过程"></a>异步 IO 的过程</h3><p>​<img src="https://p3-tt.byteimg.com/origin/pgc-image/21afcdfdb3e145318cc3a771ea11f649"></p><p>前面介绍的所有网络 IO 都是同步 IO，因为当数据在内核态就绪时，在内核态拷贝用用户态的过程中，仍然会有短暂时间的阻塞等待。而异步 IO 指：内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成，目前只有 windows 系统的 <code>IOCP</code> 是属于异步 IO。</p><h2 id="网络-IO-各种模型"><a href="#网络-IO-各种模型" class="headerlink" title="网络 IO 各种模型"></a>网络 IO 各种模型</h2><h3 id="reactor-模型"><a href="#reactor-模型" class="headerlink" title="reactor 模型"></a>reactor 模型</h3><p>目前 <code>reactor</code> 模型有以下几种实现方案：</p><ol><li>单 <code>reactor</code> 单线程模型</li><li>单 <code>reactor</code> 多线程模型</li><li><code>multi-reactor</code> 多线程模型</li><li><code>multi-reactor</code> 多进程模型</li></ol><h4 id="单-reactor-单线程模型"><a href="#单-reactor-单线程模型" class="headerlink" title="单 reactor 单线程模型"></a>单 reactor 单线程模型</h4><p>此种模型，通常是只有一个 <code>epoll</code> 对象，所有的接收客户端连接、客户端读取、客户端写入操作都包含在一个线程内。该种模型也有一些中间件在用，比如 <code>redis</code></p><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/a4a057a00b5748d9b5146a9d4dc3ba2a"></p><p>但在目前的单线程 <code>Reactor</code> 模式中，不仅 I/O 操作在该 <code>Reactor</code> 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 <code>Reactor</code> 线程上卸载，以此来加速 <code>Reactor</code> 线程对 I/O 请求的响应。</p><h4 id="单-reactor-多线程模型"><a href="#单-reactor-多线程模型" class="headerlink" title="单 reactor 多线程模型"></a>单 <code>reactor</code> 多线程模型</h4><p>该模型主要是通过将，前面的模型进行改造，将读写的业务逻辑交给具体的线程池来实现，这样可以显示 <code>reactor</code> 线程对 IO 的响应，以此提升系统性能</p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/cd4d1c679c9e48a9846e65ad76363e7b"></p><p>在工作者线程池模式中，虽然非 I/O 操作交给了线程池来处理，但是所有的 I/O 操作依然由 <code>Reactor</code> 单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于 <code>Reactor</code> 的优化，又产生出下面的多线程模式。</p><h4 id="multi-reactor-多线程模型"><a href="#multi-reactor-多线程模型" class="headerlink" title="multi-reactor 多线程模型"></a>multi-reactor 多线程模型</h4><p>在这种模型中，主要分为两个部分：<code>mainReactor</code>、<code>subReactors</code>。<code>mainReactor</code> 主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给 <code>subReactors</code>，<code>subReactors</code> 来负责具体的每个连接的读写，对于非 IO 的操作，依然交给工作线程池去做，对逻辑进行解耦</p><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/b092d02d992646b49468059f5c808036"></p><p><code>mainReactor</code> 对应 <code>Netty</code> 中配置的 <code>BossGroup</code> 线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，<code>BossGroup</code> 线程组一般一个线程工作即可 <code>subReactor</code> 对应 <code>Netty</code> 中配置的 <code>WorkerGroup</code> 线程组，<code>BossGroup</code> 线程组接受并建立完客户端的连接后，将网络 socket 转交给 <code>WorkerGroup</code> 线程组，然后在 <code>WorkerGroup</code> 线程组内选择一个线程，进行 I/O 的处理。<code>WorkerGroup</code> 线程组主要处理 I/O，一般设置 2*CPU 核数个线程</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>IO 模式和 IO 多路复用</li><li>Linux IO 模式及 select、poll、epoll 详解</li><li>Chapter 6. I/O Multiplexing: The select and poll Functions</li><li>高性能 IO 模型分析-Reactor 模式和 Proactor 模式（二）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>select</tag>
      
      <tag>poll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KOOM - 利用子进程 dump hprof</title>
    <link href="/2021/05/07/koom/"/>
    <url>/2021/05/07/koom/</url>
    
    <content type="html"><![CDATA[<h2 id="不冻结-APP-的-dump-hprof"><a href="#不冻结-APP-的-dump-hprof" class="headerlink" title="不冻结 APP 的 dump hprof"></a>不冻结 APP 的 dump hprof</h2><p>在 <a href="../../../../2021/04/12/leakcanary/">LeakCanary 浅析</a> 和 <a href="../../../../2021/04/23/matrix-resourcescanary/">Matrix - ResourcesCanary 浅析</a> 这两篇文章里，介绍了检测内存泄漏的两种相似的思路：</p><ol><li><code>WeakReference</code> + <code>ReferenceQueue</code> + 延迟 5s 检查是否被 GC</li><li><code>WeakReference</code> + <code>ConcurrentLinkedQueue</code>，子线程轮询的方式每隔 1m 检查队列里的对象是否被 GC</li></ol><p>但无论 <code>LeakCanary</code> 还是 <code>Matrix.ResourcesCanary</code> 都没有解决 dump hprof 时整个 APP 被「冻结」的问题，而一次 dump hprof 往往要持续 10s 甚至更多，这在线上环境下是不可接受的，所以在发生内存泄漏后只能上报类信息，开发者收到后人工检查涉及此类的相关代码找出泄漏点。但是这种方式是极其低效和不准确的，如果能在端侧找出泄漏对象的 GC ROOT PATH，就能极大地减少人工量，并且提高后续修复的准确度。</p><p>如果能够在不冻结 APP 的情况下 dump hprof，不仅仅能够上报内存泄漏问题，还能对 OOM 进行预警：比如监控 JVM 的内存使用率，当达到 90% 的时候将 hprof 上报分析</p><p><code>KOOM</code> 提出了一个在不冻结 APP 的情况下 dump hprof 的思路：<code>fork</code> 出子进程，总体流程是这样的：</p><ol><li>父进程 suspend JVM</li><li>父进程 fork 出子进程</li><li>父进程 resume JVM 后，线程等待子进程结束从而拿到 hprof</li><li>子进程调用 <code>Debug.dumpHprofData</code> 生成 hprof 后退出</li><li>父进程启动 <code>Service</code> 在另一个进程里解析 hprof 并构造 GC ROOT PATH</li></ol><p>整个过程 APP 只在 <code>fork</code> 前后冻结了一小会，这么短的时间是可以接受的，由于 <code>fork</code> 采用 <code>Copy-On-Write</code> 机制，子进程能够继承父进程的内存</p><h2 id="暂停和恢复-JVM"><a href="#暂停和恢复-JVM" class="headerlink" title="暂停和恢复 JVM"></a>暂停和恢复 JVM</h2><ol><li>&lt;= Android 10，使用函数 <code>SuspendVMEv</code> 和 <code>ResumeVMEv</code></li><li>&gt;= Android 11，使用类 <code>ScopedSuspendAll</code>（局部变量，构造函数暂停 JVM，析构函数恢复 JVM）</li><li>&lt;= Android 4，<code>KOOM</code> 不支持</li></ol><p>但是要从各个 Android 版本的 so 文件里准确找到这些函数（符号）是有难度的</p><p>寻找 <code>SuspendVMEv</code> 和 <code>ResumeVMEv</code> 的地址</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 自己实现 dlopen dlsym dlclose 以兼容各 Android 版本</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">initForkVMSymbols</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> *libHandle = kwai::linker::DlFcn::<span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, RTLD_NOW);<br>  <span class="hljs-keyword">if</span> (libHandle == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  suspendVM = (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)())kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(libHandle, <span class="hljs-string">&quot;_ZN3art3Dbg9SuspendVMEv&quot;</span>);<br>  <span class="hljs-keyword">if</span> (suspendVM == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art3Dbg9SuspendVMEv unsupported!&quot;</span>);<br>  &#125;<br><br>  resumeVM = (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)())kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(libHandle, <span class="hljs-string">&quot;_ZN3art3Dbg8ResumeVMEv&quot;</span>);<br>  <span class="hljs-keyword">if</span> (resumeVM == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art3Dbg8ResumeVMEv unsupported!&quot;</span>);<br>  &#125;<br><br>  kwai::linker::DlFcn::<span class="hljs-built_in">dlclose</span>(libHandle);<br>  <span class="hljs-keyword">return</span> suspendVM != <span class="hljs-literal">nullptr</span> &amp;&amp; resumeVM != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> *<span class="hljs-title">DlFcn::dlopen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lib_name, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;<br>  <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;dlopen %s&quot;</span>, lib_name);<br>  <span class="hljs-built_in">pthread_once</span>(&amp;once_control, init_api);<br>  <span class="hljs-keyword">if</span> (android_api_ &lt; __ANDROID_API_N__) &#123;                         <span class="hljs-comment">// N 以下打开 libart.so 查找符号</span><br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">dlopen</span>(lib_name, flags);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (android_api_ &gt; __ANDROID_API_N__) &#123;<br>    <span class="hljs-keyword">void</span> *handle = ::<span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libdl.so&quot;</span>, RTLD_NOW);<br>    <span class="hljs-built_in">CHECKP</span>(handle)<br>    <span class="hljs-keyword">auto</span> __loader_dlopen = <span class="hljs-keyword">reinterpret_cast</span>&lt;__loader_dlopen_fn&gt;(::<span class="hljs-built_in">dlsym</span>(handle, <span class="hljs-string">&quot;__loader_dlopen&quot;</span>));<br>    <span class="hljs-built_in">CHECKP</span>(__loader_dlopen)<br>    <span class="hljs-keyword">if</span> (android_api_ &lt; __ANDROID_API_Q__) &#123;                       <span class="hljs-comment">// Q 以下用 __loader_dlopen 查找符号</span><br>      <span class="hljs-keyword">return</span> __loader_dlopen(lib_name, flags, (<span class="hljs-keyword">void</span> *)dlerror);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      handle = __loader_dlopen(lib_name, flags, (<span class="hljs-keyword">void</span> *)dlerror); <span class="hljs-comment">// 其他情况，从 /proc/self/maps 拿到进程的内存布局，找到 mmap 进内存的 libart.so，根据 elf 文件结构解析里面的符号</span><br>      <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// Android Q added &quot;runtime&quot; namespace</span><br>        dl_iterate_data data&#123;&#125;;<br>        data.info_.dlpi_name = lib_name;<br>        <span class="hljs-built_in">dl_iterate_phdr_wrapper</span>(dl_iterate_callback, &amp;data);<br>        <span class="hljs-built_in">CHECKP</span>(data.info_.dlpi_addr &gt; <span class="hljs-number">0</span>)<br>        handle = __loader_dlopen(lib_name, flags, (<span class="hljs-keyword">void</span> *)data.info_.dlpi_addr);<br>      &#125;<br>      <span class="hljs-keyword">return</span> handle;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// __ANDROID_API_N__</span><br>  <span class="hljs-keyword">auto</span> *data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">dl_iterate_data</span>();<br>  data-&gt;info_.dlpi_name = lib_name;<br>  <span class="hljs-built_in">dl_iterate_phdr_wrapper</span>(dl_iterate_callback, data);<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> *<span class="hljs-title">DlFcn::dlsym</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *handle, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span> </span>&#123;<br>  <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;dlsym %s&quot;</span>, name);<br>  <span class="hljs-built_in">CHECKP</span>(handle)<br>  <span class="hljs-keyword">if</span> (android_api_ != __ANDROID_API_N__) &#123;                  <span class="hljs-comment">// 用 dlopen 打开则用 dlsym 查找符号</span><br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">dlsym</span>(handle, name);<br>  &#125;<br>  <span class="hljs-comment">// __ANDROID_API_N__</span><br>  <span class="hljs-keyword">auto</span> *data = (dl_iterate_data *)handle;                   <span class="hljs-comment">// 否则遍历 elf 里的符号列表查找</span><br>  <span class="hljs-built_in">ElfW</span>(Addr) dlpi_addr = data-&gt;info_.dlpi_addr;<br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Phdr)</span> *dlpi_phdr </span>= data-&gt;info_.dlpi_phdr;<br>  <span class="hljs-built_in">ElfW</span>(Half) dlpi_phnum = data-&gt;info_.dlpi_phnum;<br>  <span class="hljs-comment">// preserved for parse .symtab</span><br>  <span class="hljs-built_in">ElfW</span>(Addr) elf_base_addr;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dlpi_phnum; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (dlpi_phdr[i].p_type == PT_LOAD &amp;&amp; dlpi_phdr[i].p_offset == <span class="hljs-number">0</span>) &#123;<br>      elf_base_addr = dlpi_addr + dlpi_phdr[i].p_vaddr;<br>      <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;PT_LOAD dlpi_addr %p p_vaddr %p elf_base_addr %p&quot;</span>, dlpi_addr, dlpi_phdr[i].p_vaddr,<br>            elf_base_addr);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dlpi_phdr[i].p_type == PT_DYNAMIC) &#123;<br>      <span class="hljs-built_in">ElfW</span>(Dyn) *dyn = (<span class="hljs-built_in">ElfW</span>(Dyn) *)(dlpi_addr + dlpi_phdr[i].p_vaddr);<br>      <span class="hljs-built_in">ElfW</span>(Dyn) *dyn_end = dyn + (dlpi_phdr[i].p_memsz / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in">ElfW</span>(Dyn)));<br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *strtab;<br>      <span class="hljs-built_in">ElfW</span>(Sym) * symtab;<br>      <span class="hljs-keyword">bool</span> is_use_gnu_hash = <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">// for ELF hash</span><br>      <span class="hljs-keyword">size_t</span> nbucket_;<br>      <span class="hljs-keyword">size_t</span> nchain_;<br>      <span class="hljs-keyword">uint32_t</span> *bucket_;<br>      <span class="hljs-keyword">uint32_t</span> *chain_;<br>      <span class="hljs-comment">// for GNU hash</span><br>      <span class="hljs-keyword">size_t</span> gnu_nbucket_;<br>      <span class="hljs-keyword">uint32_t</span> *gnu_bucket_;<br>      <span class="hljs-keyword">uint32_t</span> *gnu_chain_;<br>      <span class="hljs-keyword">uint32_t</span> gnu_maskwords_;<br>      <span class="hljs-keyword">uint32_t</span> gnu_shift2_;<br>      <span class="hljs-built_in">ElfW</span>(Addr) * gnu_bloom_filter_;<br>      <span class="hljs-comment">// ELF parse</span><br>      <span class="hljs-keyword">for</span> (; dyn &lt; dyn_end; dyn++) &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (dyn-&gt;d_tag) &#123;<br>        <span class="hljs-keyword">case</span> DT_NULL:<br>          <span class="hljs-comment">// the end of the dynamic-section</span><br>          dyn = dyn_end;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DT_STRTAB: &#123;<br>          <span class="hljs-built_in">ElfW</span>(Addr) strtab_addr = dlpi_addr + dyn-&gt;d_un.d_ptr;<br>          strtab = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *&gt;(strtab_addr);<br>          <span class="hljs-built_in">CHECKP</span>(strtab_addr &gt;= dlpi_addr)<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> DT_SYMTAB: &#123;<br>          <span class="hljs-built_in">ElfW</span>(Addr) symtab_addr = dlpi_addr + dyn-&gt;d_un.d_ptr;<br>          symtab = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">ElfW</span>(Sym) *&gt;(symtab_addr);<br>          <span class="hljs-built_in">CHECKP</span>(symtab_addr &gt;= dlpi_addr)<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> DT_HASH: &#123;<br>          <span class="hljs-comment">// ignore DT_HASH when ELF contains DT_GNU_HASH hash table</span><br>          <span class="hljs-keyword">if</span> (is_use_gnu_hash) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          nbucket_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">0</span>];<br>          nchain_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">1</span>];<br>          bucket_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr + <span class="hljs-number">8</span>);<br>          chain_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr + <span class="hljs-number">8</span> + nbucket_ * <span class="hljs-number">4</span>);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> DT_GNU_HASH: &#123;<br>          gnu_nbucket_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">0</span>];<br>          <span class="hljs-comment">// skip symndx</span><br>          gnu_maskwords_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">2</span>];<br>          gnu_shift2_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">3</span>];<br><br>          gnu_bloom_filter_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">ElfW</span>(Addr) *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr + <span class="hljs-number">16</span>);<br>          gnu_bucket_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(gnu_bloom_filter_ + gnu_maskwords_);<br>          <span class="hljs-comment">// amend chain for symndx = header[1]</span><br>          gnu_chain_ = gnu_bucket_ + gnu_nbucket_ -<br>                       <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">1</span>];<br>          --gnu_maskwords_;<br><br>          is_use_gnu_hash = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// lookup symbol</span><br>      <span class="hljs-keyword">if</span> (is_use_gnu_hash) &#123;<br>        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;lookup use gnu hash&quot;</span>);<br>        <span class="hljs-keyword">uint32_t</span> hash = <span class="hljs-built_in">elf_gnu_hash</span>((<span class="hljs-keyword">uint8_t</span> *)name);<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">uint32_t</span> kBloomMaskBits = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in">ElfW</span>(Addr)) * <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; gnu_maskwords_;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span> bloom_word </span>= gnu_bloom_filter_[word_num];<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> h1 = hash % kBloomMaskBits;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> h2 = (hash &gt;&gt; gnu_shift2_) % kBloomMaskBits;<br>        <span class="hljs-comment">// test against bloom filter</span><br>        <span class="hljs-built_in">CHECKP</span>((<span class="hljs-number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) != <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// bloom test says &quot;probably yes&quot;...</span><br>        <span class="hljs-keyword">uint32_t</span> n = gnu_bucket_[hash % gnu_nbucket_];<br><br>        <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-built_in">ElfW</span>(Sym) *s = symtab + n;<br>          <span class="hljs-keyword">if</span> (((gnu_chain_[n] ^ hash) &gt;&gt; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(strtab + s-&gt;st_name, name) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;find %s %p&quot;</span>, name, dlpi_addr + s-&gt;st_value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(dlpi_addr + s-&gt;st_value);<br>          &#125;<br>        &#125; <span class="hljs-keyword">while</span> ((gnu_chain_[n++] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;lookup use elf hash&quot;</span>);<br>        <span class="hljs-keyword">uint32_t</span> hash = <span class="hljs-built_in">elf_hash</span>((<span class="hljs-keyword">uint8_t</span> *)name);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> n = bucket_[hash % nbucket_]; n != <span class="hljs-number">0</span>; n = chain_[n]) &#123;<br>          <span class="hljs-built_in">ElfW</span>(Sym) *s = symtab + n;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(strtab + s-&gt;st_name, name) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;find %s %p&quot;</span>, name, dlpi_addr + s-&gt;st_value);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(dlpi_addr + s-&gt;st_value);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>查找 <code>ScopedSuspendAll</code> 的构造函数和析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_dumpHprofDataNative</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jclass clazz, jstring file_name)</span> </span>&#123;<br>  <span class="hljs-built_in">pthread_once</span>(&amp;once_control, initDumpHprofSymbols);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// For above android 11</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initDumpHprofSymbols</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Parse .dynsym(GLOBAL)</span><br>  <span class="hljs-keyword">void</span> *libHandle = kwai::linker::DlFcn::<span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, RTLD_NOW);<br>  <span class="hljs-keyword">if</span> (libHandle == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ScopedSuspendAllConstructor = (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">bool</span>))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(<br>      libHandle, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllC1EPKcb&quot;</span>);<br>  <span class="hljs-keyword">if</span> (ScopedSuspendAllConstructor == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllC1EPKcb unsupported!&quot;</span>);<br>  &#125;<br><br>  ScopedSuspendAllDestructor =<br>      (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword">void</span> *))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(libHandle, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllD1Ev&quot;</span>);<br>  <span class="hljs-keyword">if</span> (ScopedSuspendAllDestructor == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllD1Ev unsupported!&quot;</span>);<br>  &#125;<br><br>  kwai::linker::DlFcn::<span class="hljs-built_in">dlclose</span>(libHandle);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>使用系统调用 <code>fork</code> 创建子进程</p><ol><li>子进程返回 0，dump hprof 后退出进程</li><li>父进程返回子进程 pid，首先恢复 JVM，然后利用 <code>waitpid</code> 阻塞直到子进程完成 dump hprof，然后处理 hprof</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJvmHeapDumper</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dump</span><span class="hljs-params">(String path)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">boolean</span> dumpRes = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">int</span> pid = trySuspendVMThenFork();<br>      <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;                       <span class="hljs-comment">// 子进程</span><br>        Debug.dumpHprofData(path);<br>        KLog.i(TAG, <span class="hljs-string">&quot;notifyDumped:&quot;</span> + dumpRes);<br>        <span class="hljs-comment">//System.exit(0);</span><br>        exitProcess();<br>      &#125; <span class="hljs-keyword">else</span> &#123;                              <span class="hljs-comment">// 父进程</span><br>        resumeVM();<br>        dumpRes = waitDumping(pid);<br>        KLog.i(TAG, <span class="hljs-string">&quot;hprof pid:&quot;</span> + pid + <span class="hljs-string">&quot; dumped: &quot;</span> + path);<br>      &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>      KLog.e(TAG, <span class="hljs-string">&quot;dump failed caused by IOException!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dumpRes;<br>  &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_trySuspendVMThenFork</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jobject jObject)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (suspendVM == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">initForkVMSymbols</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (suspendVM != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">suspendVM</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> fork();    <span class="hljs-comment">// 用系统调用 fork 创建子进程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Android 11 的情况下也是利用系统调用 <code>fork</code> 出子进程</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_dumpHprofDataNative</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jclass clazz, jstring file_name)</span> </span>&#123;<br>  <span class="hljs-built_in">pthread_once</span>(&amp;once_control, initDumpHprofSymbols);<br>  <span class="hljs-keyword">if</span> (ScopedSuspendAllConstructor == <span class="hljs-literal">nullptr</span> || ScopedSuspendAllDestructor == <span class="hljs-literal">nullptr</span> ||<br>      HprofConstructor == <span class="hljs-literal">nullptr</span> || HprofDestructor == <span class="hljs-literal">nullptr</span> || Dump == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> JNI_FALSE;<br>  &#125;<br>  <span class="hljs-built_in">ScopedSuspendAllConstructor</span>(gSSAHandle, LOG_TAG, <span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">pid_t</span> pid = fork();<br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// Fork error.</span><br>    __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, <span class="hljs-string">&quot;failed to fork!&quot;</span>);<br>    <span class="hljs-keyword">return</span> JNI_FALSE;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// Parent</span><br>    <span class="hljs-built_in">ScopedSuspendAllDestructor</span>(gSSAHandle);<br><br>    <span class="hljs-keyword">int</span> stat_loc;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">waitpid</span>(pid, &amp;stat_loc, <span class="hljs-number">0</span>) != <span class="hljs-number">-1</span> || errno != EINTR) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> JNI_TRUE;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="处理-hprof"><a href="#处理-hprof" class="headerlink" title="处理 hprof"></a>处理 hprof</h2><p>子进程用 <code>Debug.dumpHprofData</code> 生成 hprof 文件后结束，父进程拿到 hprof 后开个新进程，在 <code>Service</code> 里用 <code>LeakCanary.Shark</code> 解析</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJvmHeapDumper</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dump</span><span class="hljs-params">(String path)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">boolean</span> dumpRes = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">int</span> pid = trySuspendVMThenFork();<br>      <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;                   <span class="hljs-comment">// 子进程 dump hprof 后退出</span><br>        Debug.dumpHprofData(path);<br>        KLog.i(TAG, <span class="hljs-string">&quot;notifyDumped:&quot;</span> + dumpRes);<br>        exitProcess();<br>      &#125; <span class="hljs-keyword">else</span> &#123;                          <span class="hljs-comment">// 父进程等待 dump hprof 完成</span><br>        resumeVM();<br>        dumpRes = waitDumping(pid);<br>        KLog.i(TAG, <span class="hljs-string">&quot;hprof pid:&quot;</span> + pid + <span class="hljs-string">&quot; dumped: &quot;</span> + path);<br>      &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>      KLog.e(TAG, <span class="hljs-string">&quot;dump failed caused by IOException!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dumpRes;<br>  &#125;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapAnalyzeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IntentService</span> </span>&#123;     <span class="hljs-comment">// 在 HeapAnalyzeService 里解析 hprof</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runAnalysis</span><span class="hljs-params">(Application application,</span></span><br><span class="hljs-params"><span class="hljs-function">      HeapAnalysisListener heapAnalysisListener)</span> </span>&#123;<br>    KLog.i(TAG, <span class="hljs-string">&quot;runAnalysis startService&quot;</span>);<br>    Intent intent = <span class="hljs-keyword">new</span> Intent(application, HeapAnalyzeService.class);<br>    IPCReceiver ipcReceiver = buildAnalysisReceiver(heapAnalysisListener);<br>    intent.putExtra(KConstants.ServiceIntent.RECEIVER, ipcReceiver);<br>    KHeapFile heapFile = KHeapFile.getKHeapFile();<br>    intent.putExtra(KConstants.ServiceIntent.HEAP_FILE, heapFile);<br>    application.startService(intent);<br>  &#125;    <br>&#125;<br><br><span class="hljs-comment">// HeapAnalyzeService 在另一个进程，防止解析 hprof 时 OOM 影响 APP</span><br><span class="hljs-comment">// &lt;service</span><br><span class="hljs-comment">//       android:name=&quot;.analysis.HeapAnalyzeService&quot;</span><br><span class="hljs-comment">//       android:process=&quot;:heap_analysis&quot; /&gt;</span><br></code></pre></div></td></tr></table></figure><p>Android 11 则是查找类 <code>Hprof</code> 的构造/析构函数和 <code>dump</code> 函数，在 native 层进行 dump hprof，后续依然是在 java 层开个新进程解析</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_dumpHprofDataNative</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jclass clazz, jstring file_name)</span> </span>&#123;<br>  <span class="hljs-comment">// ... 直接在 native 层 dump hprof</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file_name, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">HprofConstructor</span>(gHprofHandle, filename, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);<br>  <span class="hljs-built_in">Dump</span>(gHprofHandle);<br>  <span class="hljs-built_in">HprofDestructor</span>(gHprofHandle);<br>  env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file_name, filename);<br>  _exit(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initDumpHprofSymbols</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 查找 Hprof 类的相关函数</span><br>  <span class="hljs-comment">//...</span><br>  libHandle = kwai::linker::DlFcn::<span class="hljs-built_in">dlopen_elf</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, RTLD_NOW);<br>  <span class="hljs-keyword">if</span> (libHandle == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  HprofConstructor = (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym_elf</span>(<br>      libHandle, <span class="hljs-string">&quot;_ZN3art5hprof5HprofC2EPKcib&quot;</span>);<br>  <span class="hljs-keyword">if</span> (HprofConstructor == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art5hprof5HprofC2EPKcib unsupported!&quot;</span>);<br>  &#125;<br><br>  HprofDestructor =<br>      (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword">void</span> *))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym_elf</span>(libHandle, <span class="hljs-string">&quot;_ZN3art5hprof5HprofD0Ev&quot;</span>);<br>  <span class="hljs-keyword">if</span> (HprofDestructor == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art5hprof5HprofD0Ev unsupported!&quot;</span>);<br>  &#125;<br><br>  Dump = (<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)(<span class="hljs-keyword">void</span> *))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym_elf</span>(libHandle, <span class="hljs-string">&quot;_ZN3art5hprof5Hprof4DumpEv&quot;</span>);<br>  <span class="hljs-keyword">if</span> (Dump == <span class="hljs-literal">nullptr</span>) &#123;<br>    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art5hprof5Hprof4DumpEv unsupported!&quot;</span>);<br>  &#125;<br><br>  kwai::linker::DlFcn::<span class="hljs-built_in">dlclose_elf</span>(libHandle);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/KwaiAppTeam/KOOM">KOOM</a></li><li><a href="https://www.sunmoonblog.com/2019/06/04/fake-dlopen/">Android dlopen 方法的使用限制及解决方案</a></li><li><a href="https://tboox.org/cn/2020/07/04/byopen/">一个绕过移动端系统限制的dlopen库: byOpen</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>内存优化，OOM</tag>
      
      <tag>APM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matrix - TraceCanary 浅析</title>
    <link href="/2021/04/26/matrix-tracecanary/"/>
    <url>/2021/04/26/matrix-tracecanary/</url>
    
    <content type="html"><![CDATA[<h2 id="捕获掉帧-卡顿"><a href="#捕获掉帧-卡顿" class="headerlink" title="捕获掉帧/卡顿"></a>捕获掉帧/卡顿</h2><h3 id="什么是掉帧-卡顿"><a href="#什么是掉帧-卡顿" class="headerlink" title="什么是掉帧/卡顿"></a>什么是掉帧/卡顿</h3><blockquote><p>什么是卡顿，很多人能马上联系到的是帧率 FPS (每秒显示帧数)。那么多低的 FPS 才是卡顿呢？又或者低 FPS 真的就是卡顿吗？（以下 FPS 默认指平均帧率）</p><p>其实并非如此，举个例子，游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上，但我们平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得卡顿。 在人眼结构上看，当一组动作在 1 秒内有 12 次变化（即 12FPS），我们会认为这组动作是连贯的；而当大于 60FPS 时，人眼很难区分出来明显的变化，所以 60FPS 也一直作为业界衡量一个界面流畅程度的重要指标。一个稳定在 30FPS 的动画，我们不会认为是卡顿的，但一旦 FPS 很不稳定，人眼往往容易感知到。</p><p>FPS 低并不意味着卡顿发生，而卡顿发生 FPS 一定不高。 FPS 可以衡量一个界面的流程性，但往往不能很直观的衡量卡顿的发生，这里有另一个指标（掉帧程度）可以更直观地衡量卡顿。</p><p>什么是掉帧（跳帧）？ 按照理想帧率 60FPS 这个指标，计算出平均每一帧的准备时间有 1000ms/60 = 16.6667ms，如果一帧的准备时间超出这个值，则认为发生掉帧，超出的时间越长，掉帧程度越严重。假设每帧准备时间约 32ms，每次只掉一帧，那么 1 秒内实际只刷新 30 帧，即平均帧率只有 30FPS，但这时往往不会觉得是卡顿。反而如果出现某次严重掉帧（&gt;300ms），那么这一次的变化，通常很容易感知到。所以界面的掉帧程度，往往可以更直观的反映出卡顿。</p></blockquote><p>造成 <strong>掉帧</strong> 的直接原因通常是 <code>doFrame</code> 过于繁重执行超时，或者其他任务挤压了 <code>doFrame</code> 的执行时间，这些都会造成主线程不能在 <strong>帧间隔时间</strong> 内完成 ui 绘制</p><h3 id="计算-Message-耗时"><a href="#计算-Message-耗时" class="headerlink" title="计算 Message 耗时"></a>计算 <code>Message</code> 耗时</h3><p>我们知道主线程是「生产者 - 消费者」模型，任务（<code>Message</code>）都在消息队列（<code>MessageQueue</code>）里排队等待执行，如果能够度量出每个 <code>Message</code> 的耗时，然后与某个阈值进行比较，我们就能找出耗时任务做进一步的优化</p><p>从下面的代码可以看到，<code>Message</code> 执行前后都会有特定格式的日志输出，只要捕获这些日志，就能计算出每个 <code>Message</code> 的耗时</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Looper.loop() &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">final</span> Printer logging = me.mLogging;<br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                    msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>        msg.target.dispatchMessage(msg);<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>LooperMonitor</code> 通过替换 <code>Looper.mLogging</code>，从而捕获到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code> 和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 的日志输出进而算出 <code>Message</code> 耗时，并提供 <code>dispatchStart</code> 和 <code>dispatchEnd</code> 两个钩子</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperMonitor</span> </span>&#123;<br>    <span class="hljs-comment">// 通过反射替换 Looper.mLogging</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetPrinter</span><span class="hljs-params">()</span> </span>&#123;<br>        Printer originPrinter = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!isReflectLoggingError) &#123;<br>                originPrinter = ReflectUtils.get(looper.getClass(), <span class="hljs-string">&quot;mLogging&quot;</span>, looper);<br>                <span class="hljs-keyword">if</span> (originPrinter == printer &amp;&amp; <span class="hljs-keyword">null</span> != printer) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            isReflectLoggingError = <span class="hljs-keyword">true</span>;<br>            Log.e(TAG, <span class="hljs-string">&quot;[resetPrinter] %s&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != printer) &#123;<br>            MatrixLog.w(TAG, <span class="hljs-string">&quot;maybe thread:%s printer[%s] was replace other[%s]!&quot;</span>,<br>                    looper.getThread().getName(), printer, originPrinter);<br>        &#125;<br>        looper.setMessageLogging(printer = <span class="hljs-keyword">new</span> LooperPrinter(originPrinter));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != originPrinter) &#123;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;reset printer, originPrinter[%s] in %s&quot;</span>, originPrinter, looper.getThread().getName());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 捕获根据特定格式的日志输出</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Printer</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != origin) &#123;<br>                origin.println(x);<br>                <span class="hljs-keyword">if</span> (origin == <span class="hljs-keyword">this</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(TAG + <span class="hljs-string">&quot; origin == this&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isHasChecked) &#123;<br>                isValid = x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span> || x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>                isHasChecked = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span> (!isValid) &#123;<br>                    MatrixLog.e(TAG, <span class="hljs-string">&quot;[println] Printer is inValid! x:%s&quot;</span>, x);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isValid) &#123;<br>                dispatch(x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span>, x);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 分发 Dispatching to 和 Finished to 事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isBegin, String log)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (LooperDispatchListener listener : listeners) &#123;<br>            <span class="hljs-keyword">if</span> (listener.isValid()) &#123;<br>                <span class="hljs-keyword">if</span> (isBegin) &#123;<br>                    <span class="hljs-keyword">if</span> (!listener.isHasDispatchStart) &#123;<br>                        listener.onDispatchStart(log);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (listener.isHasDispatchStart) &#123;<br>                        listener.onDispatchEnd(log);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isBegin &amp;&amp; listener.isHasDispatchStart) &#123;<br>                listener.dispatchEnd();<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了防止其他代码也替换 <code>Looper.mLogging</code>，<code>LooperMonitor</code> 还在主线程空闲的时候进行检查</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> LooperMonitor.queueIdle() &#123;<br>    <span class="hljs-keyword">if</span> (SystemClock.uptimeMillis() - lastCheckPrinterTime &gt;= CHECK_TIME) &#123;<br>        resetPrinter();<br>        lastCheckPrinterTime = SystemClock.uptimeMillis();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="计算-doFrame-耗时"><a href="#计算-doFrame-耗时" class="headerlink" title="计算 doFrame 耗时"></a>计算 <code>doFrame</code> 耗时</h3><p>上面的方法可以统计主线程里每个 <code>Message</code> 的耗时，但并不是每个 <code>Message</code> 都在做 ui 绘制（<code>doFrame</code>），比如违规放入耗时的 IO 操作；为了更精确地捕获耗时的 <code>doFrame</code>，以及进行 FPS 统计，还需做更多的工作</p><p>参考 <a href="../../../../2020/12/02/vsync/">Android 图形栈（一）vsync</a> 我们知道，当 <code>APP_VSYNC</code> 到达时会走 <code>FrameDisplayEventReceiver.onVsync</code> -&gt; <code>Choreographer.doFrame</code> -&gt; <code>Choreographer.doCallbacks</code>，最后按 INPUT - ANIMATION - TRAVERSAL 的顺序执行 <code>Choreographer.mCallbackQueues</code> 里的 <code>Runnable</code></p><p>动态地往这三个队列的头部插入钩子，从而计算出每个阶段开始时间和结束时间，加上捕获 <code>Message</code> 的方法（<code>Choreographer.doFrame</code> 是由 <code>FrameDisplayEventReceiver.onVsync</code> 放入主线程任务队列的 <code>Message</code>），最终形成完整的闭环：</p><p><code>dispatchBegin</code> -&gt; <code>doFrameBegin</code> -&gt; <code>doQueueBegin(INPUT)</code> -&gt; <code>doQueueEnd(INPUT)</code> -&gt; <code>doQueueBegin(ANIMATION)</code> -&gt; <code>doQueueEnd(ANIMATION)</code> -&gt; <code>doQueueBegin(TRAVERSAL)</code> -&gt; <code>doQueueEnd(TRAVERSAL)</code> -&gt; <code>doFrameEnd</code> -&gt; <code>dispatchEnd</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UIThreadMonitor</span> </span>&#123;<br>    <span class="hljs-comment">// 最开始先在 INPUT 头部插入钩子</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> UIThreadMonitor.onStart() &#123;<br>        <span class="hljs-comment">// ...</span><br>        queueStatus = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];<br>        queueCost = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];<br>        addFrameCallback(CALLBACK_INPUT, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 依次往 ANIMATION/TRAVERSAL 插入钩子</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> &#123;<br>            doFrameBegin(token);<br>            doQueueBegin(CALLBACK_INPUT);<br>            addFrameCallback(CALLBACK_ANIMATION, <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    doQueueEnd(CALLBACK_INPUT);<br>                    doQueueBegin(CALLBACK_ANIMATION);<br>                &#125;<br>            &#125;, <span class="hljs-keyword">true</span>);<br>            addFrameCallback(CALLBACK_TRAVERSAL, <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    doQueueEnd(CALLBACK_ANIMATION);<br>                    doQueueBegin(CALLBACK_TRAVERSAL);<br>                &#125;<br>            &#125;, <span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;<br>                MatrixLog.d(TAG, <span class="hljs-string">&quot;[UIThreadMonitor#run] inner cost:%sns&quot;</span>, System.nanoTime() - start);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 主线程消息队列的任务结束钩子，也作为 TRAVERSAL 的结束标志</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">long</span> startNs = token;<br>        <span class="hljs-keyword">long</span> intendedFrameTimeNs = startNs;<br>        <span class="hljs-keyword">if</span> (isVsyncFrame) &#123;<br>            doFrameEnd(token);<br>            intendedFrameTimeNs = getIntendedFrameTimeNs(startNs);  <span class="hljs-comment">// FrameDisplayEventReceiver.mTimestampNanos</span><br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrameEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> token)</span> </span>&#123;<br>        doQueueEnd(CALLBACK_TRAVERSAL);<br>        <span class="hljs-comment">// ...</span><br>        addFrameCallback(CALLBACK_INPUT, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);   <span class="hljs-comment">// 继续放入下一轮 doFrame 的钩子</span><br>    &#125;     <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="LooperObserver"><a href="#LooperObserver" class="headerlink" title="LooperObserver"></a><code>LooperObserver</code></h3><p>结合上面捕获到的信息，提供一个「观察者」</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperObserver</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isDispatchBegin = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Message 开始执行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginNs       开始时间（System.nanoTime）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuBeginNs    线程的开始时间（SystemClock.currentThreadTimeMillis）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token         等于 beginNs</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@CallSuper</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchBegin</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginNs, <span class="hljs-keyword">long</span> token)</span> </span>&#123;<br>        isDispatchBegin = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Message 耗时统计</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> focusedActivity       当前页面（Activity）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startNs               Message 的开始时间（等于 beginNs）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endNs                 Message 的结束时间（等于 endNs）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isVsyncFrame          是否 ui 绘制任务（doFrame）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> intendedFrameTimeNs   收到 APP_VSYNC 信号的时间（FrameDisplayEventReceiver.onVsync）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputCostNs           doFrame INPUT 阶段耗时</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> animationCostNs       doFrame ANIMATION 阶段耗时</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> traversalCostNs       doFrame TRAVERSAL 阶段耗时</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(String focusedActivity, <span class="hljs-keyword">long</span> startNs, <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">boolean</span> isVsyncFrame, <span class="hljs-keyword">long</span> intendedFrameTimeNs, <span class="hljs-keyword">long</span> inputCostNs, <span class="hljs-keyword">long</span> animationCostNs, <span class="hljs-keyword">long</span> traversalCostNs)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Message 结束执行</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginNs       开始时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuBeginMs    线程的开始时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endNs         结束时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuEndMs      结束的线程时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token         等于 beginNs</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isVsyncFrame  此任务是否 ui 绘制任务（doFrame）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@CallSuper</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">long</span> cpuEndMs, <span class="hljs-keyword">long</span> token, <span class="hljs-keyword">boolean</span> isVsyncFrame)</span> </span>&#123;<br>        isDispatchBegin = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDispatchBegin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isDispatchBegin;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="计算-FPS"><a href="#计算-FPS" class="headerlink" title="计算 FPS"></a>计算 FPS</h3><blockquote><p>我们将掉帧数划分出几个区间进行定级，掉帧数小于 3 帧的情况属于最佳，依次类推，见下表：</p><table><thead><tr><th>Best</th><th>Normal</th><th>Middle</th><th>High</th><th>Frozen</th></tr></thead><tbody><tr><td>[0:3)</td><td>[3:9)</td><td>[9:24)</td><td>[24:42)</td><td>[42:∞)</td></tr></tbody></table><p>相比单看平均帧率，掉帧程度的分布可以明显的看出，界面卡顿（平均帧率低）的原因是因为连续轻微的掉帧，还是某次严重掉帧造成的。再通过 <code>Activity</code> 区分不同场景，计算每个界面在有效绘制的时间片内，掉帧程度的分布情况及平均帧率，从而来评估出一个界面的整体流畅程度。</p></blockquote><p>也就是说，一次掉帧可能掉了一帧、两帧或者更多帧（<strong>掉帧数</strong>），这里根据上表把一次掉帧划分为 <code>Best/Normal/Middle/High/Frozen</code> 五个级别，后续评价掉帧时就不再关注掉帧数而是 <strong>掉帧次数</strong> 及其严重级别</p><p>下图绿色的 <code>62.00 FPS</code> 指的是过去 200ms 内的平均帧率</p><p>灰色的 <code>sum: 3.0</code> 是 <strong>总掉帧次数</strong>，下面的彩虹从左到右分别代表 <code>Normal/Middle/High/Frozen</code> 这四个级别的掉帧占总掉帧的比例，往下是当前页面的掉帧数和掉帧比例</p><p>最底下的图表是过去 10s 内平均帧率（200ms 时间段）的横向柱状图，每 5s 就会有 25 条记录，50 FPS 差不多是 <code>Normal</code> 的帧率下限，30 FPS 差不多是 <code>Middle</code> 的帧率下限</p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/fps_board.jpg" alt="fps_board"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每帧的时间间隔，默认取 16ms（60 FPS）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UIThreadMonitor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> frameIntervalNanos = <span class="hljs-number">16666666</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(TraceConfig config)</span> </span>&#123;<br>        frameIntervalNanos = ReflectUtils.reflectObject(choreographer, <span class="hljs-string">&quot;mFrameIntervalNanos&quot;</span>, Constants.DEFAULT_FRAME_DURATION);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameTracer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> frameIntervalNs;     <span class="hljs-comment">// UIThreadMonitor.getMonitor().getFrameIntervalNanos()</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyListener</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String focusedActivity, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startNs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isVsyncFrame,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> intendedFrameTimeNs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> inputCostNs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> animationCostNs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> traversalCostNs)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> traceBegin = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> jiter = endNs - intendedFrameTimeNs;         <span class="hljs-comment">// 从收到 vsync 到完成 doFrame 的时间，也就是实际渲染一帧的耗时</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dropFrame = (<span class="hljs-keyword">int</span>) (jiter / frameIntervalNs);  <span class="hljs-comment">// 计算出渲染这一帧对比理论 FPS 有没掉帧，掉了多少帧</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameDecorator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrameAsync</span><span class="hljs-params">(String focusedActivity, <span class="hljs-keyword">long</span> startNs, <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">int</span> dropFrame, <span class="hljs-keyword">boolean</span> isVsyncFrame, <span class="hljs-keyword">long</span> intendedFrameTimeNs, <span class="hljs-keyword">long</span> inputCostNs, <span class="hljs-keyword">long</span> animationCostNs, <span class="hljs-keyword">long</span> traversalCostNs)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.doFrameAsync(focusedActivity, startNs, endNs, dropFrame, isVsyncFrame, intendedFrameTimeNs, inputCostNs, animationCostNs, traversalCostNs);<br><br>        <span class="hljs-keyword">if</span> (!Objects.equals(focusedActivity, lastVisibleScene)) &#123;        <span class="hljs-comment">// 切换页面时，重置页面的统计数据</span><br>            dropLevel = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[FrameTracer.DropStatus.values().length];<br>            lastVisibleScene = focusedActivity;<br>            lastCost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            lastFrames[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 为什么不是用 endNs ？</span><br>        <span class="hljs-comment">// 1，因为 doFrame 执行完还要等 surfacefling 在下一帧的时间点进行合成和显示，而不是 doFrame 后立即显示，所以要用 frameIntervalMs 的倍数</span><br>        <span class="hljs-comment">// 2，其次考虑用户无操作/页面静止的情况，主线程的任务队列为空，没有刷新页面，如果用设备时间 endNs 会导致计算出极低的错误 FPS</span><br>        sumFrameCost += (dropFrame + <span class="hljs-number">1</span>) * frameIntervalMs;<br>        sumFrames += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">float</span> duration = sumFrameCost - lastCost[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 距离上一次刷新 FPS 的时间间隔</span><br><br>        <span class="hljs-keyword">if</span> (dropFrame &gt;= Constants.DEFAULT_DROPPED_FROZEN) &#123;    <span class="hljs-comment">// 根据掉帧数，给发生的掉帧事故分级别统计</span><br>            dropLevel[FrameTracer.DropStatus.DROPPED_FROZEN.index]++;<br>            sumDropLevel[FrameTracer.DropStatus.DROPPED_FROZEN.index]++;<br>            belongColor = frozenColor;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dropFrame &gt;= Constants.DEFAULT_DROPPED_HIGH) &#123;<br>            dropLevel[FrameTracer.DropStatus.DROPPED_HIGH.index]++;<br>            sumDropLevel[FrameTracer.DropStatus.DROPPED_HIGH.index]++;<br>            <span class="hljs-keyword">if</span> (belongColor != frozenColor) &#123;<br>                belongColor = highColor;<br>            &#125;<br>        &#125; <span class="hljs-comment">// ...</span><br><br><br>        <span class="hljs-keyword">long</span> collectFrame = sumFrames - lastFrames[<span class="hljs-number">0</span>];                              <span class="hljs-comment">// 200ms 内刷新了几帧</span><br>        <span class="hljs-keyword">if</span> (duration &gt;= <span class="hljs-number">200</span>) &#123;                                                      <span class="hljs-comment">// 每隔 200ms 刷新一次 FPS</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> fps = Math.min(maxFps, <span class="hljs-number">1000.f</span> * collectFrame / duration);   <span class="hljs-comment">// 统计过去 200ms 的 FPS</span><br>            updateView(view, fps, belongColor, dropLevel[FrameTracer.DropStatus.DROPPED_NORMAL.index], dropLevel[FrameTracer.DropStatus.DROPPED_MIDDLE.index] ...);<br>            lastCost[<span class="hljs-number">0</span>] = sumFrameCost;<br>            lastFrames[<span class="hljs-number">0</span>] = sumFrames;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="统计耗时-Message"><a href="#统计耗时-Message" class="headerlink" title="统计耗时 Message"></a>统计耗时 <code>Message</code></h3><p><code>TraceCanary</code> 把耗时超过 700ms 的 <code>Message</code> 作为 <code>Evil Method</code> 上报</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvilMethodTracer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">long</span> cpuEndMs, <span class="hljs-keyword">long</span> token, <span class="hljs-keyword">boolean</span> isVsyncFrame)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> dispatchCost = (endNs - beginNs) / Constants.TIME_MILLIS_TO_NANO;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="无埋点插桩收集函数耗时"><a href="#无埋点插桩收集函数耗时" class="headerlink" title="无埋点插桩收集函数耗时"></a>无埋点插桩收集函数耗时</h2><p>为了在捕捉到卡顿堆栈后，获取各个函数的执行耗时，需要对所有函数进行无埋点插桩，在函数执行前调用 <code>MethodBeat.i</code>，在函数执行后调用 <code>MethodBeat.o</code></p><blockquote><p>通过代理编译期间的任务 <code>transformClassesWithDexTask</code>，将全局 <code>class</code> 文件作为输入，利用 <code>ASM</code> 工具，高效地对所有 <code>class</code> 文件进行扫描及插桩</p><p>插桩过程有几个关键点：</p><ol><li>选择在该编译任务执行时插桩，是因为 <code>proguard</code> 操作是在该任务之前就完成的，意味着插桩时的 <code>class</code> 文件已经被混淆过的。而选择 <code>proguard</code> 之后去插桩，是因为如果提前插桩会造成部分方法不符合内联规则，没法在 <code>proguard</code> 时进行优化，最终导致程序方法数无法减少，从而引发方法数过大问题</li><li>为了减少插桩量及性能损耗，通过遍历 <code>class</code> 方法指令集，判断扫描的函数是否只含有 <code>PUT/READ FIELD</code> 等简单的指令，来过滤一些默认或匿名构造函数，以及 <code>get/set</code> 等简单不耗时函数</li><li>针对界面启动耗时，因为要统计从 <code>Activity.onCreate</code> 到 <code>Activity.onWindowFocusChange</code> 间的耗时，所以在插桩过程中需要收集应用内所有 <code>Activity</code> 的实现类，并覆盖 <code>onWindowFocusChange</code> 函数进行打点</li><li>为了方便及高效记录函数执行过程，我们为每个插桩的函数分配一个独立 ID，在插桩过程中，记录插桩的函数签名及分配的 ID，在插桩完成后输出一份 mapping，作为数据上报后的解析支持。</li></ol><p>归纳起来，编译期所做的工作如下图：</p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/build.png" alt="transform class"></p></blockquote><h3 id="Gradle-Transform"><a href="#Gradle-Transform" class="headerlink" title="Gradle Transform"></a>Gradle Transform</h3><p><code>ignoreMethodMapFilePath</code> 上面说过为了减少插桩量及性能损耗会忽略一些函数，这些被忽略的函数记录在此文件里（默认放在 <code>/app/build/outputs/mapping/&#123;var&#125;/ignoreMethodMapping.txt</code>），大概长这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">ignore methods:<br>android.arch.core.executor.ArchTaskExecutor &lt;clinit&gt; ()V<br>android.arch.core.executor.ArchTaskExecutor &lt;<span class="hljs-keyword">init</span>&gt; ()V<br>android.arch.core.executor.ArchTaskExecutor$<span class="hljs-number">1</span> execute (Ljava.lang.Runnable;)V<br>android.arch.core.executor.DefaultTaskExecutor executeOnDiskIO (Ljava.lang.Runnable;)V<br>android.arch.core.<span class="hljs-keyword">internal</span>.FastSafeIterableMap &lt;<span class="hljs-keyword">init</span>&gt; ()V<br>android.arch.core.<span class="hljs-keyword">internal</span>.FastSafeIterableMap ceil (Ljava.lang.Object;)Ljava.util.Map$Entry;<br>android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap size ()I<br>android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap equals (Ljava.lang.Object;)Z<br>android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator backward (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;<br>android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator forward (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;<br>android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator &lt;<span class="hljs-keyword">init</span>&gt; (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)V<br></code></pre></div></td></tr></table></figure><p><code>methodMapFilePath</code> 函数签名和函数 ID 的映射（默认放在 <code>/app/build/outputs/mapping/&#123;var&#125;/methodMapping.txt</code>），大概长这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">6</span> run ()V<br><span class="hljs-number">2</span>,<span class="hljs-number">10</span>,sample.tencent.matrix.MatrixApplication initSQLiteLintConfig ()Lcom.tencent.sqlitelint.config.SQLiteLintConfig;<br><span class="hljs-number">3</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">5</span> onClick (Landroid.view.View;)V<br><span class="hljs-number">4</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">4</span> onClick (Landroid.view.View;)V<br><span class="hljs-number">5</span>,<span class="hljs-number">4</span>,sample.tencent.matrix.MainActivity onResume ()V<br><span class="hljs-number">6</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MatrixApplication onCreate ()V<br><span class="hljs-number">7</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">3</span> onClick (Landroid.view.View;)V<br><span class="hljs-number">8</span>,<span class="hljs-number">4</span>,sample.tencent.matrix.MainActivity onCreate (Landroid.os.Bundle;)V<br><span class="hljs-number">9</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">2</span> onClick (Landroid.view.View;)V<br><span class="hljs-number">10</span>,<span class="hljs-number">1</span>,org.apache.commons.io.comparator.DirectoryFileComparator compare (Ljava.io.File;Ljava.io.File;)I<br></code></pre></div></td></tr></table></figure><p><code>TraceCanary</code> 用 <code>Transform API</code> 处理并输出插桩后的 <code>class</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixTraceTransform</span>: <span class="hljs-type">Transform</span></span>() &#123;<br><br>    <span class="hljs-comment">// Transform 的名称</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MatrixTraceTransform&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">// Transform 接收 Input 处理并输出 Output</span><br>    <span class="hljs-comment">// 这里声明 MatrixTraceTransform 接收所有的 class，包括 class 文件和 jar 包中的 class</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: Set&lt;QualifiedContent.ContentType&gt; &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>    &#125;<br><br>    <span class="hljs-comment">// 指定 class 的范围，限定项目内的所有 class</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt;? &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>    &#125;<br><br>    <span class="hljs-comment">// 支持增量编译</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.transform(transformInvocation)<br>        <span class="hljs-comment">// ...</span><br>        transforming(transformInvocation)<br>    &#125;<br><br>    <span class="hljs-comment">// 核心逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transforming</span><span class="hljs-params">(invocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        <span class="hljs-keyword">val</span> outputProvider = invocation.outputProvider!!<br>        <span class="hljs-keyword">val</span> isIncremental = invocation.isIncremental &amp;&amp; <span class="hljs-keyword">this</span>.isIncremental<br>        <span class="hljs-keyword">if</span> (!isIncremental) &#123;<br>            outputProvider.deleteAll()<br>        &#125;<br>        <span class="hljs-keyword">val</span> config = configure(invocation)<br><br>        <span class="hljs-keyword">val</span> changedFiles = ConcurrentHashMap&lt;File, Status&gt;()    <span class="hljs-comment">// 需要进行插桩的 class/jar</span><br>        <span class="hljs-keyword">val</span> inputToOutput = ConcurrentHashMap&lt;File, File&gt;()     <span class="hljs-comment">// Input Dir -&gt; Output Dir，Input Jar -&gt; Output Jar</span><br>        <span class="hljs-keyword">val</span> inputFiles = ArrayList&lt;File&gt;()                      <span class="hljs-comment">// Input Dir &amp;&amp; Input Jar</span><br>        <span class="hljs-keyword">var</span> transformDirectory: File? = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">for</span> (input <span class="hljs-keyword">in</span> invocation.inputs) &#123;<br><br>            <span class="hljs-comment">// 遍历并添加 class 文件</span><br>            <span class="hljs-keyword">for</span> (directoryInput <span class="hljs-keyword">in</span> input.directoryInputs) &#123;<br>                changedFiles.putAll(directoryInput.changedFiles)<br>                <span class="hljs-keyword">val</span> inputDir = directoryInput.file<br>                inputFiles.add(inputDir)<br>                <span class="hljs-keyword">val</span> outputDirectory = outputProvider.getContentLocation(<br>                        directoryInput.name,<br>                        directoryInput.contentTypes,<br>                        directoryInput.scopes,<br>                        Format.DIRECTORY)<br><br>                inputToOutput[inputDir] = outputDirectory<br>                <span class="hljs-keyword">if</span> (transformDirectory == <span class="hljs-literal">null</span>) transformDirectory = outputDirectory.parentFile<br>            &#125;<br><br>            <span class="hljs-comment">// 遍历并添加 jar 包</span><br>            <span class="hljs-keyword">for</span> (jarInput <span class="hljs-keyword">in</span> input.jarInputs) &#123;<br>                <span class="hljs-keyword">val</span> inputFile = jarInput.file<br>                changedFiles[inputFile] = jarInput.status<br>                inputFiles.add(inputFile)<br>                <span class="hljs-keyword">val</span> outputJar = outputProvider.getContentLocation(<br>                        jarInput.name,<br>                        jarInput.contentTypes,<br>                        jarInput.scopes,<br>                        Format.JAR)<br><br>                inputToOutput[inputFile] = outputJar<br>                <span class="hljs-keyword">if</span> (transformDirectory == <span class="hljs-literal">null</span>) transformDirectory = outputJar.parentFile<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (inputFiles.size == <span class="hljs-number">0</span> || transformDirectory == <span class="hljs-literal">null</span>) &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;Matrix trace do not find any input files&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-comment">// 执行插桩</span><br>        <span class="hljs-keyword">val</span> outputDirectory = transformDirectory<br>        MatrixTrace(<br>                ignoreMethodMapFilePath = config.ignoreMethodMapFilePath,<br>                methodMapFilePath = config.methodMapFilePath,<br>                baseMethodMapPath = config.baseMethodMapPath,   <span class="hljs-comment">// 上一次插桩的 method mapping file，记录了已分配的 method id，插桩时要复用</span><br>                blockListFilePath = config.blockListFilePath,   <span class="hljs-comment">// 黑名单机制，忽略匹配的函数</span><br>                mappingDir = config.mappingDir                  <span class="hljs-comment">// Proguard mapping file</span><br>        ).doTransform(<br>                classInputs = inputFiles,<br>                changedFiles = changedFiles,<br>                isIncremental = isIncremental,<br>                traceClassDirectoryOutput = outputDirectory,<br>                inputToOutput = inputToOutput,<br>                legacyReplaceChangedFile = <span class="hljs-literal">null</span>,<br>                legacyReplaceFile = <span class="hljs-literal">null</span>)<br><br>        <span class="hljs-keyword">val</span> cost = System.currentTimeMillis() - start<br>        Log.i(TAG, <span class="hljs-string">&quot; Insert matrix trace instrumentations cost time: %sms.&quot;</span>, cost)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configure</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span>: Configuration &#123;<br>        <span class="hljs-keyword">val</span> buildDir = project.buildDir.absolutePath<br>        <span class="hljs-keyword">val</span> dirName = transformInvocation.context.variantName<br>        <span class="hljs-keyword">val</span> mappingOut = Joiner.on(File.separatorChar).join(<br>                buildDir,<br>                FD_OUTPUTS,<br>                <span class="hljs-string">&quot;mapping&quot;</span>,<br>                dirName)<br><br>        <span class="hljs-keyword">return</span> Configuration.Builder()<br>                .setBaseMethodMap(extension.baseMethodMapFile)<br>                .setBlockListFile(extension.blackListFile)<br>                .setMethodMapFilePath(<span class="hljs-string">&quot;<span class="hljs-variable">$mappingOut</span>/methodMapping.txt&quot;</span>)<br>                .setIgnoreMethodMapFilePath(<span class="hljs-string">&quot;<span class="hljs-variable">$mappingOut</span>/ignoreMethodMapping.txt&quot;</span>)<br>                .setMappingPath(mappingOut)<br>                .build()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h3><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> executor: ExecutorService = Executors.newFixedThreadPool(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">val</span> config = Configuration.Builder()<br>            .setIgnoreMethodMapFilePath(ignoreMethodMapFilePath)<br>            .setMethodMapFilePath(methodMapFilePath)<br>            .setBaseMethodMap(baseMethodMapPath)<br>            .setBlockListFile(blockListFilePath)<br>            .setMappingPath(mappingDir)<br>            .build()<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * step 1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">var</span> start = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> futures = LinkedList&lt;Future&lt;*&gt;&gt;()<br>    <span class="hljs-keyword">val</span> mappingCollector = MappingCollector()<br>    <span class="hljs-keyword">val</span> methodId = AtomicInteger(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">val</span> collectedMethodMap = ConcurrentHashMap&lt;String, TraceMethod&gt;()<br><br>    <span class="hljs-comment">// 在线程池里解析各种 mapping file</span><br>    futures.add(executor.submit(ParseMappingTask(<br>            mappingCollector, collectedMethodMap, methodId, config)))<br><br>    <span class="hljs-comment">// 在线程池里扫描 class dir 和 jar，将 Input 和 Output 映射好放在下面的两个 map 里</span><br>    <span class="hljs-keyword">val</span> dirInputOutMap = ConcurrentHashMap&lt;File, File&gt;()<br>    <span class="hljs-keyword">val</span> jarInputOutMap = ConcurrentHashMap&lt;File, File&gt;()<br>    <span class="hljs-keyword">for</span> (file <span class="hljs-keyword">in</span> classInputs) &#123;<br>        <span class="hljs-keyword">if</span> (file.isDirectory) &#123;<br>            futures.add(executor.submit(CollectDirectoryInputTask(<br>                    directoryInput = file,<br>                    mapOfChangedFiles = changedFiles,<br>                    mapOfInputToOutput = inputToOutput,<br>                    isIncremental = isIncremental,<br>                    traceClassDirectoryOutput = traceClassDirectoryOutput,<br>                    legacyReplaceChangedFile = legacyReplaceChangedFile,<br>                    legacyReplaceFile = legacyReplaceFile,<br>                    resultOfDirInputToOut = dirInputOutMap<br>            )))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">val</span> status = Status.CHANGED<br>            futures.add(executor.submit(CollectJarInputTask(<br>                    inputJar = file,<br>                    inputJarStatus = status,<br>                    inputToOutput = inputToOutput,<br>                    isIncremental = isIncremental,<br>                    traceClassFileOutput = traceClassDirectoryOutput,<br>                    legacyReplaceFile = legacyReplaceFile,<br>                    resultOfDirInputToOut = dirInputOutMap,<br>                    resultOfJarInputToOut = jarInputOutMap<br>            )))<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (future <span class="hljs-keyword">in</span> futures) &#123;<br>        future.<span class="hljs-keyword">get</span>()<br>    &#125;<br>    futures.clear()<br>    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(1)[Parse]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseMappingTask</span></span>(...) : Runnable &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        <span class="hljs-keyword">val</span> mappingFile = File(config.mappingDir, <span class="hljs-string">&quot;mapping.txt&quot;</span>)    <span class="hljs-comment">// 解析 Proguard mapping file</span><br>        <span class="hljs-keyword">if</span> (mappingFile.isFile) &#123;<br>            <span class="hljs-keyword">val</span> mappingReader = MappingReader(mappingFile)<br>            mappingReader.read(mappingCollector)<br>        &#125;<br>        <span class="hljs-keyword">val</span> size = config.parseBlockFile(mappingCollector)          <span class="hljs-comment">// 解析黑名单</span><br>        <span class="hljs-keyword">val</span> baseMethodMapFile = File(config.baseMethodMapPath)      <span class="hljs-comment">// 加载已分配 method id 的函数列表</span><br>        getMethodFromBaseMethod(baseMethodMapFile, collectedMethodMap)<br>        retraceMethodMap(mappingCollector, collectedMethodMap)<br>        Log.i(TAG, <span class="hljs-string">&quot;[ParseMappingTask#run] cost:%sms, black size:%s, collect %s method from %s&quot;</span>,<br>                System.currentTimeMillis() - start, size, collectedMethodMap.size, config.baseMethodMapPath)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="收集匹配的函数"><a href="#收集匹配的函数" class="headerlink" title="收集匹配的函数"></a>收集匹配的函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;<br>    <span class="hljs-comment">// ... step 2 在线程池里用 ASM 解析 class 并收集匹配的函数</span><br>    start = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> methodCollector = MethodCollector(executor, mappingCollector, methodId, config, collectedMethodMap)<br>    methodCollector.collect(dirInputOutMap.keys, jarInputOutMap.keys)<br>    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(2)[Collection]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 搜集匹配的函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> MethodCollector.collect(Set&lt;File&gt; srcFolderList, Set&lt;File&gt; dependencyJarList) <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (File srcFile : srcFolderList) &#123;                    <span class="hljs-comment">// 在 class 里收集匹配的函数</span><br>        ArrayList&lt;File&gt; classFileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (srcFile.isDirectory()) &#123;<br>            listClassFiles(classFileList, srcFile);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            classFileList.add(srcFile);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (File classFile : classFileList) &#123;<br>            futures.add(executor.submit(<span class="hljs-keyword">new</span> CollectSrcTask(classFile)));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (File jarFile : dependencyJarList) &#123;                <span class="hljs-comment">// 在 jar 包里收集匹配的函数</span><br>        futures.add(executor.submit(<span class="hljs-keyword">new</span> CollectJarTask(jarFile)));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Future future : futures) &#123;<br>        future.get();<br>    &#125;<br>    futures.clear();<br>    futures.add(executor.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            saveIgnoreCollectedMethod(mappingCollector);    <span class="hljs-comment">// 写入 ignored methods 到文件里</span><br>        &#125;<br>    &#125;));<br>    futures.add(executor.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            saveCollectedMethod(mappingCollector);          <span class="hljs-comment">// 将 method id -&gt; method 映射写入文件里</span><br>        &#125;<br>    &#125;));<br>    <span class="hljs-keyword">for</span> (Future future : futures) &#123;<br>        future.get();<br>    &#125;<br>    futures.clear();<br>&#125;<br><br><span class="hljs-comment">// 用 ASM Core API 解析并找到匹配的函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> CollectMethodNode.visitEnd() &#123;<br>    <span class="hljs-keyword">super</span>.visitEnd();<br>    TraceMethod traceMethod = TraceMethod.create(<span class="hljs-number">0</span>, access, className, name, desc);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>.equals(name)) &#123;<br>        isConstructor = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 过滤掉空函数、getter/setter 等，加入 ignored method file 里</span><br>    <span class="hljs-keyword">boolean</span> isNeedTrace = isNeedTrace(configuration, traceMethod.className, mappingCollector);<br>    <span class="hljs-keyword">if</span> ((isEmptyMethod() || isGetSetMethod() || isSingleMethod())<br>            &amp;&amp; isNeedTrace) &#123;<br>        ignoreCount.incrementAndGet();<br>        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 需要插桩的函数，如果没有 method id 则分配一个自增的 method id，加入 collectedMethodMap</span><br>    <span class="hljs-keyword">if</span> (isNeedTrace &amp;&amp; !collectedMethodMap.containsKey(traceMethod.getMethodName())) &#123;<br>        traceMethod.id = methodId.incrementAndGet();<br>        collectedMethodMap.put(traceMethod.getMethodName(), traceMethod);<br>        incrementCount.incrementAndGet();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isNeedTrace &amp;&amp; !collectedIgnoreMethodMap.containsKey(traceMethod.className)) &#123;<br>        ignoreCount.incrementAndGet();<br>        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Jar 包则用 ZipFile API 遍历，依然用 ASM 解析</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectJarTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        ZipFile zipFile = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zipFile = <span class="hljs-keyword">new</span> ZipFile(fromJar);<br>            Enumeration&lt;? extends ZipEntry&gt; enumeration = zipFile.entries();<br>            <span class="hljs-keyword">while</span> (enumeration.hasMoreElements()) &#123;<br>                ZipEntry zipEntry = enumeration.nextElement();<br>                String zipEntryName = zipEntry.getName();<br>                <span class="hljs-keyword">if</span> (isNeedTraceFile(zipEntryName)) &#123;<br>                    InputStream inputStream = zipFile.getInputStream(zipEntry);<br>                    ClassReader classReader = <span class="hljs-keyword">new</span> ClassReader(inputStream);<br>                    ClassWriter classWriter = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);<br>                    ClassVisitor visitor = <span class="hljs-keyword">new</span> TraceClassAdapter(Opcodes.ASM5, classWriter);<br>                    classReader.accept(visitor, <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="执行插桩操作"><a href="#执行插桩操作" class="headerlink" title="执行插桩操作"></a>执行插桩操作</h3><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;<br>    <span class="hljs-comment">// ... step 3 执行插桩操作</span><br>    start = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> methodTracer = MethodTracer(executor, mappingCollector, config, methodCollector.collectedMethodMap, methodCollector.collectedClassExtendMap)<br>    methodTracer.trace(dirInputOutMap, jarInputOutMap)<br>    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(3)[Trace]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> MethodTracer.trace(Map&lt;File, File&gt; srcFolderList, Map&lt;File, File&gt; dependencyJarList) <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    traceMethodFromSrc(srcFolderList, futures);     <span class="hljs-comment">// 处理 class</span><br>    traceMethodFromJar(dependencyJarList, futures); <span class="hljs-comment">// 处理 jar</span><br>    <span class="hljs-keyword">for</span> (Future future : futures) &#123;<br>        future.get();<br>    &#125;<br>    futures.clear();<br>&#125;<br><br><span class="hljs-comment">// 一个线程处理一个 class/dir </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traceMethodFromSrc</span><span class="hljs-params">(Map&lt;File, File&gt; srcMap, List&lt;Future&gt; futures)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != srcMap) &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;File, File&gt; entry : srcMap.entrySet()) &#123;<br>            futures.add(executor.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; innerTraceMethodFromSrc(entry.getKey(), entry.getValue()); &#125;<br>            &#125;));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">innerTraceMethodFromSrc</span><span class="hljs-params">(File input, File output)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 依然是 ASM 里 classReader，classWriter 和 classVisitor 的经典用法</span><br>    is = <span class="hljs-keyword">new</span> FileInputStream(classFile);<br>    ClassReader classReader = <span class="hljs-keyword">new</span> ClassReader(is);<br>    ClassWriter classWriter = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);<br>    ClassVisitor classVisitor = <span class="hljs-keyword">new</span> TraceClassAdapter(Opcodes.ASM5, classWriter);   <span class="hljs-comment">// 重要的类</span><br>    classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> MethodVisitor TraceClassAdapter.visitMethod(<span class="hljs-keyword">int</span> access, String name, String desc,<br>                                 String signature, String[] exceptions) &#123;<br>    <span class="hljs-keyword">if</span> (isABSClass) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasWindowFocusMethod) &#123;    <span class="hljs-comment">// 匹配 Activity.onWindowFocusChanged，做页面打开速度统计</span><br>            hasWindowFocusMethod = MethodCollector.isWindowFocusChangeMethod(name, desc);<br>        &#125;<br>        MethodVisitor methodVisitor = cv.visitMethod(access, name, desc, signature, exceptions);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TraceMethodAdapter(api, methodVisitor, access, name, desc, <span class="hljs-keyword">this</span>.className,<br>                hasWindowFocusMethod, isActivityOrSubClass, isNeedTrace);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 匹配 Activity.onWindowFocusChanged(boolean hasFocus)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD = <span class="hljs-string">&quot;onWindowFocusChanged&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS = <span class="hljs-string">&quot;(Z)V&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWindowFocusChangeMethod</span><span class="hljs-params">(String name, String desc)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> != name &amp;&amp; <span class="hljs-keyword">null</span> != desc &amp;&amp; name.equals(TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD) <br>        &amp;&amp; desc.equals(TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> TraceClassAdapter.visitEnd() &#123;<br>    <span class="hljs-keyword">if</span> (!hasWindowFocusMethod &amp;&amp; isActivityOrSubClass &amp;&amp; isNeedTrace) &#123;<br>        insertWindowFocusChangeMethod(cv, className);<br>    &#125;<br>    <span class="hljs-keyword">super</span>.visitEnd();<br>&#125;<br><br><span class="hljs-comment">// 如果 Activity 没有覆盖 onWindowFocusChanged 则覆盖之（需要在里面插桩统计页面打开速度）</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertWindowFocusChangeMethod</span><span class="hljs-params">(ClassVisitor cv, String classname)</span> </span>&#123;<br>    MethodVisitor methodVisitor = cv.visitMethod(Opcodes.ACC_PUBLIC, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD,<br>            TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    methodVisitor.visitCode();<br>    methodVisitor.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number">0</span>);<br>    methodVisitor.visitVarInsn(Opcodes.ILOAD, <span class="hljs-number">1</span>);<br>    methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, TraceBuildConstants.MATRIX_TRACE_ACTIVITY_CLASS, <br>        TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS, <span class="hljs-keyword">false</span>);<br>    traceWindowFocusChangeMethod(methodVisitor, classname);<br>    methodVisitor.visitInsn(Opcodes.RETURN);<br>    methodVisitor.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    methodVisitor.visitEnd();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraceMethodAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AdviceAdapter</span> </span>&#123;<br>    <span class="hljs-comment">// 进入函数后先执行 MethodBeat.i</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMethodEnter</span><span class="hljs-params">()</span> </span>&#123;<br>        TraceMethod traceMethod = collectedMethodMap.get(methodName);<br>        <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-keyword">null</span>) &#123;<br>            traceMethodCount.incrementAndGet();<br>            mv.visitLdcInsn(traceMethod.id);<br>            mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">// 在 onWindowFocusChanged 插入 AppMethodBeat.at</span><br>            <span class="hljs-keyword">if</span> (checkNeedTraceWindowFocusChangeMethod(traceMethod)) &#123;<br>                traceWindowFocusChangeMethod(mv, className);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 退出函数前，执行 MethodBeat.o</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMethodExit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> opcode)</span> </span>&#123;<br>        TraceMethod traceMethod = collectedMethodMap.get(methodName);<br>        <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-keyword">null</span>) &#123;<br>            traceMethodCount.incrementAndGet();<br>            mv.visitLdcInsn(traceMethod.id);<br>            mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// jar 包一样的，只不过用的 ZipFile API 那套 ...</span><br></code></pre></div></td></tr></table></figure><h3 id="收集函数执行耗时"><a href="#收集函数执行耗时" class="headerlink" title="收集函数执行耗时"></a>收集函数执行耗时</h3><p>用一个 <code>long</code> 记录 <code>i/o</code> 函数调用，高位第一位表示是 <code>i</code> 函数还是 <code>o</code> 函数，后续 20 位存储 <code>method id</code>，低位 43 位存储 <em>相对时间戳</em>；运行时分配一个 100W 长度的 long 数组（占内存 7.6M）来存储，从索引 0 开始逐步递增到数组尾部，满了又从索引 0 开始，会覆盖旧数据，但因为 100W 足够大，用来收集栈帧执行时间足够了</p><blockquote><p>编译期已经对全局的函数进行插桩，在运行期间每个函数的执行前后都会调用 MethodBeat.i/o 的方法，如果是在主线程中执行，则在函数的执行前后获取当前距离 MethodBeat 模块初始化的时间 offset（为了压缩数据，存进一个long类型变量中），并将当前执行的是 MethodBeat i或者o、mehtod id 及时间 offset，存放到一个 long 类型变量中，记录到一个预先初始化好的数组 long[] 中 index 的位置（预先分配记录数据的 buffer 长度为 100w，内存占用约 7.6M）。</p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/run_store.jpg" alt="long buffer"></p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/stack.jpg" alt="summary func cast"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录函数的开始时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.i(<span class="hljs-keyword">int</span> methodId) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (threadId == sMainThreadId) &#123;                <span class="hljs-comment">// 只关心主线程的慢函数，其他线程不记录</span><br>        <span class="hljs-keyword">if</span> (assertIn) &#123;                             <span class="hljs-comment">// 防止重入</span><br>            android.util.Log.e(TAG, <span class="hljs-string">&quot;ERROR!!! AppMethodBeat.i Recursive calls!!!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        assertIn = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;       <span class="hljs-comment">// buffer 满了则重头开始，会覆盖掉旧数据</span><br>            mergeData(methodId, sIndex, <span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sIndex = <span class="hljs-number">0</span>;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">true</span>);<br>        &#125;<br>        ++sIndex;<br>        assertIn = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 插入 buffer</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.mergeData(<span class="hljs-keyword">int</span> methodId, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">boolean</span> isIn) &#123;<br>    <span class="hljs-keyword">if</span> (methodId == AppMethodBeat.METHOD_ID_DISPATCH) &#123;<br>        sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;<br>    &#125;<br>    <span class="hljs-keyword">long</span> trueId = <span class="hljs-number">0L</span>;                               <span class="hljs-comment">// 构造函数执行时间戳，第一位表示 i/o 操作</span><br>    <span class="hljs-keyword">if</span> (isIn) &#123;<br>        trueId |= <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">63</span>;<br>    &#125;<br>    trueId |= (<span class="hljs-keyword">long</span>) methodId &lt;&lt; <span class="hljs-number">43</span>;                <span class="hljs-comment">// 后续 20 位存储 method id</span><br>    trueId |= sCurrentDiffTime &amp; <span class="hljs-number">0x7FFFFFFFFFFL</span>;    <span class="hljs-comment">// 低 43 位存储相对时间戳</span><br>    sBuffer[index] = trueId;<br>    checkPileup(index);<br>    sLastIndex = index;<br>&#125;<br><span class="hljs-comment">// 记录函数的结束时间，跟上面是一样的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.o(<span class="hljs-keyword">int</span> methodId) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread().getId() == sMainThreadId) &#123;<br>        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sIndex = <span class="hljs-number">0</span>;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">false</span>);<br>        &#125;<br>        ++sIndex;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>值得注意的是，因为只有低 43 位存储时间戳，如果存储完整的时间戳那是不足的，而且在分析函数执行耗时用的是 duration = end - start，实际上不需要完整的时间戳，所以这里记录的是相对时间戳（<code>sCurrentDiffTime</code>）；而且为了性能，不在 <code>i/o</code> 函数里执行 <code>SystemClock.uptimeMillis()</code></p><p><code>sDiffTime</code> 记录加载类 <code>AppMethodBeat</code> 的时间戳，然后会起一个线程每隔 5ms 更新一次 <code>sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime</code></p><blockquote><p>另外，考虑到每个方法执行前后都获取系统时间（System.nanoTime）会对性能影响比较大，而实际上，单个函数执行耗时小于 5ms 的情况，对卡顿来说不是主要原因，可以忽略不计，如果是多次调用的情况，则在它的父级方法中可以反映出来，所以为了减少对性能的影响，通过另一条更新时间的线程每 5ms 去更新一个时间变量，而每个方法执行前后只读取该变量来减少性能损耗。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runnable sUpdateDiffTimeRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!isPauseUpdateTime &amp;&amp; status &gt; STATUS_STOPPED) &#123;<br>                    sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;<br>                    SystemClock.sleep(Constants.TIME_UPDATE_CYCLE_MS);<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (updateTimeLock) &#123;<br>                    updateTimeLock.wait();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            MatrixLog.e(TAG, <span class="hljs-string">&quot;&quot;</span> + e.toString());<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="上报耗时-Message"><a href="#上报耗时-Message" class="headerlink" title="上报耗时 Message"></a>上报耗时 <code>Message</code></h2><p>上面说过可以用一个 <code>long</code> 表示函数开始/结束的相对时间戳，然后存储在一个 100M 大小的数组里，插入索引会从 0 不断增长，到达 100M 后重置为 0</p><p>遇到耗时 <code>Message</code> 时，需要裁剪出有效的函数执行时间记录，所以在处理 <code>Message</code> 开始前先把索引记下来 <code>start</code>，处理完后从 <code>start</code> 到当前索引 <code>end</code> 之间就是这个 <code>Message</code> 的调用栈耗时记录</p><p>要注意的是索引到尾部后会重置为 0，所以要区分 <code>start</code> 和 <code>end</code> 大小关系；当 <code>start &lt; end</code> 取 <code>[start, end]</code>，当 <code>start &gt; end</code> 取 <code>[start,] + [0, end]</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvilMethodTracer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchBegin</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> token)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.dispatchBegin(beginNs, cpuBeginMs, token);<br>        indexRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;EvilMethodTracer#dispatchBegin&quot;</span>);  <span class="hljs-comment">// 把当前索引记下来</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">long</span> cpuEndMs, <span class="hljs-keyword">long</span> token, <span class="hljs-keyword">boolean</span> isVsyncFrame)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.dispatchEnd(beginNs, cpuBeginMs, endNs, cpuEndMs, token, isVsyncFrame);<br>        <span class="hljs-keyword">long</span> dispatchCost = (endNs - beginNs) / Constants.TIME_MILLIS_TO_NANO;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;<br>                <span class="hljs-keyword">long</span>[] data = AppMethodBeat.getInstance().copyData(indexRecord);    <span class="hljs-comment">// 裁剪出从开始索引到当前索引间的数据</span><br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125; ...<br>    &#125;    <br>&#125;<br><br><span class="hljs-comment">// 裁剪函数执行耗时，注意区分 start &lt; end 和 start &gt; end 两种情况</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppMethodBeat</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span>[] copyData(IndexRecord startRecord) &#123;<br>        <span class="hljs-keyword">return</span> copyData(startRecord, <span class="hljs-keyword">new</span> IndexRecord(sIndex - <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] copyData(IndexRecord startRecord, IndexRecord endRecord) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">long</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> length;<br>        <span class="hljs-keyword">int</span> start = Math.max(<span class="hljs-number">0</span>, startRecord.index);<br>        <span class="hljs-keyword">int</span> end = Math.max(<span class="hljs-number">0</span>, endRecord.index);<br>        <span class="hljs-keyword">if</span> (end &gt; start) &#123;<br>            length = end - start + <span class="hljs-number">1</span>;<br>            data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[length];<br>            System.arraycopy(sBuffer, start, data, <span class="hljs-number">0</span>, length);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end &lt; start) &#123;<br>            length = <span class="hljs-number">1</span> + end + (sBuffer.length - start);<br>            data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[length];<br>            System.arraycopy(sBuffer, start, data, <span class="hljs-number">0</span>, sBuffer.length - start);<br>            System.arraycopy(sBuffer, <span class="hljs-number">0</span>, data, sBuffer.length - start, end + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="上报-ANR"><a href="#上报-ANR" class="headerlink" title="上报 ANR"></a>上报 ANR</h2><p>在 <a href="../../../../2020/10/20/anr/">阅读源码系列：ANR 是怎么产生的</a> 说过，ANR 是因为没有及时消费 <code>MotionEvent</code>，超过 5s 后由 AMS 弹出的对话框</p><p>弹出 ANR 对话框的 <code>Runnable</code> 是在分发 <code>MotionEvent</code> 时放下的一个延时炸弹（<code>Handler.postDelayed</code>），如果 <code>MotionEvent</code> 在 5s 内被消费则炸弹被移除（<code>Handler.removeCallbacks</code>）</p><p>我们在 <code>Message</code> 执行前有钩子函数 <code>dispatchBegin</code>，那也可以学习 ANR 放入报告函数（注意是放在子线程的消息队列里，不然在主线程里还没执行就被 ANR 对话框杀掉了），延时 5s，然后在 <code>dispatchEnd</code> 里移除，如果主线程的 <code>Message</code> 超过 5s 未执行完，那极有可能触发 ANR，于是收集调用堆栈及耗时信息上报给服务器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnrTracer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchBegin</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> token)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.dispatchBegin(beginNs, cpuBeginMs, token);<br><br>        anrTask.beginRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;AnrTracer#dispatchBegin&quot;</span>);     <span class="hljs-comment">// 记下调用堆栈的索引</span><br>        anrTask.token = token;<br><br>        <span class="hljs-keyword">if</span> (traceConfig.isDevEnv()) &#123;<br>            MatrixLog.v(TAG, <span class="hljs-string">&quot;* [dispatchBegin] token:%s index:%s&quot;</span>, token, anrTask.beginRecord.index);<br>        &#125;<br>        <span class="hljs-keyword">long</span> cost = (System.nanoTime() - token) / Constants.TIME_MILLIS_TO_NANO;<br>        anrHandler.postDelayed(anrTask, Constants.DEFAULT_ANR - cost);                              <span class="hljs-comment">// 在子线程埋下延时 5s 的“炸弹”</span><br>        lagHandler.postDelayed(lagTask, Constants.DEFAULT_NORMAL_LAG - cost);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginNs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> endNs, <span class="hljs-keyword">long</span> cpuEndMs, <span class="hljs-keyword">long</span> token, <span class="hljs-keyword">boolean</span> isBelongFrame)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.dispatchEnd(beginNs, cpuBeginMs, endNs, cpuEndMs, token, isBelongFrame);<br>        <span class="hljs-comment">// ... 及时移除“炸弹”</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != anrTask) &#123;<br>            anrTask.getBeginRecord().release();<br>            anrHandler.removeCallbacks(anrTask);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != lagTask) &#123;<br>            lagHandler.removeCallbacks(lagTask);<br>        &#125;<br>    &#125;    <br>&#125;<br><br><span class="hljs-comment">// 收集调用栈帧及其耗时、INPUUT/ANIMATION/TRAVERSAL 耗时、线程及进程信息等</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnrHandleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> curTime = SystemClock.uptimeMillis();<br>        <span class="hljs-keyword">boolean</span> isForeground = isForeground();<br>        <span class="hljs-comment">// process</span><br>        <span class="hljs-keyword">int</span>[] processStat = Utils.getProcessPriority(Process.myPid());<br>        <span class="hljs-keyword">long</span>[] data = AppMethodBeat.getInstance().copyData(beginRecord);<br>        beginRecord.release();<br>        String scene = AppMethodBeat.getVisibleScene();<br>        <span class="hljs-comment">// memory</span><br>        <span class="hljs-keyword">long</span>[] memoryInfo = dumpMemory();<br>        <span class="hljs-comment">// Thread state</span><br>        Thread.State status = Looper.getMainLooper().getThread().getState();<br>        StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();<br>        String dumpStack = Utils.getStack(stackTrace, <span class="hljs-string">&quot;|*\t\t&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-comment">// frame</span><br>        UIThreadMonitor monitor = UIThreadMonitor.getMonitor();<br>        <span class="hljs-keyword">long</span> inputCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_INPUT, token);<br>        <span class="hljs-keyword">long</span> animationCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_ANIMATION, token);<br>        <span class="hljs-keyword">long</span> traversalCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_TRAVERSAL, token);<br>        <span class="hljs-comment">// trace</span><br>        LinkedList&lt;MethodItem&gt; stack = <span class="hljs-keyword">new</span> LinkedList();<br>        <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span>) &#123;<br>            TraceDataUtils.structuredDataToStack(data, stack, <span class="hljs-keyword">true</span>, curTime);<br>            TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, <span class="hljs-keyword">new</span> TraceDataUtils.IStructuredDataFilter() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> during, <span class="hljs-keyword">int</span> filterCount)</span> </span>&#123;<br>                    <span class="hljs-keyword">return</span> during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS;<br>                &#125;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFilterMaxCount</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">return</span> Constants.FILTER_STACK_MAX_COUNT;<br>                &#125;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>                    MatrixLog.w(TAG, <span class="hljs-string">&quot;[fallback] size:%s targetSize:%s stack:%s&quot;</span>, size, Constants.TARGET_EVIL_METHOD_STACK, stack);<br>                    Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK));<br>                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                        iterator.next();<br>                        iterator.remove();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        StringBuilder reportBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        StringBuilder logcatBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">long</span> stackCost = Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder));<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="统计-APP-amp-页面启动耗时"><a href="#统计-APP-amp-页面启动耗时" class="headerlink" title="统计 APP &amp; 页面启动耗时"></a>统计 APP &amp; 页面启动耗时</h2><p>包括 <code>Application</code> 执行耗时、首屏启动耗时、冷/热启动耗时、页面启动耗时，它们之间的关系如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * firstMethod.i       LAUNCH_ACTIVITY   onWindowFocusChange   LAUNCH_ACTIVITY    onWindowFocusChange</span><br><span class="hljs-comment"> * ^                         ^                   ^                     ^                  ^</span><br><span class="hljs-comment"> * |                         |                   |                     |                  |</span><br><span class="hljs-comment"> * |---------app---------|---|---firstActivity---|---------...---------|---careActivity---|</span><br><span class="hljs-comment"> * |&lt;--applicationCost--&gt;|</span><br><span class="hljs-comment"> * |&lt;--------------firstScreenCost--------------&gt;|</span><br><span class="hljs-comment"> * |&lt;---------------------------------------coldCost-------------------------------------&gt;|</span><br><span class="hljs-comment"> * .                         |&lt;-----warmCost----&gt;|</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="Application-执行耗时"><a href="#Application-执行耗时" class="headerlink" title="Application 执行耗时"></a><code>Application</code> 执行耗时</h3><p>有了上面的插桩，通过给 <code>Application.attachBaseContext</code> 插桩，也就是第一次执行 <code>AppMethodBeat.i</code> 的时候，可以拿到 <code>eggBrokenTime</code> 作为 APP 启动时间</p><p>这里解释下为什么不在 <code>Application</code> 构造函数里插桩并作为 APP 启动时间，那是因为 APP 有冷启动/热启动的概念，冷启动下 fork app process 并构造 <code>Application</code> 实例，此时算出的启动时间是正确的；但如果是热启动，<code>Application</code> 实例并没有销毁也不会执行构造函数，而是直接走 <code>onCreate</code> 函数，此时在构造函数里插桩就无法捕获到正确的启动时间了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppMethodBeat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-keyword">int</span> methodId)</span> </span>&#123;<br>        <span class="hljs-comment">// ... 第一次执行 AppMethodBeat.i 时</span><br>        <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;<br>            <span class="hljs-keyword">synchronized</span> (statusLock) &#123;<br>                <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;<br>                    realExecute();<br>                    status = STATUS_READY;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">realExecute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        ActivityThreadHacker.hackSysHandlerCallback();<br>        <span class="hljs-comment">/// ...</span><br>    &#125;        <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityThreadHacker</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> sApplicationCreateBeginTime = <span class="hljs-number">0L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getEggBrokenTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ActivityThreadHacker.sApplicationCreateBeginTime;<br>    &#125;    <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hackSysHandlerCallback</span><span class="hljs-params">()</span> </span>&#123;<br>        sApplicationCreateBeginTime = SystemClock.uptimeMillis();   <span class="hljs-comment">// 记录 Application 的创建时间</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化 <code>Application</code> 后启动第一个 <code>Activity</code>/<code>Service</code>/<code>BroadcastReceiver</code> 的时刻作为 <code>Application</code> 初始化的完结时间（为啥没有 <code>ContentProvider</code> 呢？因为它是在 <code>onCreate</code> 之前启动的，see <a href="../../../../2021/04/12/leakcanary/">LeakCanary 浅析</a>）</p><p>上述三大组件的启动会通过主线程的消息队列在 <code>ActivityThread.mH</code> 里执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CREATE_SERVICE          = <span class="hljs-number">114</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RECEIVER                = <span class="hljs-number">113</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RELAUNCH_ACTIVITY       = <span class="hljs-number">160</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXECUTE_TRANSACTION     = <span class="hljs-number">159</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">case</span> CREATE_SERVICE:<br>                <span class="hljs-keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;<br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,<br>                            (<span class="hljs-string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));<br>                &#125;<br>                handleCreateService((CreateServiceData)msg.obj);<br>                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">case</span> RECEIVER:<br>                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;broadcastReceiveComp&quot;</span>);<br>                handleReceiver((ReceiverData)msg.obj);<br>                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> RELAUNCH_ACTIVITY:<br>                handleRelaunchActivityLocally((IBinder) msg.obj);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>                <span class="hljs-keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;<br>                mTransactionExecutor.execute(transaction);<br>                <span class="hljs-keyword">if</span> (isSystem()) &#123;<br>                    <span class="hljs-comment">// Client transactions inside system process are recycled on the client side</span><br>                    <span class="hljs-comment">// instead of ClientLifecycleManager to avoid being cleared before this</span><br>                    <span class="hljs-comment">// message is handled.</span><br>                    transaction.recycle();<br>                &#125;<br>                <span class="hljs-comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span><br>                <span class="hljs-keyword">break</span>;<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Activity 生命周期是通过 LaunchActivityItem/StartActivityItem/ResumeActivityItem/... 执行</span><br></code></pre></div></td></tr></table></figure><p>所以 <code>TraceCanary</code> 选择在第一次执行 <code>AppMethodBeat.i</code> 时，替换 <code>ActivityThread.sCurrentActivityThread.mH.mCallback</code>，在 <code>Handler.Callback.handleMessage(msg)</code> 里监听第一次启动 <code>Activity</code>/<code>Service</code>/<code>BroadcastReceiver</code> 的时刻作为 <code>Application</code> 初始化的结束点</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 第一次执行时</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.i(<span class="hljs-keyword">int</span> methodId) &#123;<br>    <span class="hljs-keyword">if</span> (status &lt;= STATUS_STOPPED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (methodId &gt;= METHOD_ID_MAX) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;<br>        <span class="hljs-keyword">synchronized</span> (statusLock) &#123;<br>            <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;<br>                realExecute();<br>                status = STATUS_READY;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 替换 Handler.Callback</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.realExecute() &#123;<br>    <span class="hljs-comment">// ...</span><br>    ActivityThreadHacker.hackSysHandlerCallback();<br>    LooperMonitor.register(looperMonitorListener);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ActivityThreadHacker.hackSysHandlerCallback() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        sApplicationCreateBeginTime = SystemClock.uptimeMillis();<br>        sApplicationCreateBeginMethodIndex = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;ApplicationCreateBeginMethodIndex&quot;</span>);<br>        Class&lt;?&gt; forName = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);<br>        Field field = forName.getDeclaredField(<span class="hljs-string">&quot;sCurrentActivityThread&quot;</span>);<br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object activityThreadValue = field.get(forName);<br>        Field mH = forName.getDeclaredField(<span class="hljs-string">&quot;mH&quot;</span>);<br>        mH.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object handler = mH.get(activityThreadValue);<br>        Class&lt;?&gt; handlerClass = handler.getClass().getSuperclass();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != handlerClass) &#123;<br>            Field callbackField = handlerClass.getDeclaredField(<span class="hljs-string">&quot;mCallback&quot;</span>);<br>            callbackField.setAccessible(<span class="hljs-keyword">true</span>);<br>            Handler.Callback originalCallback = (Handler.Callback) callbackField.get(handler);<br>            HackCallback callback = <span class="hljs-keyword">new</span> HackCallback(originalCallback);<br>            callbackField.set(handler, callback);<br>        &#125;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;hook system handler completed. start:%s SDK_INT:%s&quot;</span>, sApplicationCreateBeginTime, Build.VERSION.SDK_INT);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        MatrixLog.e(TAG, <span class="hljs-string">&quot;hook system handler err! %s&quot;</span>, e.getCause().toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 记录时间点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> HackCallback.handleMessage(Message msg) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">boolean</span> isLaunchActivity = isLaunchActivity(msg);<br>    <span class="hljs-keyword">if</span> (hasPrint &gt; <span class="hljs-number">0</span>) &#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;[handleMessage] msg.what:%s begin:%s isLaunchActivity:%s SDK_INT=%s&quot;</span>, msg.what, SystemClock.uptimeMillis()isLaunchActivity, Build.VERSION.SDK_INT);<br>        hasPrint--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCreated) &#123;<br>        <span class="hljs-keyword">if</span> (isLaunchActivity || msg.what == CREATE_SERVICE<br>                || msg.what == RECEIVER) &#123; <span class="hljs-comment">// todo for provider</span><br>            ActivityThreadHacker.sApplicationCreateEndTime = SystemClock.uptimeMillis();<br>            ActivityThreadHacker.sApplicationCreateScene = msg.what;<br>            isCreated = <span class="hljs-keyword">true</span>;<br>            sIsCreatedByLaunchActivity = isLaunchActivity;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;application create end, sApplicationCreateScene:%d, isLaunchActivity:%s&quot;</span>, msg.what, isLaunchActivity);<br>            <span class="hljs-keyword">synchronized</span> (listeners) &#123;<br>                <span class="hljs-keyword">for</span> (IApplicationCreateListener listener : listeners) &#123;<br>                    listener.onApplicationCreateEnd();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="页面打开耗时"><a href="#页面打开耗时" class="headerlink" title="页面打开耗时"></a>页面打开耗时</h3><p>注册 <code>ActivityLifecycleCallbacks</code>，在 <code>onActivityCreated</code> 记录 <code>Activity</code> 的创建时间</p><p>在上面的插桩阶段，<code>AppMethodBeat.at(activity, isFocus)</code> 被添加到 <code>Activity.onWindowFocusChanged(hasFocus)</code> 的第一行代码，此时认为 <code>Activity</code> 获得焦点启动完毕（用户可见可交互），与 <code>Activity</code> 创建时间的差即为页面启动耗时</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartupTracer</span> </span>&#123;<br><br>    <span class="hljs-comment">// &quot;&#123;Activity全限定类名&#125;@&#123;activity.hashCode()&#125;&quot; -&gt; uptimeMillis</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;String, Long&gt; createdTimeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAlive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onAlive();<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;[onAlive] isStartupEnable:%s&quot;</span>, isStartupEnable);<br>        <span class="hljs-keyword">if</span> (isStartupEnable) &#123;<br>            AppMethodBeat.getInstance().addListener(<span class="hljs-keyword">this</span>);                              <span class="hljs-comment">// 添加 onWindowFocusChanged(hasFocus) 监视器</span><br>            Matrix.with().getApplication().registerActivityLifecycleCallbacks(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">// 注册 ActivityLifecycleCallbacks</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;activeActivityCount:%d, coldCost:%d&quot;</span>, activeActivityCount, coldCost);<br>        <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;<br>            lastCreateActivity = uptimeMillis();<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;lastCreateActivity:%d, activity:%s&quot;</span>, lastCreateActivity, activity.getClass().getName());<br>            isWarmStartUp = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        activeActivityCount++;<br>        <span class="hljs-keyword">if</span> (isShouldRecordCreateTime) &#123;<br>            createdTimeMap.put(activity.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode(), uptimeMillis());  <span class="hljs-comment">// 记录 Activity 创建时间</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当 Activity.onWindowFocusChanged(hasFocus) hasFocus == true 时被调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityFocused</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ActivityThreadHacker.sApplicationCreateScene == Integer.MIN_VALUE) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;start up from unknown scene&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        String activityName = activity.getClass().getName();<br>        <span class="hljs-keyword">if</span> (isColdStartup()) &#123;<br>            <span class="hljs-keyword">boolean</span> isCreatedByLaunchActivity = ActivityThreadHacker.isCreatedByLaunchActivity();<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;#ColdStartup# activity:%s, splashActivities:%s, empty:%b, &quot;</span><br>                            + <span class="hljs-string">&quot;isCreatedByLaunchActivity:%b, hasShowSplashActivity:%b, &quot;</span><br>                            + <span class="hljs-string">&quot;firstScreenCost:%d, now:%d, application_create_begin_time:%d, app_cost:%d&quot;</span>,<br>                    activityName, splashActivities, splashActivities.isEmpty(), isCreatedByLaunchActivity,<br>                    hasShowSplashActivity, firstScreenCost, uptimeMillis(),<br>                    ActivityThreadHacker.getEggBrokenTime(), ActivityThreadHacker.getApplicationCost());<br><br>            String key = activityName + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode();<br>            Long createdTime = createdTimeMap.get(key);<br>            <span class="hljs-keyword">if</span> (createdTime == <span class="hljs-keyword">null</span>) &#123;<br>                createdTime = <span class="hljs-number">0L</span>;<br>            &#125;<br>            createdTimeMap.put(key, uptimeMillis() - createdTime);      <span class="hljs-comment">// 页面启动耗时</span><br>            <span class="hljs-comment">// ...</span><br>    &#125;    <br>&#125;<br><br><span class="hljs-comment">// 当进入 Activity.onWindowFocusChanged(hasFocus) 函数时首先会执行此函数</span><br>AppMethodBeat.at(Activity activity, <span class="hljs-keyword">boolean</span> isFocus) &#123;<br>    String activityName = activity.getClass().getName();<br>    <span class="hljs-keyword">if</span> (isFocus) &#123;<br>        <span class="hljs-keyword">if</span> (sFocusActivitySet.add(activityName)) &#123;<br>            <span class="hljs-keyword">synchronized</span> (listeners) &#123;<br>                <span class="hljs-keyword">for</span> (IAppMethodBeatListener listener : listeners) &#123;<br>                    listener.onActivityFocused(activity);<br>                &#125;<br>            &#125;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;[at] visibleScene[%s] has %s focus!&quot;</span>, getVisibleScene(), <span class="hljs-string">&quot;attach&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (sFocusActivitySet.remove(activityName)) &#123;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;[at] visibleScene[%s] has %s focus!&quot;</span>, getVisibleScene(), <span class="hljs-string">&quot;detach&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="首屏打开耗时"><a href="#首屏打开耗时" class="headerlink" title="首屏打开耗时"></a>首屏打开耗时</h3><p>首屏启动耗时（<code>firstScreenCost</code>） = 第一个页面（splash activity）接收到焦点的时间 - <code>eggBrokenTime</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartupTracer</span> </span>&#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityFocused</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>        <span class="hljs-comment">// ... 记录首屏启动耗时</span><br>        <span class="hljs-keyword">if</span> (firstScreenCost == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.firstScreenCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="冷启动和热启动耗时"><a href="#冷启动和热启动耗时" class="headerlink" title="冷启动和热启动耗时"></a>冷启动和热启动耗时</h3><p>当打开一个 <code>Activity</code> 时，如果 app process 不存在则需要通过 <code>zygote</code> 进程 <code>fork</code> 出 app process，实例化并执行 <code>Application.onCreate</code> 后再启动 <code>Activity</code>，这叫做 <strong>冷启动</strong>；APP 退出后，系统在内存充足的情况下并不会立刻销毁 app process，重新打开 APP 虽然会走 <code>Application.onCreate</code> 再打开 <code>Activity</code>，但这个 <code>Application</code> 实例并没有销毁（实际上是 JVM 没有被销毁），这叫 <strong>热启动</strong></p><p>怎么判断是冷启动还是热启动呢？既然 JVM 没有销毁，那么类的静态成员变量作为 <code>GC ROOT</code> 就会一直存在于内存中，判断它有没初始化即可知道是冷启动还是热启动，实际上 <code>Matrix</code> 就是这么做的，它的 <code>GC ROOT PATH</code> 是：</p><p><code>Matrix.sInstance</code> -&gt; <code>HashSet&lt;Plugin&gt; plugins</code> -&gt; <code>TracePlugin</code> -&gt; <code>StartupTracer</code> -&gt; <code>coldCost</code></p><p><code>StartupTracer.coldCost</code> 会在 <code>StartupTracer.onActivityFocused</code> 被初始化（&gt; 0），初始化时如果遇到 <code>StartupTracer.coldCost</code> == 0 则是冷启动；跟我想的不太一样的是，我认为冷启动耗时是从 <code>eggBrokenTime</code> 到第一个页面（splash activity）打开的时间，而 <code>TraceCanary</code> 计算的是到第二个页面（splash activity 之后的第一个页面）打开的时间</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityFocused(Activity activity) &#123;<br>    <span class="hljs-comment">// ... coldCost == 0 冷启动</span><br>    <span class="hljs-keyword">if</span> (isColdStartup()) &#123;                                             <br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">if</span> (hasShowSplashActivity) &#123;<br>            coldCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (splashActivities.contains(activityName)) &#123;<br>                hasShowSplashActivity = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (splashActivities.isEmpty()) &#123;            <span class="hljs-comment">// process which is has activity but not main UI process</span><br>                <span class="hljs-keyword">if</span> (isCreatedByLaunchActivity) &#123;<br>                    coldCost = firstScreenCost;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    firstScreenCost = <span class="hljs-number">0</span>;<br>                    coldCost = ActivityThreadHacker.getApplicationCost();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isCreatedByLaunchActivity) &#123;<br>                    coldCost = firstScreenCost;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    firstScreenCost = <span class="hljs-number">0</span>;<br>                    coldCost = ActivityThreadHacker.getApplicationCost();<br>                &#125;<br>            &#125;<br>        &#125;   <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面说过冷启动耗时是到第二个页面打开的时间，那如果在第一个页面打开时 <code>coldCost</code> &gt; 0 说明 JVM 没有销毁，是热启动（<code>isWarmStartUp</code>），热启动耗时相当于第一个页面的打开耗时</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartupTracer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastCreateActivity = <span class="hljs-number">0L</span>;   <span class="hljs-comment">// 当前/上一个 Activity.onCreate 的时间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;activeActivityCount:%d, coldCost:%d&quot;</span>, activeActivityCount, coldCost);<br>        <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;<br>            lastCreateActivity = uptimeMillis();<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;lastCreateActivity:%d, activity:%s&quot;</span>, lastCreateActivity, activity.getClass().getName());<br>            isWarmStartUp = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        activeActivityCount++;<br>        <span class="hljs-keyword">if</span> (isShouldRecordCreateTime) &#123;<br>            createdTimeMap.put(activity.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode(), uptimeMillis());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityFocused(Activity activity) &#123;<br>        <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWarmStartUp()) &#123;<br>            isWarmStartUp = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">long</span> warmCost = uptimeMillis() - lastCreateActivity;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;#WarmStartup# activity:%s, warmCost:%d, now:%d, lastCreateActivity:%d&quot;</span>, activityName, warmCost, uptimeMillis(), lastCreateActivity);<br><br>            <span class="hljs-keyword">if</span> (warmCost &gt; <span class="hljs-number">0</span>) &#123;<br>                analyse(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, warmCost, <span class="hljs-keyword">true</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.wanandroid.com/blog/show/2937">ASM 入门</a></li><li><a href="https://github.com/dengshiwei/asm-module/blob/master/doc/blog/AOP%20%E5%88%A9%E5%99%A8%20ASM%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md">AOP 利器 ASM 基础入门</a></li><li><a href="https://su18.org/post/Nlwq9S-Ru/">字节码及ASM入门</a></li><li><a href="https://www.jianshu.com/p/031b62d02607">Gradle Transform API 的基本使用</a></li><li><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">Matrix Android TraceCanary</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>APM</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matrix - ResourcesCanary 浅析</title>
    <link href="/2021/04/23/matrix-resourcescanary/"/>
    <url>/2021/04/23/matrix-resourcescanary/</url>
    
    <content type="html"><![CDATA[<h2 id="Activity-的泄漏检测"><a href="#Activity-的泄漏检测" class="headerlink" title="Activity 的泄漏检测"></a><code>Activity</code> 的泄漏检测</h2><p>跟 <a href="https://github.com/square/leakcanary">LeakCanary</a> 一样，使用 <code>ActivityLifecycleCallbacks</code> 监听 <code>Activity.onDestroy()</code> 事件，从而收集到已销毁的 <code>Activity</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourcePlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Plugin</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.start();<br>        <span class="hljs-keyword">if</span> (!isSupported()) &#123;<br>            MatrixLog.e(TAG, <span class="hljs-string">&quot;ResourcePlugin start, ResourcePlugin is not supported, just return&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mWatcher.start();<br>    &#125;    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityRefWatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FilePublisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Watcher</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Application.ActivityLifecycleCallbacks mRemovedActivityMonitor = <span class="hljs-keyword">new</span> ActivityLifeCycleCallbacksAdapter() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>            pushDestroyedActivityInfo(activity);<br>            mHandler.postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    triggerGc();<br>                &#125;<br>            &#125;, <span class="hljs-number">2000</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        stopDetect();<br>        <span class="hljs-keyword">final</span> Application app = mResourcePlugin.getApplication();<br>        <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span>) &#123;<br>            app.registerActivityLifecycleCallbacks(mRemovedActivityMonitor);<br>            scheduleDetectProcedure();<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;watcher is started.&quot;</span>);<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟 <code>LeakCanary</code> 不同的是，<code>ResourceCanary</code> 并没有采用 <code>WeakReference</code> + <code>ReferenceQueue</code> 的组合来监控 GC，而是用 <code>WeakReference</code> 软引用 <code>Activity</code> 并放在 <code>ConcurrentLinkedQueue</code> 里，然后专门开一个子线程监控并处理队列，开发者的解释是：</p><blockquote><p>可见其对 <code>Activity</code> 是否泄漏的判断依赖 VM 会将可回收的对象加入 <code>WeakReference</code> 关联的 <code>ReferenceQueue</code> 这一特性，在 Demo 的测试过程中我们发现这中做法在个别系统上可能存在误报，原因大致如下：</p><ol><li>VM 并没有提供强制触发 GC 的 API，通过 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 只能“建议”系统进行 GC，如果系统忽略了我们的 GC 请求，可回收的对象就不会被加入 <code>ReferenceQueue</code></li><li>将可回收对象加入 <code>ReferenceQueue</code> 需要等待一段时间，<code>LeakCanary</code>采用延时 100ms 的做法加以规避，但似乎并不绝对管用</li><li>监测逻辑是异步的，如果判断 <code>Activity</code> 是否可回收时某个 <code>Activity</code> 正好还被某个方法的局部变量持有，就会引起误判</li><li>若反复进入泄漏的 <code>Activity</code>，<code>LeakCanary</code> 会重复提示该Activity已泄漏</li></ol><p>对此我们做了以下改进：</p><ol><li>增加一个一定能被回收的“哨兵”对象，用来确认系统确实进行了 GC</li><li>直接通过 <code>WeakReference.get()</code> 来判断对象是否已被回收，避免因延迟导致误判</li><li>若发现某个 <code>Activity</code> 无法被回收，再重复判断 3 次，且要求从该 <code>Activity</code> 被记录起有2个以上的 <code>Activity</code> 被创建才认为是泄漏，以防在判断时该 <code>Activity</code> 被局部变量持有导致误判</li><li>对已判断为泄漏的 <code>Activity</code>，记录其类名，避免重复提示该 <code>Activity</code> 已泄漏</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityRefWatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FilePublisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Watcher</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;DestroyedActivityInfo&gt; mDestroyedActivityInfos;<br><br>    <span class="hljs-comment">// 处理上面的队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RetryableTask mScanDestroyedActivitiesTask = <span class="hljs-keyword">new</span> RetryableTask() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;;    <br><br>    <span class="hljs-comment">// 销毁的 Activity 被放到上面的队列里</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushDestroyedActivityInfo</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> String activityName = activity.getClass().getName();<br>        <span class="hljs-keyword">if</span> ((mDumpHprofMode == ResourceConfig.DumpMode.NO_DUMP || mDumpHprofMode == ResourceConfig.DumpMode.AUTO_DUMP)<br>                &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()<br>                &amp;&amp; isPublished(activityName)) &#123;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;activity leak with name %s had published, just ignore&quot;</span>, activityName);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">final</span> UUID uuid = UUID.randomUUID();<br>        <span class="hljs-keyword">final</span> StringBuilder keyBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        keyBuilder.append(ACTIVITY_REFKEY_PREFIX).append(activityName)<br>                .append(<span class="hljs-string">&#x27;_&#x27;</span>).append(Long.toHexString(uuid.getMostSignificantBits())).append(Long.toHexString(uuid.getLeastSignificantBits()));<br>        <span class="hljs-keyword">final</span> String key = keyBuilder.toString();<br>        <span class="hljs-keyword">final</span> DestroyedActivityInfo destroyedActivityInfo<br>                = <span class="hljs-keyword">new</span> DestroyedActivityInfo(key, activity, activityName);<br>        mDestroyedActivityInfos.add(destroyedActivityInfo);<br>        <span class="hljs-keyword">synchronized</span> (mDestroyedActivityInfos) &#123;<br>            mDestroyedActivityInfos.notifyAll();<br>        &#125;<br>        MatrixLog.d(TAG, <span class="hljs-string">&quot;mDestroyedActivityInfos add %s&quot;</span>, activityName);<br>    &#125;    <br><br>    <span class="hljs-comment">// 在子线程里处理 Activity 队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        stopDetect();<br>        <span class="hljs-keyword">final</span> Application app = mResourcePlugin.getApplication();<br>        <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span>) &#123;<br>            app.registerActivityLifecycleCallbacks(mRemovedActivityMonitor);<br>            scheduleDetectProcedure();<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;watcher is started.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleDetectProcedure</span><span class="hljs-params">()</span> </span>&#123;<br>        mDetectExecutor.executeInBackground(mScanDestroyedActivitiesTask);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>LeakCanary</code> 每当一个 <code>Activity</code> 销毁时就放一个延时 5s 的检查任务，而 <code>ResourceCanary</code> 检测规则较为宽松：</p><ol><li>默认每隔 1min 检查一次 <code>mDestroyedActivityInfos</code></li><li>规定在检查次数 <code>mMaxRedetectTimes</code> 以下不判定为泄漏</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// If destroyed activity list is empty, just wait to save power.</span><br>    <span class="hljs-keyword">if</span> (mDestroyedActivityInfos.isEmpty()) &#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;DestroyedActivityInfo is empty! wait...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (mDestroyedActivityInfos) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mDestroyedActivityInfos.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>                <span class="hljs-comment">// Ignored.</span><br>            &#125;<br>        &#125;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;DestroyedActivityInfo is NOT empty! resume check&quot;</span>);<br>        <span class="hljs-keyword">return</span> Status.RETRY;<br>    &#125;<br>    <span class="hljs-comment">// Fake leaks will be generated when debugger is attached.</span><br>    <span class="hljs-keyword">if</span> (Debug.isDebuggerConnected() &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()) &#123;<br>        MatrixLog.w(TAG, <span class="hljs-string">&quot;debugger is connected, to avoid fake result, detection was delayed.&quot;</span>);<br>        <span class="hljs-keyword">return</span> Status.RETRY;<br>    &#125;<br><span class="hljs-comment">//          final WeakReference&lt;Object[]&gt; sentinelRef = new WeakReference&lt;&gt;(new Object[1024 * 1024]); // alloc big object</span><br>    triggerGc();<br>    triggerGc();<br>    triggerGc();<br><span class="hljs-comment">//          if (sentinelRef.get() != null) &#123;</span><br><span class="hljs-comment">//              // System ignored our gc request, we will retry later.</span><br><span class="hljs-comment">//              MatrixLog.d(TAG, &quot;system ignore our gc request, wait for next detection.&quot;);</span><br><span class="hljs-comment">//              return Status.RETRY;</span><br><span class="hljs-comment">//          &#125;</span><br>    <span class="hljs-keyword">final</span> Iterator&lt;DestroyedActivityInfo&gt; infoIt = mDestroyedActivityInfos.iterator();<br>    <span class="hljs-keyword">while</span> (infoIt.hasNext()) &#123;<br>        <span class="hljs-keyword">final</span> DestroyedActivityInfo destroyedActivityInfo = infoIt.next();<br>        <span class="hljs-keyword">if</span> ((mDumpHprofMode == ResourceConfig.DumpMode.NO_DUMP || mDumpHprofMode == ResourceConfig.DumpMode.AUTO_DUMP)<br>                &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()<br>                &amp;&amp; isPublished(destroyedActivityInfo.mActivityName)) &#123;<br>            MatrixLog.v(TAG, <span class="hljs-string">&quot;activity with key [%s] was already published.&quot;</span>, destroyedActivityInfo.mActivityName);<br>            infoIt.remove();<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        triggerGc();<br>        <span class="hljs-keyword">if</span> (destroyedActivityInfo.mActivityRef.get() == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// The activity was recycled by a gc triggered outside.</span><br>            MatrixLog.v(TAG, <span class="hljs-string">&quot;activity with key [%s] was already recycled.&quot;</span>, destroyedActivityInfo.mKey);<br>            infoIt.remove();<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        ++destroyedActivityInfo.mDetectedCount;<br>        <span class="hljs-keyword">if</span> (destroyedActivityInfo.mDetectedCount &lt; mMaxRedetectTimes<br>                &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()) &#123;<br>            <span class="hljs-comment">// Although the sentinel tell us the activity should have been recycled,</span><br>            <span class="hljs-comment">// system may still ignore it, so try again until we reach max retry times.</span><br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;activity with key [%s] should be recycled but actually still exists in %s times, wait for next detectiontoconfirm.&quot;</span>,<br>                    destroyedActivityInfo.mKey, destroyedActivityInfo.mDetectedCount);<br>            triggerGc();<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;activity with key [%s] was suspected to be a leaked instance. mode[%s]&quot;</span>, destroyedActivityInfo.mKey,mDumpHprofMode;<br>        <span class="hljs-keyword">if</span> (mLeakProcessor == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;LeakProcessor not found!!!&quot;</span>);<br>        &#125;<br>        triggerGc();<br>        <span class="hljs-keyword">if</span> (mLeakProcessor.process(destroyedActivityInfo)) &#123;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;the leaked activity [%s] with key [%s] has been processed. stop polling&quot;</span>, destroyedActivityInfomActivityName,destroyedActivityInfo.mKey);<br>            infoIt.remove();<br>        &#125;<br>    &#125;<br>    triggerGc();<br>    <span class="hljs-keyword">return</span> Status.RETRY;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="heap-dump-并分析-hprof-文件"><a href="#heap-dump-并分析-hprof-文件" class="headerlink" title="heap dump 并分析 hprof 文件"></a>heap dump 并分析 hprof 文件</h2><p>这个阶段 <code>ResourcesCanary</code> 的逻辑跟 <code>LeakCanary</code> 几乎是一模一样的，估计是 copy 代码过来的，只不过 <code>ResourcesCanary</code> 用的还是 <a href="https://github.com/square/haha">haha</a> 而最新的 <code>LeakCanary</code> 已经使用 <code>Shark</code> 了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比 <code>LeakCanary</code>，<code>ResourcesCanary</code> 的优点是提出了子线程检查泄漏对象的思路，缺点是检测对象太单一，只有 <code>Activity</code>（重复 <code>Bitmap</code> 检测感觉并不可靠），而且没有抽象出通用的泄漏检测逻辑（<code>LeakCanary</code> 抽象出 <code>ObjectWatcher</code>）</p>]]></content>
    
    
    
    <tags>
      
      <tag>内存优化，OOM</tag>
      
      <tag>APM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 OOM</title>
    <link href="/2021/04/16/looking-into-oom/"/>
    <url>/2021/04/16/looking-into-oom/</url>
    
    <content type="html"><![CDATA[<h2 id="堆内存分配失败导致的-OOM"><a href="#堆内存分配失败导致的-OOM" class="headerlink" title="堆内存分配失败导致的 OOM"></a>堆内存分配失败导致的 OOM</h2><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>采用下述 API 来度量 APP 或系统的内存使用情况</p><table><thead><tr><th>类别</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>APP</td><td><code>Runtime.maxMemory()</code></td><td>JVM 可以从系统那申请到的内存的最大值，<code>ActivityManager.getMemoryClass()</code> 和 <code>ActivityManager.getLargeMemoryClass()</code> 其中之一，超过此阈值会发生 OOM</td></tr><tr><td></td><td><code>Runtime.totalMemory()</code></td><td>JVM 已申请到的内存大小，小于等于 <code>Runtime.maxMemory()</code> 且大于 <code>Runtime.freeMemory()</code>；当需要的内存（比如创建 1M 的字节数组）超过 <code>Runtime.freeMemory()</code> 时 JVM 会向系统申请内存，此时 <code>Runtime.totalMemory()</code> 会逐渐增大；直到等于 <code>Runtime.maxMemory()</code> 时，如果需要的内存超过 <code>Runtime.freeMemory()</code> 则抛出 OOM</td></tr><tr><td></td><td><code>Runtime.freeMemory()</code></td><td>JVM 已申请到但仍未使用的内存，当需要的内存超过此值时，JVM 会向系统申请内存</td></tr><tr><td></td><td><code>ActivityManager.getMemoryClass()</code></td><td>APP 可申请的内存上限</td></tr><tr><td></td><td><code>ActivityManager.getLargeMemoryClass()</code></td><td>设置 <code>android:largeHeap=&quot;true&quot;</code> 后 APP 可申请的内存上限，一般是 <code>ActivityManager.getLargeMemoryClass()</code> 的两倍</td></tr><tr><td>系统</td><td><code>ActivityManager.MemoryInfo.availMem</code></td><td>当前系统可用内存大小，即设置里可用运存的值</td></tr><tr><td></td><td><code>ActivityManager.MemoryInfo.totalMem</code></td><td>系统总内存大小，即设置里运存总空间的值</td></tr><tr><td></td><td><code>ActivityManager.MemoryInfo.lowMemory</code></td><td>标识系统是否处于低内存状态</td></tr><tr><td></td><td><code>ActivityManager.MemoryInfo.threshold</code></td><td>当系统可用内存小于此阈值时，系统处于低内存状态</td></tr></tbody></table><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用下面的测试代码在我的测试机（iQOO 3）上，循环申请 30M/5M/500K 的内存，每次间隔 1s 并打印内存统计情况</p><p>可以看到 JVM 使用内存上限 <code>max</code> 是 256M（刚好是 <code>memoryClass</code>，如果配置了 <code>largeHeap=&quot;true&quot;</code> 则是 <code>largeMemoryClass</code>），已申请内存 <code>total</code> 逐步上升直到 256M，<code>total</code> - <code>free</code> 等于申请内存的累计量；运行内存为 11.36GB，可用运存徘徊在 5GB 左右，当运存掉到 216M 时进入低内存状态，所以目前并不是低内存；APP 可申请内存上限为 256MB，设置 <code>largeHeap=&quot;true&quot;</code> 后翻倍到 512MB</p><p>抛出 OOM 时的信息为：<code>Failed to allocate a 512016 byte allocation with 22760 free bytes and 22KB until OOM, target footprint 268435456, growth limit 268435456</code></p><p>参考日志的最后一行，当时正在申请 500KB 的内存（<code>Failed to allocate a 512016 byte allocation</code>），还剩 14.95KB（<code>with 22760 free bytes and 22KB until OOM</code>），上限是 256MB（<code>target footprint 268435456, growth limit 268435456</code>）</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 循环申请内存直到 OOM</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mallocJVM</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> steps = arrayOf(<span class="hljs-number">1024L</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">30</span>, <span class="hljs-number">1024L</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>, <span class="hljs-number">1024L</span> * <span class="hljs-number">500</span>)<br>    <span class="hljs-keyword">val</span> pool = mutableListOf&lt;ByteArray&gt;()<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">val</span> runtime = Runtime.getRuntime()<br>        <span class="hljs-keyword">val</span> free = runtime.maxMemory() - runtime.totalMemory() + runtime.freeMemory()<br>        <span class="hljs-keyword">val</span> size = <span class="hljs-keyword">if</span> (free &gt;= steps[<span class="hljs-number">0</span>]) steps[<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (free &gt;= steps[<span class="hljs-number">1</span>]) steps[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> steps[<span class="hljs-number">2</span>]<br>        pool += ByteArray(size = size.toInt())<br>        await()<br>        printMemoryUsages()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 间隔 1s</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">(time: <span class="hljs-type">Long</span> = <span class="hljs-number">1000</span>)</span></span> &#123;<br>    lock.lock()<br>    <span class="hljs-keyword">try</span> &#123;<br>        cond.await(time, TimeUnit.MILLISECONDS)<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印内存统计情况</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMemoryUsages</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> runtime = Runtime.getRuntime()<br>    am.getMemoryInfo(memInfo)<br>    d(<span class="hljs-string">&quot;max:<span class="hljs-subst">$&#123;runtime.maxMemory&#125;</span> total:<span class="hljs-subst">$&#123;runtime.totalMemory&#125;</span> free:<span class="hljs-subst">$&#123;runtime.freeMemory&#125;</span> &quot;</span> +<br>            <span class="hljs-string">&quot;availMem:<span class="hljs-subst">$&#123;memInfo.availMemReadable&#125;</span> totalMem:<span class="hljs-subst">$&#123;memInfo.totalMemReadable&#125;</span> &quot;</span> +<br>            <span class="hljs-string">&quot;threshold:<span class="hljs-subst">$&#123;memInfo.thresholdReadable&#125;</span> lowMemory:<span class="hljs-subst">$&#123;memInfo.lowMemory&#125;</span> &quot;</span> +<br>            <span class="hljs-string">&quot;memoryClass:<span class="hljs-subst">$&#123;am.memoryClassReadable&#125;</span> largeMemoryClass:<span class="hljs-subst">$&#123;am.largeMemoryClassReadable&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../../../image/2021-04-16-looking-into-oom/oom_memory_log.png" alt="oom_memory_log.png"></p><p><img src="../../../../image/2021-04-16-looking-into-oom/oom_memory.png" alt="oom_memory.png"></p><h3 id="定位抛出-OOM-的位置"><a href="#定位抛出-OOM-的位置" class="headerlink" title="定位抛出 OOM 的位置"></a>定位抛出 OOM 的位置</h3><p>最终抛出 <code>OutOfMemoryError</code> 的代码 是 <code>Thread::ThrowOutOfMemoryError</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::ThrowOutOfMemoryError</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg)</span> </span>&#123;<br>  <span class="hljs-built_in">LOG</span>(WARNING) &lt;&lt; <span class="hljs-string">&quot;Throwing OutOfMemoryError &quot;</span><br>               &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span><br>               &lt;&lt; <span class="hljs-string">&quot; (VmSize &quot;</span> &lt;&lt; <span class="hljs-built_in">GetProcessStatus</span>(<span class="hljs-string">&quot;VmSize&quot;</span>)<br>               &lt;&lt; (tls32_.throwing_OutOfMemoryError ? <span class="hljs-string">&quot;, recursive case)&quot;</span> : <span class="hljs-string">&quot;)&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!tls32_.throwing_OutOfMemoryError) &#123;<br>    tls32_.throwing_OutOfMemoryError = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">ThrowNewException</span>(<span class="hljs-string">&quot;Ljava/lang/OutOfMemoryError;&quot;</span>, msg);<br>    tls32_.throwing_OutOfMemoryError = <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">Dump</span>(<span class="hljs-built_in">LOG_STREAM</span>(WARNING));  <span class="hljs-comment">// The pre-allocated OOME has no stack, so help out and log one.</span><br>    <span class="hljs-built_in">SetException</span>(Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetPreAllocatedOutOfMemoryErrorWhenThrowingOOME</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::ThrowNewException</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* exception_class_descriptor,</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg)</span> </span>&#123;<br>  <span class="hljs-comment">// Callers should either clear or call ThrowNewWrappedException.</span><br>  <span class="hljs-built_in">AssertNoPendingExceptionForNewException</span>(msg);<br>  <span class="hljs-built_in">ThrowNewWrappedException</span>(exception_class_descriptor, msg);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::ThrowNewWrappedException</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* exception_class_descriptor,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg)</span> </span>&#123;<br>  <span class="hljs-comment">// ... 构造 Ljava/lang/OutOfMemoryError;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而因为堆内存分配失败抛出 OOM 的代码在 <code>Heap::ThrowOutOfMemoryError</code>，其中异常信息为：</p><p><code>&quot;Failed to allocate a (x) byte allocation with (x) free bytes and (x) until OOM, target footprint (x), growth limit (x)&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap::ThrowOutOfMemoryError</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">size_t</span> byte_count, AllocatorType allocator_type)</span> </span>&#123;<br>  <span class="hljs-comment">// If we&#x27;re in a stack overflow, do not create a new exception. It would require running the</span><br>  <span class="hljs-comment">// constructor, which will of course still be in a stack overflow.</span><br>  <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">IsHandlingStackOverflow</span>()) &#123;<br>    self-&gt;<span class="hljs-built_in">SetException</span>(<br>        Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetPreAllocatedOutOfMemoryErrorWhenHandlingStackOverflow</span>());<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  std::ostringstream oss;<br>  <span class="hljs-keyword">size_t</span> total_bytes_free = <span class="hljs-built_in">GetFreeMemory</span>();<br>  oss &lt;&lt; <span class="hljs-string">&quot;Failed to allocate a &quot;</span> &lt;&lt; byte_count &lt;&lt; <span class="hljs-string">&quot; byte allocation with &quot;</span> &lt;&lt; total_bytes_free<br>      &lt;&lt; <span class="hljs-string">&quot; free bytes and &quot;</span> &lt;&lt; <span class="hljs-built_in">PrettySize</span>(<span class="hljs-built_in">GetFreeMemoryUntilOOME</span>()) &lt;&lt; <span class="hljs-string">&quot; until OOM,&quot;</span><br>      &lt;&lt; <span class="hljs-string">&quot; target footprint &quot;</span> &lt;&lt; target_footprint_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed)<br>      &lt;&lt; <span class="hljs-string">&quot;, growth limit &quot;</span><br>      &lt;&lt; growth_limit_;<br>  <span class="hljs-comment">// If the allocation failed due to fragmentation, print out the largest continuous allocation.</span><br>  <span class="hljs-keyword">if</span> (total_bytes_free &gt;= byte_count) &#123;<br>    space::AllocSpace* space = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeNonMoving) &#123;<br>      space = non_moving_space_;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeRosAlloc ||<br>               allocator_type == kAllocatorTypeDlMalloc) &#123;<br>      space = main_space_;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeBumpPointer ||<br>               allocator_type == kAllocatorTypeTLAB) &#123;<br>      space = bump_pointer_space_;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeRegion ||<br>               allocator_type == kAllocatorTypeRegionTLAB) &#123;<br>      space = region_space_;<br>    &#125;<br><br>    <span class="hljs-comment">// There is no fragmentation info to log for large-object space.</span><br>    <span class="hljs-keyword">if</span> (allocator_type != kAllocatorTypeLOS) &#123;<br>      <span class="hljs-built_in">CHECK</span>(space != <span class="hljs-literal">nullptr</span>) &lt;&lt; <span class="hljs-string">&quot;allocator_type:&quot;</span> &lt;&lt; allocator_type<br>                              &lt;&lt; <span class="hljs-string">&quot; byte_count:&quot;</span> &lt;&lt; byte_count<br>                              &lt;&lt; <span class="hljs-string">&quot; total_bytes_free:&quot;</span> &lt;&lt; total_bytes_free;<br>      space-&gt;<span class="hljs-built_in">LogFragmentationAllocFailure</span>(oss, byte_count);<br>    &#125;<br>  &#125;<br>  self-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(oss.<span class="hljs-built_in">str</span>().<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="创建线程时-Could-not-allocate-JNI-Env-导致的-OOM"><a href="#创建线程时-Could-not-allocate-JNI-Env-导致的-OOM" class="headerlink" title="创建线程时 Could not allocate JNI Env 导致的 OOM"></a>创建线程时 <code>Could not allocate JNI Env</code> 导致的 OOM</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>线程数量可以通过 <code>/proc/&#123;pid&#125;/status</code> 里 <code>Threads</code> 那行拿到</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Name:m.myapplication<br><span class="hljs-attr">State</span>:R (running)<br><span class="hljs-attr">Tgid</span>:<span class="hljs-number">26939</span><br><span class="hljs-attr">Ngid</span>:<span class="hljs-number">0</span><br><span class="hljs-attr">Pid</span>:<span class="hljs-number">26939</span><br><span class="hljs-attr">PPid</span>:<span class="hljs-number">1846</span><br><span class="hljs-attr">TracerPid</span>:<span class="hljs-number">0</span><br><span class="hljs-attr">Uid</span>:<span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><br><span class="hljs-attr">Gid</span>:<span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><br><span class="hljs-attr">FDSize</span>:<span class="hljs-number">64</span><br><span class="hljs-attr">Groups</span>:<span class="hljs-number">3003</span> <span class="hljs-number">9997</span> <span class="hljs-number">20100</span> <span class="hljs-number">50100</span> <br>...<br><span class="hljs-attr">Threads</span>:<span class="hljs-number">17</span>                  <span class="hljs-comment">// 线程数量</span><br>...<br></code></pre></div></td></tr></table></figure><p>不断地创建新线程，新线程啥也不干就阻塞住，从而使 APP 进程的线程数量持续上涨，模拟 APP 随意创建线程/线程池而没有做统一的管理，导致创建大量线程的情况，最后抛出 <code>Could not allocate JNI Env: Failed anonymous mmap(0x0, 8192, 0x3, 0x2, 53, 0): Permission denied. See process maps in the log.</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryKillerService</span> : <span class="hljs-type">IntentService</span></span>(<span class="hljs-string">&quot;MemoryKillerService&quot;</span>) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        <span class="hljs-comment">// 一个线程不断地创建测试线程（间隔 1ms）</span><br>        thread &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">val</span> thread = BlockingThread()<br>                thread.start()<br>                await(time = <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 一个线程不断地打印线程数</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            d(<span class="hljs-string">&quot;threadCount: <span class="hljs-subst">$&#123;getThreadCount()&#125;</span>&quot;</span>)<br>            await(time = <span class="hljs-number">100</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试线程啥也不干，就阻塞住</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingThread</span>: <span class="hljs-type">Thread</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = ReentrantLock()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cond = lock.newCondition()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        lock.lock()<br>        <span class="hljs-keyword">try</span> &#123;<br>            cond.await()<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询进程的线程数量</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getThreadCount</span><span class="hljs-params">()</span></span> = runCatching &#123;<br>    regexGroupInFile(pattern = <span class="hljs-string">&quot;.*Threads:\\s+(\\d+).*&quot;</span>, path = <span class="hljs-string">&quot;/proc/<span class="hljs-subst">$&#123;myPid()&#125;</span>/status&quot;</span>)?.toInt()<br>&#125;.getOrDefault(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.067</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1633</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.170</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1680</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.272</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1731</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.374</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1784</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.475</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1829</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.578</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1880</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.680</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1929</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.783</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1972</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.886</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2017</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.988</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2067</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.090</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2113</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.193</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2164</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.294</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2208</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.368</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29771</span>/com.myapplication W/m.myapplicatio: Throwing OutOfMemoryError <span class="hljs-string">&quot;Could not allocate JNI Env: Failed anonymous mmap(0x0, 8192, 0x3, 0x2, 53, 0): Permission denied. See process maps in the log.&quot;</span><br>    <br>    --------- beginning <span class="hljs-keyword">of</span> crash<br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.368</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29771</span>/com.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-<span class="hljs-number">2</span><br>    <span class="hljs-attr">Process</span>: com.myapplication, <span class="hljs-attr">PID</span>: <span class="hljs-number">29743</span><br>    java.lang.OutOfMemoryError: Could not allocate JNI Env: Failed anonymous mmap(<span class="hljs-number">0x0</span>, <span class="hljs-number">8192</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">53</span>, <span class="hljs-number">0</span>): Permission denied. See process maps <span class="hljs-keyword">in</span> the log.<br>        at java.lang.Thread.nativeCreate(Native Method)<br>        at java.lang.Thread.start(Thread.java:<span class="hljs-number">733</span>)<br>        at com.myapplication.MemoryKillerService$onHandleIntent$1.invoke(MemoryKillerService.kt:<span class="hljs-number">35</span>)<br>        at com.myapplication.MemoryKillerService$onHandleIntent$1.invoke(MemoryKillerService.kt:<span class="hljs-number">22</span>)<br>        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:<span class="hljs-number">30</span>)<br></code></pre></div></td></tr></table></figure><h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Thread.<span class="hljs-built_in">start</span>()<br>Thread.<span class="hljs-function">nativeCreate</span><br><span class="hljs-function">Thread_nativeCreate</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::CreateNativeThread</span><span class="hljs-params">(JNIEnv* env, jobject java_peer, <span class="hljs-keyword">size_t</span> stack_size, <span class="hljs-keyword">bool</span> is_daemon)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// Try to allocate a JNIEnvExt for the thread. We do this here as we might be out of memory and</span><br>  <span class="hljs-comment">// do not have a good way to report this on the child&#x27;s side.</span><br>  std::string error_msg;<br>  <span class="hljs-function">std::unique_ptr&lt;JNIEnvExt&gt; <span class="hljs-title">child_jni_env_ext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      JNIEnvExt::Create(child_thread, Runtime::Current()-&gt;GetJavaVM(), &amp;error_msg))</span></span>;<br><br>  <span class="hljs-comment">// 成功创建 JNIEnvExt 后才会真正创建线程 pthread_create ...</span><br><br>  <span class="hljs-comment">// 找到了错误信息 Could not allocate JNI Env，它是由 child_jni_env_ext.get() == nullptr 触发的</span><br>  <span class="hljs-comment">// 也就是 JNIEnvExt::Create 返回 nullptr，JNIEnvExt 创建失败</span><br>  &#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">msg</span><span class="hljs-params">(child_jni_env_ext.get() == <span class="hljs-literal">nullptr</span> ?</span></span><br><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;Could not allocate JNI Env: %s&quot;</span>, error_msg.c_str()) :</span></span><br><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;pthread_create (%s stack) failed: %s&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 PrettySize(stack_size).c_str(), strerror(pthread_create_result)))</span></span>;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>    soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(msg.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 发现 JNIEnvExt.locals_.table_mem_map_.IsValid 返回 false 导致 JNIEnvExt 创建失败</span><br>JNIEnvExt::Create<br>JNIEnvExt::CheckLocalsValid<br>IndirectReferenceTable::IsValid<br>MemMap.IsValid<br><br><span class="hljs-comment">// locals_ 是在 JNIEnvExt 的构造函数里初始化的</span><br>JNIEnvExt::<span class="hljs-built_in">JNIEnvExt</span>(Thread* self_in, JavaVMExt* vm_in, std::string* error_msg)<br>    : <span class="hljs-built_in">self_</span>(self_in),<br>      <span class="hljs-built_in">vm_</span>(vm_in),<br>      <span class="hljs-built_in">local_ref_cookie_</span>(kIRTFirstSegment),<br>      <span class="hljs-built_in">locals_</span>(kLocalsInitial, kLocal, IndirectReferenceTable::ResizableCapacity::kYes, error_msg),<br>      <span class="hljs-built_in">monitors_</span>(<span class="hljs-string">&quot;monitors&quot;</span>, kMonitorsInitial, kMonitorsMax),<br>      <span class="hljs-built_in">critical_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">check_jni_</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">runtime_deleted_</span>(<span class="hljs-literal">false</span>) &#123;<br>  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(Thread::Current(), *Locks::jni_function_table_lock_)</span></span>;<br>  check_jni_ = vm_in-&gt;<span class="hljs-built_in">IsCheckJniEnabled</span>();<br>  functions = <span class="hljs-built_in">GetFunctionTable</span>(check_jni_);<br>  unchecked_functions_ = <span class="hljs-built_in">GetJniNativeInterface</span>();<br>&#125;<br><br><span class="hljs-comment">// table_mem_map_ 是由 MemMap::MapAnonymous 创建的</span><br>IndirectReferenceTable::<span class="hljs-built_in">IndirectReferenceTable</span>(<span class="hljs-keyword">size_t</span> max_count,<br>                                               IndirectRefKind desired_kind,<br>                                               ResizableCapacity resizable,<br>                                               std::string* error_msg)<br>    : <span class="hljs-built_in">segment_state_</span>(kIRTFirstSegment),<br>      <span class="hljs-built_in">kind_</span>(desired_kind),<br>      <span class="hljs-built_in">max_entries_</span>(max_count),<br>      <span class="hljs-built_in">current_num_holes_</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">resizable_</span>(resizable) &#123;<br>  <span class="hljs-built_in">CHECK</span>(error_msg != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">CHECK_NE</span>(desired_kind, kJniTransitionOrInvalid);<br><br>  <span class="hljs-comment">// Overflow and maximum check.</span><br>  <span class="hljs-built_in">CHECK_LE</span>(max_count, kMaxTableSizeInBytes / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(IrtEntry));<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> table_bytes = <span class="hljs-built_in">RoundUp</span>(max_count * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(IrtEntry), kPageSize);<br>  table_mem_map_ = MemMap::<span class="hljs-built_in">MapAnonymous</span>(<span class="hljs-string">&quot;indirect ref table&quot;</span>,<br>                                        table_bytes,<br>                                        PROT_READ | PROT_WRITE,<br>                                        <span class="hljs-comment">/*low_4gb=*/</span> <span class="hljs-literal">false</span>,<br>                                        error_msg);<br>  <span class="hljs-keyword">if</span> (!table_mem_map_.<span class="hljs-built_in">IsValid</span>() &amp;&amp; error_msg-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>    *error_msg = <span class="hljs-string">&quot;Unable to map memory for indirect ref table&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (table_mem_map_.<span class="hljs-built_in">IsValid</span>()) &#123;<br>    table_ = <span class="hljs-keyword">reinterpret_cast</span>&lt;IrtEntry*&gt;(table_mem_map_.<span class="hljs-built_in">Begin</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    table_ = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  segment_state_ = kIRTFirstSegment;<br>  last_known_previous_state_ = kIRTFirstSegment;<br>  <span class="hljs-comment">// Take into account the actual length.</span><br>  max_entries_ = table_bytes / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(IrtEntry);<br>&#125;<br><br><span class="hljs-comment">// 找到错误信息 Failed anonymous mmap 的出处了</span><br><span class="hljs-function">MemMap <span class="hljs-title">MemMap::MapAnonymous</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">uint8_t</span>* addr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">size_t</span> byte_count,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">int</span> prot,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">bool</span> low_4gb,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">bool</span> reuse,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-comment">/*inout*/</span>MemMap* reservation,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-comment">/*out*/</span>std::string* error_msg,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">bool</span> use_debug_name)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// fd 没有指向任何有效文件，addr 也是 nullptr</span><br>  <span class="hljs-comment">// 也就是说这里只是开辟了容量是 byte_count 的一段内存空间</span><br>  <span class="hljs-keyword">void</span>* actual = <span class="hljs-built_in">MapInternal</span>(addr,<br>                             page_aligned_byte_count,<br>                             prot,<br>                             flags,<br>                             fd.<span class="hljs-built_in">get</span>(),<br>                             <span class="hljs-number">0</span>,<br>                             low_4gb);<br>  saved_errno = errno;<br><br>  <span class="hljs-keyword">if</span> (actual == MAP_FAILED) &#123;<br>    <span class="hljs-keyword">if</span> (error_msg != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">if</span> (kIsDebugBuild || <span class="hljs-built_in">VLOG_IS_ON</span>(oat)) &#123;<br>        <span class="hljs-built_in">PrintFileToLog</span>(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, LogSeverity::WARNING);<br>      &#125;<br><br>      *error_msg = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Failed anonymous mmap(%p, %zd, 0x%x, 0x%x, %d, 0): %s. &quot;</span><br>                                    <span class="hljs-string">&quot;See process maps in the log.&quot;</span>,<br>                                addr,<br>                                page_aligned_byte_count,<br>                                prot,<br>                                flags,<br>                                fd.<span class="hljs-built_in">get</span>(),<br>                                <span class="hljs-built_in">strerror</span>(saved_errno));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Invalid</span>();<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 看来是将 fd 映射进内存地址时失败了</span><br>MemMap::MapInternal<br>MemMap::TargetMMap<br>mmap<br></code></pre></div></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建线程时，需要构造 <code>JNIEnvExt</code> 这么一个对象，而 <code>JNIEnvExt</code> 需要 <code>mmap</code> 一块大小为 <code>RoundUp(max_count * sizeof(IrtEntry), kPageSize)</code> 的内存地址（内存页面大小的整数倍，比如上面 logcat 里，8192 = 4096 * 2），当虚拟内存地址空间耗尽时抛出 OOM</p><ol><li><code>Could not allocate JNI Env</code> 不能为 <code>JNIEnvExt</code> 分配内存</li><li><code>Failed anonymous mmap(0x0, 8192, 0x3, 0x2, 53, 0)</code> 不能分配 8192 大小的内存地址</li><li><code>Permission denied. See process maps in the log.</code> 我用的模拟器，可能是说超出内存限制后不能用其他方式获得内存？</li></ol><h2 id="创建线程时-pthread-create-failed-导致的-OOM"><a href="#创建线程时-pthread-create-failed-导致的-OOM" class="headerlink" title="创建线程时 pthread_create failed 导致的 OOM"></a>创建线程时 <code>pthread_create failed</code> 导致的 OOM</h2><p>用上面的测试代码还会出现另外一种 OOM 如下</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.488</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1702</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.590</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1747</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.692</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1796</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.794</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1848</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.898</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1895</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1946</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.103</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1997</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.205</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2045</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.307</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2096</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.410</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2139</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.513</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2175</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.615</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2220</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.663</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27433</span>/com.myapplication W/libc: pthread_create failed: couldn<span class="hljs-string">&#x27;t allocate TLS: Permission denied</span><br><span class="hljs-string">2021-04-20 13:55:38.663 27404-27433/com.myapplication W/m.myapplicatio: Throwing OutOfMemoryError &quot;pthread_create (1040KB stack) failed: Try again&quot;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    --------- beginning of crash</span><br><span class="hljs-string">2021-04-20 13:55:38.664 27404-27433/com.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-2</span><br><span class="hljs-string">    Process: com.myapplication, PID: 27404</span><br><span class="hljs-string">    java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again</span><br><span class="hljs-string">        at java.lang.Thread.nativeCreate(Native Method)</span><br><span class="hljs-string">        at java.lang.Thread.start(Thread.java:733)</span><br><span class="hljs-string">        at com.myapplication.MemoryKillerService$onHandleIntent$1.invoke(MemoryKillerService.kt:35)</span><br><span class="hljs-string">        at com.myapplication.MemoryKillerService$onHandleIntent$1.invoke(MemoryKillerService.kt:22)</span><br><span class="hljs-string">        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br></code></pre></div></td></tr></table></figure><p>创建线程最终会执行系统调用 <code>pthread_create</code>，如果失败会抛出 <code>pthread_create (1040KB stack) failed</code>，1040KB 是线程的栈大小</p><p>上面 <code>pthread_create failed: couldn&#39;t allocate TLS: Permission denied</code> 表示为线程分配 Thread Local（TLS，THREAD LOCAL STORAGE）相关的内存时因为内存不足失败了</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Thread.<span class="hljs-built_in">start</span>()<br>Thread.<span class="hljs-function">nativeCreate</span><br><span class="hljs-function">Thread_nativeCreate</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::CreateNativeThread</span><span class="hljs-params">(JNIEnv* env, jobject java_peer, <span class="hljs-keyword">size_t</span> stack_size, <span class="hljs-keyword">bool</span> is_daemon)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 不同于上面的情况，此时已为 JNIEnvExt 分配内存，但在执行 pthread_create 时出错了</span><br>  <span class="hljs-keyword">int</span> pthread_create_result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (child_jni_env_ext.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">pthread_t</span> new_pthread;<br>    <span class="hljs-keyword">pthread_attr_t</span> attr;<br>    child_thread-&gt;tlsPtr_.tmp_jni_env = child_jni_env_ext.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_init, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setdetachstate, (&amp;attr, PTHREAD_CREATE_DETACHED),<br>                       <span class="hljs-string">&quot;PTHREAD_CREATE_DETACHED&quot;</span>);<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setstacksize, (&amp;attr, stack_size), stack_size);<br>    pthread_create_result = <span class="hljs-built_in">pthread_create</span>(&amp;new_pthread,<br>                                           &amp;attr,<br>                                           Thread::CreateCallback,<br>                                           child_thread);<br>    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_destroy, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (pthread_create_result == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// pthread_create started the new thread. The child is now responsible for managing the</span><br>      <span class="hljs-comment">// JNIEnvExt we created.</span><br>      <span class="hljs-comment">// Note: we can&#x27;t check for tmp_jni_env == nullptr, as that would require synchronization</span><br>      <span class="hljs-comment">//       between the threads.</span><br>      child_jni_env_ext.<span class="hljs-built_in">release</span>();  <span class="hljs-comment">// NOLINT pthreads API.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// pthread_create 成功会在上面返回，跑到这里是因为其执行失败了</span><br>  &#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">msg</span><span class="hljs-params">(child_jni_env_ext.get() == <span class="hljs-literal">nullptr</span> ?</span></span><br><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;Could not allocate JNI Env: %s&quot;</span>, error_msg.c_str()) :</span></span><br><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;pthread_create (%s stack) failed: %s&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 PrettySize(stack_size).c_str(), strerror(pthread_create_result)))</span></span>;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>    soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(msg.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="更多的例子"><a href="#更多的例子" class="headerlink" title="更多的例子"></a>更多的例子</h3><p>线程数超出了限制</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">W/libc: pthread_create failed: clone failed: Out of memory<br>W/art: Throwing OutOfMemoryError <span class="hljs-string">&quot;pthread_create (1040KB stack) failed: Out of memory&quot;</span><br></code></pre></div></td></tr></table></figure><p>内存不足</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">W/libc: pthread_create failed: couldn<span class="hljs-string">&#x27;t allocate 1073152-bytes mapped space: Out of memory</span><br><span class="hljs-string">W/art: Throwing OutOfMemoryError with VmSize  4191668 kB &quot;pthread_create (1040KB stack) failed: Try again&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html">Probe：Android线上OOM问题定位组件</a></li><li><a href="https://www.jianshu.com/p/e574f0ffdb42">不可思议的OOM</a></li><li><a href="https://github.com/CharonChui/AndroidNote/blob/master/AdavancedPart/OOM%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md">OOM问题分析</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尾递归及尾递归优化</title>
    <link href="/2021/04/15/tailrec/"/>
    <url>/2021/04/15/tailrec/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h2><blockquote><p>这里有一篇文章讲得很好，转载自 <a href="https://blog.csdn.net/qq_34639378/article/details/78397312">浅谈Java中的递归与尾递归</a></p></blockquote><h3 id="首先我们讲讲递归"><a href="#首先我们讲讲递归" class="headerlink" title="首先我们讲讲递归"></a>首先我们讲讲递归</h3><p>递归的本质是，某个方法中调用了自身。本质还是调用一个方法，只是这个方法正好是自身而已，递归因为是在自身中调用自身，所以会带来以下三个显著特点：</p><ol><li>调用的是同一个方法</li><li>因为 1，所以只需要写一个方法，就可以让你轻松调用无数次（不用一个个写，你定个 n 就能有 n 个方法），所以调用的方法数可能非常巨大</li><li>在自身中调用自身，是嵌套调用（栈帧无法回收，开销巨大）</li></ol><p>因为上面 2 和 3 两个特点，所以递归调用最大的诟病就是开销巨大，栈帧和堆一起爆掉，俗称内存溢出（一个误区，不是因为调用自身而开销巨大，而是嵌套加上轻易就能无数次调用，使得递归可以很容易开销巨大），既然会导致内存泄露那肯定要想办法了，方法很简单，那就是尾递归优化</p><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p>尾递归优化是利用上面的第一个特点 “调用同一个方法” 来进行优化的，包括两个东西：</p><h4 id="尾递归的形式"><a href="#尾递归的形式" class="headerlink" title="尾递归的形式"></a>尾递归的形式</h4><p>尾递归其实只是一种对递归的特殊写法，这种写法原本并不会带来跟递归不一样的影响，它只是写法不一样而已，写成这样不会有任何优化效果，该爆的栈和帧都还会爆；具体不一样在哪里，前面说了，递归的本质是某个方法调用了自身，尾递归这种形式就要求：某个方法调用自身这件事，一定是该方法做的 <strong>最后一件事</strong>（所以当有需要返回值的时候会是 <code>return f(n)</code>，没有返回的话就直接是 <code>f(n)</code>）</p><p>要求很简单，就一条，但是有一些常见的误区：</p><ol><li>这个 <code>f(n)</code> 外不能加其他东西，因为这就不是最后一件事了，值返回来后还要再干点其他的活，变量空间还需要保留</li><li>如果有返回值的，你不能：乘个常数 <code>return 3f(n)</code>，乘个 n <code>return n*f(n)</code>，甚至是 <code>f(n)+f(n-1)</code></li></ol><h4 id="编译器对尾递归的优化"><a href="#编译器对尾递归的优化" class="headerlink" title="编译器对尾递归的优化"></a>编译器对尾递归的优化</h4><p>上面说了，你光手动写成尾递归的形式，并没有什么卵用，要实现优化，还需要编译器中加入了对尾递归优化的机制，有了这个机制，编译的时候就会自动利用上面的特点一来进行优化，简单说就是重复利用同一个栈帧，不仅不用释放上一个，连下一个新的都不用开，效率非常高（有人做实验，这个比递推比迭代都要效率高）</p><p>为什么写成尾递归的形式，编译器就能优化了？</p><ol><li>因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了</li><li>正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间</li></ol><p>所以总结为了解决递归的开销大问题，使用尾递归优化，具体分两步：</p><ol><li>你把递归调用的形式写成尾递归的形式</li><li>编译器碰到尾递归，自动按照某种特定的方式进行优化编译</li></ol><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 没有使用尾递归的形式</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recsum</span>(<span class="hljs-params">x</span>):</span><br>  <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> x<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> x + recsum(x - <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用尾递归的形式）</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tailrecsum</span>(<span class="hljs-params">x, running_total=<span class="hljs-number">0</span></span>):</span><br>  <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> running_total<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> tailrecsum(x - <span class="hljs-number">1</span>, running_total + x)<br></code></pre></div></td></tr></table></figure><p>但不是所有语言的编译器都做了尾递归优化。比如 C 实现了，JAVA 没有去实现，说到这里你很容易联想到 JAVA 中的自动垃圾回收机制，同是处理内存问题的机制，尾递归优化跟垃圾回收是不是有什么关系，这是不是就是 JAVA 不实现尾递归优化的原因？ </p><h3 id="所以下面要讲一下垃圾回收（GC）"><a href="#所以下面要讲一下垃圾回收（GC）" class="headerlink" title="所以下面要讲一下垃圾回收（GC）"></a>所以下面要讲一下垃圾回收（GC）</h3><p>首先我们需要谈一下内存机制，这里我们需要了解内存机制的两个部分：栈和堆。下面虽然是在说 JAVA，但是 C 也是差不多的</p><p>在 Java 中， JVM 中的栈记录了线程的方法调用，每个线程拥有一个栈，在某个线程的运行过程中如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈帧 (<code>frame</code>)。在 <code>frame</code> 中保存有该方法调用的参数、局部变量和返回地址；Java 的参数和局部变量只能是基本类型的变量(比如 <code>int</code>)，或者对象的引用(<code>reference</code>)，因此在栈中只保存有基本类型的变量和对象引用。而引用所指向的对象保存在堆中</p><p>然后由栈和堆的空间管理方式的不同，引出 <strong>垃圾回收</strong> 的概念，当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放，线程回到原方法继续执行，当所有的栈都清空时程序也随之运行结束</p><p>如上所述，栈(<code>stack</code>)可以自己照顾自己，但堆必须要小心对待。堆是 JVM 中一块可自由分配给对象的区域，当我们谈论垃圾回收 (garbage collection) 时，我们主要回收堆(<code>heap</code>)的空间</p><p>Java 的普通对象存活在堆中，与栈不同堆的空间不会随着方法调用结束而清空（即使它在栈上的引用已经被清空了），因此在某个方法中创建的对象，可以在方法调用结束之后继续存在于堆中，这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽</p><p>如果没有垃圾回收机制的话，你就需要手动地显式分配及释放内存，如果你忘了去释放内存，那么这块内存就无法重用了（不管是什么局部变量还是其他的什么）；这块内存被占有了却没被使用，这种场景被称之为 <strong>内存泄露</strong>，所以不管是 C 还是 JAVA，最原始的情况都是需要手动释放堆中的对象，C 到现在也是这样，所以你经常需要考虑对象的生存周期，但是 JAVA 则引入了一个自动垃圾回收的机制，它能智能地释放那些被判定已经没有用的对象 </p><h3 id="现在我们就可以比较一下尾递归优化和垃圾回收了"><a href="#现在我们就可以比较一下尾递归优化和垃圾回收了" class="headerlink" title="现在我们就可以比较一下尾递归优化和垃圾回收了"></a>现在我们就可以比较一下尾递归优化和垃圾回收了</h3><p>他们最本质的区别是：尾递归优化解决的是内存溢出的问题，而垃圾回收解决的是内存泄露的问题</p><ul><li>内存泄露指程序中动态分配内存给一些临时对象，但是对象不会被 GC 所回收，它始终占用内存，即被分配的对象可达但已无用</li><li>内存溢出指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于 Old 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况</li></ul><p>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。</p><p>自动垃圾回收机制的特点是：</p><ol><li>解决了所有情况下的内存泄露的问题，但还可以由于其他原因内存溢出</li><li>针对内存中的堆空间，正在运行的方法中的堆中的对象是不会被管理的，因为还有引用（栈帧没有被清空）</li><li>一般简单的自动垃圾回收机制是采用 <strong>引用计数</strong> 机制，每个对象包含一个计数器，当有新的指向该对象的引用时计数器加 1，当引用移除时计数器减 1，当计数器为 0 时认为该对象可以进行垃圾回收</li></ol><p>与之相对，尾递归优化的特点是：</p><ol><li>优化了递归调用时的内存溢出问题</li><li>针对内存中的堆空间和栈空间，正在运行的方法的堆和栈空间正是优化的目标</li><li>只在递归调用的时候使用，而且只能对于写成尾递归形式的递归进行优化</li></ol><h2 id="验证-Kotlin-的尾递归优化"><a href="#验证-Kotlin-的尾递归优化" class="headerlink" title="验证 Kotlin 的尾递归优化"></a>验证 Kotlin 的尾递归优化</h2><p>实现阶乘，<code>factorial</code> 是普通的递归版本，<code>factorialTail</code> 是尾递归版本（Kotlin 里除了要把递归函数写成尾递归的形式，还要添加 <code>tailrec</code> 关键字）</p><p>当计算 <code>5!</code> 时，通过控制台可以看到普通的递归会有 5 个栈帧（相当于从左至右计算：1 * 2 * 3 * 4 * 5）；而尾递归则只有一个栈帧，说明 Kotlin 确实通过尾递归优化减少了递归调用时的栈帧消耗（相当于从右至左计算：5 * 4 * 3 * 2 * 1）</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            println(factorial(n = <span class="hljs-number">5</span>))<br>            println(factorialTail(step = <span class="hljs-number">5</span>))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阶乘的普通递归版本</span><br><span class="hljs-comment"> * 5! = 1 * 2 * 3 * 4 * 5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorial</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (n) &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; &#123;<br>            printStack()<br>            <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> -&gt; factorial(n - <span class="hljs-number">1</span>) * n<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阶乘的尾递归版本</span><br><span class="hljs-comment"> * 添加关键字 tailrec 看看 Kotlin 会不会对其进行优化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorialTail</span><span class="hljs-params">(step: <span class="hljs-type">Int</span>, value: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">1</span>) &#123;<br>        printStack()<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    <span class="hljs-keyword">return</span> factorialTail(step - <span class="hljs-number">1</span>, step * value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printStack</span><span class="hljs-params">()</span></span> &#123;<br>    Exception().printStackTrace()<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../../../image/2021-04-15-tailrec/factorial_output.png" alt="factorial_output.png"></p><p>打开 class 文件可以看到，其实是把递归写法转换为 <code>while</code> 循环，从而实现「只使用一个栈帧」的目标 </p><p><img src="../../../../image/2021-04-15-tailrec/code.png" alt="code.png"></p><h2 id="验证-Java-的尾递归优化"><a href="#验证-Java-的尾递归优化" class="headerlink" title="验证 Java 的尾递归优化"></a>验证 Java 的尾递归优化</h2><p>从下面的控制台输出可以看到，无论是普通递归还是尾递归都产生了四个栈帧，说明 java 编译器并未实现对尾递归的优化</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阶乘的普通递归版本</span><br><span class="hljs-comment"> * 5! = 1 * 2 * 3 * 4 * 5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (n) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            printStack();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> factorial(n - <span class="hljs-number">1</span>) * n;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阶乘的尾递归版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">factorial_tail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">1</span>) &#123;<br>        printStack();<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> factorial_tail(step - <span class="hljs-number">1</span>, step * value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printStack</span><span class="hljs-params">()</span> </span>&#123;<br>    Log.e(<span class="hljs-string">&quot;cyrus&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Exception());<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../../../image/2021-04-15-tailrec/java_output.png" alt="java_output.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>tailrec</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeakCanary 浅析</title>
    <link href="/2021/04/12/leakcanary/"/>
    <url>/2021/04/12/leakcanary/</url>
    
    <content type="html"><![CDATA[<h2 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h2><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><table><thead><tr><th>引用类型</th><th>GC 时机</th></tr></thead><tbody><tr><td>强引用</td><td>平时写代码最常用的引用类型，对象只要被强引用就不会被 GC</td></tr><tr><td>软引用 <code>SoftReference</code></td><td>只有当内存不足时才会被 GC</td></tr><tr><td>弱引用 <code>WeakReference</code></td><td>会被正常 GC</td></tr><tr><td>虚引用 <code>PhantomReference</code></td><td>会被正常 GC，因为 <code>get()</code> 总是返回 null，一般用来跟踪对象的生命周期</td></tr></tbody></table><p>所有的引用类型都可以在构造时与一个 <code>ReferenceQueue</code> 关联，当引用的对象被 GC 后，这个 <code>Reference</code> 将被入队到关联的引用队列里</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/* -- Constructors -- */</span><br><br>    Reference(T referent) &#123;<br>        <span class="hljs-keyword">this</span>(referent, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    Reference(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue) &#123;<br>        <span class="hljs-keyword">this</span>.referent = referent;<br>        <span class="hljs-keyword">this</span>.queue = queue;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="如何检测泄漏对象"><a href="#如何检测泄漏对象" class="headerlink" title="如何检测泄漏对象"></a>如何检测泄漏对象</h3><p><code>ObjectWatcher</code> 实现了 <code>LeakCanary</code> 的泄漏检测机制：监控 - 等待 - 检查</p><p>用 <code>WeakReference</code> + <code>ReferenceQueue</code> 监控对象的 GC 状态，并用 <code>watchedObjects</code> 持有它的弱引用，key 是 UUID</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectWatcher</span> <span class="hljs-keyword">constructor</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;<br>) : ReachabilityWatcher &#123;<br><br>  <span class="hljs-comment">// 持有被监控对象的弱引用，以便后续的检查</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()<br><br>  <span class="hljs-comment">// 引用队列，被 GC 的对象的引用会进入此队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将指定对象交由 <code>ObjectWatcher</code> 进行监控</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 监控检测对象</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  removeWeaklyReachableObjects()  <span class="hljs-comment">// 从 watchedObjects 移除已被 GC 的对象</span><br><br>  <span class="hljs-comment">// 弱引用监控对象并放入 watchedObjects</span><br>  <span class="hljs-keyword">val</span> key = UUID.randomUUID().toString()<br>  <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>  SharkLog.d &#123;<br>    <span class="hljs-string">&quot;Watching &quot;</span> +<br>      (<span class="hljs-keyword">if</span> (watchedObject <span class="hljs-keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;instance of <span class="hljs-subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +<br>      (<span class="hljs-keyword">if</span> (description.isNotEmpty()) <span class="hljs-string">&quot; (<span class="hljs-variable">$description</span>)&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>) +<br>      <span class="hljs-string">&quot; with key <span class="hljs-variable">$key</span>&quot;</span><br>  &#125;<br>  watchedObjects[key] = reference<br><br>  <span class="hljs-comment">// 选机检查（默认 5s 后执行检查函数 moveToRetained）</span><br>  checkRetainedExecutor.execute &#123;<br>    moveToRetained(key)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 出现在 queue 里的对象已被成功 GC 就不需要监控了</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeWeaklyReachableObjects</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span><br>  <span class="hljs-comment">// reachable. This is before finalization or garbage collection has actually happened.</span><br>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?<br>  <span class="hljs-keyword">do</span> &#123;<br>    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?<br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>      watchedObjects.remove(ref.key)<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>检查是否发生泄漏，默认情况是等待 5s，让 GC 线程有足够的机会去发现并回收这个对象，如果 5s 后仍然没有被 GC（没有出现在引用队列里），那么可以证明这个对象发生了内存泄漏，被强引用导致存活超过它的生命周期</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 上面说过检查操作将提交给 checkRetainedExecutor 执行</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  checkRetainedExecutor.execute &#123;<br>    moveToRetained(key)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 而 checkRetainedExecutor 是通过构造函数传入的</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectWatcher</span> <span class="hljs-keyword">constructor</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;<br>)<br><br><span class="hljs-comment">// 默认是等待 5s 并在主线程执行检查操作</span><br><span class="hljs-keyword">object</span> AppWatcher &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> RETAINED_DELAY_NOT_SET = -<span class="hljs-number">1L</span><br>  <span class="hljs-meta">@Volatile</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retainedDelayMillis = RETAINED_DELAY_NOT_SET<br><br>  <span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(<br>    clock = &#123; SystemClock.uptimeMillis() &#125;,<br>    checkRetainedExecutor = &#123;<br>      check(isInstalled) &#123;<br>        <span class="hljs-string">&quot;AppWatcher not installed&quot;</span><br>      &#125;<br>      mainHandler.postDelayed(it, retainedDelayMillis)  <span class="hljs-comment">// 在主线程执行检查</span><br>    &#125;,<br>    isEnabled = &#123; <span class="hljs-literal">true</span> &#125;<br>  )<br><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,   <span class="hljs-comment">// 默认等待 5s</span><br>    watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<br>  ) &#123;<br>    checkMainThread()<br>    <span class="hljs-keyword">if</span> (isInstalled) &#123;<br>      <span class="hljs-keyword">throw</span> IllegalStateException(<br>        <span class="hljs-string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause<br>      )<br>    &#125;<br>    check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span><br>    &#125;<br>    installCause = RuntimeException(<span class="hljs-string">&quot;manualInstall() first called here&quot;</span>)<br>    <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis<br>    <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;<br>      LogcatSharkLog.install()<br>    &#125;<br>    <span class="hljs-comment">// Requires AppWatcher.objectWatcher to be set</span><br>    LeakCanaryDelegate.loadLeakCanary(application)<br><br>    watchersToInstall.forEach &#123;<br>      it.install()<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果没有出现在引用队列里，说明此对象已发生泄漏，发出通知</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()    <span class="hljs-comment">// 出现在引用队列里说明对象已被 GC，可以从 watchedObjects 移除</span><br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测-Activity-泄漏"><a href="#检测-Activity-泄漏" class="headerlink" title="检测 Activity 泄漏"></a>检测 <code>Activity</code> 泄漏</h3><p>通过 <code>ActivityLifecycleCallbacks.onActivityDestroyed</code> 可以收集到 destoryed <code>Activity</code>，这些 <code>Activity</code> 已走完它的生命周期，应该被后续的 GC 回收掉</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 收集 destroyed Activity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityWatcher</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测-Fragment-和-View-的泄漏"><a href="#检测-Fragment-和-View-的泄漏" class="headerlink" title="检测 Fragment 和 View 的泄漏"></a>检测 <code>Fragment</code> 和 <code>View</code> 的泄漏</h3><p>利用 <code>FragmentLifecycleCallbacks</code> 发现被 destroyed <code>Fragment</code> 和 <code>View</code>，然后用 <code>ObjectWatcher</code> 监控是否发生泄漏</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidXFragmentDestroyWatcher</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-comment">// 发现 View</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          view, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +<br>          <span class="hljs-string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 发现 Fragment</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测-ViewModel-泄漏"><a href="#检测-ViewModel-泄漏" class="headerlink" title="检测 ViewModel 泄漏"></a>检测 <code>ViewModel</code> 泄漏</h3><p><code>Fragment</code> 里的 <code>ViewModel</code> 则是在 <code>FragmentLifecycleCallbacks.onFragmentCreated</code> 时，注入一个 <code>ViewModel</code>，通过反射拿到 <code>ViewModelStore.mMap</code>，这里有所有的 <code>ViewModel</code>，在 <code>ViewModel.onCleared</code> 时把它们加入 <code>ObjectWatcher</code> 进行泄漏检查</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelClearedWatcher</span></span>(<br>  storeOwner: ViewModelStoreOwner,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : ViewModel() &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;?<br><br>  <span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span><br>    <span class="hljs-comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span><br>    <span class="hljs-comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span><br>    viewModelMap = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> mMapField = ViewModelStore::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>      mMapField.isAccessible = <span class="hljs-literal">true</span><br>      <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>      mMapField[storeOwner.viewModelStore] <span class="hljs-keyword">as</span> Map&lt;String, ViewModel&gt;<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Exception) &#123;<br>      <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> &#123;<br>    viewModelMap?.values?.forEach &#123; viewModel -&gt;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        viewModel, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      storeOwner: <span class="hljs-type">ViewModelStoreOwner</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="hljs-keyword">object</span> : Factory &#123;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel?&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T =<br>          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="hljs-keyword">as</span> T<br>      &#125;)<br>      provider.<span class="hljs-keyword">get</span>(ViewModelClearedWatcher::<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测更多类型的泄漏"><a href="#检测更多类型的泄漏" class="headerlink" title="检测更多类型的泄漏"></a>检测更多类型的泄漏</h3><p>对 <code>Service</code> 的检查就比较 hack 了，通过反射替换 <code>ActivityThread.mH.mCallback</code>，通过 <code>Message.waht == H.STOP_SERVICE</code> 定位到 <code>ActivityThread.handleStopService</code> 的调用时机，然后把这个被 stop 的 <code>Service</code> 记录下来；用动态代理实现 <code>IActivityManager</code> 并替换掉 <code>ActivityManager.IActivityManagerSinglteon.mInstance</code>，从而拦截方法 <code>serviceDoneExecuting</code>，此方法的调用表示 <code>Service</code> 生命周期已完结，可以把它交由 <code>ObjectWatcher</code> 进行监控</p><p>这给我启示，对于我们感兴趣的对象（需要警惕泄漏的对象，比如 <code>Bitmap</code>），都可以通过 <code>ObjectWatcher</code> 去检测泄漏问题</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> : <span class="hljs-type">Service &#123;</span></span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onDestroy()<br>    AppWatcher.objectWatcher.watch(<br>      watchedObject = <span class="hljs-keyword">this</span>,<br>      description = <span class="hljs-string">&quot;MyService received Service#onDestroy() callback&quot;</span><br>    )<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Heap-Dump"><a href="#Heap-Dump" class="headerlink" title="Heap Dump"></a>Heap Dump</h2><p>发现对象泄漏后触发 <code>OnObjectRetainedListener.onObjectRetained()</code>，最终调用 <code>Debug.dumpHprofData</code> 生成 hprof 文件</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onObjectRetained</span><span class="hljs-params">()</span></span> = scheduleRetainedObjectCheck()<br><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::heapDumpTrigger.isInitialized) &#123;<br>      heapDumpTrigger.scheduleRetainedObjectCheck()<br>    &#125;<br>  &#125;  <br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapDumpTrigger</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>    <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<br>    backgroundHandler.postDelayed(&#123;<br>      checkScheduledAt = <span class="hljs-number">0</span><br>      checkRetainedObjects()<br>    &#125;, delayMillis)<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    dumpHeap(<br>      retainedReferenceCount = retainedReferenceCount,<br>      retry = <span class="hljs-literal">true</span>,<br>      reason = <span class="hljs-string">&quot;<span class="hljs-variable">$retainedReferenceCount</span> retained objects, app is <span class="hljs-variable">$visibility</span>&quot;</span><br>    )<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    retainedReferenceCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    retry: <span class="hljs-type">Boolean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    reason: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    saveResourceIdNamesToMemory()<br>    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapDumpResult = heapDumper.dumpHeap()) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;    <br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidHeapDumper</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">()</span></span>: DumpHeapResult &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">val</span> durationMillis = measureDurationMillis &#123;<br>      Debug.dumpHprofData(heapDumpFile.absolutePath)<br>    &#125;<br>    <span class="hljs-comment">// ...  </span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="解析-hprof-文件"><a href="#解析-hprof-文件" class="headerlink" title="解析 hprof 文件"></a>解析 hprof 文件</h2><h3 id="hprof-文件格式"><a href="#hprof-文件格式" class="headerlink" title="hprof 文件格式"></a>hprof 文件格式</h3><p><img src="../../../../image/2021-04-12-leakcanary/java_hprof.png" alt="Java Hprof 格式"></p><p><img src="../../../../image/2021-04-12-leakcanary/android_hprof.png" alt="Android Hprof 格式"></p><p>hprof 是结构紧凑的二进制文件，整体上分为 <code>Header</code> 和 <code>Record</code> 数组两大部分</p><p><code>Header</code> 总共 18 + 4 + 4 + 4 = 32 字节，包括：</p><ol><li>格式名和版本号：JAVA PROFILE 1.0.3（18 字节）</li><li>标识符大小（4 字节）</li><li>高位时间戳（4 字节）</li><li>地位时间戳（4 字节）</li></ol><p><img src="../../../../image/2021-04-12-leakcanary/hprof_header.png" alt="Hprof Header 结构"></p><p><code>Record</code> 数组记录了内存中的各种数据</p><ol><li>TAG，<code>Record</code> 的类型（1 字节）</li><li>TIME，时间戳（4 字节）</li><li>LENGTH，<code>Record</code> BODY 的长度（4 字节）</li><li>BODY，不同的 <code>Record</code> 类型有不同的 BODY</li></ol><p><img src="../../../../image/2021-04-12-leakcanary/hprof_record.png" alt="Hprof Record 结构"></p><p>支持的 <code>TAG</code> 类型主要有：</p><ul><li>STRING_IN_UTF8             = 0x01</li><li>LOAD_CLASS                 = 0x02</li><li>STACK_FRAME                = 0x04</li><li>STACK_TRACE                = 0x05</li><li><strong>HEAP_DUMP</strong>              = 0x0c</li><li><strong>HEAP_DUMP_SEGMENT</strong>      = 0x1c<ul><li>ROOT_UNKNOWN             = 0xff</li><li>ROOT_JNI_GLOBAL          = 0x01</li><li>ROOT_JNI_LOCAL           = 0x02</li><li>ROOT_JAVA_FRAME          = 0x03</li><li><strong>CLASS_DUMP</strong>           = 0x20</li><li><strong>INSTANCE_DUMP</strong>        = 0x21</li><li><strong>OBJECT_ARRAY_DUMP</strong>    = 0x22</li><li><strong>PRIMITIVE_ARRAY_DUMP</strong> = 0x23</li></ul></li><li>HEAP_DUMP_END              = 0x2c</li></ul><p><code>CLASS_DUMP</code>、<code>INSTANCE_DUMP</code> 等重要结构可以看 <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF Agent</a></p><h3 id="解析-Header"><a href="#解析-Header" class="headerlink" title="解析 Header"></a>解析 Header</h3><p>拿到 hprof 文件后，从 <code>HeapAnalyzerService.runAnalysis</code> 开始解析流程</p><p><code>LeakCanary</code> 使用 <code>Shark</code> 解析 hprof 文件，首先解析出头部 <code>HprofHeader</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">HeapAnalyzerService.runAnalysis<br>HeapAnalyzerService.onHandleIntentInForeground<br>HeapAnalyzerService.analyzeHeap<br>HeapAnalyzer.analyze<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> DualSourceProvider.<span class="hljs-title">openHeapGraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  indexedGcRootTypes: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = HprofIndex.defaultIndexedGcRootTags()</span></span><br>): CloseableHeapGraph &#123;<br>  <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 解析出 HprofHeader</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseHeaderOf</span><span class="hljs-params">(source: <span class="hljs-type">BufferedSource</span>)</span></span>: HprofHeader &#123;<br>  require(!source.exhausted()) &#123;<br>    <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Source has no available bytes&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 开头是版本号 JAVA PROFILE 1.0.3，以 0 结尾</span><br>  <span class="hljs-keyword">val</span> endOfVersionString = source.indexOf(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">val</span> versionName = source.readUtf8(endOfVersionString)<br>  <span class="hljs-keyword">val</span> version = supportedVersions[versionName]<br>  checkNotNull(version) &#123;<br>    <span class="hljs-string">&quot;Unsupported Hprof version [<span class="hljs-variable">$versionName</span>] not in supported list <span class="hljs-subst">$&#123;supportedVersions.keys&#125;</span>&quot;</span><br>  &#125;<br>  <span class="hljs-comment">// Skip the 0 at the end of the version string.</span><br>  source.skip(<span class="hljs-number">1</span>)<br><br>  <span class="hljs-comment">// 然后是 ID 的长度</span><br>  <span class="hljs-keyword">val</span> identifierByteSize = source.readInt()<br><br>  <span class="hljs-comment">// 时间戳</span><br>  <span class="hljs-keyword">val</span> heapDumpTimestamp = source.readLong()<br>  <span class="hljs-keyword">return</span> HprofHeader(heapDumpTimestamp, version, identifierByteSize)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="构造索引-HprofIndex"><a href="#构造索引-HprofIndex" class="headerlink" title="构造索引 HprofIndex"></a>构造索引 <code>HprofIndex</code></h3><p>从 <code>openHeapGraph</code> 里构造完 <code>HprofHeader</code> 后，开始解析 <code>HprofIndex</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> DualSourceProvider.<span class="hljs-title">openHeapGraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  indexedGcRootTypes: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = HprofIndex.defaultIndexedGcRootTags()</span></span><br>): CloseableHeapGraph &#123;<br>  <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;<br>  <span class="hljs-keyword">val</span> index = HprofIndex.indexRecordsOf(<span class="hljs-keyword">this</span>, header, proguardMapping, indexedGcRootTypes)<br>  <span class="hljs-keyword">return</span> index.openHeapGraph()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an in memory index of an hprof source provided by [hprofSourceProvider].</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexRecordsOf</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  hprofSourceProvider: <span class="hljs-type">DualSourceProvider</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  hprofHeader: <span class="hljs-type">HprofHeader</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  indexedGcRootTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = defaultIndexedGcRootTags()</span></span><br>): HprofIndex &#123;<br>  <span class="hljs-keyword">val</span> reader = StreamingHprofReader.readerFor(hprofSourceProvider, hprofHeader)<br>  <span class="hljs-keyword">val</span> index = HprofInMemoryIndex.indexHprof(<br>    reader = reader,<br>    hprofHeader = hprofHeader,<br>    proguardMapping = proguardMapping,<br>    indexedGcRootTags = indexedGcRootTags<br>  )<br>  <span class="hljs-keyword">return</span> HprofIndex(hprofSourceProvider, hprofHeader, index)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对象之所以会泄漏，是因为它被 GC ROOT 持有超过它的生命周期，所以分析 hprof 文件的首要目标是找出泄漏对象的 GC ROOT PATH；虽然 hprof 包含方方面面的信息，我们只关注需要的那几部分：<code>STRING_IN_UTF8</code>、<code>CLASS_DUMP</code>、<code>INSTANCE_DUMP</code>、<code>GC ROOT</code> 等等，其他的都不需要；而且 hprof 包含的数据非常多，全部加载到内存很容易发生 OOM</p><p>这个阶段的 <code>HprofInMemoryIndex</code> 主要包含以下信息</p><ul><li><code>hprofStringCache</code> 字符串池，string id -&gt; String，对应 TAG <code>STRING_IN_UTF8</code>，用来查找类名</li><li><code>classNames</code> 类名称池，class id -&gt; string id，对应 TAG <code>LOAD_CLASS</code>，通过类名 <code>leakcanary.KeyedWeakReference</code> 找到泄漏对象</li><li><code>gcRoots</code> GC ROOT 对象 id 数组</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HprofInMemoryIndex</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> positionSize: <span class="hljs-built_in">Int</span>,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> hprofStringCache: LongObjectScatterMap&lt;String&gt;,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> classNames: LongLongScatterMap,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> classIndex: SortedBytesMap,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> instanceIndex: SortedBytesMap,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectArrayIndex: SortedBytesMap,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> primitiveArrayIndex: SortedBytesMap,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gcRoots: List&lt;GcRoot&gt;,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> proguardMapping: ProguardMapping?,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForClassSize: <span class="hljs-built_in">Int</span>,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForInstanceSize: <span class="hljs-built_in">Int</span>,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForObjectArraySize: <span class="hljs-built_in">Int</span>,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForPrimitiveArraySize: <span class="hljs-built_in">Int</span>,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> useForwardSlashClassPackageSeparator: <span class="hljs-built_in">Boolean</span>,<br>  <span class="hljs-keyword">val</span> classFieldsReader: ClassFieldsReader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> classFieldsIndexSize: <span class="hljs-built_in">Int</span><br>)<br></code></pre></div></td></tr></table></figure><p>参照 <code>Record</code> 的结构读取需要的内容</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexHprof</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  reader: <span class="hljs-type">StreamingHprofReader</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  hprofHeader: <span class="hljs-type">HprofHeader</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">  indexedGcRootTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: HprofInMemoryIndex &#123;<br><br>  <span class="hljs-comment">// 首先过一遍 hprof，计算出 class，instance，object array 和 primitive array 的数量</span><br>  <span class="hljs-comment">// First pass to count and correctly size arrays once and for all.</span><br>  <span class="hljs-keyword">var</span> maxClassSize = <span class="hljs-number">0L</span><br>  <span class="hljs-keyword">var</span> maxInstanceSize = <span class="hljs-number">0L</span><br>  <span class="hljs-keyword">var</span> maxObjectArraySize = <span class="hljs-number">0L</span><br>  <span class="hljs-keyword">var</span> maxPrimitiveArraySize = <span class="hljs-number">0L</span><br>  <span class="hljs-keyword">var</span> classCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> instanceCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> objectArrayCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> primitiveArrayCount = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> classFieldsTotalBytes = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">val</span> bytesRead = reader.readRecords(<br>    EnumSet.of(CLASS_DUMP, INSTANCE_DUMP, OBJECT_ARRAY_DUMP, PRIMITIVE_ARRAY_DUMP),<br>    OnHprofRecordTagListener &#123; tag, _, reader -&gt;<br>      <span class="hljs-keyword">val</span> bytesReadStart = reader.bytesRead<br>      <span class="hljs-keyword">when</span> (tag) &#123;<br>        CLASS_DUMP -&gt; &#123;<br>          classCount++<br>          reader.skipClassDumpHeader()<br>          <span class="hljs-keyword">val</span> bytesReadStaticFieldStart = reader.bytesRead<br>          reader.skipClassDumpStaticFields()<br>          reader.skipClassDumpFields()<br>          maxClassSize = max(maxClassSize, reader.bytesRead - bytesReadStart)<br>          classFieldsTotalBytes += (reader.bytesRead - bytesReadStaticFieldStart).toInt()<br>        &#125;<br>        INSTANCE_DUMP -&gt; &#123;<br>          instanceCount++<br>          reader.skipInstanceDumpRecord()<br>          maxInstanceSize = max(maxInstanceSize, reader.bytesRead - bytesReadStart)<br>        &#125;<br>        OBJECT_ARRAY_DUMP -&gt; &#123;<br>          objectArrayCount++<br>          reader.skipObjectArrayDumpRecord()<br>          maxObjectArraySize = max(maxObjectArraySize, reader.bytesRead - bytesReadStart)<br>        &#125;<br>        PRIMITIVE_ARRAY_DUMP -&gt; &#123;<br>          primitiveArrayCount++<br>          reader.skipPrimitiveArrayDumpRecord()<br>          maxPrimitiveArraySize = max(maxPrimitiveArraySize, reader.bytesRead - bytesReadStart)<br>        &#125;<br>      &#125;<br>    &#125;)<br><br>  <span class="hljs-comment">// 第二次才读取 string、class、instance 等结构信息  </span><br>  <span class="hljs-keyword">val</span> bytesForClassSize = byteSizeForUnsigned(maxClassSize)<br>  <span class="hljs-keyword">val</span> bytesForInstanceSize = byteSizeForUnsigned(maxInstanceSize)<br>  <span class="hljs-keyword">val</span> bytesForObjectArraySize = byteSizeForUnsigned(maxObjectArraySize)<br>  <span class="hljs-keyword">val</span> bytesForPrimitiveArraySize = byteSizeForUnsigned(maxPrimitiveArraySize)<br>  <span class="hljs-keyword">val</span> indexBuilderListener = Builder(<br>    longIdentifiers = hprofHeader.identifierByteSize == <span class="hljs-number">8</span>,<br>    maxPosition = bytesRead,<br>    classCount = classCount,<br>    instanceCount = instanceCount,<br>    objectArrayCount = objectArrayCount,<br>    primitiveArrayCount = primitiveArrayCount,<br>    bytesForClassSize = bytesForClassSize,<br>    bytesForInstanceSize = bytesForInstanceSize,<br>    bytesForObjectArraySize = bytesForObjectArraySize,<br>    bytesForPrimitiveArraySize = bytesForPrimitiveArraySize,<br>    classFieldsTotalBytes = classFieldsTotalBytes<br>  )<br>  <span class="hljs-keyword">val</span> recordTypes = EnumSet.of(<br>    STRING_IN_UTF8,<br>    LOAD_CLASS,<br>    CLASS_DUMP,<br>    INSTANCE_DUMP,<br>    OBJECT_ARRAY_DUMP,<br>    PRIMITIVE_ARRAY_DUMP<br>  ) + HprofRecordTag.rootTags.intersect(indexedGcRootTags)<br>  reader.readRecords(recordTypes, indexBuilderListener)<br>  <span class="hljs-keyword">return</span> indexBuilderListener.buildIndex(proguardMapping, hprofHeader)<br>&#125;<br><br><span class="hljs-comment">// 类似 SAX 地流式读取各个 Record 结构，然后回调给 listener 处理</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readRecords</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  recordTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  listener: <span class="hljs-type">OnHprofRecordTagListener</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Long</span> &#123;<br>  <span class="hljs-keyword">return</span> sourceProvider.openStreamingSource().use &#123; source -&gt;<br>    <span class="hljs-keyword">val</span> reader = HprofRecordReader(header, source)<br>    reader.skip(header.recordsPosition)<br>    <span class="hljs-comment">// Local ref optimizations</span><br>    <span class="hljs-keyword">val</span> intByteSize = INT.byteSize<br>    <span class="hljs-keyword">val</span> identifierByteSize = reader.sizeOf(REFERENCE_HPROF_TYPE)<br>    <span class="hljs-keyword">while</span> (!source.exhausted()) &#123;<br>      <span class="hljs-comment">// type of the record</span><br>      <span class="hljs-keyword">val</span> tag = reader.readUnsignedByte()<br>      <span class="hljs-comment">// number of microseconds since the time stamp in the header</span><br>      reader.skip(intByteSize)<br>      <span class="hljs-comment">// number of bytes that follow and belong to this record</span><br>      <span class="hljs-keyword">val</span> length = reader.readUnsignedInt()<br>      <span class="hljs-keyword">when</span> (tag) &#123;<br>        STRING_IN_UTF8.tag -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (STRING_IN_UTF8 <span class="hljs-keyword">in</span> recordTags) &#123;<br>            listener.onHprofRecord(STRING_IN_UTF8, length, reader)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            reader.skip(length)<br>          &#125;<br>        &#125;<br>        LOAD_CLASS.tag -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (LOAD_CLASS <span class="hljs-keyword">in</span> recordTags) &#123;<br>            listener.onHprofRecord(LOAD_CLASS, length, reader)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            reader.skip(length)<br>          &#125;<br>        &#125;<br>        STACK_FRAME.tag -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (STACK_FRAME <span class="hljs-keyword">in</span> recordTags) &#123;<br>            listener.onHprofRecord(STACK_FRAME, length, reader)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            reader.skip(length)<br>          &#125;<br>        &#125;<br>        STACK_TRACE.tag -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (STACK_TRACE <span class="hljs-keyword">in</span> recordTags) &#123;<br>            listener.onHprofRecord(STACK_TRACE, length, reader)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            reader.skip(length)<br>          &#125;<br>        &#125;<br>        HEAP_DUMP.tag, HEAP_DUMP_SEGMENT.tag -&gt; &#123;<br>          <span class="hljs-keyword">val</span> heapDumpStart = reader.bytesRead<br>          <span class="hljs-keyword">var</span> previousTag = <span class="hljs-number">0</span><br>          <span class="hljs-keyword">var</span> previousTagPosition = <span class="hljs-number">0L</span><br>          <span class="hljs-keyword">while</span> (reader.bytesRead - heapDumpStart &lt; length) &#123;<br>            <span class="hljs-keyword">val</span> heapDumpTagPosition = reader.bytesRead<br>            <span class="hljs-keyword">val</span> heapDumpTag = reader.readUnsignedByte()<br>            <span class="hljs-keyword">when</span> (heapDumpTag) &#123;<br>              ROOT_UNKNOWN.tag -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (ROOT_UNKNOWN <span class="hljs-keyword">in</span> recordTags) &#123;<br>                  listener.onHprofRecord(ROOT_UNKNOWN, -<span class="hljs-number">1</span>, reader)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  reader.skip(identifierByteSize)<br>                &#125;<br>              &#125;<br>              ROOT_JNI_GLOBAL.tag -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (ROOT_JNI_GLOBAL <span class="hljs-keyword">in</span> recordTags) &#123;<br>                  listener.onHprofRecord(ROOT_JNI_GLOBAL, -<span class="hljs-number">1</span>, reader)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  reader.skip(identifierByteSize + identifierByteSize)<br>                &#125;<br>              &#125;<br>              ROOT_JNI_LOCAL.tag -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (ROOT_JNI_LOCAL <span class="hljs-keyword">in</span> recordTags) &#123;<br>                  listener.onHprofRecord(ROOT_JNI_LOCAL, -<span class="hljs-number">1</span>, reader)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  reader.skip(identifierByteSize + intByteSize + intByteSize)<br>                &#125;<br>              &#125;<br>              ROOT_JAVA_FRAME.tag -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (ROOT_JAVA_FRAME <span class="hljs-keyword">in</span> recordTags) &#123;<br>                  listener.onHprofRecord(ROOT_JAVA_FRAME, -<span class="hljs-number">1</span>, reader)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  reader.skip(identifierByteSize + intByteSize + intByteSize)<br>                &#125;<br>              &#125;<br>              <span class="hljs-comment">// ...</span><br>            &#125;<br>            previousTag = heapDumpTag<br>            previousTagPosition = heapDumpTagPosition<br>          &#125;<br>        &#125;<br>        HEAP_DUMP_END.tag -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (HEAP_DUMP_END <span class="hljs-keyword">in</span> recordTags) &#123;<br>            listener.onHprofRecord(HEAP_DUMP_END, length, reader)<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> -&gt; &#123;<br>          reader.skip(length)<br>        &#125;<br>      &#125;<br>    &#125;<br>    reader.bytesRead<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找泄漏对象"><a href="#查找泄漏对象" class="headerlink" title="查找泄漏对象"></a>查找泄漏对象</h3><p>泄漏对象被 <code>KeyedWeakReference</code> 弱引用并保存在 <code>ObjectWatcher.watchedObjects</code>，那么通过全限定类名 <code>leakcanary.KeyedWeakReference&quot;</code>/ <code>com.squareup.leakcanary.KeyedWeakReference</code> 找到 class id，通过 class id 找到 instance Record，在 instance Record 里找到名为 <code>referent</code> 的成员变量值，这个值就是泄漏对象的 instance id，最终会产生一个泄漏对象 instance id 数组 <code>leakingObjectIds</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> HeapAnalyzer.<span class="hljs-title">analyze</span><span class="hljs-params">(...)</span></span>: HeapAnalysis &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">val</span> sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))<br>  sourceProvider.openHeapGraph(proguardMapping).use &#123; graph -&gt;<br>    <span class="hljs-keyword">val</span> helpers =<br>      FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>    <span class="hljs-keyword">val</span> result = helpers.analyzeGraph(<br>      metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>    )<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">analyzeGraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  metadataExtractor: <span class="hljs-type">MetadataExtractor</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  heapDumpFile: <span class="hljs-type">File</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  analysisStartNanoTime: <span class="hljs-type">Long</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: HeapAnalysisSuccess &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">val</span> leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)<br>  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks, unreachableObjects) = findLeaks(leakingObjectIds)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">object</span> KeyedWeakReferenceFinder : LeakingObjectFinder &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findLeakingObjectIds</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: Set&lt;<span class="hljs-built_in">Long</span>&gt; =<br>    findKeyedWeakReferences(graph)<br>      .filter &#123; it.hasReferent &amp;&amp; it.isRetained &#125;<br>      .map &#123; it.referent.value &#125;<br>      .toSet()<br><br>  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findKeyedWeakReferences</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: List&lt;KeyedWeakReferenceMirror&gt; &#123;<br>    <span class="hljs-keyword">return</span> graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) &#123;<br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClass = graph.findClassByName(<span class="hljs-string">&quot;leakcanary.KeyedWeakReference&quot;</span>)<br><br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClassId = keyedWeakReferenceClass?.objectId ?: <span class="hljs-number">0</span><br>      <span class="hljs-keyword">val</span> legacyKeyedWeakReferenceClassId =<br>        graph.findClassByName(<span class="hljs-string">&quot;com.squareup.leakcanary.KeyedWeakReference&quot;</span>)?.objectId ?: <span class="hljs-number">0</span><br><br>      <span class="hljs-keyword">val</span> heapDumpUptimeMillis = heapDumpUptimeMillis(graph)<br><br>      <span class="hljs-keyword">val</span> addedToContext: List&lt;KeyedWeakReferenceMirror&gt; = graph.instances<br>        .filter &#123; instance -&gt;<br>          instance.instanceClassId == keyedWeakReferenceClassId || instance.instanceClassId == legacyKeyedWeakReferenceClassId<br>        &#125;<br>        .map &#123;<br>          KeyedWeakReferenceMirror.fromInstance(<br>            it, heapDumpUptimeMillis<br>          )<br>        &#125;<br>        .toList()<br>      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext<br>      addedToContext<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从逻辑上看引用关系是个图，图中的节点有个指向父节点的指针 <code>Node.parent</code>，而 GC ROOT 就是图中的根节点，它们没有 <code>parent</code>，GC ROOT 包括以下几类：</p><ol><li><code>ROOT UNKNOWN</code></li><li><code>ROOT JNI GLOBAL</code></li><li><code>ROOT JNI LOCAL</code></li><li><code>ROOT JAVA FRAME</code></li><li><code>ROOT NATIVE STACK</code></li><li><code>ROOT STICKY CLASS</code></li><li><code>ROOT THREAD BLOCK</code></li><li><code>ROOT MONITOR USED</code></li><li><code>ROOT THREAD OBJECT</code></li></ol><p>GC ROOT 的成员变量作为子节点，<code>parent</code> 指向 GC ROOT，成员变量还有成员变量作为子节点，这样就形成了一个很大的图</p><p>为了构造上面的引用图以及它们的引用关系，我们使用 <code>Stack</code> 来遍历找到的 <code>Record</code>，首先把 GC ROOT 都入栈，然后依次出栈执行：找到非空的成员变量并加入栈中（此时能够建立 parent - child 二级关系），如果 instance id == leakingObjectId 则记录起来，直到栈空或者已找完所有的泄漏对象；每一层二级关系的建立最终使所有关联的节点连接起来形成图，这样就可以沿着 <code>Node.parent</code> 一直往上走到 GC ROOT，这样泄漏对象的 GC ROOT PATH 就出来了</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: LeaksAndUnreachableObjects &#123;<br>  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)<br>  <span class="hljs-keyword">val</span> pathFindingResults =<br>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  computeRetainedHeapSize: <span class="hljs-type">Boolean</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: PathFindingResults &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">val</span> state = State(<br>    leakingObjectIds = leakingObjectIds.toLongScatterSet(),<br>    sizeOfObjectInstances = sizeOfObjectInstances,<br>    computeRetainedHeapSize = computeRetainedHeapSize,<br>    javaLangObjectId = javaLangObjectId,<br>    estimatedVisitedObjects = estimatedVisitedObjects<br>  )<br>  <span class="hljs-keyword">return</span> state.findPathsFromGcRoots()<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> State.<span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">()</span></span>: PathFindingResults &#123;<br>  <span class="hljs-comment">// 首先将 GC ROOT 入队</span><br>  enqueueGcRoots()<br><br>  <span class="hljs-keyword">val</span> shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()<br>  <span class="hljs-symbol">visitingQueue@</span> <span class="hljs-keyword">while</span> (queuesNotEmpty) &#123;<br>    <span class="hljs-keyword">val</span> node = poll()<br>    <span class="hljs-keyword">if</span> (leakingObjectIds.contains(node.objectId)) &#123;<br>      shortestPathsToLeakingObjects.add(node)<br>      <span class="hljs-comment">// Found all refs, stop searching (unless computing retained size)</span><br>      <span class="hljs-keyword">if</span> (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) &#123;<br>        <span class="hljs-keyword">if</span> (computeRetainedHeapSize) &#123;<br>          listener.onAnalysisProgress(FINDING_DOMINATORS)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">break</span><span class="hljs-symbol">@visitingQueue</span><br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到子节点（类的静态成员变量、实例的成员变量等等）</span><br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapObject = graph.findObjectById(node.objectId)) &#123;<br>      <span class="hljs-keyword">is</span> HeapClass -&gt; visitClassRecord(heapObject, node)<br>      <span class="hljs-keyword">is</span> HeapInstance -&gt; visitInstance(heapObject, node)<br>      <span class="hljs-keyword">is</span> HeapObjectArray -&gt; visitObjectArray(heapObject, node)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> PathFindingResults(<br>    shortestPathsToLeakingObjects,<br>    <span class="hljs-keyword">if</span> (visitTracker <span class="hljs-keyword">is</span> Dominated) visitTracker.dominatorTree <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面找到了所有泄漏对象的 GC ROOT PATH，但可能出现重复，这里利用前缀树删除重复路径；前缀树节点 <code>Node</code> 用 <code>Map&lt;Long, Node&gt;</code> 表示它引用了某个对象，叶子节点就是泄漏对象，最后广度优先遍历前缀树，将每个叶子节点及其路径记下来</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: LeaksAndUnreachableObjects &#123;<br>  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)<br>  <span class="hljs-keyword">val</span> pathFindingResults =<br>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)<br>  <span class="hljs-keyword">val</span> unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)<br>  <span class="hljs-keyword">val</span> shortestPaths =<br>    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 利用前缀树删除重复路径</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deduplicateShortestPaths</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">   inputPathResults: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferencePathNode</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function"> )</span></span>: List&lt;ShortestPath&gt; &#123;<br>   <span class="hljs-keyword">val</span> rootTrieNode = ParentNode(<span class="hljs-number">0</span>)<br><br>   inputPathResults.forEach &#123; pathNode -&gt;<br>     <span class="hljs-comment">// Go through the linked list of nodes and build the reverse list of instances from</span><br>     <span class="hljs-comment">// root to leaking.</span><br>     <span class="hljs-keyword">val</span> path = mutableListOf&lt;<span class="hljs-built_in">Long</span>&gt;()<br>     <span class="hljs-keyword">var</span> leakNode: ReferencePathNode = pathNode<br>     <span class="hljs-keyword">while</span> (leakNode <span class="hljs-keyword">is</span> ChildNode) &#123;<br>       path.add(<span class="hljs-number">0</span>, leakNode.objectId)<br>       leakNode = leakNode.parent<br>     &#125;<br>     path.add(<span class="hljs-number">0</span>, leakNode.objectId)<br>     updateTrie(pathNode, path, <span class="hljs-number">0</span>, rootTrieNode)<br>   &#125;<br><br>   <span class="hljs-keyword">val</span> outputPathResults = mutableListOf&lt;ReferencePathNode&gt;()<br>   findResultsInTrie(rootTrieNode, outputPathResults)<br><br>   <span class="hljs-keyword">if</span> (outputPathResults.size != inputPathResults.size) &#123;<br>     SharkLog.d &#123;<br>       <span class="hljs-string">&quot;Found <span class="hljs-subst">$&#123;inputPathResults.size&#125;</span> paths to retained objects,&quot;</span> +<br>         <span class="hljs-string">&quot; down to <span class="hljs-subst">$&#123;outputPathResults.size&#125;</span> after removing duplicated paths&quot;</span><br>     &#125;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     SharkLog.d &#123; <span class="hljs-string">&quot;Found <span class="hljs-subst">$&#123;outputPathResults.size&#125;</span> paths to retained objects&quot;</span> &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> outputPathResults.map &#123; retainedObjectNode -&gt;<br>     <span class="hljs-keyword">val</span> shortestChildPath = mutableListOf&lt;ChildNode&gt;()<br>     <span class="hljs-keyword">var</span> node = retainedObjectNode<br>     <span class="hljs-keyword">while</span> (node <span class="hljs-keyword">is</span> ChildNode) &#123;<br>       shortestChildPath.add(<span class="hljs-number">0</span>, node)<br>       node = node.parent<br>     &#125;<br>     <span class="hljs-keyword">val</span> rootNode = node <span class="hljs-keyword">as</span> RootNode<br>     ShortestPath(rootNode, shortestChildPath)<br>   &#125;<br> &#125;<br><br><span class="hljs-comment">// 将一个 GC ROOT PATH 添加到前缀树</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateTrie</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  pathNode: <span class="hljs-type">ReferencePathNode</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  path: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Long</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  pathIndex: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  parentNode: <span class="hljs-type">ParentNode</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> objectId = path[pathIndex]<br>  <span class="hljs-keyword">if</span> (pathIndex == path.lastIndex) &#123;<br>    parentNode.children[objectId] = LeafNode(objectId, pathNode)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> childNode = parentNode.children[objectId] ?: &#123;<br>      <span class="hljs-keyword">val</span> newChildNode = ParentNode(objectId)<br>      parentNode.children[objectId] = newChildNode<br>      newChildNode<br>    &#125;()<br>    <span class="hljs-keyword">if</span> (childNode <span class="hljs-keyword">is</span> ParentNode) &#123;<br>      updateTrie(pathNode, path, pathIndex + <span class="hljs-number">1</span>, childNode)<br>    &#125;<br>  &#125;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>到此 GC ROOT PATH 已找到，最后再封装为 <code>LeakTrace</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: LeaksAndUnreachableObjects &#123;<br>  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)<br>  <span class="hljs-keyword">val</span> pathFindingResults =<br>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)<br>  <span class="hljs-keyword">val</span> unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)<br>  <span class="hljs-keyword">val</span> shortestPaths =<br>    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)<br>  <span class="hljs-keyword">val</span> inspectedObjectsByPath = inspectObjects(shortestPaths)<br>  <span class="hljs-keyword">val</span> retainedSizes =<br>    <span class="hljs-keyword">if</span> (pathFindingResults.dominatorTree != <span class="hljs-literal">null</span>) &#123;<br>      computeRetainedSizes(inspectedObjectsByPath, pathFindingResults.dominatorTree)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-literal">null</span><br>    &#125;<br>  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks) = buildLeakTraces(<br>    shortestPaths, inspectedObjectsByPath, retainedSizes<br>  )<br>  <span class="hljs-keyword">return</span> LeaksAndUnreachableObjects(applicationLeaks, libraryLeaks, unreachableObjects)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">buildLeakTraces</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  shortestPaths: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ShortestPath</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  inspectedObjectsByPath: <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">InspectedObject</span>&gt;&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedSizes: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Long</span>, Pair&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt;&gt;?</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>  listener.onAnalysisProgress(BUILDING_LEAK_TRACES)<br>  <span class="hljs-keyword">val</span> applicationLeaksMap = mutableMapOf&lt;String, MutableList&lt;LeakTrace&gt;&gt;()<br>  <span class="hljs-keyword">val</span> libraryLeaksMap =<br>    mutableMapOf&lt;String, Pair&lt;LibraryLeakReferenceMatcher, MutableList&lt;LeakTrace&gt;&gt;&gt;()<br>  shortestPaths.forEachIndexed &#123; pathIndex, shortestPath -&gt;<br>    <span class="hljs-keyword">val</span> inspectedObjects = inspectedObjectsByPath[pathIndex]<br>    <span class="hljs-keyword">val</span> leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)<br>    <span class="hljs-keyword">val</span> referencePath = buildReferencePath(shortestPath.childPath, leakTraceObjects)<br>    <span class="hljs-keyword">val</span> leakTrace = LeakTrace(<br>      gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot), <span class="hljs-comment">// 第一个元素是 GC ROOT</span><br>      referencePath = referencePath,                                <span class="hljs-comment">// GC ROOT PATH</span><br>      leakingObject = leakTraceObjects.last()                       <span class="hljs-comment">// leaking object</span><br>    )<br>    <span class="hljs-keyword">val</span> firstLibraryLeakNode = <span class="hljs-keyword">if</span> (shortestPath.root <span class="hljs-keyword">is</span> LibraryLeakNode) &#123;<br>      shortestPath.root<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      shortestPath.childPath.firstOrNull &#123; it <span class="hljs-keyword">is</span> LibraryLeakNode &#125; <span class="hljs-keyword">as</span> LibraryLeakNode?<br>    &#125;<br>    <span class="hljs-keyword">if</span> (firstLibraryLeakNode != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">val</span> matcher = firstLibraryLeakNode.matcher<br>      <span class="hljs-keyword">val</span> signature: String = matcher.pattern.toString()<br>        .createSHA1Hash()<br>      libraryLeaksMap.getOrPut(signature) &#123; matcher to mutableListOf() &#125;<br>        .second += leakTrace<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      applicationLeaksMap.getOrPut(leakTrace.signature) &#123; mutableListOf() &#125; += leakTrace<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">val</span> applicationLeaks = applicationLeaksMap.map &#123; (_, leakTraces) -&gt;<br>    ApplicationLeak(leakTraces)<br>  &#125;<br>  <span class="hljs-keyword">val</span> libraryLeaks = libraryLeaksMap.map &#123; (_, pair) -&gt;<br>    <span class="hljs-keyword">val</span> (matcher, leakTraces) = pair<br>    LibraryLeak(leakTraces, matcher.pattern, matcher.description)<br>  &#125;<br>  <span class="hljs-keyword">return</span> applicationLeaks to libraryLeaks<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="为什么不需要手动初始化？"><a href="#为什么不需要手动初始化？" class="headerlink" title="为什么不需要手动初始化？"></a>为什么不需要手动初始化？</h3><p><code>LeakCanary</code> 把初始化代码放在 <code>ContentProvider.onCreate()</code> 里（具体是 <code>AppWatcherInstaller</code>），而 <code>ContentProvider.onCreate()</code> 会早于 <code>Application.onCreate</code> 被调用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ContentProvider.onCreate 会早于 Application.onCreate</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ActivityThread.handleBindApplication(AppBindData data) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// If the app is being launched for full backup or restore, bring it up in</span><br>    <span class="hljs-comment">// a restricted environment with the base application class.</span><br>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// Propagate autofill compat state</span><br>    app.setAutofillOptions(data.autofillOptions);<br>    <span class="hljs-comment">// Propagate Content Capture options</span><br>    app.setContentCaptureOptions(data.contentCaptureOptions);<br>    mInitialApplication = app;<br>    <span class="hljs-comment">// don&#x27;t bring up providers in restricted mode; they may depend on the</span><br>    <span class="hljs-comment">// app&#x27;s custom Application class</span><br>    <span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;<br>        <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<br>            installContentProviders(app, data.providers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Do this after providers, since instrumentation tests generally start their</span><br>    <span class="hljs-comment">// test thread at this point, and we don&#x27;t want that racing.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        mInstrumentation.onCreate(data.instrumentationArgs);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span><br>            + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mInstrumentation.callApplicationOnCreate(app);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>              <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>              + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installContentProviders</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (ProviderInfo cpi : providers) &#123;<br>        ContentProviderHolder cph = installProvider(context, <span class="hljs-keyword">null</span>, cpi,<br>                <span class="hljs-keyword">false</span> <span class="hljs-comment">/*noisy*/</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*noReleaseNeeded*/</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*stable*/</span>);<br>        <span class="hljs-keyword">if</span> (cph != <span class="hljs-keyword">null</span>) &#123;<br>            cph.noReleaseNeeded = <span class="hljs-keyword">true</span>;<br>            results.add(cph);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化 ContentProvider 并调用生命周期函数 onCreate</span><br><span class="hljs-keyword">private</span> ContentProviderHolder ActivityThread.installProvider(Context context,<br>        ContentProviderHolder holder, ProviderInfo info,<br>        <span class="hljs-keyword">boolean</span> noisy, <span class="hljs-keyword">boolean</span> noReleaseNeeded, <span class="hljs-keyword">boolean</span> stable) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();<br>    LoadedApk packageInfo = peekPackageInfo(ai.packageName, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// System startup case.</span><br>        packageInfo = getSystemContext().mPackageInfo;<br>    &#125;<br>    localProvider = packageInfo.getAppFactory()<br>            .instantiateProvider(cl, info.name);<br>    provider = localProvider.getIContentProvider();<br>    <span class="hljs-keyword">if</span> (provider == <span class="hljs-keyword">null</span>) &#123;<br>        Slog.e(TAG, <span class="hljs-string">&quot;Failed to instantiate class &quot;</span> +<br>              info.name + <span class="hljs-string">&quot; from sourceDir &quot;</span> +<br>              info.applicationInfo.sourceDir);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(<br>        TAG, <span class="hljs-string">&quot;Instantiating local provider &quot;</span> + info.name);<br>    <span class="hljs-comment">// XXX Need to create the correct context for this provider.</span><br>    localProvider.attachInfo(c, info);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ContentProvider.attachInfo(Context context, ProviderInfo info) &#123;<br>    attachInfo(context, info, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ContentProvider.attachInfo(Context context, ProviderInfo info, <span class="hljs-keyword">boolean</span> testing) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContentProvider.<span class="hljs-keyword">this</span>.onCreate();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="有什么缺点"><a href="#有什么缺点" class="headerlink" title="有什么缺点"></a>有什么缺点</h3><ol><li><code>LeakCanary</code> 是在 app process 内 heap dump 的，期间进程内的其他线程会被挂起直到 heap dump 完成，这会导致 app 无响应，生产环境下是不可接受的</li><li>hprof 文件往往达到 400M / 500M 这个量级，客户端存储是个问题</li><li>hprof 文件要回传给服务器分析，但是文件太大网络消耗也有很大问题</li><li>如果是在客户端分析 hprof 文件，由于文件太大导致分析进程在很多情况下自己也 OOM 了</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://leo-wxy.github.io/2020/12/14/Hprof%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">Hprof文件解析</a></li><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF Agent</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>内存优化，OOM</tag>
      
      <tag>LeakCanary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 的一些知识点</title>
    <link href="/2021/04/05/hashmap/"/>
    <url>/2021/04/05/hashmap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap-的桶由链表变为红黑树（树化）的过程"><a href="#HashMap-的桶由链表变为红黑树（树化）的过程" class="headerlink" title="HashMap 的桶由链表变为红黑树（树化）的过程"></a>HashMap 的桶由链表变为红黑树（树化）的过程</h2><h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><ol><li>节点为红色或者黑色</li><li>根节点必须是黑的</li><li>红色节点的左右子节点必须为黑色</li><li>一个节点到叶子节点的每条路径必须包含相同数目的黑色节点</li></ol><h3 id="颜色变换和两种选择"><a href="#颜色变换和两种选择" class="headerlink" title="颜色变换和两种选择"></a>颜色变换和两种选择</h3><p>添加新节点后，因为新节点总是红色的，那么会有几种情况出现：</p><ol><li>新节点是根节点，也就是说树是空的，根据规则二，把新节点设为黑色即可</li><li>新节点的父节点是黑色，或者父节点是根，满足规则</li><li>父节点是红色，违反规则三，需要进行 <strong>平衡</strong> 操作</li></ol><p>平衡操作主要是根据情况组合使用下面三种转换（方块表示一棵满足红黑树规则的子树）：</p><p><img src="../../../../image/2021-04-05-hashmap/op_1.png" alt="单旋"></p><p><img src="../../../../image/2021-04-05-hashmap/op_2.png" alt="双旋"></p><p><img src="../../../../image/2021-04-05-hashmap/op_3.png" alt="颜色变换"></p><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><h4 id="为什么要进行旋转？"><a href="#为什么要进行旋转？" class="headerlink" title="为什么要进行旋转？"></a>为什么要进行旋转？</h4><p>由于 P（父节点 和 X（新节点）都为红色，违反规则三</p><h4 id="为什么新节点总是红色？"><a href="#为什么新节点总是红色？" class="headerlink" title="为什么新节点总是红色？"></a>为什么新节点总是红色？</h4><p>因为添加新节点前的树结构是构建好的，一但我们添加黑色节点，无论添加在哪里都会破坏原有路径上的黑色节点的数量平等关系，所以插入红色节点是正确的选择</p><h4 id="为什么要进行颜色变换？"><a href="#为什么要进行颜色变换？" class="headerlink" title="为什么要进行颜色变换？"></a>为什么要进行颜色变换？</h4><p>如果叶子节点是红色的，那么我们在添加的时候只能添加黑色节点，然而添加任何黑色叶子节点都会违反规则四，所以要对其进行变换。进行变换后叶子节点是黑色的，而且我们默认添加的叶子节点是红色的，添加到红色的新节点后并不会违反规则四，所以这种变换很有用</p><h4 id="第二种双变换中在树的内部怎么出现的红色的节点？"><a href="#第二种双变换中在树的内部怎么出现的红色的节点？" class="headerlink" title="第二种双变换中在树的内部怎么出现的红色的节点？"></a>第二种双变换中在树的内部怎么出现的红色的节点？</h4><p>正是由于上面的颜色变换导致颜色变换后的节点与他的父节点产生了颜色冲突</p><h3 id="HashMap-树化的过程"><a href="#HashMap-树化的过程" class="headerlink" title="HashMap 树化的过程"></a>HashMap 树化的过程</h3><p>当满足下述条件时才将链表树化为红黑树</p><ul><li>桶内元素超过 <code>TREEIFY_THRESHOLD = 8</code>（当桶内元素小于 <code>UNTREEIFY_THRESHOLD = 6</code> 时，红黑树会降级为链表）</li><li>桶的数量超过 <code>MIN_TREEIFY_CAPACITY</code>（小于这个数量只是进行扩容操作）；无论是链表还是红黑树，都是为了解决哈希冲突，如果桶太少则应该首先增加桶的数量降低哈希冲突出现的概率，其次才是用红黑树增加查找效率</li></ul><p>首先将 <code>Node</code> 转变为 <code>TreeNode</code>，此时还是链表结构；第一个节点即为根，后面的节点作为新节点，按规则依次添加到树里：比父节点小则添加到左子树，比父节点大则添加到右子树，从上往下搜索直到要添加的子树为空即为新节点的位置；每次插入新节点后都需要进行 <strong>平衡</strong> 操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 将新元素添加至链表尾部（桶），如果桶的大小超过 TREEIFY_THRESHOLD，准备树化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>            p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                treeifyBin(tab, hash);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果桶的数量 &lt; MIN_TREEIFY_CAPACITY，只是扩容</span><br>    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <br>    <span class="hljs-comment">// 桶多于 MIN_TREEIFY_CAPACITY 才树化</span><br>    <span class="hljs-comment">// 将桶 tab[index] 里的节点转变为 TreeNode，但 此时还是链表</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// hd 是链表头，从它开始树化</span><br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将还是链表的桶树化，当前是链表头</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 链表里第一个元素作为红黑树初始的根</span><br>    <span class="hljs-comment">// 遍历链表，逐个添加到红黑树中</span><br>    TreeNode&lt;K,V&gt; root = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;<br>        next = (TreeNode&lt;K,V&gt;)x.next;<br>        x.left = x.right = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            x.parent = <span class="hljs-keyword">null</span>;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            root = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            K k = x.key;<br>            <span class="hljs-keyword">int</span> h = x.hash;<br>            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-comment">// 从根开始，自上而下找位置</span><br>            <span class="hljs-comment">// 比父节点小则插入到左子树，比父节点大则插入到右子树，直到所插入的位置为 null</span><br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<br><br>                <span class="hljs-comment">// x - 新节点，p - 父节点，h - 新节点 hash，ph - parent hash</span><br>                <span class="hljs-comment">// dir == -1，新节点比父节点小，添加到左子树；dir == 1，新节点比父节点大，添加到右子树</span><br>                <span class="hljs-keyword">int</span> dir, ph;<br>                K pk = p.key;<br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                    dir = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    dir = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;<br>                          (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                         (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>                    dir = tieBreakOrder(k, pk);<br><br>                <span class="hljs-comment">// xp - 新节点的父节点</span><br>                <span class="hljs-comment">// 一直找，直到新节点需要插入的位置是为 null，那么就把新节点放在那</span><br>                TreeNode&lt;K,V&gt; xp = p;<br>                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>                    x.parent = xp;<br>                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                        xp.left = x;<br>                    <span class="hljs-keyword">else</span><br>                        xp.right = x;<br>                    <span class="hljs-comment">// 插入新节点后可能会破坏红黑树的平衡，每次插入后都要执行平衡操作</span><br>                    root = balanceInsertion(root, x);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    moveRootToFront(tab, root);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 插入新节点后需要平衡红黑树</span><br><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>    x.red = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 新节点总是红色的</span><br><br>    <span class="hljs-comment">// xp - 新节点的 parent，xpp - 新节点的祖父，xppl - 祖父的左孩子，xppr - 祖父的右孩子</span><br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;<br><br>        <span class="hljs-comment">// 新节点没有父节点，说明它是根节点，根节点必须是黑色</span><br>        <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br><br>        <span class="hljs-comment">// 1，不是根节点且父节点是黑色，满足红黑树的条件，返回即可</span><br>        <span class="hljs-comment">// 2，祖父为 null 说明父节点为根，根一定是黑色，新节点为红色，满足条件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 父节点是红色且有祖父节点，那就比较麻烦了，必须要进行旋转和颜色变换操作，此时父节点是祖父的左孩子    </span><br>        <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;<br><br>            <span class="hljs-comment">// 新节点是红色，父节点也是红色，父节点旁边的兄弟节点也是红色（由于当前红黑树除新节点外是平衡的，所以祖父肯定是黑色）</span><br>            <span class="hljs-comment">// 那么进行颜色变换：将父节点和它的兄弟节点变为黑色，祖父变为红色，对应图三</span><br>            <span class="hljs-comment">// 祖父变色后，可能引起祖父上面不平衡，所以下次循环要操作祖父</span><br>            <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;<br>                xppr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                x = xpp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// 父节点的兄弟为黑色 or 为空，那么就要通过旋转解决两个红色节点相连的问题</span><br>                <span class="hljs-comment">// 新节点是右孩子，对应图二的双旋，这里是第一次的左旋</span><br>                <span class="hljs-keyword">if</span> (x == xp.right) &#123;<br>                    root = rotateLeft(root, x = xp);<br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br><br>                <span class="hljs-comment">// 继续上面的（左旋）后的第二次右旋</span><br>                <span class="hljs-comment">// 或者对应图一的单旋（右旋）</span><br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateRight(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 同样是旋转和颜色变换操作，只不过父节点现在是祖父的右孩子，流程跟上面差不多的</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;<br>                xppl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                x = xpp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (x == xp.left) &#123;<br>                    root = rotateRight(root, x = xp);<br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateLeft(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="扩容的过程"><a href="#扩容的过程" class="headerlink" title="扩容的过程"></a>扩容的过程</h2><h3 id="计算扩容大小和下一次扩容阈值"><a href="#计算扩容大小和下一次扩容阈值" class="headerlink" title="计算扩容大小和下一次扩容阈值"></a>计算扩容大小和下一次扩容阈值</h3><p>扩容时，容量翻倍，下一次扩容阈值 <code>threshold</code> 也翻倍；特殊情况是当前容量小于默认初始容量 <code>DEFAULT_INITIAL_CAPACITY = 16</code> 时，<code>threshold</code> 不翻倍而是取扩容后的负载因子倍数</p><p>第一次扩容时 <code>table</code> 尚未初始化，当前容量为零，如果构造函数有设置 <code>initialCapacity</code>，则扩容后的大小为 <code>initialCapacity</code>，下一次扩容阈值为 <code>initialCapacity * loadFactor</code>；否则扩容后大小和负载因子都取默认值</p><p>第一次扩容时，<code>threshold</code> 取 <code>initialCapacity * loadFactor</code>，而 <code>loadFactor</code> 总是小于等于 1 的，所以 <code>threshold</code> 总是小于等于 <code>capacity</code>，后续即使翻倍 <code>threshold</code> 也是小于等于 <code>capacity</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// table 已被初始化的情况（table != null）</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br><br>        <span class="hljs-comment">// 限制最大容量（MAXIMUM_CAPACITY = 1 &lt;&lt; 30）</span><br>        <span class="hljs-comment">// 因为容量是个 int 值，要限制下不至于溢出</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br><br>        <span class="hljs-comment">// 最常见的情况：capacity 和 threshold 翻一倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br><br>    <span class="hljs-comment">// 第一次扩容，table 还未被初始化但是 threshold 有值，那么把它作为扩容后的容量</span><br>    <span class="hljs-comment">// 对应 HashMap(initialCapacity, loadFactor)，HashMap(initialCapacity) 和 HashMap(Map&lt;? extends K, ? extends V&gt; m) 这三种情况</span><br>    <span class="hljs-comment">// 前两种情况 threshold 可以通过 initialCapacity 算出来，后一种情况可以通过 Map 大小算出来</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br><br>    <span class="hljs-comment">// table 还未被初始化并且 threshold 也没有值，对应 HashMap()</span><br>    <span class="hljs-comment">// 没有传入 initialCapacity，threshold 没有参考值所以为零，那么使用默认值</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br><br>    <span class="hljs-comment">// 1，当 table 尚未初始化且 threshold/initialCapacity 有值</span><br>    <span class="hljs-comment">// 2，当 table 已初始化但扩容前的容量 &lt; DEFAULT_INITIAL_CAPACITY</span><br>    <span class="hljs-comment">// 下一次扩容大小 newThr 为扩容后到达负载因子的水平</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="重新-hash"><a href="#重新-hash" class="headerlink" title="重新 hash"></a>重新 hash</h3><ol><li>只有一个元素，重新 hash 算出新位置即可</li><li>链表的情况，因为 <code>capacity</code> 总是 2 的次方，<code>capacity</code> 形如 <code>100000</code> 而 <code>capacity - 1</code> 形如 <code>011111</code>，通过 <code>e.hash &amp; oldCap) == 0</code> 把链表拆分为两个链表 low（高位为 0）和 high（高位为 1），low 留在原位 <code>newTab[j]</code>，high 迁移到 <code>newTab[j + oldCap]</code></li><li>如果是红黑树，跟链表一样先拆分和迁移，如果链表里元素数量小于等于 <code>UNTREEIFY_THRESHOLD = 6</code> 则转化为链表，否则重新构建红黑树</li></ol><p>为什么拆分链表是可行的？假设当前容量 4 扩容后为 8，那么 hash 的右值为 <code>0011</code> 和 <code>0111</code>（object.hash() * (capacity - 1)，扩容的翻倍操作实际上是左移一位），可以看到区别就是高位对应的 object.hash() 值，高位 hash 为零即使扩容了位置也不变，高位 hash 为 1 则迁移到 oldCap + j 的位置上（obj 相当于高位对应的部分，j 则是低位对应的部分）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">// ...</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;  <span class="hljs-comment">// 遍历旧 table</span><br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br><br>                <span class="hljs-comment">// 如果桶中只有一个元素，重新计算位置并迁移</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br><br>                <span class="hljs-comment">// 红黑树，拆分并重建红黑树    </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br><br>                <span class="hljs-comment">// 桶里是链表，根据高位是 0 还是 1 把链表拆分为两个链表（low 和 high）</span><br>                <span class="hljs-comment">// low 留在原来的位置，hihg 迁移到新位置</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br><br><span class="hljs-comment">// 红黑树重新 hash 的过程</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;<br>    <span class="hljs-comment">// 跟链表一样根据高位拆分为 low（0）和 high（1）两个链表</span><br>    TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>;<br>    TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>    TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;<br>        next = (TreeNode&lt;K,V&gt;)e.next;<br>        e.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)<br>                loHead = e;<br>            <span class="hljs-keyword">else</span><br>                loTail.next = e;<br>            loTail = e;<br>            ++lc;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)<br>                hiHead = e;<br>            <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>            hiTail = e;<br>            ++hc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拆分后，如果 &lt; UNTREEIFY_THRESHOLD 则转为链表，否则重新构建红黑树</span><br>    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index] = loHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index] = loHead;<br>            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// (else is already treeified)</span><br>                loHead.treeify(tab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index + bit] = hiHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index + bit] = hiHead;<br>            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)<br>                hiHead.treeify(tab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC 下一些线程安全的容器</title>
    <link href="/2021/03/31/juc-collection/"/>
    <url>/2021/03/31/juc-collection/</url>
    
    <content type="html"><![CDATA[<h2 id="写时复制（Copy-On-Write）"><a href="#写时复制（Copy-On-Write）" class="headerlink" title="写时复制（Copy On Write）"></a>写时复制（Copy On Write）</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h3><p>使用 <strong>写时复制</strong> 实现的线程安全版 <code>ArrayList</code>，当发生修改操作时（add、set、remove）才加锁，将原数组复制一份并在上面修改成为新数组，最后用新数组替换原数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也就是说所有的修改操作都不会修改原数组，这样所有的读操作（get、iterate）都可以不加锁，从而实现高效的读（虽然有可能会读到旧数据）；因为它的写操作是很昂贵的（复制一份出来），但同时它的读操作和迭代很高效（不上锁），所以它适用于读操作远大于写操作的情况；<code>CopyOnWriteArraySet</code> 内部是通过 <code>CopyOnWriteArrayList</code> 实现的</p><h2 id="分段加锁"><a href="#分段加锁" class="headerlink" title="分段加锁"></a>分段加锁</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p>跟 <code>HashMap</code> 一样采用数组 + 链表的实现，链表又叫做桶 or 箱子（bin）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>写时采用 <strong>分段加锁</strong>，不对整个写操作 or <code>table</code> 加锁，而只对所在的桶加锁，其他线程依然可以进行读操作 or 对其他桶进行写操作</p><p>整个 <code>ConcurrentHashMap</code> 都没有使用 <code>Lock</code> 进行阻塞，而是尽可能采用自旋 + CAS（乐观锁，是实现无锁操作的重要函数），最后才用 <code>synchronized</code>（参考文章，它的锁膨胀过程中掺杂自旋和阻塞）对桶上锁</p><p><code>tabAt</code>、<code>setTabAt</code> 和 <code>casTabAt</code> 使对 <code>table</code> 的操作具有可见性和原子性，避免了对 <code>table</code> 上锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-comment">// 没有对整个写操作加锁，也没有对 table 加锁</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// CAS 失败会自旋，是乐观锁</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br><br>        <span class="hljs-comment">// 如果 table == null，则进行初始化；初始化后每个桶是 null</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <br>        <span class="hljs-comment">// 所在的桶为 null，不加锁直接用 CAS 操作添加新桶头，失败的话自旋</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-comment">// 找到所在的不为 null 的桶，对单个桶上锁</span><br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br><br>                    <span class="hljs-comment">// 沿着链表从头开始走，如果找到 key 值相等的节点则覆盖旧的 value</span><br>                    <span class="hljs-comment">// 否则作为新节点添加到链表尾部</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// ... 链表被树化为红黑树的情况参考 HashMap 的文章</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 初始化 table，自旋 + CAS</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><br><span class="hljs-comment">// 使数组的读/写操作像 volatile 成员变量一样具有线程可见性</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;<br>    U.putObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>&#125;<br><br><span class="hljs-comment">// 在数组上实现 CAS 操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然都是线程安全的 map，但 <code>ConcurrentHashMap</code> 的分段加锁对比 <code>HashTable</code> 的整个方法加锁优势就体现出来了，高并发下优势会愈加明显</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// HashTable 对整个写操作加锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-comment">// Make sure the value is not null</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br><br>    <span class="hljs-comment">// Makes sure the key is not already in the hashtable.</span><br>    HashtableEntry&lt;?,?&gt; tab[] = table;<br>    <span class="hljs-keyword">int</span> hash = key.hashCode();<br>    <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];<br>    <span class="hljs-keyword">for</span>(; entry != <span class="hljs-keyword">null</span> ; entry = entry.next) &#123;<br>        <span class="hljs-keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;<br>            V old = entry.value;<br>            entry.value = value;<br>            <span class="hljs-keyword">return</span> old;<br>        &#125;<br>    &#125;<br><br>    addEntry(hash, key, value, index);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>读操作完全不加锁，但是 <code>Node.val</code> 和 <code>Node.next</code> 是 <code>volatile</code> 修饰的，所以 <code>Node</code> 的线程可见性是有保证的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;<br>    <span class="hljs-keyword">int</span> h = spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><code>BlockingQueue</code></h2><p>它提供的阻塞操作包括：</p><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td><code>put(e)</code></td><td>入队</td></tr><tr><td><code>offer(e, timeout, unit)</code></td><td>设置超时的入队</td></tr><tr><td><code>take()</code></td><td>出队</td></tr><tr><td><code>poll(timeout, unit)</code></td><td>设置超时的出队</td></tr><tr><td><code>drainTo(collection, maxElements)</code></td><td>批量出队并添加到另一个集合中</td></tr></tbody></table><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h3><p>基于数组、容量有限的阻塞队列，通过构造函数指定队列的容量</p><p>用两个指针 <code>takeIndex</code>(队头，指向下一次出队的位置) 和 <code>putIndex</code>（队尾，指向下一次入队的位置） 模拟队列，它们初始为 0（最左边），随着元素的入队 <code>putIndex</code> 往右移动，随着元素的出队 <code>takeIndex</code> 也往右移动，当它们越过数组最后边时会重置到最左边，<code>count</code> 确保 <code>takeIndex</code> 不会违规越过 <code>putIndex</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** The queued items */</span><br>    <span class="hljs-keyword">final</span> Object[] items;<br><br>    <span class="hljs-comment">/** items index for next take, poll, peek or remove */</span><br>    <span class="hljs-keyword">int</span> takeIndex;<br><br>    <span class="hljs-comment">/** items index for next put, offer, or add */</span><br>    <span class="hljs-keyword">int</span> putIndex;<br><br>    <span class="hljs-comment">/** Number of elements in the queue */</span><br>    <span class="hljs-keyword">int</span> count;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>出队/入队时用了 <code>Lock</code> 和 <code>Condition</code> 实现阻塞和唤醒，出队时如果为空则阻塞在 <code>notEmpty</code> 上，入队时如果满了则阻塞在 <code>notFull</code>，入队后唤醒阻塞在 <code>notEmpty</code> 上的线程，出队后唤醒阻塞在 <code>notFull</code> 上的线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** Main lock guarding all access */</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock;<br><br>    <span class="hljs-comment">/** Condition for waiting takes */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br>    <span class="hljs-comment">/** Condition for waiting puts */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Inserts element at current put position, advances, and signals.</span><br><span class="hljs-comment">     * Call only when holding lock.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;<br>        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>        <span class="hljs-comment">// assert items[putIndex] == null;</span><br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>        items[putIndex] = x;<br>        <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>        count++;<br>        notEmpty.signal();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Extracts element at current take position, advances, and signals.</span><br><span class="hljs-comment">     * Call only when holding lock.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>        <span class="hljs-comment">// assert items[takeIndex] != null;</span><br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        E x = (E) items[takeIndex];<br>        items[takeIndex] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>        count--;<br>        <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)<br>            itrs.elementDequeued();<br>        notFull.signal();<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;  <br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><code>LinkedBlockingQueue</code></h3><p>基于链表、无限容量（当然也可以通过构造函数设置最大容量）的阻塞队列，链表是单向的，<code>head</code> 指向队头也就是出队的位置，<code>last</code> 指向队尾也就是出队的位置</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Linked list node class.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * One of:</span><br><span class="hljs-comment">         * - the real successor Node</span><br><span class="hljs-comment">         * - this Node, meaning the successor is head.next</span><br><span class="hljs-comment">         * - null, meaning there is no successor (this is the last node)</span><br><span class="hljs-comment">         */</span><br>        Node&lt;E&gt; next;<br><br>        Node(E x) &#123; item = x; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-comment">/** Current number of elements */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Head of linked list.</span><br><span class="hljs-comment">     * Invariant: head.item == null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tail of linked list.</span><br><span class="hljs-comment">     * Invariant: last.next == null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> </span>&#123;<br>        <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span><br>        <span class="hljs-comment">// assert last.next == null;</span><br>        last = last.next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span><br>        <span class="hljs-comment">// assert head.item == null;</span><br>        Node&lt;E&gt; h = head;<br>        Node&lt;E&gt; first = h.next;<br>        h.next = h; <span class="hljs-comment">// help GC</span><br>        head = first;<br>        E x = first.item;<br>        first.item = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟 <code>ArrayBlockingQueue</code> 一样用了两个条件变量：<code>notEmpty</code> 和 <code>notFull</code> 来阻塞/唤醒生产者和消费者；为啥会有 <code>notFull</code> 的情况呢，不是无限容量吗？因为它可以设置一个最大容量</p><p>不同的是 <code>LinkedBlockingQueue</code> 用了两个锁，<code>takeLock</code> 给出队加锁，<code>putLock</code> 给入队加锁，出队和入队之所以可以并行是有 <code>count</code> 在确保数量正确</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-comment">/** Current number of elements */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/** Lock held by take, poll, etc */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">/** Wait queue for waiting takes */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<br><br>    <span class="hljs-comment">/** Lock held by put, offer, etc */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">/** Wait queue for waiting puts */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><code>PriorityBlockingQueue</code></h3><p>上面两个阻塞队列是 <code>FIFO</code> 排序的，而这个可以用 <code>Comparator</code> 和 <code>Comparable</code> 自定义优先级</p><p>底层用 <strong>小顶堆</strong> 实现的优先队列，小顶堆是用数组实现的二叉树（左右节点要大于父节点）；入队元素添加到叶子那层的最左边，然后自下往上跟父节点比较，如果小则交换，这个操作叫 <code>siftUp</code>；出队元素固定是树的根节点，出队后把最后一个节点作为根节点，从上往下跟左右节点比较，如果大则交换，这个操作叫 <code>siftDown</code>（参考 <a href="../../../../2021/02/19/threadpool/">这篇文章</a> 里堆的介绍）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Priority queue represented as a balanced binary heap: the two</span><br><span class="hljs-comment">     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span><br><span class="hljs-comment">     * priority queue is ordered by comparator, or by the elements&#x27;</span><br><span class="hljs-comment">     * natural ordering, if comparator is null: For each node n in the</span><br><span class="hljs-comment">     * heap and each descendant d of n, n &lt;= d.  The element with the</span><br><span class="hljs-comment">     * lowest value is in queue[0], assuming the queue is nonempty.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] queue;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, T x, Object[] array,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; cmp)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            Object e = array[parent];<br>            <span class="hljs-keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            array[k] = e;<br>            k = parent;<br>        &#125;<br>        array[k] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, T x, Object[] array,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                    <span class="hljs-keyword">int</span> n,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                    Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; cmp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> half = n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>                <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                Object c = array[child];<br>                <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="hljs-number">0</span>)<br>                    c = array[child = right];<br>                <span class="hljs-keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                array[k] = c;<br>                k = child;<br>            &#125;<br>            array[k] = x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然底层是数组但可以扩容，也即无限容量；扩容操作也很细致地分为两步：</p><ul><li>分配一块新内存，用 int 和 CAS 操作实现自旋（也许是认为分配新内存很快，所以用乐观锁？）</li><li>复制数组用 <code>Lock</code></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryGrow</span><span class="hljs-params">(Object[] array, <span class="hljs-keyword">int</span> oldCap)</span> </span>&#123;<br>    <span class="hljs-comment">// 分配内存，自旋</span><br>    lock.unlock(); <span class="hljs-comment">// must release and then re-acquire main lock</span><br>    Object[] newArray = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (allocationSpinLock == <span class="hljs-number">0</span> &amp;&amp;<br>        U.compareAndSwapInt(<span class="hljs-keyword">this</span>, ALLOCATIONSPINLOCK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="hljs-number">64</span>) ?<br>                                   (oldCap + <span class="hljs-number">2</span>) : <span class="hljs-comment">// grow faster if small</span><br>                                   (oldCap &gt;&gt; <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// possible overflow</span><br>                <span class="hljs-keyword">int</span> minCap = oldCap + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (minCap &lt; <span class="hljs-number">0</span> || minCap &gt; MAX_ARRAY_SIZE)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>                newCap = MAX_ARRAY_SIZE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)<br>                newArray = <span class="hljs-keyword">new</span> Object[newCap];<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            allocationSpinLock = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newArray == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// back off if another thread is allocating</span><br>        Thread.yield();<br><br>    <span class="hljs-comment">// 复制数组才上悲观锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">if</span> (newArray != <span class="hljs-keyword">null</span> &amp;&amp; queue == array) &#123;<br>        queue = newArray;<br>        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, oldCap);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟 <code>ArrayBlockingQueue</code> 一样，入队/出队用同一把锁，因为无容量限制所以只需一个条件变量 <code>notEmpty</code>（<code>notFull</code> 的情况不会出现）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Lock used for all public operations.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Condition for blocking when empty.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h3><ul><li>需要自定义优先级用 <code>PriorityBlockingQueue</code>，需要无限容量用 <code>LinkedBlockingQueue</code></li><li><code>LinkedBlockingQueue</code> 入队出队分别使用两把锁，也就是说入队出队可以并行，在高并发下会比使用同一把锁的 <code>ArrayBlockingQueue</code> 性能要好</li><li><code>ArrayBlockingQueue</code> 在内存利用率上会比 <code>LinkedBlockingQueue</code> 要好（<code>Node</code> 需要额外的空间），而且底层数组在构造函数时就已预先分配内存，使用时无需动态申请内存，内存波动较小；而动态申请内存的 <code>LinkedBlockingQueue</code> 可能会增加 JVM GC 的负担</li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a><code>ConcurrentLinkedQueue</code></h2><p>用链表实现的线程安全的队列，没有使用 <code>Lock</code> 和 <code>synchronized</code>，而是采用 <code>CAS</code> 操作和自旋的乐观锁，所以 <code>ConcurrentLinkedQueue</code> 是乐观的容器</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentLinkedQueue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 因为没使用锁，为了确保可见性，节点的成员变量都是 volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">volatile</span> E item;<br>        <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br>    &#125;<br><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;            <span class="hljs-comment">// 头节点，出队时从头结点出队</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;    <span class="hljs-comment">// 尾结点，入队时从尾结点入队</span><br>&#125;<br><br><span class="hljs-comment">// 出队操作，不移除 Node 只是将 Node.item 置空，下一次操作才会将 Node.item == null 的空节点移除</span><br><span class="hljs-comment">// 使用 for + cas</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    restartFromHead:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;<br>            E item = p.item;<br>            <span class="hljs-keyword">if</span> (item != <span class="hljs-keyword">null</span> &amp;&amp; casItem(p, item, <span class="hljs-keyword">null</span>)) &#123;<br>                <span class="hljs-comment">// Successful CAS is the linearization point</span><br>                <span class="hljs-comment">// for item to be removed from this queue.</span><br>                <span class="hljs-keyword">if</span> (p != h) <span class="hljs-comment">// hop two nodes at a time</span><br>                    updateHead(h, ((q = p.next) != <span class="hljs-keyword">null</span>) ? q : p);<br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                updateHead(h, p);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                <span class="hljs-keyword">continue</span> restartFromHead;<br>            <span class="hljs-keyword">else</span><br>                p = q;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 入队，依然用的是 for + cas</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = newNode(Objects.requireNonNull(e));<br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>        Node&lt;E&gt; q = p.next;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// p is last node</span><br>            <span class="hljs-keyword">if</span> (casNext(p, <span class="hljs-keyword">null</span>, newNode)) &#123;<br>                <span class="hljs-comment">// Successful CAS is the linearization point</span><br>                <span class="hljs-comment">// for e to become an element of this queue,</span><br>                <span class="hljs-comment">// and for newNode to become &quot;live&quot;.</span><br>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span><br>                    casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// Lost CAS race to another thread; re-read next</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>            <span class="hljs-comment">// We have fallen off list.  If tail is unchanged, it</span><br>            <span class="hljs-comment">// will also be off-list, in which case we need to</span><br>            <span class="hljs-comment">// jump to head, from which all live nodes are always</span><br>            <span class="hljs-comment">// reachable.  Else the new tail is a better bet.</span><br>            p = (t != (t = tail)) ? t : head;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// Check for tail updates after two hops.</span><br>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是 https ？</title>
    <link href="/2021/03/30/https/"/>
    <url>/2021/03/30/https/</url>
    
    <content type="html"><![CDATA[<p><code>https = http + tls</code></p><p><code>tcp</code> 三次握手建立连接后，再进行 <code>tls</code> 握手/协商得到一个秘钥，然后双方使用这个秘钥加密（对称加密）明文的 http 为密文后再发送，同样双方收到密文后也用这个秘钥解密得到明文</p><p><strong>对称加密</strong> 使用同一秘钥加密和解密，性能高，http 明文就是通过对称加密后才进行传输的，对称加密算法有：<code>DES</code>、<code>3DES</code>、<code>AES</code> 等；但秘钥交换是个问题，所以需要非对称加密的帮助</p><p><strong>非对称加密</strong> 公钥加密则私钥解密，私钥加密则公钥解密，性能比对称加密要差，不适合加解密大量的数据，但很适合于解决秘钥交换的问题，常用的有：<code>RSA</code>、<code>DSA</code> 等</p><h2 id="tls-协商的过程"><a href="#tls-协商的过程" class="headerlink" title="tls 协商的过程"></a>tls 协商的过程</h2><h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><p>客户端发送：<strong>客户端随机数</strong>（client random）和客户端支持的 <strong>加密套件列表</strong></p><h3 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h3><p>服务端从客户端支持的加密套件中选择一个，然后发送：<strong>服务端随机数</strong>（server random）和 <strong>选用的套件</strong>，比如 <code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code> 就是：</p><ul><li>密钥协商使用 <code>ECDHE</code></li><li>签名算法使用 <code>RSA</code></li><li>加密 http 明文所使用的对称加密算法是 <code>AES</code>，密钥长度 256，分组模式 <code>GCM</code></li><li>摘要算法使用 <code>SHA384</code></li></ul><h3 id="Server-Certificate"><a href="#Server-Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h3><p>服务端发送 <strong>CA 证书</strong></p><h3 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h3><p>服务端生成一个随机数作为 <strong>服务端椭圆曲线私钥</strong>，选择一个 <strong>椭圆曲线</strong>（比如 named_curve）和 <strong>椭圆曲线基点 G</strong>，根据 G 和服务端椭圆曲线私钥生成 <strong>服务端椭圆曲线公钥</strong></p><p>为了确保服务端椭圆曲线公钥不被篡改，服务端用 RSA + 服务端 CA 私钥给服务端椭圆曲线公钥做个签名 <strong>signature</strong></p><p>最后发送椭圆曲线、G、服务端椭圆曲线公钥和 signature 给客户端</p><h3 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h3><p>服务端告诉客户端我这边的信息已经发送完毕</p><h3 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h3><p>客户端进行 CA 证书校验；同样生成一个随机数作为 <strong>客户端椭圆曲线私钥</strong>，根据服务端给的 G 和客户端椭圆曲线私钥生成 <strong>客户端椭圆曲线公钥</strong> 发给服务端（服务端 CA 公钥加密签名防篡改）</p><p>此时客户端算出椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端也算出椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)</p><p>而两端算出的 <strong>椭圆曲线秘钥</strong> 是一致的，但这还没有结束，对 http 明文进行加密的 <strong>主秘钥</strong> = server random + client random + 椭圆曲线秘钥</p><h3 id="Change-Cipher-Spec"><a href="#Change-Cipher-Spec" class="headerlink" title="Change Cipher Spec"></a>Change Cipher Spec</h3><p>服务端和客户端都通知对方，后续的数据传输将使用 RSA + 主秘钥加密了</p><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>第一个由 tls 记录层协议进行加密保护的信息，双方需要验证对方发送的 Finished 信息，保证协商的密钥是可用的，保证协商过程中，没有被篡改</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>https 使用对称加密（比如 <code>RSA</code>）对 http 明文进行加密传输，这个秘钥叫 <strong>主秘钥</strong>，但要确保 <strong>秘钥交换</strong> 过程是安全的；那怎样的交换过程是安全的呢？当然不交换，服务端和客户端各自按照一定的规则生成相同秘钥最安全！</p><p>上面说到主秘钥 = server random + client random + 椭圆曲线秘钥，server random 和 client random 都是公开的不安全的（引入它俩的目的是增加随机性），那么主秘钥的安全性全靠椭圆曲线秘钥了</p><p>客户端椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)，公钥都是公开的所以由私钥确保安全性，而私钥都是随机产生且不经过网络传输的，所以椭圆曲线秘钥是安全的（椭圆曲线的数学特性确保其客户端和服务端算出的是一致的）</p><p>总的来说 <code>ECDHE</code> 靠本地计算替代网络传输保证了秘钥的安全</p><h2 id="提问时间"><a href="#提问时间" class="headerlink" title="提问时间"></a>提问时间</h2><h3 id="怎么证明CA机构的公钥是可信的"><a href="#怎么证明CA机构的公钥是可信的" class="headerlink" title="怎么证明CA机构的公钥是可信的"></a>怎么证明CA机构的公钥是可信的</h3><p>CA 证书是从上到下一级一级地签发下来的，操作系统内置 root CA，可以从下到上逐级确认</p><h3 id="如何防范中间人攻击"><a href="#如何防范中间人攻击" class="headerlink" title="如何防范中间人攻击"></a>如何防范中间人攻击</h3><p>计算报文的 hash，并用服务器的私钥加密生成数字签名；客户端用服务器的公钥解密数字签名得到报文 hash 并与实际计算出的报文 hash 值比对，即可判断出报文有没被修改过</p>]]></content>
    
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <link href="/2021/03/13/tcp-handshake-goodbye/"/>
    <url>/2021/03/13/tcp-handshake-goodbye/</url>
    
    <content type="html"><![CDATA[<p><img src="../../../../image/2021-03-23-tcp-handshake-goodbye/tcp_header.jpeg" alt="tpc_header.jpeg"></p><h2 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h2><ul><li>从 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号，这个序号称为 <strong>字节序号</strong></li><li>如果一个 TCP 报文的 <strong>报文序号</strong> 为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文携带的第一个字节序号是 301，最后一个字节序号是 400</li><li>每传送一个 TCP 报文都要等待对方回复一个确认，但这种方式效率太低，在 TCP 协议中，一般采用累积确认的方式，即每次传送多个连续 TCP 报文，可以只对最后一个 TCP 报文进行确认。对方通过回复一个 <strong>确认号</strong> 来表示已经接收到了哪个 TCP 报文。比如发送方发送了一个序号为 301 的 TCP 报文，这个报文携带了 100 字节数据，则接收方应当回复的确认号是 401，它表示接收方已经收到了字节序号为 [300, 400] 的数据，现在期望你发送字节序号为 401 以及以后的数据</li></ul><h2 id="SYN、ACK-和-FIN"><a href="#SYN、ACK-和-FIN" class="headerlink" title="SYN、ACK 和 FIN"></a>SYN、ACK 和 FIN</h2><ul><li><code>ACK</code>：TCP 协议规定，只有 <code>ACK=1</code> 时有效，也规定连接建立后所有发送的报文的 <code>ACK</code> 必须为 1</li><li><code>SYN</code>：在连接建立时用来同步序号。当 <code>SYN=1</code> 而 <code>ACK=0</code> 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 <code>SYN=1</code> 和 <code>ACK=1</code>。因此 <code>SYN</code> 置 1 就表示这是一个连接请求或连接接受报文</li><li><code>FIN</code>：用来释放一个连接。当 <code>FIN=1</code> 表明此发送方的数据已经发送完毕并要求释放连接</li></ul><h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2><p><img src="../../../../image/2021-03-23-tcp-handshake-goodbye/tcp_sequence.jpeg"></p><p>TCP 需要建立一条可靠的连接，那么对于一条可靠的连接来说，最起码的是发出去的请求能收到对方的确认。所以 Client 发送 <code>SYN</code> 并受到 <code>ACK</code> 后，才能确认连接建立，同样 Server 也需要发送 <code>SYN</code> 并受到 <code>ACK</code> 才能确认建立连接，这样最少需要三次请求，也就是 <strong>三次握手</strong></p><p>TCP 是全双工模式，也就是双方可以同时发送和接收消息。Client 发送 <code>FIN</code> 并收到 <code>ACK</code> 只是确认了 Client 没有更多数据需要传输，此时 Client 不能关闭连接，因为 Server 可能还会有数据传输过来。而当 Server 发送 <code>FIN</code> 并收到 <code>ACK</code> 后，双方都确认没有更多的消息需要传递，于是关闭连接。这样最少需要 <strong>四次挥手</strong></p><p>四次挥手之所以比三次握手多一次是因为：</p><ol><li>TCP 需要建立连接后才能传输数据，于是乎在建立连接的过程中肯定没有数据报文，可以把 <code>SYN</code> 和 <code>ACK</code> 合并为一个报文节省流量</li><li>而断开连接时，Server 回复 <code>ACK</code> 响应 Client 的 <code>FIN</code> 后，Server 依然可以继续发送报文，此时 Client 进入等待状态继续接收 Server 报文直到 Server 发送完毕并发送 <code>FIN</code>，<code>FIN</code> 和 <code>ACK</code> 并不能合并为一个报文</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析 Tinker 是如何实现热修复的</title>
    <link href="/2021/03/12/how-tinker-work/"/>
    <url>/2021/03/12/how-tinker-work/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tinker 是微信团队开源的一款 android 热修复框架，它的使用流程大体是：</p><ul><li>client 安装 V1.apk</li><li>提交了一些 hotfix，打包出 V2.apk</li><li>利用 Tinker 提供的差分工具，在 server 计算出补丁包 patch1.apk，并下发给 client</li><li>client 收到补丁包后，在后台给 V1.apk 打上 patch1.apk 得到 V2.apk（V1.apk + patch1.apk = V2.apk）</li><li>app 在下次启动时，将加载 V2.apk</li></ul><p>它的工作目录大概是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">- /data/user/0/tinker.sample.android/tinker<br>    - info.lock<br>    - patch.info<br>    - patch-d1ec6aa9<br>        - patch-d1ec6aa9.apk<br>        - dex<br>            - tinker_classN.apk<br>            - oat<br>                - tinker_classN.apk.cur.prof<br>                - x86<br>                    - tinker_classN.vdex<br>                    - tinker_classN.odex<br>        - res<br>            - resources.apk<br>        - lib<br>            - lib<br>                - armeabi<br>                    - libmmkv.so<br>                - ...<br>        - odex<br></code></pre></div></td></tr></table></figure><p>注入代码和资源的时序图如下</p><p><img src="../../../../image/2021-03-12-how-tinker-work/inject.jpg" alt="inject.jpg"></p><h2 id="代码的热更新"><a href="#代码的热更新" class="headerlink" title="代码的热更新"></a>代码的热更新</h2><h3 id="使用-TinkerClassLoader"><a href="#使用-TinkerClassLoader" class="headerlink" title="使用 TinkerClassLoader"></a>使用 <code>TinkerClassLoader</code></h3><p>Tinker 代码热更新的原理是用 <code>TinkerClassLoader</code> 替代原有的 <code>ClassLoader</code>，这样 V2 版本的类就会被优先加载，从而实现「覆盖」旧代码的功能</p><p><code>TinkerClassLoader</code> 打破了传统的双亲委派模式，其内部相当于有两个 <code>ClassLoader</code></p><ul><li><code>TinkerClassLoader</code>，包含 V2 版本的代码</li><li><code>mOriginAppClassLoader</code>，android app 的类加载器，包含 V1 版本的代码</li></ul><p>加载类的时候，首先从自身加载（也就是优先加载 V2 版本的代码），然后再从 app 的类加载器中加载（V1 版本的代码就会被 V2 所覆盖）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TinkerClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PathClassLoader</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader mOriginAppClassLoader;<br><br>    TinkerClassLoader(String dexPath, File optimizedDir, String libraryPath, ClassLoader originAppClassLoader) &#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;&quot;</span>, libraryPath, ClassLoader.getSystemClassLoader());<br>        mOriginAppClassLoader = originAppClassLoader;<br>        injectDexPath(<span class="hljs-keyword">this</span>, dexPath, optimizedDir);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        Class&lt;?&gt; cl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            cl = <span class="hljs-keyword">super</span>.findClass(name);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;<br>            cl = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cl != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mOriginAppClassLoader.loadClass(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectDexPath</span><span class="hljs-params">(ClassLoader cl, String dexPath, File optimizedDir)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> List&lt;File&gt; dexFiles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">16</span>);<br>            <span class="hljs-keyword">for</span> (String oneDexPath : dexPath.split(<span class="hljs-string">&quot;:&quot;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (oneDexPath.isEmpty()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dexFiles.add(<span class="hljs-keyword">new</span> File(oneDexPath));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!dexFiles.isEmpty()) &#123;<br>                SystemClassLoaderAdder.injectDexesInternal(cl, dexFiles, optimizedDir);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable thr) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TinkerRuntimeException(<span class="hljs-string">&quot;Fail to create TinkerClassLoader.&quot;</span>, thr);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建 <code>TinkerClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ClassLoader NewClassLoaderInjector.inject(Application app, ClassLoader oldClassLoader, <br> File dexOptDir, <span class="hljs-keyword">boolean</span> useDLC, List&lt;File&gt; patchedDexes) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">final</span> String[] patchedDexPaths = <span class="hljs-keyword">new</span> String[patchedDexes.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; patchedDexPaths.length; ++i) &#123;<br>        patchedDexPaths[i] = patchedDexes.get(i).getAbsolutePath();<br>    &#125;<br>    <span class="hljs-keyword">final</span> ClassLoader newClassLoader = createNewClassLoader(oldClassLoader, dexOptDir, useDLC, patchedDexPaths);<br>    doInject(app, newClassLoader);<br>    <span class="hljs-keyword">return</span> newClassLoader;<br>&#125;<br><br>ClassLoader NewClassLoaderInjector.createNewClassLoader(ClassLoader oldClassLoader, File dexOptDir, <br><span class="hljs-keyword">boolean</span> useDLC, String... patchDexPaths) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">final</span> Field pathListField = findField(Class.forName(<span class="hljs-string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, <span class="hljs-keyword">false</span>, oldClassLoader), <span class="hljs-string">&quot;pathList&quot;</span>);<br>    <span class="hljs-keyword">final</span> Object oldPathList = pathListField.get(oldClassLoader);<br><br>    <span class="hljs-comment">// V2 版本的 dex 列表（apk 包），组合为字符串</span><br>    <span class="hljs-keyword">final</span> StringBuilder dexPathBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hasPatchDexPaths = patchDexPaths != <span class="hljs-keyword">null</span> &amp;&amp; patchDexPaths.length &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (hasPatchDexPaths) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; patchDexPaths.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                dexPathBuilder.append(File.pathSeparator);<br>            &#125;<br>            dexPathBuilder.append(patchDexPaths[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> String combinedDexPath = dexPathBuilder.toString();<br><br>    <span class="hljs-comment">// 把 V1 版本的 so 文件目录组合为字符串</span><br>    <span class="hljs-comment">// so 文件目录其实一直是固定的，比如上面提到的 /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/lib/x86</span><br>    <span class="hljs-comment">// 这是因为 V2 版本的 so 文件被释放到这个目录，把 V1 版本的文件给覆盖掉了（在合成新版本的章节会介绍）</span><br>    <span class="hljs-keyword">final</span> Field nativeLibraryDirectoriesField = findField(oldPathList.getClass(), <span class="hljs-string">&quot;nativeLibraryDirectories&quot;</span>);<br>    List&lt;File&gt; oldNativeLibraryDirectories = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (nativeLibraryDirectoriesField.getType().isArray()) &#123;<br>        oldNativeLibraryDirectories = Arrays.asList((File[]) nativeLibraryDirectoriesField.get(oldPathList));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        oldNativeLibraryDirectories = (List&lt;File&gt;) nativeLibraryDirectoriesField.get(oldPathList);<br>    &#125;<br>    <span class="hljs-keyword">final</span> StringBuilder libraryPathBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">boolean</span> isFirstItem = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (File libDir : oldNativeLibraryDirectories) &#123;<br>        <span class="hljs-keyword">if</span> (libDir == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isFirstItem) &#123;<br>            isFirstItem = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            libraryPathBuilder.append(File.pathSeparator);<br>        &#125;<br>        libraryPathBuilder.append(libDir.getAbsolutePath());<br>    &#125;<br>    <span class="hljs-keyword">final</span> String combinedLibraryPath = libraryPathBuilder.toString();<br><br>    <span class="hljs-comment">// 构造 TinkerClassLoader</span><br>    ClassLoader result = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (useDLC &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="hljs-number">27</span>) &#123;<br>        result = <span class="hljs-keyword">new</span> DelegateLastClassLoader(combinedDexPath, combinedLibraryPath, ClassLoader.getSystemClassLoader());<br>        <span class="hljs-keyword">final</span> Field parentField = ClassLoader.class.getDeclaredField(<span class="hljs-string">&quot;parent&quot;</span>);<br>        parentField.setAccessible(<span class="hljs-keyword">true</span>);<br>        parentField.set(result, oldClassLoader);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-keyword">new</span> TinkerClassLoader(combinedDexPath, dexOptDir, combinedLibraryPath, oldClassLoader);<br>    &#125;<br>    <span class="hljs-comment">// &#x27;EnsureSameClassLoader&#x27; mechanism which is first introduced in Android O</span><br>    <span class="hljs-comment">// may cause exception if we replace definingContext of old classloader.</span><br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">26</span>) &#123;<br>        findField(oldPathList.getClass(), <span class="hljs-string">&quot;definingContext&quot;</span>).set(oldPathList, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="替代-PathClassLoader"><a href="#替代-PathClassLoader" class="headerlink" title="替代 PathClassLoader"></a>替代 <code>PathClassLoader</code></h3><p><code>PathClassLoader</code> 结构如下，因为没有公开方法设置 <code>optimizeDir</code>（odex 文件目录，后续会讲到 Tinker 触发 dex 优化时把文件输出目录设置在 patch dir 内），需要通过反射重新构造 <code>dexElements</code></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">- dalvik.system.PathClassLoader（继承自 BaseDexClassLoader）<br>    - pathList: DexPathList<br>        - nativeLibraryDirectories: File[]<br>            - 0<br>                - /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/lib/x86<br>        - dexElements: Element[]<br>            - 0<br>                - path: File = /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/base.apk<br>                - dexFile: DexFile = /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/base.apk<br>                - initialized: Boolean = false<br>                - urlHandler: ClassPathURLStreamHandler = null<br></code></pre></div></td></tr></table></figure><p>不同 android 版本里 app class loader 的实现和结构可能是不同的，需要分开处理；Tinker 整理出了 V23、V19、V14 和 V4 四个版本</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SystemClassLoaderAdder.injectDexesInternal(ClassLoader cl, List&lt;File&gt; dexFiles, File optimizeDir) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">23</span>) &#123;<br>        V23.install(cl, dexFiles, optimizeDir);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">19</span>) &#123;<br>        V19.install(cl, dexFiles, optimizeDir);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">14</span>) &#123;<br>        V14.install(cl, dexFiles, optimizeDir);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        V4.install(cl, dexFiles, optimizeDir);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">V23</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">install</span><span class="hljs-params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="hljs-function">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;<br>        <span class="hljs-comment">/* The patched class loader is expected to be a descendant of</span><br><span class="hljs-comment">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="hljs-comment">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="hljs-comment">         * file entries.</span><br><span class="hljs-comment">         */</span><br>        Field pathListField = ShareReflectUtil.findField(loader, <span class="hljs-string">&quot;pathList&quot;</span>);<br>        Object dexPathList = pathListField.get(loader);<br>        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="hljs-keyword">new</span> ArrayList&lt;IOException&gt;();<br>        ShareReflectUtil.expandFieldArray(dexPathList, <span class="hljs-string">&quot;dexElements&quot;</span>, makePathElements(dexPathList,<br>            <span class="hljs-keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,<br>            suppressedExceptions));<br>        <span class="hljs-keyword">if</span> (suppressedExceptions.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (IOException e : suppressedExceptions) &#123;<br>                ShareTinkerLog.w(TAG, <span class="hljs-string">&quot;Exception in makePathElement&quot;</span>, e);<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A wrapper around</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> private static final dalvik.system.DexPathList#makePathElements&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object[] makePathElements(<br>        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,<br>        ArrayList&lt;IOException&gt; suppressedExceptions)<br>        <span class="hljs-keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;<br>        Method makePathElements;<br>        <span class="hljs-keyword">try</span> &#123;<br>            makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="hljs-string">&quot;makePathElements&quot;</span>, List.class, File.class, List.class);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makePathElements(List,File,List) failure&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="hljs-string">&quot;makePathElements&quot;</span>, ArrayList.class, File.class, ArrayList.class);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e1) &#123;<br>                ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: try use v19 instead&quot;</span>);<br>                    <span class="hljs-keyword">return</span> V19.makeDexElements(dexPathList, files, optimizedDirectory, suppressedExceptions);<br>                &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e2) &#123;<br>                    ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makeDexElements(List,File,List) failure&quot;</span>);<br>                    <span class="hljs-keyword">throw</span> e2;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (Object[]) makePathElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注入-TinkerClassLoader"><a href="#注入-TinkerClassLoader" class="headerlink" title="注入 TinkerClassLoader"></a>注入 <code>TinkerClassLoader</code></h3><p>注入 <code>TinkerClassLoader</code>，有这么几个地方：</p><ul><li><code>Thread.getContextClassLoader()</code></li><li><code>Application.mBase(ContextImpl).mClassLoader</code></li><li><code>Application.mBase(ContextImpl).mPackageInfo(LoadedApk).mClassLoader</code></li><li><code>Resources.mClassLoader</code></li><li><code>Resources.mDrawableInflater(DrawableInflater).mClassLoader</code></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> NewClassLoaderInjector.doInject(Application app, ClassLoader classLoader) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    Thread.currentThread().setContextClassLoader(classLoader);<br>    <span class="hljs-keyword">final</span> Context baseContext = (Context) findField(app.getClass(), <span class="hljs-string">&quot;mBase&quot;</span>).get(app);<br>    <span class="hljs-keyword">try</span> &#123;<br>        findField(baseContext.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(baseContext, classLoader);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>        <span class="hljs-comment">// There&#x27;s no mClassLoader field in ContextImpl before Android O.</span><br>        <span class="hljs-comment">// However we should try our best to replace this field in case some</span><br>        <span class="hljs-comment">// customized system has one.</span><br>    &#125;<br>    <span class="hljs-keyword">final</span> Object basePackageInfo = findField(baseContext.getClass(), <span class="hljs-string">&quot;mPackageInfo&quot;</span>).get(baseContext);<br>    findField(basePackageInfo.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(basePackageInfo, classLoader);<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;<br>        <span class="hljs-keyword">final</span> Resources res = app.getResources();<br>        <span class="hljs-keyword">try</span> &#123;<br>            findField(res.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(res, classLoader);<br>            <span class="hljs-keyword">final</span> Object drawableInflater = findField(res.getClass(), <span class="hljs-string">&quot;mDrawableInflater&quot;</span>).get(res);<br>            <span class="hljs-keyword">if</span> (drawableInflater != <span class="hljs-keyword">null</span>) &#123;<br>                findField(drawableInflater.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(drawableInflater, classLoader);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// Ignored.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面列出的几个 <code>ClassLoader</code>，其中有两个是比较重要的</p><p><code>Application.mBase(ContextImpl).mClassLoader</code> 是在实例化 <code>ApplicationLike</code> 时用到；为了能够加载到 V2 版本的代码，app application 必须设置为 <code>TinkerApplication</code>（它是 Tinker 库的类，只要不更新 Tinker 版本，业务的迭代更新一般不会改动到它，所以它是比较稳定不变的）；在注入 <code>TinkerClassLoader</code> 后，通过反射调用业务方的 <code>ApplicationLike</code>（业务代码较常变动）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> TinkerApplication.attachBaseContext(Context base)<br><br><span class="hljs-keyword">void</span> TinkerApplication.onBaseContextAttached(Context base, <span class="hljs-keyword">long</span> applicationStartElapsedTime, <span class="hljs-keyword">long</span> applicationStartMillisTime) &#123;<br>    loadTinker();  <span class="hljs-comment">// 先注入 TinkerClassLoader</span><br>    mCurrentClassLoader = base.getClassLoader();  <span class="hljs-comment">// Application.mBase(ContextImpl).mClassLoader</span><br>    mInlineFence = createInlineFence(<span class="hljs-keyword">this</span>, tinkerFlags, delegateClassName, tinkerLoadVerifyFlag, <br>        applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);<br>&#125;<br><br>Handler TinkerApplication.createInlineFence(Application app, <span class="hljs-keyword">int</span> tinkerFlags, String delegateClassName, <span class="hljs-keyword">boolean</span> tinkerLoadVerifyFlag, <br>    <span class="hljs-keyword">long</span> applicationStartElapsedTime, <span class="hljs-keyword">long</span> applicationStartMillisTime, Intent resultIntent) &#123;<br>    <span class="hljs-comment">// delegateClassName 比如 tinker.sample.android.app.SampleApplicationLike</span><br>    <span class="hljs-comment">// 此时 mCurrentClassLoader 是 TinkerClassLoader</span><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="hljs-keyword">false</span>, mCurrentClassLoader);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Application.mBase(ContextImpl).mPackageInfo(LoadedApk).mClassLoader</code> 在实例化 <code>Activity</code> 时会用到，在<a href="../../../../2020/11/03/launch-activity-sequence/">这篇文章</a>里可以找到入口点：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ActivityThread.handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)=<br><br>ActivityThread.performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl appContext = createBaseContextForActivity(r);<br>    Activity activity = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 用这个 cl 加载目标 Activity 类；而这个 cl 是上面 ContextImpl 的</span><br>        java.lang.ClassLoader cl = appContext.getClassLoader();<br>        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br>        <span class="hljs-comment">// ...</span><br>&#125;<br><br>Instrumentation.newActivity(ClassLoader cl, String className, Intent intent) <br>    <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    String pkg = intent != <span class="hljs-keyword">null</span> &amp;&amp; intent.getComponent() != <span class="hljs-keyword">null</span> ? intent.getComponent().getPackageName() : <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);<br>&#125;<br><br>AppComponentFactory.instantiateActivity(ClassLoader cl, String className, Intent intent)<br>    <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> (Activity) cl.loadClass(className).newInstance();<br>&#125;<br><br>ActivityThread.createBaseContextForActivity(ActivityClientRecord r) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> displayId;<br>    <span class="hljs-keyword">try</span> &#123;<br>        displayId = ActivityTaskManager.getService().getDisplayId(r.token);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>    &#125;<br>    ContextImpl appContext = ContextImpl.createActivityContext(<span class="hljs-keyword">this</span>, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>ContextImpl.createActivityContext(ActivityThread mainThread, LoadedApk packageInfo, ActivityInfo activityInfo, <br>    IBinder activityToken, <span class="hljs-keyword">int</span> displayId, Configuration overrideConfiguration) &#123;<br>    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;packageInfo&quot;</span>);<br>    String[] splitDirs = packageInfo.getSplitResDirs();<br>    ClassLoader classLoader = packageInfo.getClassLoader();  <span class="hljs-comment">// ContextImpl.getClassLoader() 来自于 LoadedApk.mClassLoader</span><br>    <span class="hljs-comment">// ...</span><br>    ContextImpl context = <span class="hljs-keyword">new</span> ContextImpl(<span class="hljs-keyword">null</span>, mainThread, packageInfo, <span class="hljs-keyword">null</span>, activityInfo.splitName, activityToken, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, classLoader, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="资源的热更新"><a href="#资源的热更新" class="headerlink" title="资源的热更新"></a>资源的热更新</h2><h3 id="app-resources"><a href="#app-resources" class="headerlink" title="app resources"></a>app resources</h3><p>对于资源的热更新 Tinker 做了两块</p><p>一块是针对 app context 的，Tinker 用新的资源包（比如上面说到的 <code>/data/user/0/tinker.sample.android/tinker/patch-d1ec6aa9/res/resources.apk</code>）构造出一个新的 <code>AssetManager</code>，替换掉 <code>Resources</code> 里旧的 <code>Resource.mResourcesImpl(ResourcesImpl).mAssets</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TinkerResourceLoader.loadTinkerResources(TinkerApplication application, String directory, Intent intentResult)<br><br><span class="hljs-comment">// 资源热更新的逻辑在这里</span><br>TinkerResourcePatcher.monkeyPatchExistingResources(Context context, String externalResourceFile) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// ... 创建一个新的 AssetManager，它指向新的资源包</span><br>    <span class="hljs-keyword">if</span> (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Could not create new AssetManager&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;<br>        <span class="hljs-keyword">final</span> Resources resources = wr.get();<br>        <span class="hljs-keyword">if</span> (resources == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 替换 Resources 里的 AssetManager</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//pre-N</span><br>            assetsFiled.set(resources, newAssetManager);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>            <span class="hljs-comment">// N</span><br>            <span class="hljs-keyword">final</span> Object resourceImpl = resourcesImplFiled.get(resources);<br>            <span class="hljs-comment">// for Huawei HwResourcesImpl</span><br>            <span class="hljs-keyword">final</span> Field implAssets = findField(resourceImpl, <span class="hljs-string">&quot;mAssets&quot;</span>);<br>            implAssets.set(resourceImpl, newAssetManager);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>app context 里的 <code>Resources</code> 是在构造 app context 的同时通过 <code>ResourcesManager.getResources</code> 创建的，而且 <code>ResourcesManager.mResourceReferences</code> 会持有一个它的弱引用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ActivityThread.handleBindApplication(AppBindData data) &#123;<br>    <span class="hljs-comment">// ... 实例化 ContextImpl 和 Application</span><br>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 构造 app context（ContextImpl）和 Application</span><br>Application LoadedApk.makeApplication(<span class="hljs-keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);<br>    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 在构造 ContextImpl 时候会创建 Resources</span><br>ContextImpl LoadedApk.createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123;<br>    <span class="hljs-keyword">return</span> createAppContext(mainThread, packageInfo, <span class="hljs-keyword">null</span>);<br>&#125;<br>ContextImpl LoadedApk.createAppContext(ActivityThread mainThread, LoadedApk packageInfo, String opPackageName) &#123;<br>    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;packageInfo&quot;</span>);<br>    ContextImpl context = <span class="hljs-keyword">new</span> ContextImpl(<span class="hljs-keyword">null</span>, mainThread, packageInfo, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, opPackageName);<br>    context.setResources(packageInfo.getResources());<br>    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br><br><span class="hljs-comment">// 通过 ResourcesManager.getResources() 创建 Resources 实例时，ResourcesManager.mResourceReferences 会持有一个它的弱引用</span><br>Resources LoadedApk.getResources() &#123;<br>    <span class="hljs-keyword">if</span> (mResources == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> String[] splitPaths;<br>        <span class="hljs-keyword">try</span> &#123;<br>            splitPaths = getSplitPaths(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NameNotFoundException e) &#123;<br>            <span class="hljs-comment">// This should never fail.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;null split not found&quot;</span>);<br>        &#125;<br>        mResources = ResourcesManager.getInstance().getResources(<span class="hljs-keyword">null</span>, mResDir,<br>                splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,<br>                Display.DEFAULT_DISPLAY, <span class="hljs-keyword">null</span>, getCompatibilityInfo(),<br>                getClassLoader(), <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mResources;<br>&#125;<br>ResourcesManager.getResources(...) &#123;<br>    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, <span class="hljs-string">&quot;ResourcesManager#getResources&quot;</span>);<br>    <span class="hljs-keyword">final</span> ResourcesKey key = <span class="hljs-keyword">new</span> ResourcesKey(...);<br>    classLoader = classLoader != <span class="hljs-keyword">null</span> ? classLoader : ClassLoader.getSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (activityToken != <span class="hljs-keyword">null</span>) &#123;<br>        rebaseKeyForActivity(activityToken, key);<br>    &#125;<br>    <span class="hljs-comment">// Preload the ApkAssets required by the key to prevent performing heavy I/O while the</span><br>    <span class="hljs-comment">// ResourcesManager lock is held.</span><br>    <span class="hljs-keyword">final</span> ApkAssetsSupplier assetsSupplier = createApkAssetsSupplierNotLocked(key);<br>    <span class="hljs-keyword">return</span> createResources(activityToken, key, classLoader, assetsSupplier);    <br>&#125;<br>ResourcesManager.createResources(...) &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        ResourcesImpl resourcesImpl = findOrCreateResourcesImplForKeyLocked(key, apkSupplier);<br>        <span class="hljs-keyword">if</span> (resourcesImpl == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (activityToken != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> createResourcesForActivityLocked(activityToken, classLoader, resourcesImpl, key.mCompatInfo);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> createResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);<br>        &#125;<br>    &#125;<br>&#125;<br>ResourcesManager.createResourcesLocked(...) &#123;<br>    cleanupReferences(mResourceReferences, mResourcesReferencesQueue);<br>    Resources resources = compatInfo.needsCompatResources() ? <span class="hljs-keyword">new</span> CompatResources(classLoader) : <span class="hljs-keyword">new</span> Resources(classLoader);<br>    resources.setImpl(impl);<br>    resources.setCallbacks(mUpdateCallbacks);<br>    mResourceReferences.add(<span class="hljs-keyword">new</span> WeakReference&lt;&gt;(resources, mResourcesReferencesQueue));<br>    <span class="hljs-keyword">return</span> resources;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Application</code> 创建后会调用 <code>Application.attach</code>，后续会触发 <code>TinkerResourcePatcher.isResourceCanPatch</code> 和 <code>TinkerResourcePatcher.monkeyPatchExistingResources</code>，从而把 <code>ResourcesManager.mResourceReferences</code> 里的 <code>Resources</code> 都修改掉</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Instrumentation.newApplication(ClassLoader cl, String className, Context context) <br><span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);<br>    app.attach(context);<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br>Application.attach(Context context) &#123;<br>    attachBaseContext(context);<br>    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;<br>&#125;<br><br>TinkerLoader.tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent)<br><br>TinkerResourceLoader.checkComplete(Context context, String directory, ShareSecurityCheck securityCheck, Intent intentResult)<br><br><span class="hljs-comment">// 通过反射拿到 ResourcesManager.mResourceReferences</span><br>TinkerResourceLoader.isResourceCanPatch(Context context) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// Iterate over all known Resources objects</span><br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= KITKAT) &#123;<br>        <span class="hljs-comment">//pre-N</span><br>        <span class="hljs-comment">// Find the singleton instance of ResourcesManager</span><br>        <span class="hljs-keyword">final</span> Class&lt;?&gt; resourcesManagerClass = Class.forName(<span class="hljs-string">&quot;android.app.ResourcesManager&quot;</span>);<br>        <span class="hljs-keyword">final</span> Method mGetInstance = findMethod(resourcesManagerClass, <span class="hljs-string">&quot;getInstance&quot;</span>);<br>        <span class="hljs-keyword">final</span> Object resourcesManager = mGetInstance.invoke(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field fMActiveResources = findField(resourcesManagerClass, <span class="hljs-string">&quot;mActiveResources&quot;</span>);<br>            <span class="hljs-keyword">final</span> ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt; activeResources19 =<br>                    (ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(resourcesManager);<br>            references = activeResources19.values();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException ignore) &#123;<br>            <span class="hljs-comment">// N moved the resources to mResourceReferences</span><br>            <span class="hljs-keyword">final</span> Field mResourceReferences = findField(resourcesManagerClass, <span class="hljs-string">&quot;mResourceReferences&quot;</span>);<br>            references = (Collection&lt;WeakReference&lt;Resources&gt;&gt;) mResourceReferences.get(resourcesManager);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> Field fMActiveResources = findField(activityThread, <span class="hljs-string">&quot;mActiveResources&quot;</span>);<br>        <span class="hljs-keyword">final</span> HashMap&lt;?, WeakReference&lt;Resources&gt;&gt; activeResources7 =<br>                (HashMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(currentActivityThread);<br>        references = activeResources7.values();<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="local-resources"><a href="#local-resources" class="headerlink" title="local resources"></a>local resources</h3><p>另一块是针对局部 <code>Context</code> 的，比如 <code>Activity</code>，从<a href="../../../../2020/11/03/launch-activity-sequence/">Activity 启动流程时序图</a>可以找到创建 <code>Activity</code> 的入口点</p><p>创建 <code>Activity</code> 的时候会创建并使用它自己的 <code>Context</code>，而且把 <code>Context.getResources</code> 指向从 <code>ActivityThread.mPackages</code> 里找到的资源目录，所以 Tinker 会在 <code>monkeyPatchExistingResources</code> 修改 <code>ActivityThread.mPackages</code> 指向新资源包</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建 Activity</span><br>ActivityThread.handleLaunchActivity ...<br><br>ActivityThread.performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>        ActivityInfo aInfo = r.activityInfo;<br>    <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-keyword">null</span>) &#123;<br>        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl appContext = createBaseContextForActivity(r);<br>    <span class="hljs-comment">// ...</span><br>    activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br>    <span class="hljs-comment">// ...</span><br>    activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>            r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>            r.embeddedID, r.lastNonConfigurationInstances, config,<br>            r.referrer, r.voiceInteractor, window, r.configCallback,<br>            r.assistToken);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 创建 Activity ContextImpl，可以看到它的 Resources 是指向 ActivityClientRecord.packageInfo.getResDir() 的</span><br><span class="hljs-comment">// 而 ActivityClientRecord.packageInfo 在上面被赋值了</span><br>ContextImpl.createBaseContextForActivity(ActivityClientRecord r) <br>ContextImpl.createActivityContext(ActivityThread mainThread,<br>        LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, <span class="hljs-keyword">int</span> displayId,<br>        Configuration overrideConfiguration) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl context = <span class="hljs-keyword">new</span> ContextImpl(<span class="hljs-keyword">null</span>, mainThread, packageInfo, <span class="hljs-keyword">null</span>,<br>            activityInfo.splitName, activityToken, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, classLoader, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>    context.setResources(resourcesManager.createBaseTokenResources(activityToken,<br>            packageInfo.getResDir(),<br>            splitDirs,<br>            packageInfo.getOverlayDirs(),<br>            packageInfo.getApplicationInfo().sharedLibraryFiles,<br>            displayId,<br>            overrideConfiguration,<br>            compatInfo,<br>            classLoader,<br>            packageInfo.getApplication() == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : packageInfo.getApplication().getResources().getLoaders()));<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ActivityClientRecord.packageInfo 是从 ActivityThread.mPackages 里取的</span><br>ActivityThread.getPackageInfo(String packageName, CompatibilityInfo compatInfo, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> userId) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> differentUser = (UserHandle.myUserId() != userId);<br>    ApplicationInfo ai = PackageManager.getApplicationInfoAsUserCached(<br>            packageName,<br>            PackageManager.GET_SHARED_LIBRARY_FILES<br>            | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,<br>            (userId &lt; <span class="hljs-number">0</span>) ? UserHandle.myUserId() : userId);<br>    <span class="hljs-keyword">synchronized</span> (mResourcesManager) &#123;<br>        WeakReference&lt;LoadedApk&gt; ref;<br>        <span class="hljs-keyword">if</span> (differentUser) &#123;<br>            <span class="hljs-comment">// Caching not supported across users</span><br>            ref = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((flags &amp; Context.CONTEXT_INCLUDE_CODE) != <span class="hljs-number">0</span>) &#123;<br>            ref = mPackages.get(packageName);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ref = mResourcePackages.get(packageName);<br>        &#125;<br>        LoadedApk packageInfo = ref != <span class="hljs-keyword">null</span> ? ref.get() : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (ai != <span class="hljs-keyword">null</span> &amp;&amp; packageInfo != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!isLoadedApkResourceDirsUpToDate(packageInfo, ai)) &#123;<br>                List&lt;String&gt; oldPaths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                LoadedApk.makePaths(<span class="hljs-keyword">this</span>, ai, oldPaths);<br>                packageInfo.updateApplicationInfo(ai, oldPaths);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (packageInfo.isSecurityViolation() &amp;&amp; (flags&amp;Context.CONTEXT_IGNORE_SECURITY) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<br>                        <span class="hljs-string">&quot;Requesting code from &quot;</span> + packageName<br>                        + <span class="hljs-string">&quot; to be run in process &quot;</span><br>                        + mBoundApplication.processName<br>                        + <span class="hljs-string">&quot;/&quot;</span> + mBoundApplication.appInfo.uid);<br>            &#125;<br>            <span class="hljs-keyword">return</span> packageInfo;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ai != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> getPackageInfo(ai, compatInfo, flags);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">// Tinker 将 ActivityThread.mPackages 里的 LoadedApk.mResDir 改为新的资源包</span><br>TinkerResourcePatcher.isResourceCanPatch(Context context) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    Class&lt;?&gt; activityThread = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);<br>    <span class="hljs-comment">// ...</span><br>    packagesFiled = findField(activityThread, <span class="hljs-string">&quot;mPackages&quot;</span>);<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;<br>        resourcePackagesFiled = findField(activityThread, <span class="hljs-string">&quot;mResourcePackages&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>TinkerResourcePatcher.monkeyPatchExistingResources(Context context, String externalResourceFile) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (externalResourceFile == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ApplicationInfo appInfo = context.getApplicationInfo();<br>    <span class="hljs-keyword">final</span> Field[] packagesFields;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;<br>        packagesFields = <span class="hljs-keyword">new</span> Field[]&#123;packagesFiled, resourcePackagesFiled&#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        packagesFields = <span class="hljs-keyword">new</span> Field[]&#123;packagesFiled&#125;;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Field field : packagesFields) &#123;<br>        <span class="hljs-keyword">final</span> Object value = field.get(currentActivityThread);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;<br>            <span class="hljs-keyword">final</span> Object loadedApk = entry.getValue().get();<br>            <span class="hljs-keyword">if</span> (loadedApk == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">final</span> String resDirPath = (String) resDir.get(loadedApk);<br>            <span class="hljs-keyword">if</span> (appInfo.sourceDir.equals(resDirPath)) &#123;<br>                resDir.set(loadedApk, externalResourceFile);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>hotfix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Application 是如何被创建和初始化的？</title>
    <link href="/2021/03/02/how-application-being-created-and-init/"/>
    <url>/2021/03/02/how-application-being-created-and-init/</url>
    
    <content type="html"><![CDATA[<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>从 <code>startActivity</code> 开始，比如打开一个 app 的首页，当 app 未启动时就会走创建 <code>Application</code> 这条路</p><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/from_startActivity_to_zygote.png" alt="from_startActivity_to_zygote.png"></p><h2 id="AMS-承担的工作"><a href="#AMS-承担的工作" class="headerlink" title="AMS 承担的工作"></a>AMS 承担的工作</h2><p>其中的转折点在 <code>resumeTopActivityInnerLocked</code>，发现 app process 不存在，走启动 app process 的流程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ActivityStack.resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;<br>    <span class="hljs-comment">// ... Launching this app&#x27;s activity, make sure the app is no longer considered stopped. 下面是启动 Activity 的逻辑</span><br>    <span class="hljs-keyword">if</span> (next.attachedToProcess()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 此时 app process 还没有起来，走下面一段逻辑</span><br>        <span class="hljs-comment">// Whoops, need to restart this activity!</span><br>        <span class="hljs-keyword">if</span> (!next.hasBeenLaunched) &#123;<br>            next.hasBeenLaunched = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;<br>                next.showStartingWindow(<span class="hljs-keyword">null</span> <span class="hljs-comment">/* prev */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* newTask */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* taskSwich */</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="hljs-string">&quot;Restarting: &quot;</span> + next);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="hljs-string">&quot;resumeTopActivityLocked: Restarting &quot;</span> + next);<br>        mStackSupervisor.startSpecificActivity(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后走到 <code>attemptZygoteSendArgsAndGetResult</code>，AMS 将 app 的相关参数通过 socket 发送给 zygote 进程，由 zygote 负责 fork 出一个 app process，这一段路程就算完结了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">attemptZygoteSendArgsAndGetResult</span><span class="hljs-params">(ZygoteState zygoteState, String msgStr)</span> <span class="hljs-keyword">throws</span> ZygoteStartFailedEx </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;<br>        <span class="hljs-keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;<br>        zygoteWriter.write(msgStr);<br>        zygoteWriter.flush();<br>        Process.ProcessStartResult result = <span class="hljs-keyword">new</span> Process.ProcessStartResult();<br>        result.pid = zygoteInputStream.readInt();<br>        result.usingWrapper = zygoteInputStream.readBoolean();<br>        <span class="hljs-keyword">if</span> (result.pid &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        zygoteState.close();<br>        Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with Zygote - &quot;</span> + ex.toString());<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(ex);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>值得注意的是，AMS 是通过 <code>LocalSocket</code> 与 zygote 交互的，它们建立连接的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.ProcessStartResult ZygoteProcess.startViaZygote(...) &#123;<br>    ArrayList&lt;String&gt; argsForZygote = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    argsForZygote.add(<span class="hljs-string">&quot;--runtime-args&quot;</span>);<br>    <span class="hljs-comment">// 拼接字符串参数 ...</span><br>    <span class="hljs-keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), zygotePolicyFlags, argsForZygote);<br>&#125;<br><br><span class="hljs-keyword">private</span> ZygoteState ZygoteProcess.openZygoteSocketIfNeeded(String abi) <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        attemptConnectionToPrimaryZygote();<br>        <span class="hljs-keyword">if</span> (primaryZygoteState.matches(abi)) &#123;<br>            <span class="hljs-keyword">return</span> primaryZygoteState;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mZygoteSecondarySocketAddress != <span class="hljs-keyword">null</span>) &#123;<br>            attemptConnectionToSecondaryZygote();<br>            <span class="hljs-keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;<br>                <span class="hljs-keyword">return</span> secondaryZygoteState;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;Error connecting to zygote&quot;</span>, ioe);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;Unsupported zygote ABI: &quot;</span> + abi);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ZygoteProcess.attemptConnectionToPrimaryZygote() <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (primaryZygoteState == <span class="hljs-keyword">null</span> || primaryZygoteState.isClosed()) &#123;<br>        primaryZygoteState = ZygoteState.connect(mZygoteSocketAddress, mUsapPoolSocketAddress);<br>        maybeSetApiDenylistExemptions(primaryZygoteState, <span class="hljs-keyword">false</span>);<br>        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> ZygoteState ZygoteState.connect(LocalSocketAddress zygoteSocketAddress, LocalSocketAddress usapSocketAddress) <span class="hljs-keyword">throws</span> IOException &#123; <br>    DataInputStream zygoteInputStream;<br>    BufferedWriter zygoteOutputWriter;<br><br>    <span class="hljs-keyword">final</span> LocalSocket zygoteSessionSocket = <span class="hljs-keyword">new</span> LocalSocket()<br>    <span class="hljs-keyword">if</span> (zygoteSocketAddress == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;zygoteSocketAddress can&#x27;t be null&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        zygoteSessionSocket.connect(zygoteSocketAddress);<br>        zygoteInputStream = <span class="hljs-keyword">new</span> DataInputStream(zygoteSessionSocket.getInputStream());<br>        zygoteOutputWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(zygoteSessionSocket.getOutputStream()), Zygote.SOCKET_BUFFER_SIZE);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zygoteSessionSocket.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignore) &#123;&#125; <br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZygoteState(zygoteSocketAddress, usapSocketAddress, zygoteSessionSocket, zygoteInputStream, zygoteOutputWriter, <br>getAbiList(zygoteOutputWriter, zygoteInputStream));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="走入-zygote"><a href="#走入-zygote" class="headerlink" title="走入 zygote"></a>走入 zygote</h2><h3 id="从-zygote-开始"><a href="#从-zygote-开始" class="headerlink" title="从 zygote 开始"></a>从 zygote 开始</h3><p>下面就轮到 zygote 出场了，zygote 进程是 system server 和 app 进程的父进程，它在 java 的入口点是 <code>ZygoteInit.main</code>；zygote 启动后会加载各个进程共享的资源，然后启动 system server，最后工作在主循环 <code>runSelectLoop</code> 上；在 <code>runSelectLoop</code> 里，zygote 通过 <code>epoll</code> 监听 zygote server socket 并根据请求参数 fork 出 app 进程（上面也说到过 AMS 是通过 <code>LocalSocket</code> 请求让 zygote fork app process）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * zygote 的入口点</span><br><span class="hljs-comment"> * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,</span><br><span class="hljs-comment"> * and handles other tasks related to preparing the process for forking into applications.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ZygoteInit.main(String[] argv) &#123;<br>    ZygoteServer zygoteServer = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// ...</span><br>    zygoteServer = <span class="hljs-keyword">new</span> ZygoteServer(isPrimaryZygote);<br>    <span class="hljs-comment">// ...</span><br>    caller = zygoteServer.runSelectLoop(abiList);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>zygote server socket 实际上是个挂载在 <code>/dev/sockets/</code> 目录下的 FD，它是由脚本 <code>init.rc</code> 创建的，这个 FD 可以通过环境变量 <code>ANDROID_SOCKET_&lt;socketName&gt;</code> 获得</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ZygoteServer(<span class="hljs-keyword">boolean</span> isPrimaryZygote) &#123;<br>    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();<br>    <span class="hljs-keyword">if</span> (isPrimaryZygote) &#123;<br>        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);  <span class="hljs-comment">// PRIMARY_SOCKET_NAME = &quot;zygote&quot;</span><br>        mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);<br>        mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);<br>    &#125;<br>    mUsapPoolSupported = <span class="hljs-keyword">true</span>;<br>    fetchUsapPoolPolicyProps();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a managed LocalServerSocket object using a file descriptor</span><br><span class="hljs-comment"> * created by an init.rc script.  The init scripts that specify the</span><br><span class="hljs-comment"> * sockets name can be found in system/core/rootdir.  The socket is bound</span><br><span class="hljs-comment"> * to the file system in the /dev/sockets/ directory, and the file</span><br><span class="hljs-comment"> * descriptor is shared via the ANDROID_SOCKET_&lt;socketName&gt; environment</span><br><span class="hljs-comment"> * variable.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> LocalServerSocket Zygote.createManagedSocketFromInitSocket(String socketName) &#123;<br>    <span class="hljs-keyword">int</span> fileDesc;<br>    <span class="hljs-keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;  <span class="hljs-comment">// ANDROID_SOCKET_PREFIX = &quot;ANDROID_SOCKET_&quot;</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        String env = System.getenv(fullSocketName);<br>        fileDesc = Integer.parseInt(env);<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Socket unset or invalid: &quot;</span> + fullSocketName, ex);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        FileDescriptor fd = <span class="hljs-keyword">new</span> FileDescriptor();<br>        fd.setInt$(fileDesc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LocalServerSocket(fd);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Error building socket from file descriptor: &quot;</span> + fileDesc, ex);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而 zygote 主循环的整个代码就是 epoll 多路复用的模型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Runs the zygote process&#x27;s select loop. Accepts new connections as</span><br><span class="hljs-comment"> * they happen, and reads commands from connections one spawn-request&#x27;s</span><br><span class="hljs-comment"> * worth at a time.</span><br><span class="hljs-comment"> */</span><br>Runnable ZygoteServer.runSelectLoop(String abiList) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-comment">// epoll 可以同时监听多个 FD：pollFDs，当 epoll 返回时要逐个处理</span><br>        StructPollfd[] pollFDs;<br>        pollFDs = <span class="hljs-keyword">new</span> StructPollfd[socketFDs.size()];<br>        <span class="hljs-keyword">int</span> pollIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileDescriptor socketFD : socketFDs) &#123;<br>            pollFDs[pollIndex] = <span class="hljs-keyword">new</span> StructPollfd();<br>            pollFDs[pollIndex].fd = socketFD;<br>            pollFDs[pollIndex].events = (<span class="hljs-keyword">short</span>) POLLIN;<br>            ++pollIndex;<br>        &#125;<br>        <span class="hljs-comment">// ... 阻塞直到 pollFDs 里有消息输入</span><br>        <span class="hljs-keyword">int</span> pollReturnValue;<br>        <span class="hljs-keyword">try</span> &#123;<br>            pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);<br>        &#125; <span class="hljs-keyword">catch</span> (ErrnoException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;poll failed&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-comment">// ... 第一个 PD 总是 Zygote server socket，它接收 fork 请求并创建一个新的 FD 与对方交互</span><br>        <span class="hljs-keyword">while</span> (--pollIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pollIndex == <span class="hljs-number">0</span>) &#123;<br>                ZygoteConnection newPeer = acceptCommandPeer(abiList);<br>                peers.add(newPeer);<br>                socketFDs.add(newPeer.getFileDescriptor());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;<br>                <span class="hljs-comment">// 从 FD 里解析请求参数并处理</span><br>                ZygoteConnection connection = peers.get(pollIndex);<br>                <span class="hljs-keyword">boolean</span> multipleForksOK = !isUsapPoolEnabled() &amp;&amp; ZygoteHooks.indefiniteThreadSuspensionOK();<br>                <span class="hljs-keyword">final</span> Runnable command = connection.processCommand(<span class="hljs-keyword">this</span>, multipleForksOK);  <span class="hljs-comment">// commands alaways null in zygote server</span><br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="fork-app-process"><a href="#fork-app-process" class="headerlink" title="fork app process"></a>fork app process</h3><p>下面看看 zygote 是怎么 fork 出 app process 的</p><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/fork_by_zygote.png" alt="fork_by_zygote.png"></p><p>在 <code>fork()</code> 系统调用后，返回 0 表示当前处于子进程，&gt; 0 处于父进程（也就是 zygote）</p><p>zygote 进程会继续它的主循环 <code>runSelectLoop</code>，而子进程会跳出主循环，执行 <code>ZygoteConnection.processCommand</code> 返回的 <code>Runnable</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ZygoteInit.main(String[] argv) &#123;<br>    <span class="hljs-comment">// ...</span><br>    Runnable caller;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        Log.i(TAG, <span class="hljs-string">&quot;Accepting command socket connections&quot;</span>);<br>        <span class="hljs-comment">// The select loop returns early in the child process after a fork and</span><br>        <span class="hljs-comment">// loops forever in the zygote.</span><br>        caller = zygoteServer.runSelectLoop(abiList);<br>    &#125; ...<br>    <span class="hljs-comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span><br>    <span class="hljs-comment">// command.</span><br>    <span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;<br>        caller.run();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个 <code>Runnable</code> 实际上是通过反射调用 <code>ActivityThread.main</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// app 进程的 entry point 被设置为 android.app.ActivityThread</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> zygotePolicyFlags, <span class="hljs-keyword">boolean</span> disableHiddenApiChecks, <span class="hljs-keyword">boolean</span> disableTestApiChecks,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">boolean</span> mountExtStorageFull, String abiOverride)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// Start the process.  It will either succeed and return a result containing</span><br>    <span class="hljs-comment">// the PID of the new process, or else throw a RuntimeException.</span><br>    <span class="hljs-keyword">final</span> String entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br>    <span class="hljs-keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, <br>zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime);<br>&#125;<br><br><span class="hljs-comment">// 寻找方法 main(String[] args)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">findStaticMain</span><span class="hljs-params">(String className, String[] argv, ClassLoader classLoader)</span> </span>&#123;<br>    Class&lt;?&gt; cl;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cl = Class.forName(className, <span class="hljs-keyword">true</span>, classLoader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Missing class when invoking static main &quot;</span> + className, ex);<br>    &#125;<br>    Method m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m = cl.getMethod(<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> Class[] &#123; String[].class &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Missing static main on &quot;</span> + className, ex);<br>    &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Problem getting static main on &quot;</span> + className, ex);<br>    &#125;<br>    <span class="hljs-keyword">int</span> modifiers = m.getModifiers();<br>    <span class="hljs-keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main method is not public and static on &quot;</span> + className);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MethodAndArgsCaller(m, argv);<br>&#125;<br><br><span class="hljs-comment">// 通过反射调用 main 方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAndArgsCaller</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">/** method to call */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method mMethod;<br>    <span class="hljs-comment">/** argument array */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] mArgs;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodAndArgsCaller</span><span class="hljs-params">(Method method, String[] args)</span> </span>&#123;<br>        mMethod = method;<br>        mArgs = args;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mMethod.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Object[] &#123; mArgs &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>            Throwable cause = ex.getCause();<br>            <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>                <span class="hljs-keyword">throw</span> (RuntimeException) cause;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                <span class="hljs-keyword">throw</span> (Error) cause;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Application-实例的创建和初始化"><a href="#Application-实例的创建和初始化" class="headerlink" title="Application 实例的创建和初始化"></a>Application 实例的创建和初始化</h2><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/create_application.png" alt="create_application.png"></p><p>app process 的起始点是 <code>ActivityThread.main</code>，做完所有准备龚州工作后进入 loop 循环，后续的任务通过 <code>Handler</code> 执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    Looper.prepareMainLooper();<br>    <span class="hljs-comment">// ...</span><br>    Looper.loop();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ActivityThread.handleBindApplication</code> 是 <code>Application</code> 实例创建和初始化的地方</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ActivityThread.handleBindApplication(AppBindData data) &#123;<br>    <span class="hljs-comment">// ...</span><br>    Application app;<br>    <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();<br>    <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();<br>    <span class="hljs-keyword">try</span> &#123;<br>        app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125; ...<br>&#125;<br><br><span class="hljs-keyword">public</span> Application LoadedApk.makeApplication(<span class="hljs-keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation) &#123;<br>    <span class="hljs-comment">// ...</span><br>    Application app = <span class="hljs-keyword">null</span>;<br>    String appClass = mApplicationInfo.className;<br>    <span class="hljs-keyword">if</span> (forceDefaultAppClass || (appClass == <span class="hljs-keyword">null</span>)) &#123;<br>        appClass = <span class="hljs-string">&quot;android.app.Application&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> java.lang.ClassLoader cl = getClassLoader();<br>        <span class="hljs-keyword">if</span> (!mPackageName.equals(<span class="hljs-string">&quot;android&quot;</span>)) &#123;<br>            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;initializeJavaContextClassLoader&quot;</span>);<br>            initializeJavaContextClassLoader();<br>            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>        &#125;<br>        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// ... 创建 Application 实例</span><br>        app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);<br>        appContext.setOuterContext(app);<br>    &#125; ...<br>    mActivityThread.mAllApplications.add(app);<br>    mApplication = app;<br>    <span class="hljs-keyword">if</span> (instrumentation != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            instrumentation.callApplicationOnCreate(app);  <span class="hljs-comment">// 这里会调用生命周期函数 onCreate</span><br>        &#125; ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br><span class="hljs-keyword">public</span> Instrumentation.<span class="hljs-function">Application <span class="hljs-title">newApplication</span><span class="hljs-params">(ClassLoader cl, String className, Context context)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;<br>    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);<br>    app.attach(context);  <span class="hljs-comment">// 在这里会调用 attachBaseContext</span><br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br><span class="hljs-comment">// 最终调用 loadClass 加载 app Application 类</span><br>Application AppComponentFactory.instantiateApplication(ClassLoader cl, String className)<br>        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> (Application) cl.loadClass(className).newInstance();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Application</tag>
      
      <tag>AMS</tag>
      
      <tag>Zygote</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池 ThreadPool 的实现</title>
    <link href="/2021/02/19/threadpool/"/>
    <url>/2021/02/19/threadpool/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>线程池有几个重要的参数：</p><ul><li><code>maximumPoolSize</code> 最大线程数量，如果新提交的任务因为 <code>workQueue</code> 的容量限制而无法入队，则会尝试新开一个线程执行任务，而如果此时总线程数超过 <code>maximumPoolSize</code> 的限制，那么不再新开一个线程而是提交失败</li><li><code>corePoolSize</code> 核心线程数量，当任务执行完毕，线程也将结束它的生命周期，但最少不会低于 <code>corePoolSize</code></li><li><code>keepAliveTime</code> 空闲线程的存活时间，执行完任务的线程会存活至少 <code>keepAliveTime</code>，再根据当前线程数量和 <code>corePoolSize</code> 决定要不要结束生命</li><li><code>workQueue</code> 任务队列，当提交的任务不能被立刻执行时（线程数 &gt; <code>corePoolSize</code>），会放在 <code>workQueue</code> 排队等待执行</li></ul><p>线程池的内部状态：</p><ul><li><code>RUNNING</code>，可以提交新任务</li><li><code>SHUTDOWN</code>，不能提交新任务，但可以继续把 workQueue 里的任务执行完</li><li><code>STOP</code>，不能提交新任务，不执行 workQueue 里的任务，且中断正在执行的任务</li><li><code>TIDYING</code>，所有任务都已结束，此时线程数为零，准备执行 terminated()</li><li><code>TERMINATED</code>，<code>terminated()</code> 执行完毕</li></ul><h2 id="生产者-消费者模式的-worker"><a href="#生产者-消费者模式的-worker" class="headerlink" title="生产者 - 消费者模式的 worker"></a>生产者 - 消费者模式的 worker</h2><p>线程（worker）作为消费者，不断地从任务队列（workQueue）里获取任务并执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// worker 的执行流程</span><br><span class="hljs-comment">// 用一个 while 循环不断地从 workQueue 里获取任务（blocked &amp; timeouted）</span><br><span class="hljs-comment">// getTask 返回 null 导致当前线程结束生命</span><br><span class="hljs-keyword">void</span> ThreadPoolExecutor.runWorker(Worker w) &#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从 workQueue 获取任务（blocked &amp; timeouted）</span><br>Runnable ThreadPoolExecutor.getTask() &#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>        <br>        <span class="hljs-comment">// 1. 线程池已 shutdown（只需把 workQueue 执行完毕），但 workQueue 已清空</span><br>        <span class="hljs-comment">// 2. 线程池已 stop，无需执行 workQueue 剩下的任务</span><br>        <span class="hljs-comment">// 此时返回 null 结束线程 </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当线程数 &gt; corePoolSize，如果阻塞 keepAliveTime 时间段都没有新任务进来，则返回 null 结束当前线程</span><br>        <span class="hljs-comment">// 当线程数 &gt; maximumPoolSize 且 workQueue 为空，也要结束当前线程，从而降低线程数</span><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="corePoolSize，workQueue-和-maximumPoolSize-之间的关系"><a href="#corePoolSize，workQueue-和-maximumPoolSize-之间的关系" class="headerlink" title="corePoolSize，workQueue 和 maximumPoolSize 之间的关系"></a><code>corePoolSize</code>，<code>workQueue</code> 和 <code>maximumPoolSize</code> 之间的关系</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ThreadPoolExecutor.execute(Runnable command) &#123;<br>    <span class="hljs-comment">// 如果线程数 &lt; corePoolSize，则新开一个线程执行任务</span><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><br>    <span class="hljs-comment">// 否则放入 workQueue 等待执行</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果超过 workQueue 容量限制，则尝试新开一个线程执行任务</span><br>    <span class="hljs-comment">// 从下面的 addWorker 可以知道，如果新开线程的时候发现当前线程总数 &gt;= maximumPoolSize，那么任务提交失败</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br><br><span class="hljs-keyword">boolean</span> ThreadPoolExecutor.addWorker(Runnable firstTask, <span class="hljs-keyword">boolean</span> core) &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="定时任务（ScheduledExecutorService）"><a href="#定时任务（ScheduledExecutorService）" class="headerlink" title="定时任务（ScheduledExecutorService）"></a>定时任务（<code>ScheduledExecutorService</code>）</h2><p>上文里的任务队列用的是 <code>BlockingQueue</code>，它是按照 FIFO 的优先级给任务排队的；要实现定时，就要按照执行时间点的优先级给任务排序，只有到达执行时间点的任务才能出队</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>要排序，每次取最小值（到达执行时间点的任务），而且会插入新元素，典型的数据结构是「小顶堆」；<code>DelayedWorkQueue</code> 就是用小顶堆实现的阻塞队列</p><p>堆有几个特性：</p><ul><li>堆在逻辑上是二叉树，存储为数组；节点从上到下，从左到右按顺序摊平在数组上</li><li>既然节点是按顺序排的，那么可以从索引计算出父/子节点：<ul><li><code>parent(i) = floor((i - 1)/2)</code></li><li><code>left(i) = 2i + 1</code></li><li><code>right(i) = 2i + 2</code></li></ul></li><li>父节点比子节点要小的是小顶堆，根节点最小；父节点比子节点大的是大顶堆，根节点最大；左右节点之间没有大小要求</li><li><code>shiftDown()</code>，出队最小/大值（也即根节点）后，将数组最后一个元素转移到根节点，然后从根节点开始递归地重排：如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动，这样是这个节点在数组的位置下降</li><li><code>shiftUp()</code>，入队一个新元素到数组尾部，那么从这个元素开始从下往上重排：如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置，这样是这个节点在数组的位置上升</li></ul><h3 id="DelayedWorkQueue-按执行时间优先级排序的阻塞队列"><a href="#DelayedWorkQueue-按执行时间优先级排序的阻塞队列" class="headerlink" title="DelayedWorkQueue 按执行时间优先级排序的阻塞队列"></a><code>DelayedWorkQueue</code> 按执行时间优先级排序的阻塞队列</h3><p>提交一个新任务到 <code>DelayedWorkQueue</code>，重排 workQueue</p><p>workQueue 是按执行时间点排序的，leader 是在队头任务上挂起的线程，leader 未唤醒时新来的出队请求将在 available 上挂起</p><p>队列为空时线程也在 available 上挂起</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ScheduledFuture&lt;?&gt; ScheduledThreadPoolExecutor.schedule(Runnable command, <span class="hljs-keyword">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span> || unit == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,<br>        <span class="hljs-keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="hljs-keyword">null</span>, triggerTime(delay, unit), sequencer.getAndIncrement()));<br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">void</span> ScheduledThreadPoolExecutor.delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123;<br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">super</span>.getQueue().add(task);<br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">else</span><br>            ensurePrestart();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">boolean</span> DelayedWorkQueue.add(Runnable e) &#123;<br>    <span class="hljs-keyword">return</span> offer(e);<br>&#125;<br><br><span class="hljs-comment">// 插入小顶堆</span><br><span class="hljs-keyword">boolean</span> DelayedWorkQueue.offer(Runnable x) &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 小顶堆底层是数组，数组容量不足需要扩容（扩容 50%）</span><br>        <span class="hljs-keyword">int</span> i = size;<br>        <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>            grow();<br>        <span class="hljs-comment">// 小顶堆的插入操作 siftUp</span><br>        size = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            queue[<span class="hljs-number">0</span>] = e;<br>            setIndex(e, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            siftUp(i, e);<br>        &#125;<br>        <span class="hljs-comment">// 新加入的任务排在队头，它的执行时间点最近</span><br>        <span class="hljs-comment">// 此时 leader 是挂起在上一个队头上的，要置空（有更近的执行时间点进来了）并唤醒 available 上的线程来争抢新的队头任务</span><br>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;<br>            leader = <span class="hljs-keyword">null</span>;<br>            available.signal();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 堆是一个二叉树，广度优先、从左到右存储为数组</span><br><span class="hljs-comment">// 新元素添加到数组尾部（相当于二叉树中的叶子节点），k 是它的索引，为了继续满足小顶堆的要求，需要重新排序</span><br><span class="hljs-keyword">void</span> DelayedWorkQueue.siftUp(<span class="hljs-keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key) &#123;<br><span class="hljs-comment">// 从下往上比较，如果它比父节点小，交换之</span><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        setIndex(e, k);<br>        k = parent;<br>    &#125;<br>    <span class="hljs-comment">// 直到满足小于父节点的要求（小顶堆），那么这就是 key 的合适位置</span><br>    queue[k] = key;<br>    setIndex(key, k);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面说过 <code>worker</code> 是一个「生产者-消费者」模型，通过 <code>getTask</code> 不断地从 <code>workQueue</code> 获取任务</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从 workQueue 获取任务（blocked &amp; timeouted）</span><br>Runnable ThreadPoolExecutor.getTask() &#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任务出队（blocked）</span><br>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br><br>            <span class="hljs-comment">// 任务队列为空，在 available 挂起</span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)<br>                available.await();<br>            <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// 到达执行时间点的才能出队</span><br>                <span class="hljs-keyword">long</span> delay = first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> finishPoll(first);<br><br>                <span class="hljs-comment">// leader 是挂起在 first 上的线程，它将在 first 执行时间点上恢复</span><br>                <span class="hljs-comment">// 如果已有线程在 first 上挂起，则当前线程在 available 上挂起</span><br>                first = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-keyword">null</span>)<br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Thread thisThread = Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 出队后，唤醒在 available 上挂起的线程</span><br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>)<br>            available.signal();<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将小顶堆的根 queue[0] 出队后，需要重排堆：</span><br><span class="hljs-comment">// 1. 将最后一个数组元素转移到根节点</span><br><span class="hljs-comment">// 2. 从上往下重排：比较父节点和子节点，如果父节点大于子节点则交换之</span><br>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;<br>    <span class="hljs-keyword">int</span> s = --size;<br>    RunnableScheduledFuture&lt;?&gt; x = queue[s];<br>    queue[s] = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        siftDown(<span class="hljs-number">0</span>, x);<br>    setIndex(f, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">void</span> DelayedWorkQueue.siftDown(<span class="hljs-keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key) &#123;<br>    <span class="hljs-keyword">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>        <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        RunnableScheduledFuture&lt;?&gt; c = queue[child];<br>        <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (key.compareTo(c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<br>        setIndex(c, k);<br>        k = child;<br>    &#125;<br>    queue[k] = key;<br>    setIndex(key, k);<br>&#125;<br><br><span class="hljs-comment">// 任务出队（timeouted）</span><br>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.poll(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)<br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br><br>            <span class="hljs-comment">// 队列为空，挂起 timeout 后继续</span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">else</span><br>                    nanos = available.awaitNanos(nanos);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// first 到达执行时间点，立刻返回</span><br>                <span class="hljs-keyword">long</span> delay = first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> finishPoll(first);<br><br>                <span class="hljs-comment">// 否则挂起</span><br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                first = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                <span class="hljs-keyword">if</span> (nanos &lt; delay || leader != <span class="hljs-keyword">null</span>)<br>                    nanos = available.awaitNanos(nanos);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Thread thisThread = Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">long</span> timeLeft = available.awaitNanos(delay);<br>                        nanos -= delay - timeLeft;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>)<br>            available.signal();<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="如果-worker-数量超过-maximumPoolSize，task-会被-reject"><a href="#如果-worker-数量超过-maximumPoolSize，task-会被-reject" class="headerlink" title="如果 worker 数量超过 maximumPoolSize，task 会被 reject"></a>如果 worker 数量超过 maximumPoolSize，task 会被 reject</h2><p><code>ThreadPoolExecutor</code> 提供了 <code>RejectedExecutionHandler</code> 来处理这种情况，平常通过 <code>Executors</code> 创建的线程池使用默认的 <code>AbortPolicy</code>，它会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that throws a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> RejectedExecutionException&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Always throws RejectedExecutionException.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException always</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其他的还有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扔掉 task 不做任何处理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 既然 workQueue 满了那我就扔掉一个，然后把这个 task 入队</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由提交 task 的线程负责执行 task</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;        <br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>threadpool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（五）Condition 的语言实现：Object.wait 和 Object.notify</title>
    <link href="/2021/02/11/wait-notify/"/>
    <url>/2021/02/11/wait-notify/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="../../../../2021/01/24/condition-by-lock/">Lock（三）利用 Lock 实现 Condition</a> 我们介绍了如何用 <code>Lock</code> 来实现 <code>Condition</code>，而 <code>Condition</code> 对标的是 <code>Object.wait</code> 和 <code>Object.notify</code></p><p>我们来看看 ART 是怎么实现 wait/notify 的（最好先了解下 <a href="../../../../2021/02/08/synchronized-implementation/">synchronized 的基础知识</a>）</p><h2 id="ConditionVariable"><a href="#ConditionVariable" class="headerlink" title="ConditionVariable"></a>ConditionVariable</h2><p>对 futex/mutex 的封装，宏 <code>ART_USE_FUTEXES</code> 决定底层是使用 futex 还是 mutex；它不是「条件变量」，<code>Monitor</code> 才是（而且它还包含 Lock 的角色）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::Wait</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  guard_.<span class="hljs-built_in">CheckSafeToWait</span>(self);<br>  <span class="hljs-built_in">WaitHoldingLocks</span>(self);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::WaitHoldingLocks</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());<br>  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_recursion_count = guard_.recursion_count_;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>  num_waiters_++;<br>  <span class="hljs-comment">// Ensure the Mutex is contended so that requeued threads are awoken.</span><br>  guard_.<span class="hljs-built_in">increment_contenders</span>();<br>  guard_.recursion_count_ = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int32_t</span> cur_sequence = sequence_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  guard_.<span class="hljs-built_in">ExclusiveUnlock</span>(self);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_sequence, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// Futex failed, check it is an expected error.</span><br>    <span class="hljs-comment">// EAGAIN == EWOULDBLK, so we let the caller try again.</span><br>    <span class="hljs-comment">// EINTR implies a signal was sent to this thread.</span><br>    <span class="hljs-keyword">if</span> ((errno != EINTR) &amp;&amp; (errno != EAGAIN)) &#123;<br>      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);<br>  guard_.<span class="hljs-built_in">ExclusiveLock</span>(self);<br>  <span class="hljs-built_in">CHECK_GT</span>(num_waiters_, <span class="hljs-number">0</span>);<br>  num_waiters_--;<br>  <span class="hljs-comment">// We awoke and so no longer require awakes from the guard_&#x27;s unlock.</span><br>  <span class="hljs-built_in">CHECK_GT</span>(guard_.<span class="hljs-built_in">get_contenders</span>(), <span class="hljs-number">0</span>);<br>  guard_.<span class="hljs-built_in">decrement_contenders</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">pid_t</span> old_owner = guard_.<span class="hljs-built_in">GetExclusiveOwnerTid</span>();<br>  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);<br>  guard_.recursion_count_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_wait, (&amp;cond_, &amp;guard_.mutex_));<br>  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(old_owner, std::memory_order_relaxed);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  guard_.recursion_count_ = old_recursion_count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::Signal</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());<br>  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>  <span class="hljs-built_in">RequeueWaiters</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_signal, (&amp;cond_));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::RequeueWaiters</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> count)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (num_waiters_ &gt; <span class="hljs-number">0</span>) &#123;<br>    sequence_++;  <span class="hljs-comment">// Indicate a signal occurred.</span><br>    <span class="hljs-comment">// Move waiters from the condition variable&#x27;s futex to the guard&#x27;s futex,</span><br>    <span class="hljs-comment">// so that they will be woken up when the mutex is released.</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(),<br>                      FUTEX_REQUEUE_PRIVATE,<br>                      <span class="hljs-comment">/* Threads to wake */</span> <span class="hljs-number">0</span>,<br>                      <span class="hljs-comment">/* Threads to requeue*/</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> timespec*&gt;(count),<br>                      guard_.state_and_contenders_.<span class="hljs-built_in">Address</span>(),<br>                      <span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (!done &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) &#123;<br>      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex requeue failed for &quot;</span> &lt;&lt; name_;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>从逻辑上实现了「条件变量」，对应 Condition；它有两条单向链表的排队队列：</p><ul><li>等待队列，被挂起的线程（wait）在这里排队，<code>Monitor::wait_set_</code> 是队头</li><li>唤醒队列，等待被唤醒的线程（notify）在这里排队，<code>Monitor::wake_set_</code> 是队头</li></ul><p><code>Thread</code> 有个成员变量充当 next 指针：<code>Thread::GetWaitNext()</code> 和 <code>Thread::SetWaitNext(Thread* next)</code></p><p>await 是把线程添加到 wait set 队尾，notify 是把 wait set 队头转移为 wake set 队头，然后在退出临界区（释放锁）时唤醒 wake set 队头</p><p>同时 <code>Thread::wait_monitor_</code> 标识线程在哪个 <code>Monitor</code> 上挂起</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br>  <span class="hljs-comment">// Threads currently waiting on this monitor.</span><br>  <span class="hljs-function">Thread* wait_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;<br>  <span class="hljs-comment">// Threads that were waiting on this monitor, but are now contending on it.</span><br>  <span class="hljs-function">Thread* wake_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 将新挂起的线程添加到 wait set 队尾</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::AppendToWaitSet</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// Not checking that the owner is equal to this thread, since we&#x27;ve released</span><br>  <span class="hljs-comment">// the monitor by the time this method is called.</span><br>  <span class="hljs-built_in">DCHECK</span>(thread != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(thread-&gt;<span class="hljs-built_in">GetWaitNext</span>() == <span class="hljs-literal">nullptr</span>) &lt;&lt; thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>  <span class="hljs-keyword">if</span> (wait_set_ == <span class="hljs-literal">nullptr</span>) &#123;<br>    wait_set_ = thread;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// push_back.</span><br>  Thread* t = wait_set_;<br>  <span class="hljs-keyword">while</span> (t-&gt;<span class="hljs-built_in">GetWaitNext</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>    t = t-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>  &#125;<br>  t-&gt;<span class="hljs-built_in">SetWaitNext</span>(thread);<br>&#125;<br><br><span class="hljs-comment">// notify 并没有唤醒线程，而是把 wait set 的队头转移到 wake set 队头</span><br><span class="hljs-comment">// 实际上是在释放锁时唤醒 wake set 队头</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-comment">// Make sure that we hold the lock.</span><br>  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;<br>    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// Move one thread from waiters to wake set</span><br>  Thread* to_move = wait_set_;<br>  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;<br>    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);<br>    wake_set_ = to_move;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait"></a>Object.wait</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> Object.wait() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">void</span> Object.wait(<span class="hljs-keyword">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    wait(timeout, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> Object.wait(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/native/java_lang_Object.cc</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object_waitJI</span><span class="hljs-params">(JNIEnv* env, jobject java_this, jlong ms, jint ns)</span> </span>&#123;<br>  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Wait</span>(soa.<span class="hljs-built_in">Self</span>(), ms, ns);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">int64_t</span> ms, <span class="hljs-keyword">int32_t</span> ns)</span> </span>&#123;<br>  Monitor::<span class="hljs-built_in">Wait</span>(self, <span class="hljs-keyword">this</span>, ms, ns, <span class="hljs-literal">true</span>, kTimedWaiting);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ObjPtr&lt;mirror::Object&gt; obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">int64_t</span> ms,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">int32_t</span> ns,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">bool</span> interruptShouldThrow,</span></span><br><span class="hljs-params"><span class="hljs-function">                   ThreadState why)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;<br>  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;<br><br>  <span class="hljs-comment">// 将锁膨胀为 fat lock</span><br>  LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">while</span> (lock_word.<span class="hljs-built_in">GetState</span>() != LockWord::kFatLocked) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br>      <span class="hljs-keyword">case</span> LockWord::kHashCode:<br><br>      <span class="hljs-comment">// wait/notify 必须先用 synchronized 获取此对象上的锁</span><br>      <span class="hljs-comment">// 否则抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kUnlocked:<br>        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br><br>      <span class="hljs-comment">// 同上，必须获得此对象锁；此时对象锁被别的线程持有，抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>        <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>        <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;<br>          <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>          <span class="hljs-comment">// 将 thin lock（偏向锁）膨胀为 fat lock（重量级锁），同时创建一个监视器 Monitor</span><br>          <span class="hljs-comment">// We own the lock, inflate to enqueue ourself on the Monitor. May fail spuriously so</span><br>          <span class="hljs-comment">// re-load.</span><br>          <span class="hljs-built_in">Inflate</span>(self, self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>);<br>          lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 已经是 fat lock 了</span><br>      <span class="hljs-keyword">case</span> LockWord::kFatLocked:  <span class="hljs-comment">// Unreachable given the loop condition above. Fall-through.</span><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 必须膨胀为 fat lock，它才有 Monitor</span><br>  Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>  mon-&gt;<span class="hljs-built_in">Wait</span>(self, ms, ns, interruptShouldThrow, why);<br>&#125;<br><br><span class="hljs-comment">// 在监视器上挂起</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">int64_t</span> ms, <span class="hljs-keyword">int32_t</span> ns,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">bool</span> interruptShouldThrow, ThreadState why)</span> </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Release our hold - we need to let it go even if we&#x27;re a few levels</span><br><span class="hljs-comment">   * deep in a recursive lock, and we need to restore that later.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> prev_lock_count = lock_count_;<br>  lock_count_ = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 挂起线程前需要释放锁</span><br>  <span class="hljs-comment">// 将线程添加到 wait set 队尾，释放锁，wake set 不为空则唤醒第一个（队头开始）</span><br>  <span class="hljs-keyword">bool</span> was_interrupted = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">bool</span> timed_out = <span class="hljs-literal">false</span>;<br>  owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>  num_waiters_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>  &#123;<br>    <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, why)</span></span>;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;<br>    <span class="hljs-built_in">AppendToWaitSet</span>(self);<br>    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);<br>    <span class="hljs-comment">// Handle the case where the thread was interrupted before we called wait().</span><br>    <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">IsInterrupted</span>()) &#123;<br>      was_interrupted = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">// 然后将线程在它的成员变量 Thread.wait_cond_ 上挂起</span><br>      <span class="hljs-comment">// Wait for a notification or a timeout to occur.</span><br>      <span class="hljs-keyword">if</span> (why == kWaiting) &#123;<br>        self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Wait</span>(self);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">DCHECK</span>(why == kTimedWaiting || why == kSleeping) &lt;&lt; why;<br>        timed_out = self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">TimedWait</span>(self, ms, ns);<br>      &#125;<br>      was_interrupted = self-&gt;<span class="hljs-built_in">IsInterrupted</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 线程被唤醒后，要将线程上的监视器置空，并重新获得锁</span><br>  &#123;<br>    <span class="hljs-comment">// We reset the thread&#x27;s wait_monitor_ field after transitioning back to runnable so</span><br>    <span class="hljs-comment">// that a thread in a waiting/sleeping state has a non-null wait_monitor_ for debugging</span><br>    <span class="hljs-comment">// and diagnostic purposes. (If you reset this earlier, stack dumps will claim that threads</span><br>    <span class="hljs-comment">// are waiting on &quot;null&quot;.)</span><br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;<br>    <span class="hljs-built_in">DCHECK</span>(self-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>);<br>    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  Lock&lt;LockReason::kForWait&gt;(self);<br>  lock_count_ = prev_lock_count;<br>  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>  self-&gt;<span class="hljs-built_in">GetWaitMutex</span>()-&gt;<span class="hljs-built_in">AssertNotHeld</span>(self);<br>  num_waiters_.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>  <span class="hljs-built_in">RemoveFromWaitSet</span>(self);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Object-notify"><a href="#Object-notify" class="headerlink" title="Object.notify"></a>Object.notify</h2><p>把挂起的线程从 wait set 转移到 wake set</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object_notify</span><span class="hljs-params">(JNIEnv* env, jobject java_this)</span> </span>&#123;<br>  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Notify</span>(soa.<span class="hljs-built_in">Self</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  Monitor::<span class="hljs-built_in">Notify</span>(self, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span></span><br><span class="hljs-function">      <span class="hljs-title">REQUIRES_SHARED</span><span class="hljs-params">(Locks::mutator_lock_)</span> </span>&#123;<br>    <span class="hljs-built_in">DoNotify</span>(self, obj, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::DoNotify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-keyword">bool</span> notify_all)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);<br>  LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br>    <span class="hljs-keyword">case</span> LockWord::kHashCode:<br>      <span class="hljs-comment">// Fall-through.</span><br>    <span class="hljs-keyword">case</span> LockWord::kUnlocked:<br>      <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br>    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>      <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>      <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>      <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;<br>        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// We own the lock but there&#x27;s no Monitor and therefore no waiters.</span><br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;<br>      Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>      <span class="hljs-keyword">if</span> (notify_all) &#123;<br>        mon-&gt;<span class="hljs-built_in">NotifyAll</span>(self);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        mon-&gt;<span class="hljs-built_in">Notify</span>(self);<br>      &#125;<br>      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span><br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>      <span class="hljs-built_in">UNREACHABLE</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-comment">// Make sure that we hold the lock.</span><br>  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;<br>    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// Move one thread from waiters to wake set</span><br>  Thread* to_move = wait_set_;<br>  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;<br>    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);<br>    wake_set_ = to_move;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用 notify 前需要先获得它的对象锁，notify 把线程转移到 wake set，释放锁时会唤醒线程（从而让线程能够重新获得锁）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-keyword">if</span> (owner == self) &#123;<br>    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span><br>    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);<br>    <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;<br>      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      --lock_count_;<br>      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);<br>      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span><br>      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-comment">// We want to release the monitor and signal up to one thread that was waiting</span><br>  <span class="hljs-comment">// but has since been notified.</span><br>  <span class="hljs-built_in">DCHECK_EQ</span>(lock_count_, <span class="hljs-number">0u</span>);<br>  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>  <span class="hljs-keyword">while</span> (wake_set_ != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">// No risk of waking ourselves here; since monitor_lock_ is not released until we&#x27;re ready to</span><br>    <span class="hljs-comment">// return, notify can&#x27;t move the current thread from wait_set_ to wake_set_ until this</span><br>    <span class="hljs-comment">// method is done checking wake_set_.</span><br>    Thread* thread = wake_set_;<br>    wake_set_ = thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>    thread-&gt;<span class="hljs-built_in">SetWaitNext</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">DCHECK</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) == <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// Check to see if the thread is still waiting.</span><br>    &#123;<br>      <span class="hljs-comment">// In the case of wait(), we&#x27;ll be acquiring another thread&#x27;s GetWaitMutex with</span><br>      <span class="hljs-comment">// self&#x27;s GetWaitMutex held. This does not risk deadlock, because we only acquire this lock</span><br>      <span class="hljs-comment">// for threads in the wake_set_. A thread can only enter wake_set_ from Notify or NotifyAll,</span><br>      <span class="hljs-comment">// and those hold monitor_lock_. Thus, the threads whose wait mutexes we acquire here must</span><br>      <span class="hljs-comment">// have already been released from wait(), since we have not released monitor_lock_ until</span><br>      <span class="hljs-comment">// after we&#x27;ve chosen our thread to wake, so there is no risk of the following lock ordering</span><br>      <span class="hljs-comment">// leading to deadlock:</span><br>      <span class="hljs-comment">// Thread 1 waits</span><br>      <span class="hljs-comment">// Thread 2 waits</span><br>      <span class="hljs-comment">// Thread 3 moves threads 1 and 2 from wait_set_ to wake_set_</span><br>      <span class="hljs-comment">// Thread 1 enters this block, and attempts to acquire Thread 2&#x27;s GetWaitMutex to wake it</span><br>      <span class="hljs-comment">// Thread 2 enters this block, and attempts to acquire Thread 1&#x27;s GetWaitMutex to wake it</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// Since monitor_lock_ is not released until the thread-to-be-woken-up&#x27;s GetWaitMutex is</span><br>      <span class="hljs-comment">// acquired, two threads cannot attempt to acquire each other&#x27;s GetWaitMutex while holding</span><br>      <span class="hljs-comment">// their own and cause deadlock.</span><br>      <span class="hljs-function">MutexLock <span class="hljs-title">wait_mu</span><span class="hljs-params">(self, *thread-&gt;GetWaitMutex())</span></span>;<br>      <span class="hljs-keyword">if</span> (thread-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// Release the lock, so that a potentially awakened thread will not</span><br>        <span class="hljs-comment">// immediately contend on it. The lock ordering here is:</span><br>        <span class="hljs-comment">// monitor_lock_, self-&gt;GetWaitMutex, thread-&gt;GetWaitMutex</span><br>        monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);  <span class="hljs-comment">// Releases contenders.</span><br>        thread-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Signal</span>(self);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);<br>  <span class="hljs-built_in">DCHECK</span>(!monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><ul><li>与 JCU.Condition 不同，对象监视器 Monitor 并没有把「条件变量」这部分功能抽离出来，它既是 Lock 又是 Condition</li><li>Condition 和 Monitor 都用排队队列来组织挂起的线程</li><li>Condition 在 notify 后立刻唤醒线程，而 Monitor 因为 wait/notify 需要获得锁后才能执行，只能在 notify 线程释放锁时才唤醒 wait 线程</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>wait</tag>
      
      <tag>notify</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（四）synchronized 的语言实现</title>
    <link href="/2021/02/08/synchronized-implementation/"/>
    <url>/2021/02/08/synchronized-implementation/</url>
    
    <content type="html"><![CDATA[<h2 id="monitor-指令"><a href="#monitor-指令" class="headerlink" title="monitor 指令"></a>monitor 指令</h2><p>在 <a href="../../../../2021/01/13/aqs-lock-implementation/">Lock（二）AQS 源码分析以及 Lock 的实现</a> 这篇文章里介绍了基于 AQS 的 <code>Lock</code>，它是双向链表的排队队列和系统调用 <code>futex</code> 实现的</p><p>其实 java 语言规范里自带了 Lock 的实现：<code>synchronized</code> 关键字，下面看看 ART 是怎么实现它的</p><p>先写一个使用了 <code>synchronized</code> 的测试方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapplication;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>            System.out.println(msg != <span class="hljs-keyword">null</span> ? msg : <span class="hljs-string">&quot;null&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        Hello instance = <span class="hljs-keyword">new</span> Hello();<br>        instance.say(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译打包出 apk 文件，解压出其中的 classes.dex，并用 <code>baksmali</code> 转换成 smali 指令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">java -jar baksmali-2.4.0.jar disassemble classes.dex<br></code></pre></div></td></tr></table></figure><p><code>Hello.say(String)</code> 对应的 smali 代码是这样的</p><p><code>synchronized</code> 代码块被两条指令包裹：<code>monitor-enter</code> 和 <code>monitor-exit</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">.method public say(Ljava/lang/String;)V<br>    .registers 5<br>    .param p1, <span class="hljs-string">&quot;msg&quot;</span>    <span class="hljs-comment"># Ljava/lang/String;</span><br><br>    .line 8<br><span class="hljs-comment"># 本地变量寄存器 v0 被赋予 Hello.lock</span><br>    iget-object v0, p0, Lcom/example/myapplication/Hello;-&gt;lock:Ljava/lang/Object;<br><br><span class="hljs-comment"># 重点</span><br>    monitor-enter v0<br><br>    .line 9<br>    :try_start_3<br>    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;<br><br>    if-eqz p1, :cond_9<br><br>    move-object v2, p1<br><br>    goto :goto_b<br><br>    :cond_9<br>    const-string v2, <span class="hljs-string">&quot;null&quot;</span><br><br>    :goto_b<br>    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V<br><br>    .line 10<br><span class="hljs-comment"># 重点</span><br>    monitor-exit v0<br><br>    .line 11<br>    return-void<br><br>    .line 10<br>    :catchall_10<br>    move-exception v1<br><br>    monitor-exit v0<br>    :try_end_12<br>    .catchall &#123;:try_start_3 .. :try_end_12&#125; :catchall_10<br><br>    throw v1<br>.end method<br></code></pre></div></td></tr></table></figure><h2 id="对象锁的概念"><a href="#对象锁的概念" class="headerlink" title="对象锁的概念"></a>对象锁的概念</h2><p>在进一步分析代码之前，先要了解下 java 对象锁的一些背景知识（from <a href="https://blog.csdn.net/fan1865221/article/details/96338419">JAVA锁的膨胀过程</a>）</p><p>java 对象锁会有一个膨胀加码的过程：无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p><ul><li><strong>无锁</strong></li><li><strong>偏向锁，</strong>为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</li><li><strong>轻量级锁，</strong>在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，所以轻量级锁一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li><li><strong>重量级锁，</strong>当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。</li></ul><h2 id="LockWord"><a href="#LockWord" class="headerlink" title="LockWord"></a>LockWord</h2><p>先了解一个结构<code>LockWord</code> ，它其实是一个 <code>uint32_t</code>，低 16 bits 保存持有锁的 thread id，后续 12 bits 保存锁的个数</p><p>它是 <code>Object</code> 的成员变量 <code>monitor_</code>，所以每个 java 对象都可以作为锁使用</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> LockWord <span class="hljs-title">FromThinLockId</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> thread_id, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> gc_state)</span> </span>&#123;<br>    <span class="hljs-built_in">CHECK_LE</span>(thread_id, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(kThinLockMaxOwner));<br>    <span class="hljs-built_in">CHECK_LE</span>(count, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(kThinLockMaxCount));<br>    <span class="hljs-comment">// DCHECK_EQ(gc_bits &amp; kGCStateMaskToggled, 0U);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">LockWord</span>((thread_id &lt;&lt; kThinLockOwnerShift) |<br>                    (count &lt;&lt; kThinLockCountShift) |<br>                    (gc_state &lt;&lt; kGCStateShift) |<br>                    (kStateThinOrUnlocked &lt;&lt; kStateShift));<br>&#125;<br><br><span class="hljs-comment">// C++ mirror of java.lang.Object</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MANAGED</span> <span class="hljs-title">LOCKABLE</span> <span class="hljs-title">Object</span> &#123;</span><br><span class="hljs-comment">// Monitor and hash code information.</span><br><span class="hljs-keyword">uint32_t</span> monitor_;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>ART 使用 <code>Mutex</code> 作为互斥量的实现（lock &amp; unlock），它根据宏 <code>ART_USE_FUTEXES</code> 决定是使用 <code>futex</code> 还是 <code>mutex</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span><br><br><span class="hljs-comment">// 获取排它锁</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Mutex::ExclusiveLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">// Mutex::state_and_contenders_ 是 AtomicInteger</span><br>      <span class="hljs-comment">// 最低 1 bit 表示互斥量是否被持有（1 - 持有，0 - 未持有），其余高位的 bits 表示在此互斥量上挂起的线程数量</span><br>      <span class="hljs-keyword">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>      <span class="hljs-comment">// 锁没有被取走，立刻获得锁（cas）</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) <span class="hljs-comment">/* lock not held */</span>) &#123;<br>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-comment">// 否则将挂起线程的数量加一，并用 futex 挂起当前线程</span><br>        ScopedContentionRecorder <span class="hljs-built_in">scr</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">SafeGetTid</span>(self), <span class="hljs-built_in">GetExclusiveOwnerTid</span>());<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self, [](<span class="hljs-keyword">int32_t</span> v) &#123; <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;<br>          <span class="hljs-comment">// Increment contender count. We can&#x27;t create enough threads for this to overflow.</span><br>          <span class="hljs-built_in">increment_contenders</span>();<br>          <span class="hljs-comment">// Make cur_state again reflect the expected value of state_and_contenders.</span><br>          cur_state += kContenderIncrement;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(should_respond_to_empty_checkpoint_request_)) &#123;<br>            self-&gt;<span class="hljs-built_in">CheckEmptyCheckpointFromMutex</span>();<br>          &#125;<br>          <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_state, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">if</span> ((errno != EAGAIN) &amp;&amp; (errno != EINTR)) &#123;<br>                <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;<br>              &#125;<br>            &#125;<br>            <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);<br>            <span class="hljs-comment">// Retry until not held. In heavy contention situations we otherwise get redundant</span><br>            <span class="hljs-comment">// futex wakeups as a result of repeatedly decrementing and incrementing contenders.</span><br>            cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>          &#125; <span class="hljs-keyword">while</span> ((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>);<br>          <span class="hljs-built_in">decrement_contenders</span>();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-comment">// Confirm that lock is now held.</span><br>    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><br>    <span class="hljs-comment">// 使用 pthread_mutex_lock 加锁</span><br>    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_lock, (&amp;mutex_));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// exclusive_owner_ 记下获得排他锁的 thread id</span><br>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);<br>    <span class="hljs-built_in">RegisterAsLocked</span>(self);<br>  &#125;<br>  recursion_count_++;<br>&#125;<br><br><span class="hljs-comment">// tryLock 方法</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br><br>      <span class="hljs-comment">// 使用 futex 的情况下，利用一个 AtomicInteger 的最低 1 bit 表示锁有没被借出，一个 cas 操作即可</span><br>      <span class="hljs-keyword">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>      <span class="hljs-keyword">if</span> ((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Change state to held and impose load/store ordering appropriate for lock acquisition.</span><br>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><br>    <span class="hljs-comment">// mutex</span><br>    <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">pthread_mutex_trylock</span>(&amp;mutex_);<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// exclusive_owner_ 记下获得锁的 thread id</span><br>    <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetExclusiveOwnerTid</span>(), <span class="hljs-number">0</span>);<br>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);<br>    <span class="hljs-built_in">RegisterAsLocked</span>(self);<br>  &#125;<br>  recursion_count_++;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 也是 tryLock 方法，特别的是它会自旋一小会</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLockWithSpinning</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-comment">// Spin a small number of times, since this affects our ability to respond to suspension</span><br>  <span class="hljs-comment">// requests. We spin repeatedly only if the mutex repeatedly becomes available and unavailable</span><br>  <span class="hljs-comment">// in rapid succession, and then we will typically not spin for the maximal period.</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kMaxSpins = <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; kMaxSpins; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ExclusiveTryLock</span>(self)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self,<br>            [](<span class="hljs-keyword">int32_t</span> v) &#123; <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ExclusiveTryLock</span>(self);<br>&#125;<br><br><span class="hljs-comment">// 释放排它锁</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Mutex::ExclusiveUnlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  recursion_count_--;<br>  <span class="hljs-keyword">if</span> (!recursive_ || recursion_count_ == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">RegisterAsUnlocked</span>(self);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br><br>      <span class="hljs-comment">// 使用 cas 将 state_and_contenders_ 最低 1 bit 置零（表示锁没被借出）</span><br>      <span class="hljs-keyword">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// We&#x27;re no longer the owner.</span><br>        exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);<br>        <span class="hljs-comment">// Change state to not held and impose load/store ordering appropriate for lock release.</span><br>        <span class="hljs-keyword">uint32_t</span> new_state = cur_state &amp; ~kHeldMask;  <span class="hljs-comment">// Same number of contenders.</span><br>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakRelease</span>(cur_state, new_state);<br><br>        <span class="hljs-comment">// state_and_contenders_ 不为零表示仍有线程在锁上挂起，用 futex 让系统唤醒其中一个</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(done)) &#123;  <span class="hljs-comment">// Spurious fail or waiters changed ?</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(new_state != <span class="hljs-number">0</span>) <span class="hljs-comment">/* have contenders */</span>) &#123;<br>            <span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE, kWakeOne,<br>                  <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>          &#125;<br>          <span class="hljs-comment">// We only do a futex wait after incrementing contenders and verifying the lock was</span><br>          <span class="hljs-comment">// still held. If we didn&#x27;t see waiters, then there couldn&#x27;t have been any futexes</span><br>          <span class="hljs-comment">// waiting on this lock when we did the CAS. New arrivals after that cannot wait for us,</span><br>          <span class="hljs-comment">// since the futex wait call would see the lock available and immediately return.</span><br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 异常情况...</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!done);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><br>    <span class="hljs-comment">// mutex</span><br>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);<br>    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_unlock, (&amp;mutex_));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Unlock 等同于 ExclusiveUnlock</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(Thread* self)</span> <span class="hljs-title">RELEASE</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">ExclusiveUnlock</span>(self); &#125;<br></code></pre></div></td></tr></table></figure><h2 id="monitor-enter-指令"><a href="#monitor-enter-指令" class="headerlink" title="monitor-enter 指令"></a><code>monitor-enter</code> 指令</h2><h3 id="无锁、偏向锁和轻量级锁"><a href="#无锁、偏向锁和轻量级锁" class="headerlink" title="无锁、偏向锁和轻量级锁"></a>无锁、偏向锁和轻量级锁</h3><p>进入临界区，尝试获得锁</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 在 cs.android.com 找到的相关性很高的方法，可能不是指令 monitor-enter 直接调用的方法，但最终应该会走到这里来</span><br><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Object::MonitorEnter</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorEnter</span>(self, <span class="hljs-keyword">this</span>, <span class="hljs-comment">/*trylock=*/</span><span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function">ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Monitor::MonitorEnter</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-keyword">bool</span> trylock)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);<br>  self-&gt;<span class="hljs-built_in">AssertThreadSuspensionIsAllowable</span>();<br>  obj = <span class="hljs-built_in">FakeLock</span>(obj);<br>  <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>  <span class="hljs-keyword">size_t</span> contention_count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kExtraSpinIters = <span class="hljs-number">100</span>;<br>  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;<br>  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !ART_USE_FUTEXES</span><br>  <span class="hljs-comment">// In this case we cannot inflate an unowned monitor, so we sometimes defer inflation.</span><br>  <span class="hljs-keyword">bool</span> should_inflate = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br><br>      <span class="hljs-comment">// 无锁的情况下，升级为偏向锁（thin lock）</span><br>      <span class="hljs-comment">// 偏向锁记录下 thread id 和锁的个数 0，通过 cas 记录在 Object.monitor_</span><br>      <span class="hljs-keyword">case</span> LockWord::kUnlocked: &#123;<br>        <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id, <span class="hljs-number">0</span>, lock_word.GCState()))</span></span>;<br>        <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, thin_locked, CASMode::kWeak, std::memory_order_acquire)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !ART_USE_FUTEXES</span><br>          <span class="hljs-keyword">if</span> (should_inflate) &#123;<br>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<br>          &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>          <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);<br>          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>        &#125;<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span><br>      &#125;<br><br>      <span class="hljs-comment">// 偏向锁，而且当前线程跟偏向锁里记录的线程是同一个线程</span><br>      <span class="hljs-comment">// 那么只需把偏向锁里的锁个数加一即可，依然使用 cas 保存在 Object.monitor_</span><br>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>        <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>        <span class="hljs-keyword">if</span> (owner_thread_id == thread_id) &#123;<br>          <span class="hljs-comment">// No ordering required for initial lockword read.</span><br>          <span class="hljs-comment">// We own the lock, increase the recursion count.</span><br>          <span class="hljs-keyword">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() + <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(new_count &lt;= LockWord::kThinLockMaxCount)) &#123;<br>            <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                          new_count,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                          lock_word.GCState()))</span></span>;<br>            <span class="hljs-comment">// 重新设置偏向锁，一个选择用 cas 原子操作符，另一个选择没用，不明这样区分的意义</span><br>            <span class="hljs-comment">// Only this thread pays attention to the count. Thus there is no need for stronger</span><br>            <span class="hljs-comment">// than relaxed memory ordering.</span><br>            <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;<br>              h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(thin_locked, <span class="hljs-comment">/* as_volatile= */</span> <span class="hljs-literal">false</span>);<br>              <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);<br>              <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// Use CAS to preserve the read barrier state.</span><br>              <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word,<br>                                     thin_locked,<br>                                     CASMode::kWeak,<br>                                     std::memory_order_relaxed)) &#123;<br>                <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-comment">// 当前线程持有偏向锁，但锁的个数超过阈值 kThinLockMaxCount</span><br>            <span class="hljs-comment">// 那么将偏向锁（thin lock）升级为重量级锁（fat lock）</span><br>            <span class="hljs-comment">// We&#x27;d overflow the recursion count, so inflate the monitor.</span><br>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>          <span class="hljs-comment">// 持有偏向锁的线程不是当前线程，此时的 thin lock 对应上文的轻量级锁</span><br>          <span class="hljs-comment">// 也就是说轻量级锁是这么一种情况：一个线程持有偏向锁，遇到了另一个线程的争抢</span><br>          <span class="hljs-comment">// 争抢的线程在这里自旋（spin），contention_count 表示自旋的次数</span><br>          <span class="hljs-comment">// 1. 如果自旋次数 &lt;= kExtraSpinIters，那么继续在外一层的 while 循环里自旋</span><br>          <span class="hljs-comment">// 2. 如果自旋次数 &lt; kExtraSpinIters，争抢线程让渡 CPU 给优先级更高的线程，并将自己排到 CPU 调度队列的队尾（sched_yield），相当于优化的自旋</span><br>          <span class="hljs-comment">// 3. 最后将轻量级锁膨胀为重量级锁</span><br>          <span class="hljs-keyword">if</span> (trylock) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>          &#125;<br>          contention_count++;<br>          Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>          <span class="hljs-keyword">if</span> (contention_count<br>              &lt;= kExtraSpinIters + runtime-&gt;<span class="hljs-built_in">GetMaxSpinsBeforeThinLockInflation</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (contention_count &gt; kExtraSpinIters) &#123;<br>              <span class="hljs-built_in">sched_yield</span>();<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>            contention_count = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// No ordering required for initial lockword read. Install rereads it anyway.</span><br>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-comment">// Can&#x27;t inflate from non-owning thread. Keep waiting. Bad for power, but this code</span><br>            <span class="hljs-comment">// isn&#x27;t used on-device.</span><br>            should_inflate = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">10</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span><br>      &#125;<br><br>      <span class="hljs-comment">// 重量级锁的情况下会挂起当前线程，在下一节分析</span><br>      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;<br>        std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);<br>        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>        <span class="hljs-keyword">if</span> (trylock) &#123;<br>          <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">TryLock</span>(self) ? h_obj.<span class="hljs-built_in">Get</span>() : <span class="hljs-literal">nullptr</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          mon-&gt;<span class="hljs-built_in">Lock</span>(self);<br>          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 不清楚这个条件</span><br>      <span class="hljs-keyword">case</span> LockWord::kHashCode:<br>        <span class="hljs-built_in">Inflate</span>(self, <span class="hljs-literal">nullptr</span>, h_obj.<span class="hljs-built_in">Get</span>(), lock_word.<span class="hljs-built_in">GetHashCode</span>());<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="锁膨胀的过程（inflate）"><a href="#锁膨胀的过程（inflate）" class="headerlink" title="锁膨胀的过程（inflate）"></a>锁膨胀的过程（inflate）</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// thin lock 膨胀至重量级锁（fat lock）的过程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::InflateThinLocked</span><span class="hljs-params">(Thread* self, Handle&lt;mirror::Object&gt; obj, LockWord lock_word, <span class="hljs-keyword">uint32_t</span> hash_code)</span> </span>&#123;<br>  <span class="hljs-comment">// 当前线程持有此偏向锁的情况（由于锁个数超过阈值导致膨胀）</span><br>  <span class="hljs-comment">// 升级到重量级锁（fat lock）</span><br>  <span class="hljs-built_in">DCHECK_EQ</span>(lock_word.<span class="hljs-built_in">GetState</span>(), LockWord::kThinLocked);<br>  <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>  <span class="hljs-keyword">if</span> (owner_thread_id == self-&gt;<span class="hljs-built_in">GetThreadId</span>()) &#123;<br>    <span class="hljs-comment">// We own the monitor, we can easily inflate it.</span><br>    <span class="hljs-built_in">Inflate</span>(self, self, obj.<span class="hljs-built_in">Get</span>(), hash_code);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    <span class="hljs-comment">// 当前线程不持有此偏向锁，出现争抢（此时对应轻量级锁）</span><br>    <span class="hljs-comment">// 挂起持有偏向锁的线程，将轻量级锁膨胀为重量级锁（fat lock），然后恢复线程</span><br>    ThreadList* thread_list = Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetThreadList</span>();<br>    <span class="hljs-comment">// Suspend the owner, inflate. First change to blocked and give up mutator_lock_.</span><br>    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(obj.<span class="hljs-built_in">Get</span>());<br>    <span class="hljs-keyword">bool</span> timed_out;<br>    Thread* owner;<br>    &#123;<br>      <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, kWaitingForLockInflation)</span></span>;<br>      owner = thread_list-&gt;<span class="hljs-built_in">SuspendThreadByThreadId</span>(owner_thread_id, SuspendReason::kInternal, &amp;timed_out);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// We succeeded in suspending the thread, check the lock&#x27;s status didn&#x27;t change.</span><br>      lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">GetState</span>() == LockWord::kThinLocked &amp;&amp;<br>          lock_word.<span class="hljs-built_in">ThinLockOwner</span>() == owner_thread_id) &#123;<br>        <span class="hljs-comment">// Go ahead and inflate the lock.</span><br>        <span class="hljs-built_in">Inflate</span>(self, owner, obj.<span class="hljs-built_in">Get</span>(), hash_code);<br>      &#125;<br>      <span class="hljs-keyword">bool</span> resumed = thread_list-&gt;<span class="hljs-built_in">Resume</span>(owner, SuspendReason::kInternal);<br>      <span class="hljs-built_in">DCHECK</span>(resumed);<br>    &#125;<br>    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(<span class="hljs-literal">nullptr</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体的膨胀过程</span><br><span class="hljs-comment">// 膨胀到 fat lock 后多个一个概念 Monitor</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Inflate</span><span class="hljs-params">(Thread* self, Thread* owner, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-keyword">int32_t</span> hash_code)</span> </span>&#123;<br>  <span class="hljs-comment">// Allocate and acquire a new monitor.</span><br>  Monitor* m = MonitorPool::<span class="hljs-built_in">CreateMonitor</span>(self, owner, obj, hash_code);<br>  <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">Install</span>(self)) &#123;<br>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetMonitorList</span>()-&gt;<span class="hljs-built_in">Add</span>(m);<br>    <span class="hljs-built_in">CHECK_EQ</span>(obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>).<span class="hljs-built_in">GetState</span>(), LockWord::kFatLocked);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    MonitorPool::<span class="hljs-built_in">ReleaseMonitor</span>(self, m);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// fat lock 在这里被设置到 Object.monitor</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::Install</span><span class="hljs-params">(Thread* self)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;<br>  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-built_in">CHECK</span>(owner == <span class="hljs-literal">nullptr</span> || owner == self || (ART_USE_FUTEXES &amp;&amp; owner-&gt;<span class="hljs-built_in">IsSuspended</span>()));<br>  <span class="hljs-function">LockWord <span class="hljs-title">lw</span><span class="hljs-params">(GetObject()-&gt;GetLockWord(<span class="hljs-literal">false</span>))</span></span>;<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lw.<span class="hljs-built_in">GetState</span>()) &#123;<br>    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>      lock_count_ = lw.<span class="hljs-built_in">ThinLockCount</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>      monitor_lock_.<span class="hljs-built_in">ExclusiveLockUncontendedFor</span>(owner);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>      monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(owner);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>      <span class="hljs-function">LockWord <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, lw.GCState())</span></span>;<br>      <span class="hljs-comment">// Publish the updated lock word, which may race with other threads.</span><br>      <span class="hljs-keyword">bool</span> success = <span class="hljs-built_in">GetObject</span>()-&gt;<span class="hljs-built_in">CasLockWord</span>(lw, fat, CASMode::kWeak, std::memory_order_release);<br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ATraceEnabled</span>()) &#123;<br>          <span class="hljs-built_in">SetLockingMethod</span>(owner);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>        monitor_lock_.<span class="hljs-built_in">ExclusiveUnlockUncontended</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt;= lockCount; ++i) &#123;<br>          monitor_lock_.<span class="hljs-built_in">ExclusiveUnlock</span>(owner);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 上面说过，thin lock 的 LockWord 低 16 bits 是 thread id，然后是 12 bits 的锁个数</span><br><span class="hljs-comment">// 对于 fat lock，低 28 bits 是 monitor id</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">LockWord::LockWord</span><span class="hljs-params">(Monitor* mon, <span class="hljs-keyword">uint32_t</span> gc_state)</span></span><br><span class="hljs-function">    : value_(mon-&gt;GetMonitorId() | (gc_state &lt;&lt; kGCStateShift) | (kStateFat &lt;&lt; kStateShift)) &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __LP64__</span><br>  <span class="hljs-built_in">DCHECK_ALIGNED</span>(mon, kMonitorIdAlignment);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">FatLockMonitor</span>(), mon);<br>  <span class="hljs-built_in">DCHECK_LE</span>(mon-&gt;<span class="hljs-built_in">GetMonitorId</span>(), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(kMaxMonitorId));<br>  <span class="hljs-built_in">CheckReadBarrierState</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Monitor-Lock-挂起线程"><a href="#Monitor-Lock-挂起线程" class="headerlink" title="Monitor::Lock 挂起线程"></a><code>Monitor::Lock</code> 挂起线程</h3><p>上面介绍的是对象锁，也就是把 <code>Object</code> 作为 <code>Lock</code> 使用，具体来说是 <code>Object.monitor</code> 的四种状态：无锁、偏向锁、轻量级锁和重量级锁</p><p>而 <code>Monitor::Lock</code> 实现的是在重量级锁状态下，「挂起」线程的过程，它包含了自旋、futex/mutex 系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;LockReason reason&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Lock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">bool</span> called_monitors_callback = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 一小会的自旋</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(self, <span class="hljs-comment">/*spin=*/</span> <span class="hljs-literal">true</span>)) &#123;<br>  <span class="hljs-comment">//... 挂起</span><br>  <span class="hljs-comment">// Acquire monitor_lock_ without mutator_lock_, expecting to block this time.</span><br>  <span class="hljs-comment">// We already tried spinning above. The shutdown procedure currently assumes we stop</span><br>  <span class="hljs-comment">// touching monitors shortly after we suspend, so don&#x27;t spin again here.</span><br>  monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(self);<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 自己持有锁，锁加一；否则自旋一小会尝试加锁</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::TryLock</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">bool</span> spin)</span> </span>&#123;<br>  Thread *owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-keyword">if</span> (owner == self) &#123;<br>    lock_count_++;<br>    <span class="hljs-built_in">CHECK_NE</span>(lock_count_, <span class="hljs-number">0u</span>);  <span class="hljs-comment">// Abort on overflow.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">bool</span> success = spin ? monitor_lock_.<span class="hljs-built_in">ExclusiveTryLockWithSpinning</span>(self)<br>        : monitor_lock_.<span class="hljs-built_in">ExclusiveTryLock</span>(self);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="monitor-exit-指令"><a href="#monitor-exit-指令" class="headerlink" title="monitor-exit 指令"></a><code>monitor-exit</code> 指令</h2><h3 id="偏向锁和轻量级锁"><a href="#偏向锁和轻量级锁" class="headerlink" title="偏向锁和轻量级锁"></a>偏向锁和轻量级锁</h3><p>退出临界区，释放锁</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Object::MonitorExit</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorExit</span>(self, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::MonitorExit</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br>      <span class="hljs-keyword">case</span> LockWord::kHashCode:<br>        <span class="hljs-comment">// Fall-through.</span><br><br>      <span class="hljs-comment">// 对象的锁并没有借出，抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kUnlocked:<br>        <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), <span class="hljs-number">0u</span>, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span><br><br>      <span class="hljs-comment">// 当前线程并不拥有锁，抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>        <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>        <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;<br>          <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), thread_id, owner_thread_id, <span class="hljs-literal">nullptr</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>          <span class="hljs-comment">// 偏向锁，锁减一，如果锁为零则释放锁，最后写回 Object.monitor</span><br>          <span class="hljs-comment">// We own the lock, decrease the recursion count.</span><br>          LockWord new_lw = LockWord::<span class="hljs-built_in">Default</span>();<br>          <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">ThinLockCount</span>() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() - <span class="hljs-number">1</span>;<br>            new_lw = LockWord::<span class="hljs-built_in">FromThinLockId</span>(thread_id, new_count, lock_word.<span class="hljs-built_in">GCState</span>());<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            new_lw = LockWord::<span class="hljs-built_in">FromDefault</span>(lock_word.<span class="hljs-built_in">GCState</span>());<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;<br>            <span class="hljs-built_in">DCHECK_EQ</span>(new_lw.<span class="hljs-built_in">ReadBarrierState</span>(), <span class="hljs-number">0U</span>);<br>            h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(new_lw, <span class="hljs-literal">true</span>);<br>            <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, new_lw, CASMode::kWeak, std::memory_order_release)) &#123;<br>              <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>          &#125;<br>          <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 释放重量级锁</span><br>      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;<br>        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>        <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">Unlock</span>(self);<br>      &#125;<br><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前线程持有此重量级锁，且锁为零，退出临界区导致释放锁并唤醒等待线程</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-keyword">if</span> (owner == self) &#123;<br>    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span><br>    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);<br>    <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;<br>      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">// 当前线程持有此重量级锁，且锁不为零（重入）</span><br>      <span class="hljs-comment">// 退出临界区导致锁减一，但不释放锁</span><br>      --lock_count_;<br>      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);<br>      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span><br>      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 当前线程不持有此重量级锁，抛出 java 异常</span><br>  <span class="hljs-comment">// We don&#x27;t own this, so we&#x27;re not allowed to unlock it.</span><br>  <span class="hljs-comment">// The JNI spec says that we should throw IllegalMonitorStateException in this case.</span><br>  <span class="hljs-keyword">uint32_t</span> owner_thread_id = <span class="hljs-number">0u</span>;<br>  &#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;<br>    owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;<br>      owner_thread_id = owner-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">FailedUnlock</span>(<span class="hljs-built_in">GetObject</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), owner_thread_id, <span class="hljs-keyword">this</span>);<br>  <span class="hljs-comment">// Pretend to release monitor_lock_, which we should not.</span><br>  <span class="hljs-built_in">FakeUnlockMonitorLock</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 释放重量级锁</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的代码总结下 <code>synchronized</code> 加锁的流程：</p><ul><li>初始为无锁</li><li>线程 A 进入临界区获得锁，升级为偏向锁（thin lock），偏向锁记下线程 A 的 thread id 和初始锁个数 0</li><li>如果线程 A 重入临界区，锁个数加一；当锁个数超过阈值时，膨胀为重量级锁</li><li>如果在线程 A 持有偏向锁的情况下，线程 B 尝试进入临界区；那么线程 B 首先自旋一小会等待线程 A 释放锁，失败后将偏向锁膨胀为重量级锁，并在锁上挂起；这一过程称为轻量级锁</li><li>线程 A 持有重量级锁的情况下，其他线程尝试进入临界区，会在锁上挂起（futex/mutex）</li></ul><p>总结下 <code>synchronized</code> 和 <code>Lock</code> 的区别：</p><ul><li><code>synchronized</code> 使用 <code>Object</code> 作为锁，也即所有的 <code>Object</code> 都可以当做锁使用；但具体的 lock/unlock 逻辑是在 <code>Monitor</code> 实现的，严谨地说是 <code>Object</code> + <code>Monitor</code> = Lock</li><li>偏向锁和轻量级锁并没有使用 <code>Monitor</code>，而是用 cas，<code>Object::monitor</code> 和自旋实现排他性；直到重量级锁时才构造 <code>Monitor</code>；<code>Monitor</code> 除了扮演 Lock 的角色外，<a href="../../../../2021/02/11/wait-notify/">还扮演了 Condition 的角色</a>，所以一旦调用 Object.wait/Object.notify，就会立刻升级为重量级锁</li><li>Lock 用排队队列来组织挂起的线程，而且以 FIFO 的优先级排队；<code>synchronized</code> 没有组织挂起的线程，完全由 CPU 决定谁能获得锁，可能会发生「饥饿」问题</li><li>Lock 全靠 futex/mutex 阻塞线程，而 <code>synchronized</code> 先让线程自旋一会在陷入阻塞</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（三）利用 Lock 实现 Condition</title>
    <link href="/2021/01/24/condition-by-lock/"/>
    <url>/2021/01/24/condition-by-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="Condition-简介"><a href="#Condition-简介" class="headerlink" title="Condition 简介"></a><code>Condition</code> 简介</h2><p><code>Condition</code> 主要有两类方法：</p><ul><li>await，释放锁并阻塞线程直到 signal 被调用，恢复后会重新获得锁</li><li>signal，唤醒阻塞在这个 <code>Condition</code> 上的一个或全部线程</li></ul><p>利用条件变量前需要先获得锁</p><p>所以 <code>Condition</code> 的所有方法都需要加锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">lock.lock();<br><span class="hljs-comment">// ...</span><br>condition.await();<br><span class="hljs-comment">// ...</span><br>lock.unlock();<br></code></pre></div></td></tr></table></figure><p><code>Condition</code> 的 await/signal 对标 <code>Object</code> 的 wait/notify，wait/notify 使用对象监视器实现的，而 await/signal 使用 <code>Lock</code> 实现的（<code>Lock</code> 对标 <code>synchronized</code> 关键字）</p><p><code>ConditionObject</code> 自己持有一个双向链表的排队队列 condition queue，所有阻塞在此条件变量上的线程都在此排队</p><p>被唤醒的线程会被转移到 AQS 队列尾部（又叫 sync queue）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter; <span class="hljs-comment">/** First node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  <span class="hljs-comment">/** Last node of condition queue. */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>整个 await 大体就是以是否在 sync queue 为标识的循环，当节点转移到 sync queue 时表示线程被唤醒，跳出阻塞循环</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ConditionObject.await() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// ... 在 condition queue 队尾添加一个 Node.CONDITION 类型的新节点（所有阻塞在此条件变量上的线程都在此排队）</span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">// 进入阻塞状态前需要释放锁，同时唤醒下一个等待锁的线程</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 进入阻塞</span><br>    <span class="hljs-comment">// 被唤醒的线程会从 condition queue 转移到 AQS 排队队列（又叫同步队列，sync queue）</span><br>    <span class="hljs-comment">// isOnSyncQueue 返回 true 表示此节点已被转移到 sync queue，跳出阻塞循环</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// await() 是可被中断的，awaitUninterruptibly() 不会被中断</span><br>        <span class="hljs-comment">// 线程恢复后，如果发生了中断，要跳出阻塞状态</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 线程恢复后需要重新获得锁</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br><br><span class="hljs-keyword">private</span> Node ConditionObject.addConditionWaiter() &#123;<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    Node node = <span class="hljs-keyword">new</span> Node(Node.CONDITION)<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-keyword">int</span> AbstractQueuedSynchronizer.fullyRelease(Node node) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> savedState = getState();<br>        <span class="hljs-keyword">if</span> (release(savedState))<br>            <span class="hljs-keyword">return</span> savedState;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        node.waitStatus = Node.CANCELLED;<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">boolean</span> AbstractQueuedSynchronizer.release(<span class="hljs-keyword">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">boolean</span> ReentrantLock.Sync.tryRelease(<span class="hljs-keyword">int</span> releases) &#123;<br>    <span class="hljs-keyword">int</span> c = getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="唤醒一个阻塞的线程（从队头节点开始）"><a href="#唤醒一个阻塞的线程（从队头节点开始）" class="headerlink" title="唤醒一个阻塞的线程（从队头节点开始）"></a>唤醒一个阻塞的线程（从队头节点开始）</h2><p>将在 condition queue 上节点转移到 sync queue 上</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 把 condition queue 第一个节点（等待最久的线程）从队列里移除，添加到 sync queue 并唤醒其线程</span><br><span class="hljs-keyword">void</span> ConditionObject.signal() &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignal(first);<br>&#125;<br><br><span class="hljs-comment">// 从 condition queue 里移除</span><br><span class="hljs-keyword">void</span> ConditionObject.doSignal(Node first) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)<br>            lastWaiter = <span class="hljs-keyword">null</span>;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">// 插入至 sync queue 队尾并唤醒其线程</span><br><span class="hljs-keyword">boolean</span> ConditionObject.transferForSignal(Node node) &#123;<br>    <span class="hljs-keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    Node p = enq(node);<br>    <span class="hljs-keyword">int</span> ws = p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>Node AbstractQueuedSynchronizer.enq(Node node) &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node oldTail = tail;<br>        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-keyword">null</span>) &#123;<br>            U.putObject(node, Node.PREV, oldTail);<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                oldTail.next = node;<br>                <span class="hljs-keyword">return</span> oldTail;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            initializeSyncQueue();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="唤醒全部线程"><a href="#唤醒全部线程" class="headerlink" title="唤醒全部线程"></a>唤醒全部线程</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 跟唤醒第一个线程时一样的：</span><br><span class="hljs-comment">// 将所有在 Condition 上排队的线程逐个从 Condition 排队队列里移除，添加到 AQS 队尾，并唤醒其线程</span><br><span class="hljs-keyword">void</span> ConditionObject.signalAll() &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignalAll(first);<br>&#125;<br><br><span class="hljs-keyword">void</span> ConditionObject.doSignalAll(Node first) &#123;<br>    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        Node next = first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>Condition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见面试题备忘</title>
    <link href="/2021/01/19/reviews/"/>
    <url>/2021/01/19/reviews/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>观察者（Observer），<code>LiveData</code></li><li>单例（Singleton），double check</li><li>适配器（Adapter），<code>RecyclerView.Adapter</code></li><li>装饰器（Decorator），<code>ContextWrapper</code></li><li>代理模式（Proxy），例如 VPN、Retrofit</li><li>责任链（Chain of Responsibility），<code>OkHttp</code> 大体上就是个责任链模式</li><li>建造者（Builder）</li><li>工厂（Factory）</li></ul><p>代理模式强调不能直接访问一个对象，只能通过代理间接访问，不能直接访问的原因比如：权限校验、操作日志、RPC</p><p>装饰器模式强调增强对象的功能：把一个对象的功能拆分为几部分，在运行时按需组装</p><h2 id="实现-LRU"><a href="#实现-LRU" class="headerlink" title="实现 LRU"></a>实现 LRU</h2><p><code>map</code> + 双端链表，链尾是最近使用过的，链头是最久未使用的</p><ul><li><code>get(key)</code>，通过 <code>map</code> 可以在 O(1) 时间内找到 <code>value</code>，然后把 <code>value</code> 从双端链表中断开并移到链尾，双端链表的特性使得「断开」操作很容易实现</li><li><code>put(key, value)</code>，把 <code>value</code> 添加到链尾，当超过容量限制时，从链头逐个移除 <code>value</code> 直到满足容量限制</li></ul><h2 id="几个重要的排序算法"><a href="#几个重要的排序算法" class="headerlink" title="几个重要的排序算法"></a>几个重要的排序算法</h2><ul><li><p>归并排序 O(nlogn)<br><code>step</code> 从 1 逐步递增，合并两个长度为 <code>step</code> 的已排序区间，当 <code>step</code> &gt; length/2 时，已排序区间就等于整个数组<br>合并两个有序区间很简单，用「双指针法」即可</p></li><li><p>快速排序 O(nlogn)<br>双指针，一个在头一个在尾，取第一个元素为「基准」（挖出一个坑），从尾部找一个比「基准」小的填入坑，然后又从头部找一个比「基准」大的填入尾部的坑，循环往复直到双指针碰头，那么这个位置就是「基准」的位置<br>每一轮都可以找出一个元素的排序后的位置，从整体看，这个元素和它左右两块是已排序的<br>然后递归操作左右两块区间直到区间长度为 1</p></li><li><p>堆排序 O(nlogn)<br>利用「堆」这个特殊的数据结构来排序（大顶堆、小顶堆）<br>恰好堆也是用数组实现的，初始已排序区间的长度为 1，逐步扩大长度相当于逐个添加一个新元素到堆<br>添加一个新元素到堆，相当于添加到数组尾部，逻辑上看就是添加到二叉树叶子那层最左边，为了让堆继续满足性质，需要把新元素逐层地跟它的父节点比较：新节点大于父节点则交换（大顶堆，小顶堆则相反）<br>当已排序区间 == 数组时，整个数组就排好序了</p></li></ul><h2 id="五层网络"><a href="#五层网络" class="headerlink" title="五层网络"></a>五层网络</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>HTTP</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>IP 地址（替代 MAC 地址，形成网络），ARP（通过 IP 地址查询得到 MAC 地址）</td></tr><tr><td>链接层</td><td>以太网协议（Ethernet），帧（Frame），MAC 地址，广播（同一网络的所有计算机都会受到消息，它们比较帧的 MAC 地址和自己的 MAC 地址是否相同来决定是否接收）</td></tr><tr><td>物理层（实体层）</td><td></td></tr></tbody></table><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>抽象类是对实体的抽象，而接口是对特征的抽象；所以 Java 类最多只能继承自一个抽象类，但却可是实现多个特征</p><h2 id="多线程同步的方法"><a href="#多线程同步的方法" class="headerlink" title="多线程同步的方法"></a>多线程同步的方法</h2><ul><li><code>synchronized</code></li><li><code>volatile</code></li><li><code>Lock</code> &amp; <code>Condition</code> &amp; <code>Atoimc</code></li></ul><h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a><code>HashMap</code> 和 <code>HashTable</code> 的区别</h2><ul><li>都是数组 + 链表的实现（链表是为了解决 hash 冲突）</li><li><code>HashTable</code> 是线程安全的（大多数方法都加了 <code>synchronized</code>），而 <code>HashMap</code> 不是</li><li><code>HashMap</code> 允许为 <code>null</code> 的 key 和 value，而 <code>HashTable</code> 则不允许</li><li><code>HashMap</code> 重算了 hash code：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，而 <code>HashTable</code> 直接使用 <code>hashCode()</code></li></ul><h2 id="怎么解决-ANR-问题"><a href="#怎么解决-ANR-问题" class="headerlink" title="怎么解决 ANR 问题"></a>怎么解决 ANR 问题</h2><p>先把 <code>/data/anr/trace.txt</code> 拉下来，搜索包名定位到 app 进程那一段，找到 <code>main</code> 线程，看看主线程是不是出于异常状态（比如 <code>Blocked</code>、<code>Sleeping</code>）<br>如果主线程状态异常，那么查看主线程的调用堆栈，看看是哪段代码导致主线程进入异常状态<br>像 <code>Blocked</code> 有可能是锁导致的，能看到主线程被哪个锁阻塞，那个锁被哪个线程持有<br>有时候主线程没发现异常，看调用堆栈发现主线程正在执行 binder 相关操作，此时有可能是阻塞在这里（等待 binder 对面那端的响应）</p><p>还找不到问题，就在 logcat 里搜索 anr 找到 anr 相关日志，它会有一个 CPU 负载统计，如果 io 占比很大说明卡在 io 上了，继续往上找找看当时正在做什么文件操作，或者在 trace 文件里找找</p><h2 id="Double-Check-会有什么问题？"><a href="#Double-Check-会有什么问题？" class="headerlink" title="Double Check 会有什么问题？"></a>Double Check 会有什么问题？</h2><p><code>mSingleton = new Object();</code> 这行语句实际上会分解为多条 CPU 指令：</p><ol><li>为 <code>Object</code> 分配一块内存</li><li>初始化 <code>Object</code> 实例</li><li>把 <code>mSingleton</code> 指向这块内存</li></ol><p>但是「指令重排」可能导致第三部与第二部交换位置，也就是说把 <code>mSingleton</code> 指向了一块尚未初始化的内存区域；此时线程 B 在执行 <code>if (mSingleton == null)</code> 时就会发现 <code>mSingleton</code> 的确不为 null 并返回 <code>mSingleton</code>，从而导致程序异常（因为 <code>mSingleton</code> 指向的内存还没有初始化）</p><p>使用 <code>volatile</code> 修饰 <code>mSingleton</code> 即可，<code>volatile</code> 可以防止相关指令的重排</p><h2 id="IdleHandler-是怎么实现的？"><a href="#IdleHandler-是怎么实现的？" class="headerlink" title="IdleHandler 是怎么实现的？"></a><code>IdleHandler</code> 是怎么实现的？</h2><p>在 <code>MessageQueue.next</code> 里，当队列为空，或者还不到第一个消息的执行时间时（<code>Message</code> 是按照执行时间排序的），在 <code>MessageQueue.mIdleHandlers</code> 里的 <code>IdleHandler</code> 会被执行</p><h2 id="Retrofit-是怎么接口的？"><a href="#Retrofit-是怎么接口的？" class="headerlink" title="Retrofit 是怎么接口的？"></a>Retrofit 是怎么接口的？</h2><p>使用动态代理 <code>Proxy.newProxyInstance</code>，其核心是方法拦截</p><p>在运行时创建一个实现了所选接口的类，这个类的构造函数需要一个 <code>InvocationHandler</code>，接口所有的方法调用都会代理至 <code>InvocationHandler</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T Retrofit.create(<span class="hljs-keyword">final</span> Class&lt;T&gt; service) &#123;<br>  Utils.validateServiceInterface(service);<br>  <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>    eagerlyValidateMethods(service);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,<br>      <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Platform platform = Platform.get();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];<br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>          <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span><br>          <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (platform.isDefaultMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);<br>          &#125;<br>          <span class="hljs-keyword">return</span> loadServiceMethod(method).invoke(args != <span class="hljs-keyword">null</span> ? args : emptyArgs);<br>        &#125;<br>      &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Activity-重建的过程"><a href="#Activity-重建的过程" class="headerlink" title="Activity 重建的过程"></a><code>Activity</code> 重建的过程</h2><p>旧的 <code>Activity</code> 走向死亡（<code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>），新的 <code>Activity</code> 进入（<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ActivityThread.handleRelaunchActivity(...)<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRelaunchActivityInner</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-params"><span class="hljs-function">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingIntents,</span></span><br><span class="hljs-params"><span class="hljs-function">        PendingTransactionActions pendingActions, <span class="hljs-keyword">boolean</span> startsNotResumed,</span></span><br><span class="hljs-params"><span class="hljs-function">        Configuration overrideConfig, String reason)</span> </span>&#123;<br>    <span class="hljs-comment">// Preserve last used intent, it may be set from Activity#setIntent().</span><br>    <span class="hljs-keyword">final</span> Intent customIntent = r.activity.mIntent;<br><br>    <span class="hljs-comment">// 旧的 Activity 走向死亡（销毁）</span><br>    <span class="hljs-comment">// Need to ensure state is saved.</span><br>    <span class="hljs-keyword">if</span> (!r.paused) &#123;<br>        performPauseActivity(r, <span class="hljs-keyword">false</span>, reason, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* pendingActions */</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>        callActivityOnStop(r, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* saveState */</span>, reason);<br>    <br>    handleDestroyActivity(r.token, <span class="hljs-keyword">false</span>, configChanges, <span class="hljs-keyword">true</span>, reason)<br>    r.activity = <span class="hljs-keyword">null</span>;<br>    r.window = <span class="hljs-keyword">null</span>;<br>    r.hideForNow = <span class="hljs-keyword">false</span>;<br>    r.nextIdle = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// Merge any pending results and pending intents; don&#x27;t just replace them</span><br>    <span class="hljs-keyword">if</span> (pendingResults != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.pendingResults == <span class="hljs-keyword">null</span>) &#123;<br>            r.pendingResults = pendingResults;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.pendingResults.addAll(pendingResults);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pendingIntents != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.pendingIntents == <span class="hljs-keyword">null</span>) &#123;<br>            r.pendingIntents = pendingIntents;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.pendingIntents.addAll(pendingIntents);<br>        &#125;<br>    &#125;<br>    r.startsNotResumed = startsNotResumed;<br>    r.overrideConfig = overrideConfig<br>    <span class="hljs-comment">// 走创建新 Activity 的流程</span><br>    handleLaunchActivity(r, pendingActions, customIntent);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ViewModel-和-Fragment-会随之重建吗"><a href="#ViewModel-和-Fragment-会随之重建吗" class="headerlink" title="ViewModel 和 Fragment 会随之重建吗?"></a><code>ViewModel</code> 和 <code>Fragment</code> 会随之重建吗?</h3><p>不会，在 <code>Activity.onStop</code> 之后 <code>Activity.onDestory</code> 之前，<code>FragmentActivity</code> 将 <code>Fragment</code> 和 <code>ViewModelStore</code> 借由方法 <code>onRetainNonConfigurationInstance</code> 传递给 <code>ActivityClientRecord</code> 保存<br>并在 <code>Activity.attach</code> 被重新赋值给新的 <code>Activity</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object FragmentActivity.onRetainNonConfigurationInstance() &#123;<br>    Object custom = onRetainCustomNonConfigurationInstance()<br>    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig()<br>    <span class="hljs-keyword">if</span> (fragments == <span class="hljs-keyword">null</span> &amp;&amp; mViewModelStore == <span class="hljs-keyword">null</span> &amp;&amp; custom == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">// 在旧的 Activity 销毁前，保存 ViewModel 和 Fragment</span><br>    NonConfigurationInstances nci = <span class="hljs-keyword">new</span> NonConfigurationInstances();<br>    nci.custom = custom;<br>    nci.viewModelStore = mViewModelStore;<br>    nci.fragments = fragments;<br>    <span class="hljs-keyword">return</span> nci;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>    mFragments.attachHost(<span class="hljs-keyword">null</span> <span class="hljs-comment">/*parent*/</span>);<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    NonConfigurationInstances nc =<br>            (NonConfigurationInstances) getLastNonConfigurationInstance();<br>    <span class="hljs-comment">// 恢复 ViewModel</span><br>    <span class="hljs-keyword">if</span> (nc != <span class="hljs-keyword">null</span> &amp;&amp; nc.viewModelStore != <span class="hljs-keyword">null</span> &amp;&amp; mViewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>        mViewModelStore = nc.viewModelStore;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);<br>        <span class="hljs-comment">// 恢复 Fragment</span><br>        mFragments.restoreAllState(p, nc != <span class="hljs-keyword">null</span> ? nc.fragments : <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 旧的 Activity 实例会被销毁，但其对应的 ActivityClientRecord 不会被销毁</span><br><span class="hljs-comment">// 那么 NonConfigurationInstances 就由 ActivityClientRecord 暂时保管</span><br><span class="hljs-function">ActivityClientRecord <span class="hljs-title">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> configChanges, <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>    ActivityClientRecord r = mActivities.get(token);<br>    Class&lt;? extends Activity&gt; activityClass = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Performing finish of &quot;</span> + r);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        activityClass = r.activity.getClass();<br>        r.activity.mConfigChangeFlags |= configChanges;<br>        <span class="hljs-keyword">if</span> (finishing) &#123;<br>            r.activity.mFinished = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        performPauseActivityIfNeeded(r, <span class="hljs-string">&quot;destroy&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>            callActivityOnStop(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* saveState */</span>, <span class="hljs-string">&quot;destroy&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (getNonConfigInstance) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                r.lastNonConfigurationInstances<br>                        = r.activity.retainNonConfigurationInstances();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                            <span class="hljs-string">&quot;Unable to retain activity &quot;</span><br>                            + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// call destory</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 然后在 launch activity 时重新把 NonConfigurationInstances 赋给新建的 Activity 实例</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>            r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>            r.embeddedID, r.lastNonConfigurationInstances, config,<br>            r.referrer, r.voiceInteractor, window, r.configCallback,<br>            r.assistToken);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="CountDownLatch-和-CyclicBarrier-的区别"><a href="#CountDownLatch-和-CyclicBarrier-的区别" class="headerlink" title="CountDownLatch 和 CyclicBarrier 的区别"></a><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 的区别</h2><p>开始多个线程通过 <code>CountDownLatch.await()</code> 被它阻塞，然后其他线程执行完一个任务就通过 <code>countDown()</code> 把里面的计算器 <code>count</code> 减一，直到计数器归零阻塞的线程才被唤醒；它是 oneshot 不能重复使用，内部通过 <code>AQS</code> 实现</p><p>N 个并行线程执行任务，执行完就阻塞在 <code>CyclicBarrier.await()</code> 上面，直到 N 个线程都执行完任务，最后一个调用 <code>await()</code> 的线程执行完 <code>barrierCommand</code> 后，其他线程被唤醒，而 <code>CyclicBarrier</code> 被重置为初始状态；不同于 <code>CountDownLatch</code> 的一次性，<code>CyclicBarrier</code> 可以重复使用</p><h2 id="如何让-N-个线程串行执行？"><a href="#如何让-N-个线程串行执行？" class="headerlink" title="如何让 N 个线程串行执行？"></a>如何让 N 个线程串行执行？</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable task;<br>    <span class="hljs-keyword">private</span> Thread prev;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JoinThread</span><span class="hljs-params">(Runnable task, Thread prev)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.task = task;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用 Thread.join()，调用后当前线程被阻塞直到 prev 执行完毕才恢复</span><br><span class="hljs-comment">     * join 可以使并行的线程串行执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        prev.join();<br>        task.run();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="5-个线程，前-4-个执行完后才执行第-5-个"><a href="#5-个线程，前-4-个执行完后才执行第-5-个" class="headerlink" title="5 个线程，前 4 个执行完后才执行第 5 个"></a>5 个线程，前 4 个执行完后才执行第 5 个</h2><p>用 <code>CountDownLatch</code>，计算器设为 4，第 5 个线程通过 <code>await()</code> 阻塞在计数器上面，前 4 个执行到最后一步时使计数器减一，当计数器为零时第 5 个线程被唤醒</p><h2 id="两个线程交替输出-1-100"><a href="#两个线程交替输出-1-100" class="headerlink" title="两个线程交替输出 1 - 100"></a>两个线程交替输出 1 - 100</h2><h3 id="自旋-volatile"><a href="#自旋-volatile" class="headerlink" title="自旋 + volatile"></a>自旋 + <code>volatile</code></h3><p>既然是交替输出，那必然一个输出奇数一个输出偶数，输出日志这一操作是很快的，所以可以考虑乐观锁：自旋</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> OddThread().start();<br>        <span class="hljs-keyword">new</span> EvenThread().start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s - %d%n&quot;</span>, Thread.currentThread().getName(), i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OddThread</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;Odd&quot;</span>); &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> c = count;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">if</span> (++c % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    print(c);<br>                    count = c;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvenThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EvenThread</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;Even&quot;</span>); &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> c = count;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">if</span> (++c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    print(c);<br>                    count = c;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="基于条件变量-Condition"><a href="#基于条件变量-Condition" class="headerlink" title="基于条件变量 Condition"></a>基于条件变量 <code>Condition</code></h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition cond = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    lock.lock();<br>                    cond.signalAll();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br>                        count++;<br>                        print(count);<br>                        cond.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        lock.unlock();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">new</span> Thread(run, <span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(run, <span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s - %d%n&quot;</span>, Thread.currentThread().getName(), i);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="思考：N-个线程按顺序输出-1-100-？"><a href="#思考：N-个线程按顺序输出-1-100-？" class="headerlink" title="思考：N 个线程按顺序输出 1 - 100 ？"></a>思考：N 个线程按顺序输出 1 - 100 ？</h3><p>不使用锁的情况下，把判断奇偶的逻辑改一下，通过 <code>(count % N) == i</code> 判断该数字是否应该由当前线程打印</p><p>用条件变量的情况下，每个线程都在自己的条件变量上阻塞，前面的线程持有下一个线程的条件变量（形成一个环），打印完后唤醒下一个线程；开始时主线程主动唤醒第一个线程</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（二）AQS 源码分析以及 Lock 的实现</title>
    <link href="/2021/01/13/aqs-lock-implementation/"/>
    <url>/2021/01/13/aqs-lock-implementation/</url>
    
    <content type="html"><![CDATA[<p>AQS 是 <code>Semaphore</code>、<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 的基础，它们紧密地结合在一块，分析 AQS 除了要明晰排队队列的操作，还要结合 <code>Semaphore</code>、<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 看看是怎么利用排队队列实现锁和信号量的</p><h2 id="AQS-是基于-CLH-锁修改而来的，它的排队队列也是双向链表"><a href="#AQS-是基于-CLH-锁修改而来的，它的排队队列也是双向链表" class="headerlink" title="AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表"></a>AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 队头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 队尾节点</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> Node prev;     <span class="hljs-comment">// 前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node next;     <span class="hljs-comment">// 后驱节点</span><br>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 节点对应的线程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// tryAcquire 返回 true 表示获得锁，返回 false 表示未获得锁</span><br><span class="hljs-comment">// 由子类实现，比如公平锁、非公平锁等，这里先不讨论</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 如果不能获得锁，在队列里排队并阻塞</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="hljs-comment">// 因为 futex 可能会因为中断而返回，acquireQueued 返回 true 表示发生了中断，这里主动调用中断</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-comment">// 在队尾添加一个新节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(mode);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node oldTail = tail;<br>        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-keyword">null</span>) &#123;<br>            U.putObject(node, Node.PREV, oldTail);<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                oldTail.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            initializeSyncQueue();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 刚开始 head 和 tail 都为 null，这里将 head 和 tail 都初始化为同一个空的 Node</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeSyncQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    Node h;<br>    <span class="hljs-keyword">if</span> (U.compareAndSwapObject(<span class="hljs-keyword">this</span>, HEAD, <span class="hljs-keyword">null</span>, (h = <span class="hljs-keyword">new</span> Node())))<br>        tail = h;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="阻塞线程（不是自旋）"><a href="#阻塞线程（不是自旋）" class="headerlink" title="阻塞线程（不是自旋）"></a>阻塞线程（不是自旋）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 当线程没有阻塞且前驱是 head 时，既是轮到当前线程去尝试获得锁</span><br>            <span class="hljs-comment">// 未获得锁，会进入下面的阻塞代码</span><br>            <span class="hljs-comment">// 获得锁时，将 node 设为新的表头</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 节点入队后，如果不能获得锁，则阻塞线程；中断会打断阻塞</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般情况下，waitStatus == 0，然后被置为 SIGNAL 并返回 false</span><br><span class="hljs-comment">// 然后在下一次的循环里，这个方法返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 阻塞当前线程直到 LockSupport.unpark 被调用</span><br>    LockSupport.park(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 中断会导致 park 返回，这里返回是不是由中断引起的返回</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><br><span class="hljs-comment">// 表头 head 其实是个空节点</span><br><span class="hljs-comment">// head.next 有机会去获得锁，后续的节点都是阻塞的</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    head = node;<br>    node.thread = <span class="hljs-keyword">null</span>;<br>    node.prev = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="LockSupport-park-LockSupport-unpark"><a href="#LockSupport-park-LockSupport-unpark" class="headerlink" title="LockSupport.park / LockSupport.unpark"></a><code>LockSupport.park</code> / <code>LockSupport.unpark</code></h2><p>它们是专为 <code>Lock</code> 设计的线程同步 API，<code>park</code> 可以阻塞线程，<code>unpark</code> 恢复线程，但它们又与 <code>wait</code>/<code>notify</code> 有所不同</p><ul><li><code>park</code>，如果 <code>permit</code> 为真则把它置为假，否则阻塞（<code>unpark</code> 和中断会导致函数返回）</li><li><code>unpark</code>，如果线程阻塞中则恢复线程，否则将 <code>permit</code> 置为真；也就是说 <code>park</code> 之前的 <code>unpark</code> 会导致下一次的 <code>park</code> 无效，而且多次 <code>unpark</code> 不叠加效果</li></ul><p>可以看到线程的阻塞和唤醒是通过 <code>futex</code> 系统调用实现的，<code>futex</code> 的原型是 <code>int futex (int *uaddr, int op, int val, const struct timespec *timeout,int *uaddr2, int val3)</code></p><ul><li>op == <code>FUTEX_WAIT</code>，原子性的检查 <code>uaddr</code> 中计数器的值是否为 <code>val，</code>如果是则让进程休眠，直到 <code>FUTEX_WAKE</code> 或者超时，也就是把进程挂到 <code>uaddr</code> 相对应的等待队列上去</li><li>op == <code>FUTEX_WAKE</code>，最多唤醒 <code>val</code> 个等待在 <code>uaddr</code> 上进程</li></ul><p>而 <code>permit</code> 则是通过 <code>tls32_.park_state_</code> 实现，它是一个 <code>AtomicInteger</code>，取值范围为 <code>kPermitAvailable</code> = 0，<code>kNoPermit</code> = 1，<code>kNoPermitWaiterWaiting</code> = 2</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockSupport</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(Object blocker)</span> </span>&#123;<br>        Thread t = Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>); <span class="hljs-comment">// U 是 sun.misc.Unsafe</span><br>        setBlocker(t, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Thread thread)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-keyword">null</span>)<br>            U.unpark(thread);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1, <span class="hljs-keyword">long</span> var2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Object var1)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Unsafe.park 在 art/runtime/native/sun_misc_Unsafe.cc 里注册为 Unsafe_park</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Unsafe_park</span><span class="hljs-params">(JNIEnv* env, jobject, jboolean isAbsolute, jlong time)</span> </span>&#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>    Thread::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">Park</span>(isAbsolute, time);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    kPermitAvailable = <span class="hljs-number">0</span>,  <span class="hljs-comment">// Incrementing consumes the permit</span><br>    kNoPermit = <span class="hljs-number">1</span>,         <span class="hljs-comment">// Incrementing marks as waiter waiting</span><br>    kNoPermitWaiterWaiting = <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-comment">// 初始值为 kNoPermit，自增为 kNoPermitWaiterWaiting 并阻塞；恢复后复原为 kNoPermit</span><br><span class="hljs-comment">// 如果执行过 unpark，那么为 kPermitAvailable，自增为 kNoPermit 但不会阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::Park</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> is_absolute, <span class="hljs-keyword">int64_t</span> time)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">int</span> old_state = tls32_.park_state_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>    <span class="hljs-keyword">if</span> (old_state == kNoPermit) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">futex</span>(tls32_.park_state_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE,<br>            <span class="hljs-comment">/* sleep if val = */</span> kNoPermitWaiterWaiting,<br>            <span class="hljs-comment">/* timeout */</span> <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Mark as no longer waiting, and consume permit if there is one.</span><br>    tls32_.park_state_.<span class="hljs-built_in">store</span>(kNoPermit, std::memory_order_relaxed);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 置为 kPermitAvailable，如果原值为 kNoPermitWaiterWaiting 表示线程被阻塞，需要执行系统调用 futex 唤醒</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::Unpark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Set permit available; will be consumed either by fetch_add (when the thread</span><br>    <span class="hljs-comment">// tries to park) or store (when the parked thread is woken up)</span><br>    <span class="hljs-keyword">if</span> (tls32_.park_state_.<span class="hljs-built_in">exchange</span>(kPermitAvailable, std::memory_order_relaxed) == kNoPermitWaiterWaiting) &#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">futex</span>(tls32_.park_state_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE,<br>                           <span class="hljs-comment">/* number of waiters = */</span> <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入的公平锁（ReentrantLock-FairSync）"><a href="#可重入的公平锁（ReentrantLock-FairSync）" class="headerlink" title="可重入的公平锁（ReentrantLock.FairSync）"></a>可重入的公平锁（<code>ReentrantLock.FairSync</code>）</h2><p>公平锁按照 FIFO 的优先级顺序，从排队队列的头部开始依次传递锁的所有权</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 锁没有被取走，把排队队列想象成在 ATM 钱排队取钱的人们，只有当前面没有人的时候才轮到自己取钱</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current); <span class="hljs-comment">// 标识锁在谁手上</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">// 可重入，如果锁在自己手上，递增 state</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br><span class="hljs-comment">// 返回 true 表示在前面有人在排队取钱，还没轮到自己；返回 false 表示前面没人了，轮到自己取钱了</span><br><span class="hljs-comment">// h == t 和 h.next == null 是刚初始化 head 和 tail 为空 node 且没有线程入队的情况</span><br><span class="hljs-comment">// h.next 是第一个等待取钱的人，如果它不是当前线程，说明还没轮到自己</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// The correctness of this depends on head being initialized</span><br>        <span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br>        <span class="hljs-comment">// thread is first in queue.</span><br>        Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>        Node h = head;<br>        Node s;<br>        <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>            ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入的非公平锁（ReentrantLock-NonfairSync）"><a href="#可重入的非公平锁（ReentrantLock-NonfairSync）" class="headerlink" title="可重入的非公平锁（ReentrantLock.NonfairSync）"></a>可重入的非公平锁（<code>ReentrantLock.NonfairSync</code>）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 只要锁没有被取走，自己就可以获得锁</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 锁没有被取走，那么自己可以直接获得锁</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 可重入，锁已经在自己手上，递增 state</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>排队取锁的线程都被阻塞了，释放锁的同时需要唤醒下一个排队的线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-comment">// tryRelease 由子类实现，返回 true 表示当前线程持有锁并成功释放锁（可重入的情况下，未必能够释放锁）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// head 是持有锁的线程</span><br>            Node h = head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">         * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>            node.compareAndSetWaitStatus(ws, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">         * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">         * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">         * non-cancelled successor.</span><br><span class="hljs-comment">         * head.next 一般是排队等待锁里的第一个，但它可能被取消了或者其他原因从队伍里删除了，那么我们从队尾开始遍历找可以唤醒的线程</span><br><span class="hljs-comment">         */</span><br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="hljs-keyword">null</span>; p = p.prev)<br>                <span class="hljs-keyword">if</span> (p.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = p;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒下一个线程，让他去尝试获取锁</span><br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>            LockSupport.unpark(s.thread);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入锁的释放过程（ReentrantLock-Sync）"><a href="#可重入锁的释放过程（ReentrantLock-Sync）" class="headerlink" title="可重入锁的释放过程（ReentrantLock.Sync）"></a>可重入锁的释放过程（<code>ReentrantLock.Sync</code>）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-comment">// releases 恒为一，而 state 为重入得次数，也即重入次数减一</span><br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-comment">// 当前线程不持有锁，抛出异常</span><br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-comment">// 如果重入次数为零，那么可以释放锁</span><br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入的读写锁（ReentrantReadWriteLock）"><a href="#可重入的读写锁（ReentrantReadWriteLock）" class="headerlink" title="可重入的读写锁（ReentrantReadWriteLock）"></a>可重入的读写锁（<code>ReentrantReadWriteLock</code>）</h2><p>一个资源能够被多个读线程访问（读锁有多把），或者被一个写线程访问（写锁只有一把），但是不能同时存在读写线程（读锁和写锁是互斥的）</p><h2 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquireShared(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 能不能获得读锁</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-comment">// 对于上面的可重入排它锁，state == 0 表示锁未被其他线程获得，</span><br>        <span class="hljs-comment">// state == 1 表示锁已被某个线程获得，state &gt; 1 表示重入得次数</span><br>        <span class="hljs-comment">// 对于读写锁，state 高 16 位表示读锁的个数，state 低 16 位表示写锁重入得个数</span><br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">// 写锁被其他线程获得了，读写锁是互斥的，不能借出读锁</span><br>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>            getExclusiveOwnerThread() != current)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 获得读锁，state 读锁次数加一</span><br>        <span class="hljs-comment">// 获得读锁的线程用 threadlocal count 记录获得的读锁的数量，这里也要加一（用来观察当前线程拿了几个读锁）</span><br>        <span class="hljs-comment">// readerShouldBlock 的解释见下文</span><br>        <span class="hljs-keyword">int</span> r = sharedCount(c);<br>        <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>            r &lt; MAX_COUNT &amp;&amp;<br>            compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>            <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                firstReader = current;<br>                firstReaderHoldCount = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                firstReaderHoldCount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                HoldCounter rh = cachedHoldCounter;<br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-keyword">null</span> || rh.tid != getThreadId(current))<br>                    cachedHoldCounter = rh = readHolds.get();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                    readHolds.set(rh);<br>                rh.count++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// fullTryAcquireShared 其实是 tryAcquireShared 的自旋版本</span><br>        <span class="hljs-comment">// 针对 compareAndSetState(c, c + SHARED_UNIT) 失败而自旋，也就是被别的线程抢先获得了一个读锁</span><br>        <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不能获得锁，排队并阻塞</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="hljs-comment">// 添加 shared 节点至队尾</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 循环取锁</span><br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            cancelAcquire(node);<br>            <span class="hljs-keyword">throw</span> t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// tryAcquireShared 有可能是在排队等待的过程中线程被唤醒而执行</span><br><span class="hljs-comment">// 此时对于公平锁，只有当前面没有排队的前驱时才能去拿锁</span><br><span class="hljs-comment">// 对于非公平锁，见下面的注释，为了防止「写饥饿」，也就是认为写操作要比读操作更重要一点，不能完全地让所有取锁的线程去争抢</span><br><span class="hljs-comment">// 而是得让在对头等待的写线程优先获得锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/* As a heuristic to avoid indefinite writer starvation,</span><br><span class="hljs-comment">         * block if the thread that momentarily appears to be head</span><br><span class="hljs-comment">         * of queue, if one exists, is a waiting writer.  This is</span><br><span class="hljs-comment">         * only a probabilistic effect since a new reader will not</span><br><span class="hljs-comment">         * block if there is a waiting writer behind other enabled</span><br><span class="hljs-comment">         * readers that have not yet drained from the queue.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">apparentlyFirstQueuedIsExclusive</span><span class="hljs-params">()</span> </span>&#123;<br>        Node h, s;<br>        <span class="hljs-keyword">return</span> (h = head) != <span class="hljs-keyword">null</span> &amp;&amp;<br>            (s = h.next)  != <span class="hljs-keyword">null</span> &amp;&amp;<br>            !s.isShared()         &amp;&amp;<br>            s.thread != <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 能不能获得写锁；失败的话跟排它锁一样排队阻塞</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">int</span> w = exclusiveCount(c);<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br>            <span class="hljs-comment">// 读锁不为零，读写锁互斥，不能获得写锁</span><br>            <span class="hljs-comment">// 写锁不为零，但是被别的线程获得，当前线程也不能获得写锁</span><br>            <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 不能超过 16 位的长度（因为写锁的数量存储在 state 的低 16 位）</span><br>            <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 当前线程已持有写锁，重入导致写锁数量加一</span><br>            setState(c + acquires);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 读锁和写锁都为零，当然可以获得写锁；state 里的写锁数量加一，记下谁拿了写锁</span><br>        <span class="hljs-comment">// 因为 tryAcquire 有可能是在排队过程中被唤醒而触发的，所以在非公平锁的情况下，能获得锁直接拿就好了</span><br>        <span class="hljs-comment">// 而在公平锁的情况下，需要等前面排队的先拿锁</span><br>        <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// writers can always barge</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 上面介绍过，判断自己前面还有没有前驱</span><br>        <span class="hljs-comment">// 公平锁的情况下，只有轮到自己（没有前驱，或者说前面没有排队的）的情况下，才去获取锁</span><br>        <span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-comment">// threadlocal count（线程的读锁计数器）减一</span><br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>                firstReader = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span><br>                firstReaderHoldCount--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            HoldCounter rh = cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-keyword">null</span> || rh.tid != getThreadId(current))<br>                rh = readHolds.get();<br>            <span class="hljs-keyword">int</span> count = rh.count;<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>                readHolds.remove();<br>                <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>            &#125;<br>            --rh.count;<br>        &#125;<br>        <span class="hljs-comment">// 总的读锁计数器减一</span><br>        <span class="hljs-comment">// 读锁是共享的，释放一个读锁不影响其他的读锁；但如果读锁为零，需要唤醒阻塞在写锁上的线程</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> c = getState();<br>            <span class="hljs-keyword">int</span> nextc = c - SHARED_UNIT;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                <span class="hljs-comment">// Releasing the read lock has no effect on readers,</span><br>                <span class="hljs-comment">// but it may allow waiting writers to proceed if</span><br>                <span class="hljs-comment">// both read and write locks are now free.</span><br>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-comment">// 写锁个数减一，当写锁个数为零时，返回 true 导致 AQS 移除当前节点并唤醒下一个排队的线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">int</span> nextc = getState() - releases;<br>        <span class="hljs-keyword">boolean</span> free = exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (free)<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量相当于一个保存着多个锁的保险箱，它可以向外借出锁（<code>acquire</code>）和回收借出的锁（<code>release</code>），当锁用完的时候 <code>acquire</code> 会阻塞</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得锁</span><br><span class="hljs-keyword">void</span> Semaphore.acquire() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">void</span> AbstractQueuedSynchronizer.acquireSharedInterruptibly(<span class="hljs-keyword">int</span> arg) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br><span class="hljs-comment">// 看下排队队列，跟上面的 Lock 操作是一样的</span><br><span class="hljs-comment">// 添加节点到队尾，循环判断是否轮到自己获得锁，否则陷入阻塞直到被唤醒</span><br><span class="hljs-keyword">void</span> AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(<span class="hljs-keyword">int</span> arg) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非公平锁</span><br><span class="hljs-comment">// state 表示保险箱内锁的数量</span><br><span class="hljs-comment">// 如果已经没有锁可以借出，则返回负数导致线程进入排队队列，排队并阻塞</span><br><span class="hljs-comment">// 如果可以借出锁，则更新 state 并返回</span><br><span class="hljs-comment">// 因为是非公平锁，所以无需考虑前面是否有排队的线程</span><br><span class="hljs-keyword">int</span> NonfairSync.tryAcquireShared(<span class="hljs-keyword">int</span> acquires) &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><span class="hljs-keyword">int</span> Sync.nonfairTryAcquireShared(<span class="hljs-keyword">int</span> acquires) &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> available = getState();<br>        <span class="hljs-keyword">int</span> remaining = available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> || compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 公平锁，跟非公平锁一样的，只不过当前面有排队线程时，要让它先获得锁</span><br><span class="hljs-keyword">int</span> FairSync.tryAcquireShared(<span class="hljs-keyword">int</span> acquires) &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> available = getState();<br>        <span class="hljs-keyword">int</span> remaining = available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 释放锁</span><br><span class="hljs-comment">// state 加一，唤醒排队线程</span><br><span class="hljs-keyword">void</span> Semaphore.release() &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">boolean</span> AbstractQueuedSynchronizer.releaseShared(<span class="hljs-keyword">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> current = getState();<br>        <span class="hljs-keyword">int</span> next = current + releases;<br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108449850">AQS与CLH相关论文学习系列（四）- AQS的设计思路</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（一）AQS 基础</title>
    <link href="/2021/01/10/aqs-basic/"/>
    <url>/2021/01/10/aqs-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h2><p>获得锁的时候，不阻塞线程，而是跟平常一样继续获得 CPU 时间，继续执行代码/逻辑，那就是自旋锁；比如下面的 <code>lock()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 一个简单的自旋锁的实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cas = AtomicReference&lt;Thread&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">while</span> (!cas.compareAndSet(<span class="hljs-literal">null</span>, Thread.currentThread())) &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span> &#123;<br>        cas.compareAndSet(Thread.currentThread(), <span class="hljs-literal">null</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="MCS-锁"><a href="#MCS-锁" class="headerlink" title="MCS 锁"></a>MCS 锁</h2><p>上面的自旋锁容易出现「饥饿」问题，因为所有线程同时争抢一个锁，如果一直有线程加入到争抢的过程中来，那么可能会出现某一个或多个线程总是抢不到锁的情况</p><p>而 MCS 在自旋的基础上，引入了「排队」的概念（基于链表）</p><ul><li><code>acquire_lock</code>，<code>L</code> 是链尾节点，<code>I</code> 是当前线程所使用的节点，<code>fetch_and_store</code> 相当于原子性地把 I 添加到链尾，并对 <code>I→locked</code> 进行自旋</li><li><code>release_lock</code>，将 <code>I→next→locked</code> 置为 <code>false</code>，从而使下一个线程获得锁（跳出自旋）</li></ul><p>那么所有未获得锁的线程都会按顺序排成一队（通过 <code>I→next</code> 形成的单向链表），并对 <code>I→locked</code> 自旋，这就是排队自旋锁</p><p>获得锁的线程负责将锁传递给下一个未获得锁的线程（<code>I→next→locked := false</code>）</p><p><img src="../../../../image/2021-01-10-aqs-basic/2020090217384261.png" alt="2020090217384261.png"></p><h2 id="CLH-锁"><a href="#CLH-锁" class="headerlink" title="CLH 锁"></a>CLH 锁</h2><p>它减少释放锁时的自旋开销：</p><ul><li>MCS 锁的持有进程在让渡锁的所有权时，由于需要关心自己的后继结点是否存在以及是否会被突然添加，所以多了一些负担</li><li>MCS 锁在持有进程在让渡锁的所有权时，由于已经知道后继结点肯定只能监控自己在入队时就设置好的结点，所以无需关心是否存在后继结点，只需要修改自己预留给后继结点监控的队列结点状态即可。</li></ul><p>MCS 实现了基于 FIFO 的优先级，而 CLH 可以实现自定义的优先级</p><p>CLH 锁的排队队列是个双向链表，<code>Lock.head</code> 和 <code>Lock.tail</code> 分别是表头和表尾</p><p><code>Process.watch</code> 是当前线程用来自旋的，<code>Process.myreq</code> 留给下一个线程进行自旋；比如线程 P2 在 <code>P2.watch</code> 上自旋，同时 <code>P2.watch</code> 又是 <code>P1.myreq</code>；而 <code>P2.myreq</code> 则是 <code>P3.watch</code>，P3 在 <code>P3.watch</code> 上自旋</p><p><code>Request.watcher</code> 表示那个线程在对它自旋，<code>Request.myproc</code> 表示自旋线程的上一个线程</p><p>从表头开始遍历线程：<code>Lock.head.watcher</code> → <code>Process.myreq.watcher</code> → <code>Process.myreq.watcher</code>→ …</p><p>从表尾开始遍历线程：<code>Lock.tail.myproc</code> → <code>Process.watch.myproc</code> → <code>Process.watch.myproc</code> → …</p><p><code>request_lock</code>（获得锁），将 <code>P.myreq</code> 添加到队尾，并在 <code>P.watch</code>（既是上一个队尾，也是上一个线程的 <code>Process.myreq</code>） 上自旋</p><p><code>grant_lock</code>（释放锁），从头开始遍历排队的线程，找到优先级最高的线程（<code>Process.pri</code>，不仅仅是 FIFO），将它的 <code>Process.watch.state := GRANTED</code> 从而使它跳出自旋（将锁的所有权转移给它）</p><p><img src="../../../../image/2021-01-10-aqs-basic/2020090322512651.png" alt="2020090322512651.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903154644711.png" alt="20200903154644711.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903162049551.png" alt="20200903162049551.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903222817656.png" alt="20200903222817656.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903223128890.png" alt="20200903223128890.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108227584">AQS与CLH相关论文学习系列（一）- 排队式自旋锁思想启蒙</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108448199">AQS与CLH相关论文学习系列（二）- MCS 锁</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108449111">AQS与CLH相关论文学习系列（三）- CLH 锁</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（三）render thread</title>
    <link href="/2020/12/27/render-thread/"/>
    <url>/2020/12/27/render-thread/</url>
    
    <content type="html"><![CDATA[<p>接着<a href="../../../../2020/12/13/ui-thread-in-vsync/">上一篇文章</a>，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 <code>DisplayList</code>，而 render thread 会根据 <code>DisplayList</code> 执行真正的渲染工作，主要是 <code>DrawFrameTask.syncFrameState</code> 和 <code>CanvasContext.draw</code> 这两个方法</p><h2 id="syncFrameState"><a href="#syncFrameState" class="headerlink" title="syncFrameState"></a>syncFrameState</h2><p>重要的方法有三个：<code>makeCurrent</code>，<code>unpinImages</code> 和 <code>prepareTree</code></p><p><code>TreeInfo</code> 用来在后续的一系列操作中收集信息，你会看到它在各个方法中作为参数传递</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DrawFrameTask::syncFrameState</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">bool</span> canDraw = mContext-&gt;<span class="hljs-built_in">makeCurrent</span>();<br>    mContext-&gt;<span class="hljs-built_in">unpinImages</span>();<br>    <span class="hljs-comment">// ...</span><br>    mContext-&gt;<span class="hljs-built_in">setContentDrawBounds</span>(mContentDrawBounds);<br>    mContext-&gt;<span class="hljs-built_in">prepareTree</span>(info, mFrameInfo, mSyncQueued, mTargetNode);<br>    <span class="hljs-comment">// ... If prepareTextures is false, we ran out of texture cache space</span><br>    <span class="hljs-keyword">return</span> info.prepareTextures;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="makeCurrent"><a href="#makeCurrent" class="headerlink" title="makeCurrent"></a>makeCurrent</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CanvasContext::makeCurrent</span><span class="hljs-params">()</span></span><br><span class="hljs-function">MakeCurrentResult <span class="hljs-title">SkiaOpenGLPipeline::makeCurrent</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!mEglManager.<span class="hljs-built_in">makeCurrent</span>(mEglSurface, &amp;error)) &#123;<br>        <span class="hljs-keyword">return</span> MakeCurrentResult::AlreadyCurrent;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EglManager::makeCurrent</span><span class="hljs-params">(EGLSurface surface, EGLint* errOut, <span class="hljs-keyword">bool</span> force)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">eglMakeCurrent</span>(mEglDisplay, surface, surface, mEglContext)) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终是调用了 opengl 的 <code>[eglMakeCurrent](https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml)</code> 方法准备 opengl 环境；现在是 ui thread，并不会在这里进行渲染，而是为了待会将 mutable images 上传到 gpu</p><p>opengl api 都是像 <code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glBindTexture</code> 这样只有方法名和参数的，它的上下文是绑定在 thread 上的，在调用 opengl api 前 <code>eglMakeCurrent</code> 就是确保当前线程有 opengl 上下文；mEglDisplay 可以理解为设备的屏幕；opengl 有双缓冲，一个被主线程读取，一个被渲染线程写入，就是第二和第三个参数，渲染完交换一下，读变写，写变读，当前都是用得同一个 surface；第四个就是 opengl 的上下文，保存了 opengl 状态机</p><h2 id="unpinImages"><a href="#unpinImages" class="headerlink" title="unpinImages"></a>unpinImages</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/** \class SkImage</span><br><span class="hljs-comment">    SkImage describes a two dimensional array of pixels to draw. The pixels may be</span><br><span class="hljs-comment">    decoded in a raster bitmap, encoded in a SkPicture or compressed data stream,</span><br><span class="hljs-comment">    or located in GPU memory as a GPU texture.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SkImage cannot be modified after it is created. SkImage may allocate additional</span><br><span class="hljs-comment">    storage as needed; for instance, an encoded SkImage may decode when drawn.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SkImage width and height are greater than zero. Creating an SkImage with zero width</span><br><span class="hljs-comment">    or height returns SkImage equal to nullptr.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SkImage may be created from SkBitmap, SkPixmap, SkSurface, SkPicture, encoded streams,</span><br><span class="hljs-comment">    GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported</span><br><span class="hljs-comment">    include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encoding details</span><br><span class="hljs-comment">    vary with platform.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SK_API</span> <span class="hljs-title">SkImage</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">    /**</span><br><span class="hljs-class">     * <span class="hljs-title">Pin</span> <span class="hljs-title">any</span> <span class="hljs-title">mutable</span> <span class="hljs-title">images</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">GPU</span> <span class="hljs-title">cache</span>. <span class="hljs-title">A</span> <span class="hljs-title">pinned</span> <span class="hljs-title">images</span> <span class="hljs-title">is</span> <span class="hljs-title">guaranteed</span> <span class="hljs-title">to</span></span><br><span class="hljs-class">     * <span class="hljs-title">remain</span> <span class="hljs-title">in</span> <span class="hljs-title">the</span> <span class="hljs-title">cache</span> <span class="hljs-title">until</span> <span class="hljs-title">it</span> <span class="hljs-title">has</span> <span class="hljs-title">been</span> <span class="hljs-title">unpinned</span>. <span class="hljs-title">We</span> <span class="hljs-title">leverage</span> <span class="hljs-title">this</span> <span class="hljs-title">feature</span></span><br><span class="hljs-class">     * <span class="hljs-title">to</span> <span class="hljs-title">avoid</span> <span class="hljs-title">making</span> <span class="hljs-title">a</span> <span class="hljs-title">CPU</span> <span class="hljs-title">copy</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">pixels</span>.</span><br><span class="hljs-class">     *</span><br><span class="hljs-class">     * @<span class="hljs-title">return</span> <span class="hljs-title">true</span> <span class="hljs-title">if</span> <span class="hljs-title">all</span> <span class="hljs-title">images</span> <span class="hljs-title">have</span> <span class="hljs-title">been</span> <span class="hljs-title">successfully</span> <span class="hljs-title">pinned</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">GPU</span> <span class="hljs-title">cache</span></span><br><span class="hljs-class">     *         <span class="hljs-title">and</span> <span class="hljs-title">false</span> <span class="hljs-title">otherwise</span> (<span class="hljs-title">e</span>.<span class="hljs-title">g</span>. <span class="hljs-title">cache</span> <span class="hljs-title">limits</span> <span class="hljs-title">have</span> <span class="hljs-title">been</span> <span class="hljs-title">exceeded</span>).</span><br><span class="hljs-class">     */</span><br><span class="hljs-class">    <span class="hljs-title">bool</span> <span class="hljs-title">pinImages</span>(<span class="hljs-title">std</span>:</span>:vector&lt;SkImage*&gt;&amp; mutableImages) &#123;<br>        <span class="hljs-keyword">return</span> mRenderPipeline-&gt;<span class="hljs-built_in">pinImages</span>(mutableImages);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Unpin any image that had be previously pinned to the GPU cache</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unpinImages</span><span class="hljs-params">()</span> </span>&#123; mRenderPipeline-&gt;<span class="hljs-built_in">unpinImages</span>(); &#125;<br></code></pre></div></td></tr></table></figure><p><code>SkImage</code> 对一切图像的抽象，包括 jpg、webp 等压缩格式、Bitmap 位图、流、甚至 gpu 上的纹理</p><p><code>pinImages</code> 把在内存的 SkImage 作为纹理上传到 gpu 内存，然后可以通过纹理 id 引用，从而避免在内存里操作（复制）像素</p><p><code>unpinImages</code> 从 gpu 内存里移除纹理</p><h2 id="DamageAccumulator"><a href="#DamageAccumulator" class="headerlink" title="DamageAccumulator"></a>DamageAccumulator</h2><p><code>DamageAccumulator</code> 是 <code>DirtyStack</code> stack（FIFO，用双向链表实现），用来累计脏区，它的一般用法是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">info.damageAccumulator-&gt;<span class="hljs-built_in">pushTransform</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-built_in">damageSelf</span>(info);<br>info.damageAccumulator-&gt;<span class="hljs-built_in">popTransform</span>();<br><br><span class="hljs-comment">// 将 node 压入栈顶</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DamageAccumulator::pushTransform</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RenderNode* transform)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 更新栈顶元素的脏区 = 已有脏区 + node 大小，也就是并集</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::damageSelf</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isRenderable</span>()) &#123;<br>        mDamageGenerationId = info.damageGenerationId;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getClipDamageToBounds</span>()) &#123;<br>            info.damageAccumulator-&gt;<span class="hljs-built_in">dirty</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getWidth</span>(), <span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getHeight</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Hope this is big enough?</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Get this from the display list ops or something</span><br>            info.damageAccumulator-&gt;<span class="hljs-built_in">dirty</span>(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DamageAccumulator::dirty</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">float</span> bottom)</span> </span>&#123;<br>    mHead-&gt;pendingDirty.<span class="hljs-built_in">join</span>(&#123;left, top, right, bottom&#125;);<br>&#125;<br><br><span class="hljs-comment">// 弹出栈顶元素 head，并将栈顶元素的脏区合并到当前栈顶元素 prev 的脏区</span><br><span class="hljs-comment">// 可见脏区是累加的</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DamageAccumulator::popTransform</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(mHead-&gt;prev == mHead, <span class="hljs-string">&quot;Cannot pop the root frame!&quot;</span>);<br>    DirtyStack* dirtyFrame = mHead;<br>    mHead = mHead-&gt;prev;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (dirtyFrame-&gt;type) &#123;<br>        <span class="hljs-keyword">case</span> TransformRenderNode:<br>            <span class="hljs-built_in">applyRenderNodeTransform</span>(dirtyFrame);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TransformMatrix4:<br>            <span class="hljs-built_in">applyMatrix4Transform</span>(dirtyFrame);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TransformNone:<br>            mHead-&gt;pendingDirty.<span class="hljs-built_in">join</span>(dirtyFrame-&gt;pendingDirty);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;Tried to pop an invalid type: %d&quot;</span>, dirtyFrame-&gt;type);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="prepareTree"><a href="#prepareTree" class="headerlink" title="prepareTree"></a>prepareTree</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info, <span class="hljs-keyword">int64_t</span>* uiFrameInfo, <span class="hljs-keyword">int64_t</span> syncQueued, RenderNode* target)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;<br>        <span class="hljs-comment">// Only the primary target node will be drawn full - all other nodes would get drawn in</span><br>        <span class="hljs-comment">// real time mode. In case of a window, the primary node is the window content and the other</span><br>        <span class="hljs-comment">// node(s) are non client / filler nodes.</span><br>        info.mode = (node.<span class="hljs-built_in">get</span>() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);<br>        node-&gt;<span class="hljs-built_in">prepareTree</span>(info);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>target 是 <code>HardwareRenderer.mRootNode</code> 对应的 native <code>RootRenderNode</code>，<code>mRenderNodes</code> 正常情况下应该只有一个元素 target，所以这里应该总是 <code>TreeInfo::MODE_FULL</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::prepareTreeImpl</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer)</span> </span>&#123;    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;<br>        <span class="hljs-built_in">pushStagingDisplayListChanges</span>(observer, info);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mDisplayList) &#123;<br>        info.out.hasFunctors |= mDisplayList-&gt;<span class="hljs-built_in">hasFunctor</span>();<br>        <span class="hljs-keyword">bool</span> isDirty = mDisplayList-&gt;<span class="hljs-built_in">prepareListAndChildren</span>(observer, info, childFunctorsNeedLayer,<br>            [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer) &#123;<br>                child-&gt;<span class="hljs-built_in">prepareTreeImpl</span>(observer, info, functorsNeedLayer);<br>            &#125;);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-built_in">pushLayerUpdate</span>(info);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::pushStagingDisplayListChanges</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mNeedsDisplayListSync) &#123;<br>        mNeedsDisplayListSync = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">damageSelf</span>(info);<br>        <span class="hljs-built_in">syncDisplayList</span>(observer, &amp;info);<br>        <span class="hljs-built_in">damageSelf</span>(info);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::syncDisplayList</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo* info)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mStagingDisplayList) &#123;<br>        mStagingDisplayList-&gt;<span class="hljs-built_in">updateChildren</span>([](RenderNode* child) &#123; child-&gt;<span class="hljs-built_in">incParentRefCount</span>(); &#125;);<br>    &#125;<br>    <span class="hljs-built_in">deleteDisplayList</span>(observer, info);<br>    mDisplayList = mStagingDisplayList;<br>    mStagingDisplayList = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (mDisplayList) &#123;<br>        WebViewSyncData syncData &#123;<br>            .applyForceDark = info &amp;&amp; !info-&gt;disableForceDark<br>        &#125;;<br>        mDisplayList-&gt;<span class="hljs-built_in">syncContents</span>(syncData);<br>        <span class="hljs-built_in">handleForceDark</span>(info);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还记得在<a href="../../../../2020/12/13/ui-thread-in-vsync/">上篇文章</a>里提到， DisplayList 在 endRecording 阶段被放在 <code>RenderNode.mStagingDisplayList</code>，这时候转移到 <code>mDisplayList</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SkiaDisplayList::prepareListAndChildren</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer,</span></span><br><span class="hljs-params"><span class="hljs-function">        std::function&lt;<span class="hljs-keyword">void</span>(RenderNode*, TreeObserver&amp;, TreeInfo&amp;, <span class="hljs-keyword">bool</span>)&gt; childFn)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (info.prepareTextures &amp;&amp; !info.canvasContext.<span class="hljs-built_in">pinImages</span>(mMutableImages)) &#123;<br>        info.prepareTextures = <span class="hljs-literal">false</span>;<br>        info.canvasContext.<span class="hljs-built_in">unpinImages</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">bool</span> hasBackwardProjectedNodesHere = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">bool</span> hasBackwardProjectedNodesSubtree = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : mChildNodes) &#123;<br>        RenderNode* childNode = child.<span class="hljs-built_in">getRenderNode</span>();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">childFn</span>(childNode, observer, info, functorsNeedLayer);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>SkiaRecordingCanvas.drawBitmap</code> 等方法会将 mutable image 放入 <code>mMutableImages</code>，然后在 prepare 阶段上传到 gpu；为什么这么做呢，我猜想是在渲染之前需要确保所有内容都计算完毕并确保不变，mutable image 可以被修改，所以放到 gpu 里确保不被改动，immutable image 因为本身就不可修改所以无需这样处理</p><p><code>TreeInfo.prepareTextures</code> 标识 mutable images 有没上传成功；如果上传成功，ui thread 在 <code>DrawFrameTask::syncFrameState</code> 之后就会被唤醒，否则会一直阻塞直到 <code>CanvasContext.draw</code> 完成；这对 ui thread 有着很大的影响</p><p><code>SkiaDisplayList.mChildNodes</code> 应该只有一个 <code>DecorView.mRenderNode</code>，在这里它的 <code>prepareTreeImpl</code> 被调用</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::pushLayerUpdate</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (info.canvasContext.<span class="hljs-built_in">createOrUpdateLayer</span>(<span class="hljs-keyword">this</span>, *info.damageAccumulator, info.errorHandler)) &#123;<br>        <span class="hljs-built_in">damageSelf</span>(info);<br>    &#125;<br>    <span class="hljs-comment">// ... 将有 layer 的 RenderNode 和它的脏区加入 TreeInfo.layerUpdateQueue</span><br>    SkRect dirty;<br>    info.damageAccumulator-&gt;<span class="hljs-built_in">peekAtDirty</span>(&amp;dirty);<br>    info.layerUpdateQueue-&gt;<span class="hljs-built_in">enqueueLayerWithDamage</span>(<span class="hljs-keyword">this</span>, dirty);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 如果 node 没有 layer，或者 node 的大小发送了改变，则新建 layer</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SkiaPipeline::createOrUpdateLayer</span><span class="hljs-params">(RenderNode* node, <span class="hljs-keyword">const</span> DamageAccumulator&amp; damageAccumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       ErrorHandler* errorHandler)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    SkSurface* layer = node-&gt;<span class="hljs-built_in">getLayerSurface</span>();<br>    <span class="hljs-keyword">if</span> (!layer || layer-&gt;<span class="hljs-built_in">width</span>() != surfaceWidth || layer-&gt;<span class="hljs-built_in">height</span>() != surfaceHeight) &#123;<br>        SkImageInfo info;<br>        info = SkImageInfo::<span class="hljs-built_in">Make</span>(surfaceWidth, surfaceHeight, <span class="hljs-built_in">getSurfaceColorType</span>(),<br>                                 kPremul_SkAlphaType, <span class="hljs-built_in">getSurfaceColorSpace</span>());<br>        <span class="hljs-function">SkSurfaceProps <span class="hljs-title">props</span><span class="hljs-params">(<span class="hljs-number">0</span>, kUnknown_SkPixelGeometry)</span></span>;<br>        node-&gt;<span class="hljs-built_in">setLayerSurface</span>(SkSurface::<span class="hljs-built_in">MakeRenderTarget</span>(mRenderThread.<span class="hljs-built_in">getGrContext</span>(),<br>                                                          SkBudgeted::kYes, info, <span class="hljs-number">0</span>,<br>                                                          <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getSurfaceOrigin</span>(), &amp;props));<br>    <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们知道 <code>View</code> 是 framework ui api，<code>RenderNode</code> 相当于绘制这块 <code>View</code> 所需的配置文件；这里新增了一个新的概念 layer，它是这块 <code>View</code> 对应的 surface，它所呈现的内容将绘制在这个 surface 上，同 opengl 里 surface 的概念</p><p><code>RenderNode</code> 和它的脏区被添加到 <code>TreeInfo.layerUpdateQueue</code>；queue 里应该有两个元素，一个是 <code>HardwareRenderer.mRootNode</code> 对应的 native <code>RootRenderNode</code>，一个是 <code>DecorView.mRenderNode</code></p><h2 id="CanvasContext-draw"><a href="#CanvasContext-draw" class="headerlink" title="CanvasContext.draw"></a>CanvasContext.draw</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 还记得上面说的吗，脏区是累加的，这里是总的脏区</span><br>    SkRect dirty;<br>    mDamageAccumulator.<span class="hljs-built_in">finish</span>(&amp;dirty);<br>    <span class="hljs-comment">// ...</span><br>    Frame frame = mRenderPipeline-&gt;<span class="hljs-built_in">getFrame</span>();<br>    <span class="hljs-built_in">setPresentTime</span>();<br>    <span class="hljs-comment">// 再次计算脏区</span><br>    SkRect windowDirty = <span class="hljs-built_in">computeDirtyRect</span>(frame, &amp;dirty);<br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;<span class="hljs-built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,<br>                                      &amp;(<span class="hljs-built_in">profiler</span>()));<br>    <span class="hljs-keyword">int64_t</span> frameCompleteNr = <span class="hljs-built_in">getFrameNumber</span>();<br>    <span class="hljs-built_in">waitOnFences</span>();<br>    <span class="hljs-keyword">bool</span> requireSwap = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> error = OK;<br>    <span class="hljs-keyword">bool</span> didSwap = mRenderPipeline-&gt;<span class="hljs-built_in">swapBuffers</span>(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="getFrame"><a href="#getFrame" class="headerlink" title="getFrame"></a>getFrame</h2><p>看下 <code>Frame</code>，它包含 <code>EGLSurface</code> 和 surface 宽高</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Frame <span class="hljs-title">SkiaOpenGLPipeline::getFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function">Frame <span class="hljs-title">EglManager::beginFrame</span><span class="hljs-params">(EGLSurface surface)</span> </span>&#123;<br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-built_in">makeCurrent</span>(surface);<br>    Frame frame;<br>    frame.mSurface = surface;<br>    <span class="hljs-built_in">eglQuerySurface</span>(mEglDisplay, surface, EGL_WIDTH, &amp;frame.mWidth);<br>    <span class="hljs-built_in">eglQuerySurface</span>(mEglDisplay, surface, EGL_HEIGHT, &amp;frame.mHeight);<br>    frame.mBufferAge = <span class="hljs-built_in">queryBufferAge</span>(surface);<br>    <span class="hljs-built_in">eglBeginFrame</span>(mEglDisplay, surface);<br>    <span class="hljs-keyword">return</span> frame;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="IRenderPipeline-draw"><a href="#IRenderPipeline-draw" class="headerlink" title="IRenderPipeline::draw"></a>IRenderPipeline::draw</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SkiaOpenGLPipeline::draw</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaPipeline::renderFrame</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    SkCanvas* canvas = <span class="hljs-built_in">tryCapture</span>(surface.<span class="hljs-built_in">get</span>(), nodes[<span class="hljs-number">0</span>].<span class="hljs-built_in">get</span>(), layers);<br>    <span class="hljs-comment">// draw all layers up front</span><br>    <span class="hljs-built_in">renderLayersImpl</span>(layers, opaque);<br>    <span class="hljs-built_in">renderFrameImpl</span>(clip, nodes, opaque, contentDrawBounds, canvas, preTransform);<br>    <span class="hljs-built_in">endCapture</span>(surface.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-comment">// 绘制「布局边界」、「渲染分析」等 debug 信息，这里略过</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(Properties::debugOverdraw)) &#123;<br>        <span class="hljs-built_in">renderOverdraw</span>(clip, nodes, contentDrawBounds, surface, preTransform);<br>    &#125;<br>    surface-&gt;<span class="hljs-built_in">getCanvas</span>()-&gt;<span class="hljs-built_in">flush</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>SkiaPipeline::renderLayersImpl</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 看上面，layers 是在 RenderNode::prepareTree 阶段加入的，包括 </span><br><span class="hljs-comment">// HardwareRenderer.mRootNode 对应的 native RootRenderNode 和 DecorView.mRenderNode</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaPipeline::renderLayersImpl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LayerUpdateQueue&amp; layers, <span class="hljs-keyword">bool</span> opaque)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; layers.<span class="hljs-built_in">entries</span>().<span class="hljs-built_in">size</span>(); i++) &#123;<br>        RenderNode* layerNode = layers.<span class="hljs-built_in">entries</span>()[i].renderNode.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-comment">// ...</span><br>        SkCanvas* layerCanvas = layerNode-&gt;<span class="hljs-built_in">getLayerSurface</span>()-&gt;<span class="hljs-built_in">getCanvas</span>();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function">RenderNodeDrawable <span class="hljs-title">root</span><span class="hljs-params">(layerNode, layerCanvas, <span class="hljs-literal">false</span>)</span></span>;<br>        root.forceDraw(layerCanvas);<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// cache the current context so that we can defer flushing it until</span><br>        <span class="hljs-comment">// either all the layers have been rendered or the context changes</span><br>        GrContext* currentContext = layerNode-&gt;<span class="hljs-built_in">getLayerSurface</span>()-&gt;<span class="hljs-built_in">getCanvas</span>()-&gt;<span class="hljs-built_in">getGrContext</span>();<br>        <span class="hljs-keyword">if</span> (cachedContext.<span class="hljs-built_in">get</span>() != currentContext) &#123;<br>            <span class="hljs-keyword">if</span> (cachedContext.<span class="hljs-built_in">get</span>()) &#123;<br>                <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;flush layers (context changed)&quot;</span>);<br>                cachedContext-&gt;<span class="hljs-built_in">flush</span>();<br>            &#125;<br>            cachedContext.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">SkSafeRef</span>(currentContext));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    cachedContext-&gt;<span class="hljs-built_in">flush</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNodeDrawable::forceDraw</span><span class="hljs-params">(SkCanvas* canvas)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNodeDrawable::drawContent</span><span class="hljs-params">(SkCanvas* canvas)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-comment">// displayList 是 layerNode 的，canvas 是 layerNode 对应的 layer surface 的</span><br>    <span class="hljs-comment">// 下面看看这个由 layer surface 作为 backend 的 canvas 做了什么</span><br>    displayList-&gt;<span class="hljs-built_in">draw</span>(canvas);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>RenderNode → mSkiaLayer → layerSurface，这里我们接触到 <code>RenderNode</code> 的一个属性/概念 layer</p><p>它是 <code>SkiaLayer</code> 结构体，主要包含一个 <code>layerSurface</code>，它是一个 offscreen render target，backend 可以是纹理、pixels buffer 等</p><p>它在 <code>SkiaPipeline::createOrUpdateLayer</code> 里通过 <code>RenderNode::setLayerSurface</code> 被赋予 <code>SkSurface_Gpu</code>；那么上面的 canvas 则是以 <code>SkGpuDevice</code> 为 backend 的 <code>SkCanvas</code>，所有的 draw 操作（onDrawXXX）都被重定向到 <code>SkGpuDevice</code>（drawXXX）；而在 <code>SkGpuDevice</code> 里，draw 操作又被重定向到 <code>GrRenderTargetContext</code>；在 <code>GrRenderTargetContext</code> 里，draw 操作被封装为 <code>GrDrawOp</code>，通过 <code>GrOpsTask::addDrawOp</code> 加入到 <code>GrRenderTargetContext::fOpsTask</code>；而 <code>GrRenderTargetContext::fOpsTask</code> 会被 <code>GrDrawingManager::fDAG</code> 持有</p><p>drawing op 在这里被再次包装，由 <code>DisplayList</code> 包装为 <code>GrDrawOp</code></p><p><code>RenderNode</code> 的 <code>DisplayList</code> 会被渲染到 layer 上</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Call to ensure all drawing to the context has been issued to the underlying 3D API.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrContext::flush</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">GrSemaphoresSubmitted <span class="hljs-title">GrContext::flush</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GrFlushInfo&amp; info, <span class="hljs-keyword">const</span> GrPrepareForExternalIORequests&amp; externalRequests)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">GrSemaphoresSubmitted <span class="hljs-title">GrDrawingManager::flush</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">auto</span> direct = fContext-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">asDirectContext</span>();<br>    GrGpu* gpu = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">getGpu</span>();<br>    fFlushing = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">auto</span> resourceProvider = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">resourceProvider</span>();<br>    <span class="hljs-keyword">auto</span> resourceCache = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">getResourceCache</span>();<br>    <span class="hljs-function">GrOpFlushState <span class="hljs-title">flushState</span><span class="hljs-params">(gpu, resourceProvider, &amp;fTokenTracker, fCpuBufferCache)</span></span>;<br>    <span class="hljs-function">GrOnFlushResourceProvider <span class="hljs-title">onFlushProvider</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">int</span> startIndex, stopIndex;<br>    <span class="hljs-keyword">bool</span> flushed = <span class="hljs-literal">false</span>;<br>    &#123;<br>        <span class="hljs-keyword">while</span> (alloc.<span class="hljs-built_in">assign</span>(&amp;startIndex, &amp;stopIndex, &amp;error)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">executeRenderTasks</span>(startIndex, stopIndex, &amp;flushState, &amp;numRenderTasksExecuted)) &#123;<br>                flushed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    fDAG.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clearDDLTargets</span>();<br>    GrSemaphoresSubmitted result = gpu-&gt;<span class="hljs-built_in">finishFlush</span>(proxies, numProxies, access, info, externalRequests);<br>    <span class="hljs-comment">// Give the cache a chance to purge resources that become purgeable due to flushing.</span><br>    <span class="hljs-keyword">if</span> (flushed) &#123;<br>        resourceCache-&gt;<span class="hljs-built_in">purgeAsNeeded</span>();<br>        flushed = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (GrOnFlushCallbackObject* onFlushCBObject : fOnFlushCBObjects) &#123;<br>        onFlushCBObject-&gt;<span class="hljs-built_in">postFlush</span>(fTokenTracker.<span class="hljs-built_in">nextTokenToFlush</span>(), fFlushingRenderTaskIDs.<span class="hljs-built_in">begin</span>(),<br>                                   fFlushingRenderTaskIDs.<span class="hljs-built_in">count</span>());<br>        flushed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flushed) &#123;<br>        resourceCache-&gt;<span class="hljs-built_in">purgeAsNeeded</span>();<br>    &#125;<br>    fFlushingRenderTaskIDs.<span class="hljs-built_in">reset</span>();<br>    fFlushing = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GrDrawingManager::executeRenderTasks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> stopIndex, GrOpFlushState* flushState,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-keyword">int</span>* numRenderTasksExecuted)</span> </span>&#123;<br>    <span class="hljs-built_in">SkASSERT</span>(startIndex &lt;= stopIndex &amp;&amp; stopIndex &lt;= fDAG.<span class="hljs-built_in">numRenderTasks</span>());<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> GR_FLUSH_TIME_OP_SPEW</span><br>    <span class="hljs-built_in">SkDebugf</span>(<span class="hljs-string">&quot;Flushing opsTask: %d to %d out of [%d, %d]\n&quot;</span>, startIndex, stopIndex, <span class="hljs-number">0</span>, fDAG.<span class="hljs-built_in">numRenderTasks</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (fDAG.<span class="hljs-built_in">renderTask</span>(i)) &#123;<br>            fDAG.<span class="hljs-built_in">renderTask</span>(i)-&gt;<span class="hljs-built_in">dump</span>(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-keyword">bool</span> anyRenderTasksExecuted = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;<br>        GrRenderTask* renderTask = fDAG.<span class="hljs-built_in">renderTask</span>(i);<br>        <span class="hljs-keyword">if</span> (!renderTask || !renderTask-&gt;<span class="hljs-built_in">isInstantiated</span>()) &#123;<br>             <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">SkASSERT</span>(renderTask-&gt;<span class="hljs-built_in">deferredProxiesAreInstantiated</span>());<br>        renderTask-&gt;<span class="hljs-built_in">prepare</span>(flushState);<br>    &#125;<br><br>    <span class="hljs-comment">// Upload all data to the GPU</span><br>    flushState-&gt;<span class="hljs-built_in">preExecuteDraws</span>();<br><br>    <span class="hljs-comment">// For Vulkan, if we have too many oplists to be flushed we end up allocating a lot of resources</span><br>    <span class="hljs-comment">// for each command buffer associated with the oplists. If this gets too large we can cause the</span><br>    <span class="hljs-comment">// devices to go OOM. In practice we usually only hit this case in our tests, but to be safe we</span><br>    <span class="hljs-comment">// put a cap on the number of oplists we will execute before flushing to the GPU to relieve some</span><br>    <span class="hljs-comment">// memory pressure.</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> kMaxRenderTasksBeforeFlush = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">// Execute the onFlush renderTasks first, if any.</span><br>    <span class="hljs-keyword">for</span> (sk_sp&lt;GrRenderTask&gt;&amp; onFlushRenderTask : fOnFlushRenderTasks) &#123;<br>        <span class="hljs-keyword">if</span> (!onFlushRenderTask-&gt;<span class="hljs-built_in">execute</span>(flushState)) &#123;<br>            <span class="hljs-built_in">SkDebugf</span>(<span class="hljs-string">&quot;WARNING: onFlushRenderTask failed to execute.\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">SkASSERT</span>(onFlushRenderTask-&gt;<span class="hljs-built_in">unique</span>());<br>        onFlushRenderTask = <span class="hljs-literal">nullptr</span>;<br>        (*numRenderTasksExecuted)++;<br>        <span class="hljs-keyword">if</span> (*numRenderTasksExecuted &gt;= kMaxRenderTasksBeforeFlush) &#123;<br>            flushState-&gt;<span class="hljs-built_in">gpu</span>()-&gt;<span class="hljs-built_in">finishFlush</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SkSurface::BackendSurfaceAccess::kNoAccess,<br>                                           <span class="hljs-built_in">GrFlushInfo</span>(), <span class="hljs-built_in">GrPrepareForExternalIORequests</span>());<br>            *numRenderTasksExecuted = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    fOnFlushRenderTasks.<span class="hljs-built_in">reset</span>();<br><br>    <span class="hljs-comment">// Execute the normal op lists.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;<br>        GrRenderTask* renderTask = fDAG.<span class="hljs-built_in">renderTask</span>(i);<br>        <span class="hljs-keyword">if</span> (!renderTask || !renderTask-&gt;<span class="hljs-built_in">isInstantiated</span>()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (renderTask-&gt;<span class="hljs-built_in">execute</span>(flushState)) &#123;<br>            anyRenderTasksExecuted = <span class="hljs-literal">true</span>;<br>        &#125;<br>        (*numRenderTasksExecuted)++;<br>        <span class="hljs-keyword">if</span> (*numRenderTasksExecuted &gt;= kMaxRenderTasksBeforeFlush) &#123;<br>            flushState-&gt;<span class="hljs-built_in">gpu</span>()-&gt;<span class="hljs-built_in">finishFlush</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SkSurface::BackendSurfaceAccess::kNoAccess,<br>                                           <span class="hljs-built_in">GrFlushInfo</span>(), <span class="hljs-built_in">GrPrepareForExternalIORequests</span>());<br>            *numRenderTasksExecuted = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">SkASSERT</span>(!flushState-&gt;<span class="hljs-built_in">opsRenderPass</span>());<br>    <span class="hljs-built_in">SkASSERT</span>(fTokenTracker.<span class="hljs-built_in">nextDrawToken</span>() == fTokenTracker.<span class="hljs-built_in">nextTokenToFlush</span>());<br><br>    <span class="hljs-comment">// We reset the flush state before the RenderTasks so that the last resources to be freed are</span><br>    <span class="hljs-comment">// those that are written to in the RenderTasks. This helps to make sure the most recently used</span><br>    <span class="hljs-comment">// resources are the last to be purged by the resource cache.</span><br>    flushState-&gt;<span class="hljs-built_in">reset</span>();<br>    fDAG.<span class="hljs-built_in">removeRenderTasks</span>(startIndex, stopIndex);<br>    <span class="hljs-keyword">return</span> anyRenderTasksExecuted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终 <code>flush</code> 将 <code>GrDrawOp</code> 转换为 opengl 命令并提交给 gpu 执行，下面看看绘制一个矩形 <code>GrFillRectOp</code> 是怎么转换为 opengl 命令的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkCanvas::drawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; r, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkCanvas::onDrawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; r, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">needs_autodrawlooper</span>(<span class="hljs-keyword">this</span>, paint)) &#123;<br>        <span class="hljs-built_in">LOOPER_BEGIN_CHECK_COMPLETE_OVERWRITE</span>(paint, &amp;r, <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">while</span> (iter.<span class="hljs-built_in">next</span>()) &#123;<br>            iter.fDevice-&gt;<span class="hljs-built_in">drawRect</span>(r, looper.<span class="hljs-built_in">paint</span>());<br>        &#125;<br>        LOOPER_END<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkGpuDevice::drawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; rect, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetContext::drawRect</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">const</span> SkStrokeRec&amp; stroke = style-&gt;<span class="hljs-built_in">strokeRec</span>();<br>    <span class="hljs-keyword">if</span> (stroke.<span class="hljs-built_in">getStyle</span>() == SkStrokeRec::kFill_Style) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">drawFilledRect</span>(clip, std::<span class="hljs-built_in">move</span>(paint), aa, viewMatrix, rect);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetContext::drawFilledRect</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    GrAAType aaType = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">chooseAAType</span>(aa, GrAllowMixedSamples::kNo);<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addDrawOp</span>(clip, GrFillRectOp::<span class="hljs-built_in">Make</span>(fContext, std::<span class="hljs-built_in">move</span>(paint), aaType, viewMatrix,<br>                                             croppedRect, ss));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>看看 <code>GrFillRectOp</code> 的定义</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">GrFillRectOp::Make</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">Make</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Op, <span class="hljs-keyword">typename</span>... OpArgs&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">FactoryHelper</span><span class="hljs-params">(GrRecordingContext* context, GrPaint&amp;&amp; paint, OpArgs... opArgs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> GrSimpleMeshDrawOpHelper::FactoryHelper&lt;Op, OpArgs...&gt;(context, std::<span class="hljs-built_in">move</span>(paint), std::forward&lt;OpArgs&gt;(opArgs)...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Op, <span class="hljs-keyword">typename</span>... OpArgs&gt;<br><span class="hljs-function">std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">GrSimpleMeshDrawOpHelper::FactoryHelper</span><span class="hljs-params">(GrRecordingContext* context,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                                  GrPaint&amp;&amp; paint,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                                  OpArgs... opArgs)</span> </span>&#123;<br>    GrOpMemoryPool* pool = context-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">opMemoryPool</span>();<br>    MakeArgs makeArgs;<br>    <span class="hljs-keyword">if</span> (paint.<span class="hljs-built_in">isTrivial</span>()) &#123;<br>        makeArgs.fProcessorSet = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> pool-&gt;allocate&lt;Op&gt;(makeArgs, paint.<span class="hljs-built_in">getColor4f</span>(), std::forward&lt;OpArgs&gt;(opArgs)...);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-built_in">FillRectOp</span>(Helper::MakeArgs args, SkPMColor4f paintColor, GrAAType aaType,<br>               DrawQuad* quad, <span class="hljs-keyword">const</span> GrUserStencilSettings* stencil, Helper::InputFlags inputFlags)<br>            : <span class="hljs-built_in">INHERITED</span>(<span class="hljs-built_in">ClassID</span>())<br>            , <span class="hljs-built_in">fHelper</span>(args, aaType, stencil, inputFlags)<br>            , <span class="hljs-built_in">fQuads</span>(<span class="hljs-number">1</span>, !fHelper.<span class="hljs-built_in">isTrivial</span>()) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetContext::addDrawOp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GrClip&amp; clip, std::unique_ptr&lt;GrDrawOp&gt; op,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">const</span> std::function&lt;WillAddOpFn&gt;&amp; willAddFn)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> opList = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getRTOpList</span>();<br>    <span class="hljs-comment">// ...</span><br>    opList-&gt;<span class="hljs-built_in">addDrawOp</span>(std::<span class="hljs-built_in">move</span>(op), analysis, std::<span class="hljs-built_in">move</span>(appliedClip), dstProxy, *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">caps</span>());<br>&#125;<br><br><span class="hljs-function">GrRenderTargetOpList* <span class="hljs-title">GrRenderTargetContext::getRTOpList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!fOpList || fOpList-&gt;<span class="hljs-built_in">isClosed</span>()) &#123;<br>        fOpList = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">drawingManager</span>()-&gt;<span class="hljs-built_in">newRTOpList</span>(fRenderTargetProxy.<span class="hljs-built_in">get</span>(), fManagedOpList);<br>    &#125;<br>    <span class="hljs-keyword">return</span> fOpList.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-function">sk_sp&lt;GrRenderTargetOpList&gt; <span class="hljs-title">GrDrawingManager::newRTOpList</span><span class="hljs-params">(GrRenderTargetProxy* rtp, <span class="hljs-keyword">bool</span> managedOpList)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">auto</span> resourceProvider = fContext-&gt;<span class="hljs-built_in">contextPriv</span>().<span class="hljs-built_in">resourceProvider</span>();<br>    <span class="hljs-function">sk_sp&lt;GrRenderTargetOpList&gt; <span class="hljs-title">opList</span><span class="hljs-params">(<span class="hljs-keyword">new</span> GrRenderTargetOpList(resourceProvider, fContext-&gt;contextPriv().refOpMemoryPool(), rtp, fContext-&gt;contextPriv().getAuditTrail()))</span></span>;<br>    <span class="hljs-keyword">if</span> (managedOpList) &#123;<br>        fDAG.<span class="hljs-built_in">add</span>(opList);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> opList;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetOpList::addDrawOp</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> addDependency = [ &amp;caps, <span class="hljs-keyword">this</span> ] (GrSurfaceProxy* p) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addDependency</span>(p, caps);<br>    &#125;;<br>    op-&gt;<span class="hljs-built_in">visitProxies</span>(addDependency);<br>    clip.<span class="hljs-built_in">visitProxies</span>(addDependency);<br>    <span class="hljs-keyword">if</span> (dstProxy.<span class="hljs-built_in">proxy</span>()) &#123;<br>        <span class="hljs-built_in">addDependency</span>(dstProxy.<span class="hljs-built_in">proxy</span>());<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">recordOp</span>(std::<span class="hljs-built_in">move</span>(op), processorAnalysis, clip.<span class="hljs-built_in">doesClip</span>() ? &amp;clip : <span class="hljs-literal">nullptr</span>, &amp;dstProxy, caps);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FillRectOp</span> <span class="hljs-keyword">final</span> :</span> <span class="hljs-keyword">public</span> GrMeshDrawOp &#123;<br>    <span class="hljs-function">VertexSpec <span class="hljs-title">vertexSpec</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> indexBufferOption = GrQuadPerEdgeAA::<span class="hljs-built_in">CalcIndexBufferOption</span>(fHelper.<span class="hljs-built_in">aaType</span>(), fQuads.<span class="hljs-built_in">count</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">VertexSpec</span>(fQuads.<span class="hljs-built_in">deviceQuadType</span>(), fColorType, fQuads.<span class="hljs-built_in">localQuadType</span>(),<br>            fHelper.<span class="hljs-built_in">usesLocalCoords</span>(), GrQuadPerEdgeAA::Domain::kNo,<br>            fHelper.<span class="hljs-built_in">aaType</span>(),<br>            fHelper.<span class="hljs-built_in">compatibleWithCoverageAsAlpha</span>(), indexBufferOption);<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tessellate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> VertexSpec&amp; vertexSpec, <span class="hljs-keyword">char</span>* dst)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> SkRect kEmptyDomain = SkRect::<span class="hljs-built_in">MakeEmpty</span>();<br>        <span class="hljs-function">GrQuadPerEdgeAA::Tessellator <span class="hljs-title">tessellator</span><span class="hljs-params">(vertexSpec, dst)</span></span>;<br>        <span class="hljs-keyword">auto</span> iter = fQuads.<span class="hljs-built_in">iterator</span>();<br>        <span class="hljs-keyword">while</span> (iter.<span class="hljs-built_in">next</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> info = iter.<span class="hljs-built_in">metadata</span>();<br>            tessellator.<span class="hljs-built_in">append</span>(iter.<span class="hljs-built_in">deviceQuad</span>(), iter.<span class="hljs-built_in">localQuad</span>(), info.fColor, kEmptyDomain, info.fAAFlags);<br>        &#125;<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPrePrepareDraws</span><span class="hljs-params">(...)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        SkArenaAlloc* arena = context-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">recordTimeAllocator</span>();<br>        <span class="hljs-keyword">const</span> VertexSpec vertexSpec = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">vertexSpec</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> totalNumVertices = fQuads.<span class="hljs-built_in">count</span>() * vertexSpec.<span class="hljs-built_in">verticesPerQuad</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> totalVertexSizeInBytes = vertexSpec.<span class="hljs-built_in">vertexSize</span>() * totalNumVertices;<br>        fPrePreparedVertices = arena-&gt;makeArrayDefault&lt;<span class="hljs-keyword">char</span>&gt;(totalVertexSizeInBytes);<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">tessellate</span>(vertexSpec, fPrePreparedVertices);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>render thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（二）ui thread</title>
    <link href="/2020/12/13/ui-thread-in-vsync/"/>
    <url>/2020/12/13/ui-thread-in-vsync/</url>
    
    <content type="html"><![CDATA[<h2 id="从一段-systrace-开始"><a href="#从一段-systrace-开始" class="headerlink" title="从一段 systrace 开始"></a>从一段 systrace 开始</h2><p><img src="../../../../image/2020-12-13-ui-thread-in-vsync/114050.png" alt="114050.png"></p><p>这是一段 systrace 记录，看得出来页面是比较流畅的，ui thread 全都在一个 VSYNC_app 内完成绘制，surfaceflinger 也在一个 VSYNC_sf 内完成各个层的合成；但有没发现在 ui thread 完成 <code>doFrame</code> 后，总是会有一个 <code>ReaderThread</code> 跟在后面，看名字像是跟渲染相关的线程，它跟 ui 绘制有关系吗？平时我们常说的，只要 ui thread 在一个刷新周期 16ms 内完成 view 的绘制，即可保证页面流畅，真的是这样吗？</p><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从 ViewRootImpl 开始</span><br>ViewRootImpl.doTraversal()<br>ViewRootImpl.performTraversals()<br>ViewRootImpl.performDraw()<br>ViewRootImpl.draw(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)<br><br><span class="hljs-comment">// 进入 ThreadedRenderer</span><br>ThreadedRenderer.draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ...</span><br>    updateRootDisplayList(view, callbacks);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里出现了两个很重要的函数：<code>updateRootDisplayList</code> 和 <code>syncAndDrawFrame</code>，我们一个个看</p><h2 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList"></a>updateRootDisplayList</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ...</span><br>    updateViewTreeDisplayList(view);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;<br>        RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>            canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mRootNode.endRecording();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>两段逻辑：</p><ol><li><code>updateViewTreeDisplayList(view)</code>，其中 view 是 root view 也就是 <code>DecorView</code></li><li><code>Canvas.drawRenderNode</code>，<code>RenderNode</code> 是 View 返回的</li></ol><h2 id="updateViewTreeDisplayList"><a href="#updateViewTreeDisplayList" class="headerlink" title="updateViewTreeDisplayList"></a>updateViewTreeDisplayList</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateViewTreeDisplayList(View view)<br>RenderNode View.updateDisplayListIfDirty() &#123;<br>    <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">final</span> RecordingCanvas canvas = renderNode.beginRecording(width, height);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        draw(canvas);<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        renderNode.endRecording();<br>        setDisplayListProperties(renderNode);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> renderNode;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终在这里调用了 <code>View.draw</code>，里面就是常规的画布绘制操作，我们继续看看 <code>RecordingCanvas</code> 这个类</p><h2 id="RecordingCanvas"><a href="#RecordingCanvas" class="headerlink" title="RecordingCanvas"></a>RecordingCanvas</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecordingCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DisplayListCanvas</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">DisplayListCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRecordingCanvas</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">BaseRecordingCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Canvas</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawArc</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">float</span> bottom, <span class="hljs-keyword">float</span> startAngle,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">float</span> sweepAngle, <span class="hljs-keyword">boolean</span> useCenter, <span class="hljs-meta">@NonNull</span> Paint paint)</span> </span>&#123;<br>        nDrawArc(mNativeCanvasWrapper, left, top, right, bottom, startAngle, sweepAngle,<br>                useCenter, paint.getNativeInstance());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBitmap</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bitmap bitmap, <span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@Nullable</span> Paint paint)</span> </span>&#123;<br>        throwIfCannotDraw(bitmap);<br>        nDrawBitmap(mNativeCanvasWrapper, bitmap.getNativeInstance(), left, top,<br>                paint != <span class="hljs-keyword">null</span> ? paint.getNativeInstance() : <span class="hljs-number">0</span>, mDensity, mScreenDensity,<br>                bitmap.mDensity);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRect</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">float</span> bottom,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@NonNull</span> Paint paint)</span> </span>&#123;<br>        nDrawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.getNativeInstance());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>RecordingCanvas</code> 继承自 <code>DisplayListCanvas</code>，<code>DisplayListCanvas</code> 继承自 <code>BaseRecordingCanvas</code></p><p>在 <code>BaseRecordingCanvas</code> 里，<code>View.draw(Canvas)</code> 所用到的 <code>drawBitmap</code>、<code>drawText</code>、<code>drawRect</code> 等绘图方法都被重定向到 <code>BaseCanvas.mNativeCanvasWrapper</code>，继续看看它指向谁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从构造开始</span><br>RecordingCanvas RenderNode.beginRecording(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) &#123;<br>    <span class="hljs-comment">// ...</span><br>    mCurrentRecordingCanvas = RecordingCanvas.obtain(<span class="hljs-keyword">this</span>, width, height);<br>    <span class="hljs-keyword">return</span> mCurrentRecordingCanvas;<br>&#125;<br>RecordingCanvas RecordingCanvas.obtain(RenderNode node, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;node cannot be null&quot;</span>);<br>    RecordingCanvas canvas = sPool.acquire();<br>    <span class="hljs-keyword">if</span> (canvas == <span class="hljs-keyword">null</span>) &#123;<br>        canvas = <span class="hljs-keyword">new</span> RecordingCanvas(node, width, height);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode, width, height);<br>    &#125;<br>    canvas.mNode = node;<br>    canvas.mWidth = width;<br>    canvas.mHeight = height;<br>    <span class="hljs-keyword">return</span> canvas;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>RecordingCanvas</code> 会被频繁地创建和销毁，所以用了池化，池子大小是 25，从池子里拿出的对象用 <code>nResetDisplayListCanvas</code> 重置；我们走创建新实例这条路继续看下去</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">RecordingCanvas</span><span class="hljs-params">(RenderNode node, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));<br>&#125;<br><br><span class="hljs-comment">// /frameworks/base/core/jni/android_view_DisplayListCanvas.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="hljs-params">(jlong renderNodePtr, jint width, jint height)</span> </span>&#123;<br>    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);<br>    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));<br>&#125;<br><br>Canvas* Canvas::create_recording_canvas(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, uirenderer::RenderNode* renderNode) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到 <code>RecordingCanvas.mNativeCanvasWrapper</code> 是 native <code>SkiaRecordingCanvas</code></p><p><code>SkiaRecordingCanvas</code> 继承自 <code>SkiaCanvas</code>，大部分 2D 绘图方法都是由 <code>SkiaCanvas</code> 实现的，而 <code>SkiaCanvas</code> 又把绘图操作交由 <code>SkiaCanvas.mCanvas</code> 执行，我们看下它指向谁</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SkiaRecordingCanvas</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    <span class="hljs-built_in">initDisplayList</span>(renderNode, width, height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaRecordingCanvas::initDisplayList</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    mCurrentBarrier = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">SkASSERT</span>(mDisplayList.<span class="hljs-built_in">get</span>() == <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">if</span> (renderNode) &#123;<br>        mDisplayList = renderNode-&gt;<span class="hljs-built_in">detachAvailableList</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mDisplayList) &#123;<br>        mDisplayList.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SkiaDisplayList</span>());<br>    &#125;<br><br>    mDisplayList-&gt;<span class="hljs-built_in">attachRecorder</span>(&amp;mRecorder, SkIRect::<span class="hljs-built_in">MakeWH</span>(width, height));<br>    SkiaCanvas::<span class="hljs-built_in">reset</span>(&amp;mRecorder);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaCanvas::reset</span><span class="hljs-params">(SkCanvas* skiaCanvas)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mCanvas != skiaCanvas) &#123;<br>        mCanvas = skiaCanvas;<br>        mCanvasOwned.<span class="hljs-built_in">reset</span>();<br>    &#125;<br>    mSaveStack.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>SkiaRecordingCanvas.mRecorder</code> 被赋值给了 <code>SkiaCanvas.mCanvas</code>，它是 <code>RecordingCanvaas</code>，而它又把 draw 交由 <code>RecordingCanvas.fDL</code> 执行</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayListData::drawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; rect, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;push&lt;DrawRect&gt;(<span class="hljs-number">0</span>, rect, paint);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DrawRect</span> <span class="hljs-keyword">final</span> :</span> Op &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> kType = Type::DrawRect;<br>    <span class="hljs-built_in">DrawRect</span>(<span class="hljs-keyword">const</span> SkRect&amp; rect, <span class="hljs-keyword">const</span> SkPaint&amp; paint) : <span class="hljs-built_in">rect</span>(rect), <span class="hljs-built_in">paint</span>(paint) &#123;&#125;<br>    SkRect rect;<br>    SkPaint paint;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(SkCanvas* c, <span class="hljs-keyword">const</span> SkMatrix&amp;)</span> <span class="hljs-keyword">const</span> </span>&#123; c-&gt;<span class="hljs-built_in">drawRect</span>(rect, paint); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayListData::drawImage</span><span class="hljs-params">(sk_sp&lt;<span class="hljs-keyword">const</span> SkImage&gt; image, SkScalar x, SkScalar y, onst SkPaint* paint, BitmapPalette palette)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;push&lt;DrawImage&gt;(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">move</span>(image), x, y, paint, palette);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DrawImage</span> <span class="hljs-keyword">final</span> :</span> Op &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> kType = Type::DrawImage;<br>    <span class="hljs-built_in">DrawImage</span>(sk_sp&lt;<span class="hljs-keyword">const</span> SkImage&gt;&amp;&amp; image, SkScalar x, SkScalar y, <span class="hljs-keyword">const</span> SkPaint* paint, BitmapPalette palette)<br>            : <span class="hljs-built_in">image</span>(std::<span class="hljs-built_in">move</span>(image)), <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">palette</span>(palette) &#123;<br>        <span class="hljs-keyword">if</span> (paint) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;paint = *paint;<br>        &#125;<br>    &#125;<br>    sk_sp&lt;<span class="hljs-keyword">const</span> SkImage&gt; image;<br>    SkScalar x, y;<br>    SkPaint paint;<br>    BitmapPalette palette;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(SkCanvas* c, <span class="hljs-keyword">const</span> SkMatrix&amp;)</span> <span class="hljs-keyword">const</span> </span>&#123; c-&gt;<span class="hljs-built_in">drawImage</span>(image.<span class="hljs-built_in">get</span>(), x, y, &amp;paint); &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>RecordingCanvas.fDL</code> 是个 <code>DisplayListData</code>，它把绘图操作的所有参数记录为一个结构体 Op 并记录起来</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaRecordingCanvas::initDisplayList</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaDisplayList::attachRecorder</span><span class="hljs-params">(RecordingCanvas* recorder, <span class="hljs-keyword">const</span> SkIRect&amp; bounds)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::reset</span><span class="hljs-params">(DisplayListData* dl, <span class="hljs-keyword">const</span> SkIRect&amp; bounds)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">resetCanvas</span>(bounds.<span class="hljs-built_in">right</span>(), bounds.<span class="hljs-built_in">bottom</span>());<br>    fDL = dl;<br>    mClipMayBeComplex = <span class="hljs-literal">false</span>;<br>    mSaveCount = mComplexSaveCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结下：java <code>RecordingCanvas.mNativeCanvasWrapper</code> 持有 native <code>SkiaRecordingCanvas</code>，<code>SkiaRecordingCanvas→mDisplayList→mDisplayList</code> 里记录所有的绘图操作</p><h2 id="endRecording"><a href="#endRecording" class="headerlink" title="endRecording"></a>endRecording</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">RenderNode View.<span class="hljs-built_in">updateDisplayListIfDirty</span>() &#123;<br>    <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">final</span> RecordingCanvas canvas = renderNode.<span class="hljs-built_in">beginRecording</span>(width, height);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">draw</span>(canvas);<br>        <span class="hljs-comment">// ...</span><br>    &#125; finally &#123;<br>        renderNode.<span class="hljs-built_in">endRecording</span>();<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> renderNode;<br>&#125;<br><br>RecordingCanvas.<span class="hljs-built_in">endRecording</span>() &#123;<br>    <span class="hljs-comment">// ...</span><br>    RecordingCanvas canvas = mCurrentRecordingCanvas;<br>    mCurrentRecordingCanvas = null;<br>    <span class="hljs-keyword">long</span> displayList = canvas.<span class="hljs-built_in">finishRecording</span>();<br>    <span class="hljs-built_in">nSetDisplayList</span>(mNativeRenderNode, displayList);<br>    canvas.<span class="hljs-built_in">recycle</span>();<br>&#125;<br><br><span class="hljs-function">uirenderer::DisplayList* <span class="hljs-title">SkiaRecordingCanvas::finishRecording</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> mDisplayList.<span class="hljs-built_in">release</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::setStagingDisplayList</span><span class="hljs-params">(DisplayList* displayList)</span> </span>&#123;<br>    mValid = (displayList != <span class="hljs-literal">nullptr</span>);<br>    mNeedsDisplayListSync = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">delete</span> mStagingDisplayList;<br>    mStagingDisplayList = displayList;<br>&#125;<br><br>RecordingCanvas.<span class="hljs-built_in">recycle</span>() &#123;<br>    mNode = null;<br>    sPool.<span class="hljs-built_in">release</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终，<code>RecordingCanvas</code> 被回收到池里，保存了绘制 Op 的 <code>SkiaDisplayList</code> 被转移到 native <code>RenderNode.mStagingDisplayList</code></p><h2 id="drawRenderNode"><a href="#drawRenderNode" class="headerlink" title="drawRenderNode"></a>drawRenderNode</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ...</span><br>    updateViewTreeDisplayList(view);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;<br>        RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>            canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mRootNode.endRecording();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> SkiaRecordingCanvas::drawRenderNode(uirenderer::RenderNode* renderNode) &#123;<br>    <span class="hljs-comment">// Record the child node. Drawable dtor will be invoked when mChildNodes deque is cleared.</span><br>    mDisplayList-&gt;mChildNodes.emplace_back(renderNode, asSkCanvas(), <span class="hljs-keyword">true</span>, mCurrentBarrier);<br>    auto&amp; renderNodeDrawable = mDisplayList-&gt;mChildNodes.back();<br>    <span class="hljs-keyword">if</span> (Properties::getRenderPipelineType() == RenderPipelineType::SkiaVulkan) &#123;<br>        <span class="hljs-comment">// Put Vulkan WebViews with non-rectangular clips in a HW layer</span><br>        renderNode-&gt;mutateStagingProperties().setClipMayBeComplex(mRecorder.isClipMayBeComplex());<br>    &#125;<br>    drawDrawable(&amp;renderNodeDrawable);<br><br>    <span class="hljs-comment">// use staging property, since recording on UI thread</span><br>    <span class="hljs-keyword">if</span> (renderNode-&gt;stagingProperties().isProjectionReceiver()) &#123;<br>        mDisplayList-&gt;mProjectionReceiver = &amp;renderNodeDrawable;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面，<code>DecorView</code> 的 DisplayList 已经被更新过了，所以 <code>view.updateDisplayListIfDirty()</code> 直接返回它的 <code>RenderNode</code></p><p>beginRecording → draw → endRecording 三步走跟上面的是一样的，<code>HardwareRenderer.mRootNode</code> 对应的是 native <code>RootRenderNode</code>；它的 <code>mStagingDisplayList</code> 只有一个 <code>RenderNodeDrawable</code></p><h2 id="syncAndDrawFrame"><a href="#syncAndDrawFrame" class="headerlink" title="syncAndDrawFrame"></a>syncAndDrawFrame</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 现在从新回到开头的地方</span><br><span class="hljs-keyword">void</span> ThreadedRenderer.draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ... 这里会调用 View.draw(Canvas)，并把绘制 op 保存起来</span><br>    updateRootDisplayList(view, callbacks);<br>    <span class="hljs-comment">// ... 这个方法看起来会执行真正的绘制操作，进去看下</span><br>    <span class="hljs-keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 进入 native</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> HardwareRenderer.syncAndDrawFrame(<span class="hljs-meta">@NonNull</span> FrameInfo frameInfo) &#123;<br>    <span class="hljs-keyword">return</span> nSyncAndDrawFrame(mNativeProxy, frameInfo.frameInfo, frameInfo.frameInfo.length);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// frameworks/base/core/jni/android_view_ThreadedRenderer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    env-&gt;<span class="hljs-built_in">GetLongArrayRegion</span>(frameInfo, <span class="hljs-number">0</span>, frameInfoSize, proxy-&gt;<span class="hljs-built_in">frameInfo</span>());<br>    <span class="hljs-keyword">return</span> proxy-&gt;<span class="hljs-built_in">syncAndDrawFrame</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RenderProxy::syncAndDrawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mDrawFrameTask.<span class="hljs-built_in">drawFrame</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DrawFrameTask::drawFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 到此都还是在 ui thread</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::postAndWait</span><span class="hljs-params">()</span> </span>&#123;<br>    AutoMutex _lock(mLock);<br>    <span class="hljs-comment">// RenderThread 继承自 Thread，DrawFrameTask::run 被提交至 RenderThread 的 WorkQueue 等待执行</span><br>    mRenderThread-&gt;<span class="hljs-built_in">queue</span>().<span class="hljs-built_in">post</span>([<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-built_in">run</span>(); &#125;);<br>    <span class="hljs-comment">// 这里会导致 ui thread 阻塞，直到 DrawFrameTask::run() 里把相关数据同步过来后才恢复 ui thread</span><br>    mSignal.<span class="hljs-built_in">wait</span>(mLock);<br>&#125;<br><br><span class="hljs-comment">// 记住此时已经是在 RenderThread 而不是 ui thread，ui thread 此时被阻塞了</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DrawFrame&quot;</span>);<br><br>    <span class="hljs-keyword">bool</span> canUnblockUiThread;<br>    <span class="hljs-keyword">bool</span> canDrawThisFrame;<br>    &#123;<br>        <span class="hljs-function">TreeInfo <span class="hljs-title">info</span><span class="hljs-params">(TreeInfo::MODE_FULL, *mContext)</span></span>;<br>        canUnblockUiThread = <span class="hljs-built_in">syncFrameState</span>(info);<br>        canDrawThisFrame = info.out.canDrawThisFrame;<br><br>        <span class="hljs-keyword">if</span> (mFrameCompleteCallback) &#123;<br>            mContext-&gt;<span class="hljs-built_in">addFrameCompleteListener</span>(std::<span class="hljs-built_in">move</span>(mFrameCompleteCallback));<br>            mFrameCompleteCallback = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Grab a copy of everything we need</span><br>    CanvasContext* context = mContext;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int64_t</span>)&gt; callback = std::<span class="hljs-built_in">move</span>(mFrameCallback);<br>    mFrameCallback = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// From this point on anything in &quot;this&quot; is *UNSAFE TO ACCESS*</span><br>    <span class="hljs-keyword">if</span> (canUnblockUiThread) &#123;<br>        <span class="hljs-built_in">unblockUiThread</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Even if we aren&#x27;t drawing this vsync pulse the next frame number will still be accurate</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(callback)) &#123;<br>        context-&gt;<span class="hljs-built_in">enqueueFrameWork</span>(<br>                [callback, frameNr = context-&gt;<span class="hljs-built_in">getFrameNumber</span>()]() &#123; <span class="hljs-built_in">callback</span>(frameNr); &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_LIKELY</span>(canDrawThisFrame)) &#123;<br>        context-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// wait on fences so tasks don&#x27;t overlap next frame</span><br>        context-&gt;<span class="hljs-built_in">waitOnFences</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!canUnblockUiThread) &#123;<br>        <span class="hljs-built_in">unblockUiThread</span>();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里有两个函数是需要关注的：<code>syncFrameState(info)</code> 和 <code>context-&gt;draw()</code>，但不打算深入下去，因为后续涉及到很多状态判断和方法调用，而且会进入 skia 引擎的相关方法，不是代码跟踪就可以理解的（凡是跟 opengl 相关的代码，经过层层封装都不太好理解）</p><p>搜索 <code>DrawFrameTask</code> 或者 <code>DisplayList</code> 等关键字可以找到如何把 <code>DisplayList</code> 处理为 <code>egl</code> 相关指令的文章，这里根据<a href="https://blog.csdn.net/jinzhuojun/article/details/54234354">《Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)》</a> 的描述总结下此阶段的工作：</p><ol><li><code>syncFrameState(info)</code> 上传纹理</li><li><code>unblockUiThread()</code> 然后恢复 ui thread</li><li><code>context-&gt;draw()</code> 输出 egl 指令</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../../../../image/2020-12-13-ui-thread-in-vsync/52054.png" alt="52054.png"></p><p>这是一个 sync_app 信号内的 systrace，结合这张图片，尝试解答开头提出的问题</p><ol><li>app 内的 ui 渲染至少包含两个线程：ui thread（执行 <code>View.draw()</code>）和 render thread（执行 egl 指令）</li><li>ui thread 和 render thread 有一段重合的地方，也就是在 ui thread 完成「Record <code>View#draw()</code>」后，ui thread 被阻塞了；而 render thread 开始执行 <code>syncFrameState</code>，完成后恢复 ui thread，此时 ui thread 的任务已完成，后续的都是 render thread 的任务了</li><li>从时长看，ui thread 执行 <code>Choreographer#doFrame</code> 用时 4ms，render thread 执行 <code>DrawFrame</code> 用时 8ms；render thread 的存在大大地释放了 ui thread 的压力</li><li>要在 16ms 内完成一帧的绘制，不能都让 ui thread 给消耗掉了，还得留出一段时间给 render thread，也就是说 ui thread 在一帧内的任务 <code>Choreographer#doFrame</code> 耗时要小于 16ms 才行；而且从上图看 render thread 的耗时远大于 ui thread，留给 ui thread 的时间应该是远小于 16ms 的</li></ol><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li><code>DisplayList</code>：对 <code>Canvas</code> 的所有绘制操作并不会立刻执行，而是保存为 <code>DisplayList</code>；这一过程称为“录制”，后续可以“回放”进行渲染</li><li><code>View</code> 是表，是 framework 暴露出来的 ui api，就像 DOM 是浏览器暴露出来的 ui api；<code>RenderNode</code> 是里</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>ui thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（一）vsync</title>
    <link href="/2020/12/02/vsync/"/>
    <url>/2020/12/02/vsync/</url>
    
    <content type="html"><![CDATA[<p>android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 <code>View.invalidate</code> 讲起，看看简单的一个 <code>invalidate</code> 后面隐藏着多么复杂的工作</p><h2 id="从-View-invalidate-说起"><a href="#从-View-invalidate-说起" class="headerlink" title="从 View.invalidate() 说起"></a>从 <code>View.invalidate()</code> 说起</h2><p><img src="../../../../image/2020-12-02-vsync/invalidate.jpg" alt="invalidate.jpg"></p><p>看上图，<code>View.invalidate()</code> 主要做了两件事：</p><ol><li>将 <code>ViewRootImpl.doTraversal()</code> 加入到 <code>Choreographer</code> 的任务列表里，等待下一次 vsync 信号到来时执行；<code>doTraversal()</code>主要执行 view tree 的三个重要方法：measure、layout 和 draw；<code>Choreographer</code>则是在一次 vsync 信号到来时，依次执行 <code>INPUT</code>，<code>ANIMATION</code> 和 <code>TRAVERSAL</code> 这三个类别的任务；也就是说 view tree 的渲染和 input 的处理都是从 vsync 到来时开始的，而且此时会开启同步栅栏，屏蔽非 ui 任务（用户任务），集中力量在下一次的 vsync 到来前完成一帧的渲染</li><li>唤醒 <code>EventThread</code> 去看看有没 vsync 信号的到来；<code>EventThread</code> 看名字就知道是一个线程，看它的 loop 流程，是将 <code>mPendingEvents</code> 分发给 consumer，那么我们可以猜想下，event 也许包含了 vsync，而 consumer 很有可能最终走到 <code>Choreographer.doFrame</code>里触发 view tree 的绘制</li></ol><p>按照从下到上追踪法，下一步就是看看是谁在什么时候把 event 放到 <code>mPendingEvents</code> 里，但这里我选择掉转方向盘，先从 surfaceflinger 讲起</p><p>继续之前，我们得先了解几个跟硬件有关的概念</p><h2 id="HAL，Hardware-Abstract-Layer，硬件抽象层"><a href="#HAL，Hardware-Abstract-Layer，硬件抽象层" class="headerlink" title="HAL，Hardware Abstract Layer，硬件抽象层"></a>HAL，Hardware Abstract Layer，硬件抽象层</h2><p>看名字就知道这是跟硬件、设备相关的东西，应该是最贴近硬件的那一层软件，我没有做过相关的开发，但是结合 google 和这两篇文章：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，我大概了解了它是干什么的，我说说我的理解：</p><ul><li>它用接口的方式定义协议，而协议则定义了组件间的沟通规范；Android app 开发其实也就这个概念，就是各个业务、基础能力的 interface；我做过 java web 开发，所以对这个概念比较熟悉；整个 java web 是由很多协议构成的：Servlet、JSP、JDBC 等，sun 给出包含这些协议 interface 的 jar 包出来（它自己也可能会给出一个默认实现比如 glassfish），各个厂商给出自己对协议的实现如：Tomcat、Jboss、Resin 等；而 web app 开发者只需根据协议 jar 包开发业务，部署时根据条件可以放在各种厂商的容器上</li><li>HAL 也是这个道理，android HWC HAL 定义了各种 interface（在 <code>hardware/interfaces/graphics/composer/2.1/</code> 目录下），各个厂商需要实现这些接口并给出 so 文件；打包 android image 的时候，根据硬件设备挑选合适的 HAL 实现，把 so 文件放到镜像里；而 android framework 开发者只需根据 HAL 接口进行业务开发即可，无需关心实现细节</li></ul><h2 id="HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言"><a href="#HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言" class="headerlink" title="HIDL，HAL Interface Definition Language，HAL 接口定义语言"></a>HIDL，HAL Interface Definition Language，HAL 接口定义语言</h2><p>看名字好像跟 AIDL 有点渊源啊，对的，它是 HAL 的代码生成器；具体怎么用我们了解下即可：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/89173162">Android HIDL 之 hal 进程启动及服务注册过程</a></p><p>总结下关键点：</p><ul><li>各个 HAL 是独立进程的（看看 <code>hardware/interfaces/graphics/composer/2.1/default/</code> 是怎么启动 HWC 进程并加载厂商 so 库的），surfaceflinger 进程通过 binder 与 HWC 进程通讯（也就是 C/S 架构，HWC 是 server，surfaceflinger 是 client）</li><li>HWC 将服务注册到 <code>hwservicemanager</code>，surfaceflinger 从 <code>hwservicemanager</code> 获取 composer 服务</li><li>所以用从下到上的方法找调用栈的时候会发现，onVsync 方法找不到调用的地方，那是因为发送 vsync 信号的代码是厂商代码（framework 提供 callback interface），不在 aosp 里面</li></ul><h2 id="HWC，硬件图层合成器"><a href="#HWC，硬件图层合成器" class="headerlink" title="HWC，硬件图层合成器"></a>HWC，硬件图层合成器</h2><p><a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a> 这里也介绍了，它是一个合成多个图层的组件（原来状态栏、导航栏、壁纸、app 等不是一起渲染，而是独自渲染最后合成为屏幕内容的），这里只关心它会发出 vsync 信号</p><p><img src="../../../../image/2020-12-02-vsync/vsync_flow.jpg" alt="vsync_flow.jpg"></p><p>我们先理解这张图，屏幕（硬件）发出 vsync 信号（就是上图的 HW_VSYNC），经过软件的一系列的调整生成 SW_VSYNC，然后输出到两路：</p><ol><li><code>SF_VSYNC</code>，输出到 surfaceflinger</li><li><code>APP_VSYNC</code>，输出到 app</li></ol><h2 id="HW-VSYNC-硬件垂直同步信号"><a href="#HW-VSYNC-硬件垂直同步信号" class="headerlink" title="HW_VSYNC - 硬件垂直同步信号"></a>HW_VSYNC - 硬件垂直同步信号</h2><p><img src="../../../../image/2020-12-02-vsync/hw_vsync.jpg" alt="hw_vsync.jpg"></p><p>surfaceflinger 是一个很重要的服务进程，它跟图像和显示有关，源码在 <code>/frameworks/native/services/surfaceflinger</code>；目录下有个编译配置文件 <code>Android.bp</code> ，看下它的内容，它输出了可执行文件 surfaceflinger、共享库 libsurfaceflinger.so 和 libSurfaceFlingerProp.so；然后有个 <code>surfaceflinger.rc</code>，它是一个启动配置文件，意味着 surfaceflinger 会在系统启动后被 init 进程启动为服务进程，看下里面的内容，可执行文件是 <code>/system/bin/surfaceflinger</code>，<code>main</code> 函数入口在 main_surfaceflinger.cpp</p><p>从上图可以看到 surfaceflinger 进程启动后，会查找 HWC server 并注册 callback，当设备发出 hw_vsync 时，<code>SurfaceFlinger.onVsyncReceived</code> 被执行，看上面那张图，hw_vsync 不是直接被使用，而是被调整转换为 sw_vsync，也就是 <code>DispSync.addResyncSample</code></p><h2 id="SW-VSYNC-软件垂直同步信号"><a href="#SW-VSYNC-软件垂直同步信号" class="headerlink" title="SW_VSYNC - 软件垂直同步信号"></a>SW_VSYNC - 软件垂直同步信号</h2><p><code>DispSyncThread</code> 和 <code>DispSync</code> 收集 HW_VSYNC，计算并输出 SW_VSYNC；主循环是 <code>DispSyncThread.threadLoop()</code>，但在分析 main loop 之前，我们需要先了解 <code>DispSync</code> 几个重要的属性（参考<a href="https://www.jianshu.com/p/d3e4b1805c92">「Android SurfaceFlinger SW Vsync模型」</a>）</p><p><code>mResyncSamples</code> 数组 - 通过上面的分析我们知道 <code>addResyncSample</code> 把 HW_VSYNC 加入 <code>DispSync</code>，但 <code>mResyncSamples</code> 只会保留最新的 32 个以供后续计算；它是个首尾相连、环状的循环列表，容量为 32</p><p><code>mPeriod</code> - 两个 HW_VSYNC 之间的时间间隔，相当于刷新率，我们看下它是怎么计算的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);<br>    <span class="hljs-comment">// 只有收集到足够多（≥ 6）的 HW_VSYNC 才去计算刷新率（以及其他参数）</span><br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Computing...&quot;</span>, mName);<br>        <span class="hljs-keyword">nsecs_t</span> durationSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">nsecs_t</span> minDuration = INT64_MAX;<br>        <span class="hljs-keyword">nsecs_t</span> maxDuration = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// We skip the first 2 samples because the first vsync duration on some</span><br>        <span class="hljs-comment">// devices may be much more inaccurate than on other devices, e.g. due</span><br>        <span class="hljs-comment">// to delays in ramping up from a power collapse. By doing so this</span><br>        <span class="hljs-comment">// actually increases the accuracy of the DispSync model even though</span><br>        <span class="hljs-comment">// we&#x27;re effectively relying on fewer sample points.</span><br><br>        <span class="hljs-comment">// 把收集到的 HW_VSYNC 时间间隔去掉前两个，去掉最大值和最小值，剩下的求平均值</span><br>        <span class="hljs-comment">// 这就算出了硬件的刷新率，它是计算出来的一个平均值，因为 HW_VSYNC 速率极可能是会变动的</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> numSamplesSkipped = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;<br>            <span class="hljs-keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;<br>            <span class="hljs-keyword">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;<br>            <span class="hljs-keyword">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];<br>            durationSum += duration;<br>            minDuration = <span class="hljs-built_in">min</span>(minDuration, duration);<br>            maxDuration = <span class="hljs-built_in">max</span>(maxDuration, duration);<br>        &#125;<br><br>        <span class="hljs-comment">// Exclude the min and max from the average</span><br>        durationSum -= minDuration + maxDuration;<br>        mPeriod = durationSum / (mNumResyncSamples - numSamplesSkipped - <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>mPhase</code> - <code>mPeriod</code> 的偏差值；我们知道 <code>mPeriod</code> 是一个计算出来的平均值，而且还去除了一些噪音（极大值、极小值等），那么它与真实的 HW_VSYNC 之间必定会有偏差，<code>mPhase</code> 就是这个平均偏差（要从数学理论上去理解）；这里不深入细节了</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);<br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">double</span> sampleAvgX = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> sampleAvgY = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> scale = <span class="hljs-number">2.0</span> * M_PI / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(mPeriod);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;<br>            <span class="hljs-keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;<br>            <span class="hljs-keyword">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;<br>            <span class="hljs-keyword">double</span> samplePhase = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(sample % mPeriod) * scale;<br>            sampleAvgX += <span class="hljs-built_in">cos</span>(samplePhase);<br>            sampleAvgY += <span class="hljs-built_in">sin</span>(samplePhase);<br>        &#125;<br><br>        sampleAvgX /= <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(mNumResyncSamples - numSamplesSkipped);<br>        sampleAvgY /= <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(mNumResyncSamples - numSamplesSkipped);<br><br>        mPhase = <span class="hljs-built_in">nsecs_t</span>(<span class="hljs-built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);<br><br>        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));<br><br>        <span class="hljs-keyword">if</span> (mPhase &lt; -(mPeriod / <span class="hljs-number">2</span>)) &#123;<br>            mPhase += mPeriod;<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));<br>        &#125;<br><br>        <span class="hljs-comment">// Artificially inflate the period if requested.</span><br>        mPeriod += mPeriod * mRefreshSkipCount;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>mReferenceTime</code>，这个最新那个 HW_VSYNC 的时间，每次计算下一个 SW_VSYNC 时都是以该时间作为基准，这样可以减少误差。如果每一个 SW_VSYNC 都以上一个 SW_VSYNC 作为基准，那误差就会不停的累加；而如果以第一个 HW_VSYNC 作基准，那每次 SW_VSYNC 误差是不会累加的</p><p>现在我们看下 main loop</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">status_t</span> err;<br>    <span class="hljs-keyword">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        std::vector&lt;CallbackInvocation&gt; callbackInvocations;<br>        <span class="hljs-keyword">nsecs_t</span> targetTime = <span class="hljs-number">0</span>;<br>        &#123; <span class="hljs-comment">// Scope for lock</span><br>            <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;<br>                <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);<br>            &#125;<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);<br>            ++mFrameNumber;<br>            <span class="hljs-keyword">if</span> (mStop) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 收集到足够多的 HW_VSYNC 算出刷新率后，才计算 SW_VSYNC，否则 wait</span><br>            <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;<br>                err = mCond.<span class="hljs-built_in">wait</span>(mMutex);<br>                <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// computeNextEventTimeLocked 这个方法很重要，我们知道随着 HW_VSYNC 样本的不断更新，</span><br>            <span class="hljs-comment">// mPeriod、mPhase 和 mReferenceTime 也跟着轻微变动，上一次的 SW_VSYNC 是根据上一次的参数算出来的</span><br>            <span class="hljs-comment">// 下一次的 SW_VSYNC 则在上次时间戳的基础上重新计算</span><br>            targetTime = <span class="hljs-built_in">computeNextEventTimeLocked</span>(now);<br><br>            <span class="hljs-comment">// 没到时间则 wait</span><br>            <span class="hljs-keyword">bool</span> isWakeup = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (now &lt; targetTime) &#123;<br>                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DispSync waiting&quot;</span>);<br>                <span class="hljs-keyword">if</span> (targetTime == INT64_MAX) &#123;<br>                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting forever&quot;</span>, mName);<br>                    err = mCond.<span class="hljs-built_in">wait</span>(mMutex);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(targetTime));<br>                    err = mCond.<span class="hljs-built_in">waitRelative</span>(mMutex, targetTime - now);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (err == TIMED_OUT) &#123;<br>                    isWakeup = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>            <span class="hljs-comment">// Don&#x27;t correct by more than 1.5 ms</span><br>            <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">nsecs_t</span> kMaxWakeupLatency = <span class="hljs-built_in">us2ns</span>(<span class="hljs-number">1500</span>);<br>            <span class="hljs-keyword">if</span> (isWakeup) &#123;<br>                mWakeupLatency = ((mWakeupLatency * <span class="hljs-number">63</span>) + (now - targetTime)) / <span class="hljs-number">64</span>;<br>                mWakeupLatency = <span class="hljs-built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);<br>                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;<br>                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);<br>                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 发送时，再次计算发送时间，只有此时到达发送时间的才发送（时间算得很精确）</span><br>            callbackInvocations = <span class="hljs-built_in">gatherCallbackInvocationsLocked</span>(now);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (callbackInvocations.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fireCallbackInvocations</span>(callbackInvocations);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总的来说，SW_VSYNC 它去除了噪音，而且用过去 32 个 HW_VSYNC 样本的平均值作刷新率，对比 HW_VSYNC 显得平滑了很多</p><p>那谁接收 SW_VSYNC？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 一个是 app，叫做 APP_VSYNC 吧</span><br>    mAppConnectionHandle =<br>            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;app&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().app,<br>                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),<br>                                         impl::EventThread::<span class="hljs-built_in">InterceptVSyncsCallback</span>());<br>    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span><br>    mSfConnectionHandle =<br>            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,<br>                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),<br>                                         [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">nsecs_t</span> timestamp) &#123;<br>                                             mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);<br>                                         &#125;);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="APP-VSYNC-发送给-app-的垂直同步信号"><a href="#APP-VSYNC-发送给-app-的垂直同步信号" class="headerlink" title="APP_VSYNC - 发送给 app 的垂直同步信号"></a>APP_VSYNC - 发送给 app 的垂直同步信号</h2><p>还记得文章开头那张 <code>View.invalidate()</code> 时序图吗？最后面它唤醒了 <code>EventThread</code>，现在我们来看看 <code>EventThread</code> 的主循环都做了些什么</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::threadMain</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;<br>    DisplayEventConsumers consumers;<br><br>    <span class="hljs-keyword">while</span> (mState != State::Quit) &#123;<br>        std::optional&lt;DisplayEventReceiver::Event&gt; event;<br><br>        <span class="hljs-comment">// 在文章的开头，我们就猜测 mPendingEvents 里放的是同步信号</span><br>        <span class="hljs-comment">// 现在我们知道了里面包含 SW_VSYNC，那是谁放进去的呢？</span><br>        <span class="hljs-keyword">if</span> (!mPendingEvents.<span class="hljs-built_in">empty</span>()) &#123;<br>            event = mPendingEvents.<span class="hljs-built_in">front</span>();<br>            mPendingEvents.<span class="hljs-built_in">pop_front</span>();<br>...<br>        &#125;<br><br>        <span class="hljs-keyword">bool</span> vsyncRequested = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// Find connections that should consume this event.</span><br>        <span class="hljs-keyword">auto</span> it = mDisplayEventConnections.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (it != mDisplayEventConnections.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> connection = it-&gt;<span class="hljs-built_in">promote</span>()) &#123;<br>                vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;<br><br>                <span class="hljs-keyword">if</span> (event &amp;&amp; <span class="hljs-built_in">shouldConsumeEvent</span>(*event, connection)) &#123;<br>                    consumers.<span class="hljs-built_in">push_back</span>(connection);<br>                &#125;<br><br>                ++it;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                it = mDisplayEventConnections.<span class="hljs-built_in">erase</span>(it);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 分发给消费者，怎么回调给 Choreographer？</span><br>        <span class="hljs-keyword">if</span> (!consumers.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">dispatchEvent</span>(*event, consumers);<br>            consumers.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>DispSyncThread</code> 把 SW_VSYNC 压入 <code>EventThread.mPendingEvents</code></p><p><img src="../../../../image/2020-12-02-vsync/on_vsync.jpg" alt="on_vsync.jpg"></p><p>分发 SW_VSYNC 的流程</p><ul><li><code>ViewRootImpl</code> 里拿到的是接收 APP_VSYNC 的 <code>Choreographer</code></li><li><code>Choreographer</code> 在构造函数里通过 <code>SurfaceFlinger</code> 与 <code>EventThread</code> 建立连接；这个连接其实是个 <code>Parcelable</code>，一块可以 io 的内存，<code>EventThread</code> 往里面写入 SW_VSYNC，<code>DisplayEventReceiver</code> 则通过 <code>Looper.addFd</code> 监听（这是 app main looper）</li><li>当收到 SW_VSYNC 时<code>FrameDisplayEventReceiver</code> 把 <code>Choreographer.doFrame</code> 放入 message queue，这样 input、animate 和 view 绘制即将执行</li></ul><p><img src="../../../../image/2020-12-02-vsync/consumer.jpg" alt="consumer.jpg"></p><h2 id="SF-VSYNC"><a href="#SF-VSYNC" class="headerlink" title="SF_VSYNC"></a>SF_VSYNC</h2><p>上面我们在分析是谁接收 SW_VSYNC 时，除了 APP_VSYNC 外，还有一路 SF_VSYNC</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span><br>    mSfConnectionHandle =<br>    mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,<br>                                 mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),<br>                                 [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">nsecs_t</span> timestamp) &#123;<br>                                     mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);<br>                                 &#125;);<br>    <span class="hljs-comment">// 看看 mEventQueue-&gt;setEventConnection 做了什么</span><br>    mEventQueue-&gt;<span class="hljs-built_in">setEventConnection</span>(mScheduler-&gt;<span class="hljs-built_in">getEventConnection</span>(mSfConnectionHandle));<br>    <span class="hljs-comment">// ...</span><br>&#125; <br><br><span class="hljs-comment">// 上面有分析过，vsync event 是写入到一块内存里，通过 fd 可以监听到，而回调是 MessageQueue::cb_eventReceiver</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::setEventConnection</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mEventTube.<span class="hljs-built_in">getFd</span>() &gt;= <span class="hljs-number">0</span>) &#123;<br>        mLooper-&gt;<span class="hljs-built_in">removeFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>());<br>    &#125;<br>    mEvents = connection;<br>    mEvents-&gt;<span class="hljs-built_in">stealReceiveChannel</span>(&amp;mEventTube);<br>    mLooper-&gt;<span class="hljs-built_in">addFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继续看 eventReceiver 方法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data)</span> </span>&#123;<br>    MessageQueue* queue = <span class="hljs-keyword">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);<br>    <span class="hljs-keyword">return</span> queue-&gt;<span class="hljs-built_in">eventReceiver</span>(fd, events);<br>&#125;<br><br><span class="hljs-comment">// 把 events 解包成 DisplayEventReceiver::Event，当有 vsync 时执行 dispatchInvalidate</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-keyword">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> n;<br>    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::<span class="hljs-built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;<br>                mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 看来得找出 Handler.handleMessage，看看里面怎么处理 MessageQueue::INVALIDATE</span><br><span class="hljs-keyword">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchInvalidate</span>() &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::INVALIDATE));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 最终发现是走到了 SurfaceFlinger::onMessageReceived</span><br><span class="hljs-keyword">void</span> MessageQueue::Handler::<span class="hljs-built_in">handleMessage</span>(<span class="hljs-keyword">const</span> Message&amp; message) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (message.what) &#123;<br>        <span class="hljs-keyword">case</span> INVALIDATE:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REFRESH:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 代码比较长，这就不贴出来了，总结下：</span><br><span class="hljs-comment">// SF_VSYNC 最终会调用 onMessageReceived(MessageQueue::INVALIDATE)，然后又会调用 onMessageReceived(MessageQueue::REFRESH)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h2 id="结合-systrace"><a href="#结合-systrace" class="headerlink" title="结合 systrace"></a>结合 systrace</h2><p>为什么会有 APP_VSYNC 和 SF_VSYNC 呢？这就不得不从屏幕上的内容讲起</p><p>实际上，我们在屏幕上看到的内容是由多个 layer 组合而成的：前台 app（多窗口模式下会有多个 app 显示）、桌面、壁纸、systemui 等，每个 app ui thread 负责绘制自己的内容，然后由 SurfaceFlinger 将它们合成在一起并显示在屏幕上</p><p>也就是说 APP_VSYNC 触发各个 app 的绘制，而最终屏幕内容的改变是由 SF_VSYNC 触发的；是不是这样呢？我们来看下 systrace </p><p><img src="../../../../image/2020-12-02-vsync/45517.png" alt="45517.png"></p><p><img src="../../../../image/2020-12-02-vsync/45545.png" alt="45545.png"></p><p><img src="../../../../image/2020-12-02-vsync/45553.png" alt="45553.png"></p><p><img src="../../../../image/2020-12-02-vsync/45532.png" alt="45532.png"></p><p><img src="../../../../image/2020-12-02-vsync/45628.png" alt="45628.png"></p><p><img src="../../../../image/2020-12-02-vsync/45643.png" alt="45643.png"></p><p>可以看到 ui thread doFrame 的确跟随着 APP_VSYNC（render thread 是执行 opengl 的线程，在 ui thread 计算完后获取结果并输出至 gpu），surfaceflinger onMessageReceived 也是跟随着 SF_VSYNC 的；但有没发现，它们俩似乎是同时执行的？surfaceflinger 不是应该等待 app 渲染完它那一层再合成吗？</p><p>我们重新回顾 initScheduler，有没发现这两路 vsync 都有一个 offset 参数？没错，就是这个参数控制着收到 vsync 后到执行工作的这一段延迟时间；实际上图 surfaceflinger 的延迟差不多是一个 vsync 的周期时间那么大，每个 surfaceflinger 合成的内容却是上一个周期里 app 渲染的内容；而且在合成工作完成后，当前周期的 app 渲染工作（render thread）才开始，避免了 layer 的内容被覆盖；这几个线程就这样有节奏地工作在一起。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>invalidate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scoped Storage（沙盒）</title>
    <link href="/2020/11/19/scoped-storage/"/>
    <url>/2020/11/19/scoped-storage/</url>
    
    <content type="html"><![CDATA[<h2 id="以前的存储访问权限"><a href="#以前的存储访问权限" class="headerlink" title="以前的存储访问权限"></a>以前的存储访问权限</h2><p>先看看以前（ &lt; 10/Q ）的存储访问权限是怎样的</p><p>从 APP 目录（app-specific directories）的角度看，可以分为：</p><ol><li>内部存储（app-specific directories in internal storage）<ol><li>对于 app 自己，无需申请任何读/写权限</li><li>对于其他 app，没有访问权限</li></ol></li><li>外部存储（app-specific directories in external storage）<ol><li>对于 app 自己，无需申请任何读/写权限</li><li>对于其他 app，可以访问但需要申请读/写权限</li></ol></li></ol><p>从存储设备的角度看，可以分为：</p><ol><li>内部存储，除了自己的目录，没有访问权限</li><li>外部存储，可以访问但需申请读/写权限（除了自己的目录）</li></ol><h2 id="启用-Scoped-Storage-后"><a href="#启用-Scoped-Storage-后" class="headerlink" title="启用 Scoped Storage 后"></a>启用 Scoped Storage 后</h2><p>而启用 Scoped Storage（ ≥ 10/Q）后，APP 只能通过下述三种方法访问文件：</p><ol><li>对于 APP 目录（ app-specific directories ），无论是内部存储还是外部存储，无需申请任何读/写权限即可访问（ File API ），APP 卸载时被删除</li><li>通过 MediaStore API 操作媒体文件，读/写 APP 自己的文件时无需任何权限，访问其他 APP 的内容时需要申请 READ_EXTERNAL_STORAGE；开启 Scoped Storage 后，只能访问 <code>MediaStore.Images</code>，<code>MediaStore.Video</code>，<code>MediaStore.Audio</code> 和自己的 <code>MediaStore.Downloads</code></li><li>通过 SAF（ <code>Storage Access Framework</code>，也就是文件选择器 ）读/写其他的文件，参考 <a href="https://developer.android.google.cn/guide/topics/providers/document-provider">Open files using storage access framework</a></li><li>其他方式即使拥有读写权限也会抛出 <code>java.io.IOException: Permission denied</code></li></ol><p>兼容性（ targetSDK ）</p><ol><li>&lt; 29，默认关闭，可以通过 <code>requestLegacyExternalStorage = false</code> 打开</li><li>= 29，默认开启，可以通过 <code>requestLegacyExternalStorage = true</code> 关闭</li><li>&gt; 29，强制开启，<code>requestLegacyExternalStorage</code> 被忽略</li></ol><p>常用的 APP 目录</p><table><thead><tr><th align="left">API</th><th align="left">Storage</th><th align="left">权限</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="left">getDataDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication</td></tr><tr><td align="left">getFilesDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/files</td></tr><tr><td align="left">getCacheDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/cache</td></tr><tr><td align="left">getDir(“apple”, Context.MODE_PRIVATE)</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/app_apple</td></tr><tr><td align="left">getExternalCacheDir()</td><td align="left">external storage</td><td align="left">NO</td><td align="left">/storage/emulated/0/Android/data/com.example.myapplication/cache</td></tr><tr><td align="left">getExternalFilesDir(“apple”)</td><td align="left">external storage</td><td align="left">NO</td><td align="left">/storage/emulated/0/Android/data/com.example.myapplication/files/apple</td></tr><tr><td align="left">Environment.getExternalStoragePublicDirectory()</td><td align="left">external storage</td><td align="left">YES</td><td align="left">/storage/emulated/0/Pictures, /storage/emulated/0/Alarms, …</td></tr></tbody></table><h2 id="学会使用-MediaStore-API"><a href="#学会使用-MediaStore-API" class="headerlink" title="学会使用 MediaStore API"></a>学会使用 MediaStore API</h2><p>当 APP 卸载时，APP 目录也随之被删除；如果需要将一些文件，比如图片，持久地保存下来， 媒体文件如图片、视频和音频 CURD 操作可以参考 <a href="https://developer.android.com/training/data-storage/shared/media">Access media files from shared storage</a></p><p>APP 访问自己创建的媒体文件时，无需额外的权限，因为这些媒体文件的属性「owner app」被设置为此 APP；当 APP 被卸载，这些媒体文件的「owner app」被清空；当 APP 被再次安装并访问这些媒体文件时，需要 <code>READ_EXTERNAL_STORAGE</code>，参考 <a href="https://developer.android.com/training/data-storage/shared/media#app-attribution">App attribution of media files</a></p><p>创建媒体文件时，可以通过 <code>RELATIVE_PATH</code> 指定路径，例如图片可以放在 <code>&quot;$&#123;Environment.DIRECTORY_PICTURES&#125;/tangzhi&quot;</code> 下（/storage/emulated/0/Pictures/tangzhi）</p><ol><li><code>MediaStore.Images</code> 可选择 <code>Environment.DIRECTORY_PICTURES</code> 和 <code>Environment.DIRECTORY_DCIM</code></li><li><code>MediaStore.Video</code> 可选择 <code>Environment.DIRECTORY_MOVIES</code> 和 <code>Environment.DIRECTORY_DCIM</code></li><li><code>MediaStore.Audio</code> 可选择 <code>Environment.DIRECTORY_MUSIC</code>，<code>Environment.DIRECTORY_RINGTONES</code>，<code>Environment.DIRECTORY_PODCASTS</code> …</li><li><code>MediaStore.Downloads</code> 可选择 <code>Environment.DIRECTORY_DOWNLOADS</code></li></ol><p><code>MediaStore</code> 一些重要的列</p><table><thead><tr><th align="left">字段</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">BUCKET_DISPLAY_NAME</td><td align="left">媒体文件的分类，例如：Camera，Screenshot，WeiXin</td></tr><tr><td align="left">BUCKET_ID</td><td align="left">媒体的分类 ID</td></tr><tr><td align="left">DISPLAY_NAME</td><td align="left">媒体文件名，例如：Screenshot_20201102_123620.jpg</td></tr><tr><td align="left">RELATIVE_PATH</td><td align="left">在 external storage 的相对路径，例如：Pictures/WeiXin/，DCIM/Camera/，一般是正确的</td></tr><tr><td align="left">DATA</td><td align="left">一般会将媒体文件的真实路径保存在这一列，但不保证它是正确的</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Scoped Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>starting window 和 windowDisablePreview</title>
    <link href="/2020/11/11/starting-window/"/>
    <url>/2020/11/11/starting-window/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>中午和同事聊天时，提到一个问题：设计把爱范儿 app 的启动页改成暗黑样式，本来很简单的一个改动，测试却发现启动会有闪屏；下午我看了下效果，发现确实有问题：</p><ul><li>把启动页的图片换成暗黑主体的图片后，冷/热启动都会有从白色到黑色的闪动</li><li>同事给的 bug fixed 是 <code>windowDisablePreview = true</code>，这导致 app 热启动时，会有很长的一段延迟</li></ul><h2 id="starting-window-是如何出现的"><a href="#starting-window-是如何出现的" class="headerlink" title="starting window 是如何出现的"></a>starting window 是如何出现的</h2><p>网上搜索下，发现是 starting widow 引起的，我决定看看这个 starting window 是怎么打开和关闭的，以及如何设置它的背景色来匹配启动页的黑色背景</p><p>跟寻<a href="../../../../2020/11/03/launch-activity-sequence/">上一篇文章</a>的脚步，找到 start point：<code>ActivityStarter.startActivityUnchecked</code></p><p><img src="../../../../image/2020-11-11-starting-window/starting_window.jpg" alt="starting_window.jpg"></p><p>从上图可以看到，starting window 其实是系统通过 <code>ViewManager.addView</code> 往屏幕上添加的一个 <code>window</code>；而且它的显示时间比较早，比创建 app 进程（<code>ActivityStackSupervisor.startProcessAsync</code>）和 <code>ActivityThread</code> 执行 <code>Activity</code> 生命周期函数（<code>ActivityThread.performLaunchActivity</code>）都要早，所以它才能起到快速响应用户点击操作的效果；其次它的 view 是很简单的纯色背景，这样渲染也比较快出来，下面是构建 starting window 的代码，我们来看看它的样式是如何设置的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> StartingSurface <span class="hljs-title">addSplashScreen</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ... theme 是 launch activity theme，在这个 theme 里我们可以设置 starting window 样式</span><br>        <span class="hljs-keyword">if</span> (theme != context.getThemeResId() || labelRes != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                context = context.createPackageContext(packageName, CONTEXT_RESTRICTED);<br>                context.setTheme(theme);<br>            &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>                <span class="hljs-comment">// Ignore</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (overrideConfig != <span class="hljs-keyword">null</span> &amp;&amp; !overrideConfig.equals(EMPTY)) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="hljs-string">&quot;addSplashScreen: creating context based&quot;</span><br>                    + <span class="hljs-string">&quot; on overrideConfig&quot;</span> + overrideConfig + <span class="hljs-string">&quot; for splash screen&quot;</span>);<br>            <span class="hljs-keyword">final</span> Context overrideContext = context.createConfigurationContext(overrideConfig);<br>            overrideContext.setTheme(theme);<br>            <span class="hljs-keyword">final</span> TypedArray typedArray = overrideContext.obtainStyledAttributes(com.android.internal.R.styleable.Window);<br><br>            <span class="hljs-comment">// 我们可以通过 windowBackground 设置窗口背景</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resId = typedArray.getResourceId(R.styleable.Window_windowBackground, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (resId != <span class="hljs-number">0</span> &amp;&amp; overrideContext.getDrawable(resId) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// We want to use the windowBackground for the override context if it is</span><br>                <span class="hljs-comment">// available, otherwise we use the default one to make sure a themed starting</span><br>                <span class="hljs-comment">// window is displayed for the app.</span><br>                <span class="hljs-keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="hljs-string">&quot;addSplashScreen: apply overrideConfig&quot;</span><br>                        + overrideConfig + <span class="hljs-string">&quot; to starting window resId=&quot;</span> + resId);<br>                context = overrideContext;<br>            &#125;<br>            typedArray.recycle();<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> PhoneWindow win = <span class="hljs-keyword">new</span> PhoneWindow(context);<br>        <span class="hljs-comment">// ...</span><br>        addSplashscreenContent(win, context);<br>        wm = (WindowManager) context.getSystemService(WINDOW_SERVICE);<br>        view = win.getDecorView();<br>        wm.addView(view, params);<br>        <span class="hljs-comment">// ....</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSplashscreenContent</span><span class="hljs-params">(PhoneWindow win, Context ctx)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> TypedArray a = ctx.obtainStyledAttributes(R.styleable.Window);<br><br>    <span class="hljs-comment">// 看这里，我们可以通过 windowSplashscreenContent 设置 starting window content view 背景</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resId = a.getResourceId(R.styleable.Window_windowSplashscreenContent, <span class="hljs-number">0</span>);<br>    a.recycle();<br>    <span class="hljs-keyword">if</span> (resId == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> Drawable drawable = ctx.getDrawable(resId);<br>    <span class="hljs-keyword">if</span> (drawable == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// We wrap this into a view so the system insets get applied to the drawable.</span><br>    <span class="hljs-keyword">final</span> View v = <span class="hljs-keyword">new</span> View(ctx);<br>    v.setBackground(drawable);<br>    win.setContentView(v);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>从上面的代码可以看出，starting window 有两个样式是比较重要的，而它们都来自于 launch activity theme</p><ol><li><code>windowBackground</code> 设置窗口背景</li><li><code>windowSplashscreenContent</code> 设置 content view 背景（requires API level 26）</li></ol><p>把 launch activity 的窗口背景设置为黑色，即可避免启动时由白到黑的闪屏问题</p><p>更进一步，把窗口背景替换为 launch activity 的 ifanr logo 素材，这样 starting window 和 launch activity 的背景一致，两个窗口无缝切换，视觉上就感受不到 starting window 的存在了，感觉上 app 的启动非常块</p>]]></content>
    
    
    
    <tags>
      
      <tag>windowDisablePreview</tag>
      
      <tag>starting window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity 启动流程时序图</title>
    <link href="/2020/11/03/launch-activity-sequence/"/>
    <url>/2020/11/03/launch-activity-sequence/</url>
    
    <content type="html"><![CDATA[<p>记录下启动 <code>Activity</code> 的时序图，方便后面查找</p><p><img src="../../../../image/2020-11-03-launch-activity-sequence/launch_activity.jpg" alt="launch_activity.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解 Glide</title>
    <link href="/2020/10/31/how-glide-work/"/>
    <url>/2020/10/31/how-glide-work/</url>
    
    <content type="html"><![CDATA[<p>网上讲解 <code>Glide</code> 的文章一搜一大把，但几乎都是以文字的形式来讲解；我自己也写过不少 <code>Glide</code> 的笔记，也是文字为主；但是时间长了经常忘了其中的细节，加上 <code>Glide</code> 的源码不太易懂，所以决定用时序图来分析和记录研究 <code>Glide</code> 的过程</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>下面两张图是一次图片加载的大体流程，有读过源码的同学基本上通过这两种图就能回忆起其中的细节；没读过源码的同学也可以先了解下 <code>Glide</code> 里各个类的作用</p><p><img src="../../../../image/2020-10-31-how-glide-work/glide_1.jpg" alt="glide_1.jpg"></p><p><img src="../../../../image/2020-10-31-how-glide-work/glide_task.jpg" alt="glide_task.jpg"></p><h2 id="RequestManager-请求管理器"><a href="#RequestManager-请求管理器" class="headerlink" title="RequestManager - 请求管理器"></a><code>RequestManager</code> - 请求管理器</h2><p>往 <code>Activity</code>/<code>Fragment</code> 添加一个 <code>RequestManagerFragment</code>（没有 <code>View</code>） 用以监听宿主的生命周期，从而实现请求的管理和绑定</p><p><img src="../../../../image/2020-10-31-how-glide-work/1.jpg" alt="1.jpg"></p><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存有 <code>ActiveResources</code> 和 <code>LruResourceCache</code>（<code>MemoryCache</code>），如下图，它们关系是：</p><ul><li>从 source/data 解码的 resource 将被加入 <code>ActiveResources</code></li><li>当 <code>onStop</code>/<code>onDestory</code>/<code>onTrimMemory</code> 时 resource 被释放，从 <code>ActiveResources</code> 移除并放入 <code>MemoryCache</code></li><li>加载时如果命中缓存，则从 <code>MemoryCache</code> 移除并加入 <code>ActiveResources</code></li></ul><p>它们的不同之处：</p><ul><li>它们对应 resource 的不同生命周期：使用中 - <code>ActiveResources</code>，释放后 - <code>MemoryCache</code></li><li><code>ActiveResources</code> 是对所有使用中 resource 的弱引用，相当于对所有使用中 resource 的收集和统计，没有大小限制</li><li><code>MemoryCache</code> 引用释放的资源，有大小限制，实现是 <code>LruResourceCache</code></li></ul><p><img src="../../../../image/2020-10-31-how-glide-work/glide_memory_cache.jpg" alt="glide_memory_cache.jpg"></p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>磁盘缓存有两层：data cache 和 resource cache，它们的关系在于：</p><ul><li>都是磁盘缓存，都以文件的形式存在于 disk cache dir，只是 key 不同</li><li>从网络抓取 → 保存为 data cache → 解码为 resource → 保存为 resource cache（optional）→ 返回 resource</li><li>下次加载时，先尝试加载 resource cache 再尝试加载 data cache</li></ul><p>它们的区别在于：</p><ul><li>data cache 缓存的是原始数据（也就是从 source 直接抓取到的数据流），resource cache 缓存的是解码后（比如 <code>Bitmap</code>）的数据</li><li>resource cache 能够加速解码的速度；比如 source 是网络上的图片，一般是 jpg or png，则从 data cache 加载需要解码为 Bitmap，而 resource cache 直接缓存 bitmap bytes，省了解码这步</li><li>resource cache 会增大磁盘缓存起码一倍；比如上述的 bitmap bytes 比压缩格式的 jpg 要大</li><li>是否有 resource cache 受几个条件的影响</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">DiskCacheStrategy<br>NONE      - 没有磁盘缓存<br>DATA      - 只缓存 data cache<br>RESOURCE  - 只缓存 resource cache<br>ALL       - 都缓存<br>AUTOMATIC - 自动<br><br><span class="hljs-comment">// 看下 AUTOMATIC 的情况</span><br><span class="hljs-comment">// data cache，只缓存网络资源，不缓存 asset file，local disk file 等本地资源</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDataCacheable</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dataSource == DataSource.REMOTE;<br>&#125;<br><br><span class="hljs-comment">// resource cache 只缓存 asset file，local disk file 等本地资源</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isResourceCacheable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">boolean</span> isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((isFromAlternateCacheKey &amp;&amp; dataSource == DataSource.DATA_DISK_CACHE)<br>            || dataSource == DataSource.LOCAL)<br>            &amp;&amp; encodeStrategy == EncodeStrategy.TRANSFORMED;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../../../image/2020-10-31-how-glide-work/glide_disk_cache.jpg" alt="glide_disk_cache.jpg"></p><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>使用池化技术（<code>ArrayPool</code> 和 <code>BitmapPool</code>）降低内存抖动</p><p><code>Glide</code> 在很多地方都需要临时用到一小块的内存，使用 byte array pool 可以平缓内存使用，避免频繁的内存申请</p><ul><li>io 时需要一个内存缓冲区来读写</li><li>从文件解码图片时 <code>BitmapFactory.Options.inTempStorage</code></li><li><code>downsample</code> 时需要先加载 image exif 信息</li></ul><p><code>BitmapPool</code> 则在 <code>Transformation.transform</code> 做 <code>Bitmap</code> 转换时用得比较多</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li>load memory cache 阶段是 ui 线程</li><li>decode cache 阶段是一个 decode 线程；此阶段会将 data 解码至 memory resource，采用单个线程排队解码，可以防止多个线程同时解码申请大内存造成内存抖动甚至 OOM</li><li>fetch source 阶段是线程池</li></ul><h2 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h2><p>加载路径把 model - dataClass - resourceClass - transcodeClass 串联起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// url string 是 model，类型是 String；transcodeClass 是 Drawable.class，最终的目标类型；此时的 resourceClass 是 Object.class</span><br>GlideApp.with(<span class="hljs-keyword">this</span>).as(Drawable.class).load(url).into(photoView);<br></code></pre></div></td></tr></table></figure><ol><li>通过 <code>ModelLoaderRegistry</code> 知道 model 能使用哪些 <code>ModelLoader</code>，能加载到 jvm 里成为哪些 dataClass；string url 的话，适用于 <code>StringLoader</code>，能加载为 <code>InputStream</code> 和 <code>ParcelFileDescriptor</code>；如果有多个 loader 可以用，则使用 <code>MultiModelLoader</code>，它专门用来包裹多个 loader，因为对于一个 model 可能会有多个 loader 可以处理它；对于 <code>MultiXXX</code>，内部都有个属性 <code>currentIndex</code> 指定使用哪个实例（一般情况下就是第 0 个了，除非有代码设置过 <code>currentIndex</code>）；loader 在注册表中的位置可以通过 append、prepend 调整</li><li>通过 <code>ResourceDecoderRegistry</code> 知道上述 dataClass 列表能够 decode 为哪些 resourceClass；<code>InputStream</code> 能够 decode 为 <code>Bitmap</code>，<code>GifDrawable</code> 和 <code>BitmapDrawable</code>；<code>ParcelFileDescriptor</code> 能够 decode 为 <code>Bitmap</code> 和 <code>BitmapDrawable</code></li><li>如果上述的 resourceClass 等于 transcodeClass 或它的子类，则把 resourceClass 加入到目标类型列表里；否则通过 <code>TranscoderRegistry</code> 判断能否使用注册的 <code>ResourceTranscoder</code> 将 resourceClass 转换为 transcodeClass 或它的子类，可以的话也将其加入目标类型列表里面；比如 <code>Bitmap</code> 可以用 <code>BitmapDrawableTranscoder</code> 转换为 <code>Drawable</code></li><li>最终得到一个目标类型列表，里面的类型等于 transcodeClass 或它的子类；它表明可以从 model 加载得到 <code>Drawable</code>；这个列表有：<code>Bitmap</code>，<code>BitmapDrawable</code>，<code>GifDrawable</code></li><li>按顺序（也即是注册表里的顺序），使用对应的 decoder 把 <code>InputStream</code> 解码；这里说下，因为 url 所在的是一张图片，所以 <code>StreamGifDecoder.handles</code> 发现不是 gif 会返回 false，于是不能转为 <code>GifDrawable</code>，跳到下一个；假设下一个是 <code>Bitmap</code>，可以正常 decode 为 <code>Drawable</code>，于是就略过了 <code>BitmapDrawable</code> 这个目标类型</li></ol><p><code>Glide</code> 有三层主要的 component：<code>ModelLoader</code>，<code>ResourceDecoder</code> 和 <code>ResourceTranscoder</code>；每层都注册了大量的实现，所以对于某个加载请求，会有多个路径；而到底使用哪条加载路径，取决于 component 在 <code>Register</code> 里的位置，靠前的 component 会被优先选择，如果这条路径走得通，那么后续的路径就被忽略了</p><ol><li>string url -&gt; <code>InputStream</code> -&gt; <code>Bitmap</code> -&gt; <code>Drawable</code>（用了 transcode，<code>Bitmap</code> 可以转换成 <code>BitmapDrawable</code>）</li><li>string url -&gt; <code>InputStream</code> -&gt; <code>BitmapDrawable</code></li><li>string url -&gt; <code>ByteBuffer</code> -&gt; <code>Bitmap</code> -&gt; <code>Drawable</code></li><li>…</li></ol><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li>同一个 <code>ImageView</code>，加载多个图片，为什么不会错乱呢？</li></ol><p>将 <code>Request</code> 放入 <code>View.setTag</code>，旧的 <code>Resquest</code> 将被新的 <code>Request</code> 取消，防止同一个 <code>ImageView</code> 的多个请求错乱</p>]]></content>
    
    
    
    <tags>
      
      <tag>Glide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读源码系列：ANR 是怎么产生的</title>
    <link href="/2020/10/20/anr/"/>
    <url>/2020/10/20/anr/</url>
    
    <content type="html"><![CDATA[<p>根据日常的经验我们大概知道，如果 app 没有及时消费 <code>MotionEvent</code>，超过 5s 就会弹出 ANR 对话框；那么 ANR 的逻辑肯定是在事件分发过程中产生的，我们从事件的源头找起，看看 input 事件是怎么产生的</p><h2 id="input-的分发"><a href="#input-的分发" class="headerlink" title="input 的分发"></a>input 的分发</h2><p><img src="../../../../image/2020-10-20-anr/sequence.png" alt="sequence.png"></p><p>事件分发是从线程 <code>InputReaderThread</code> 开始的，它的主要工作是：</p><ol><li>从目录 <code>/dev/input</code> 获取 input event<ul><li>看来 android 的输入设备是挂载在 <code>/dev/input</code> 下的，当然会有多个输入设备：屏幕触摸、键盘、手柄等，使用 <code>epoll</code> 监听多个 <code>fd</code></li><li><code>EventHub.getEvents()</code> 从 <code>fd</code> 读取 <code>input_event</code> 并转换为 <code>RawEvent</code>（看来输入设备的驱动都需要构造 <code>input_event</code> 给系统）</li></ul></li><li>经过识别分类（按键、手势、手柄、滚轮等）、过滤等一系列操作后，添加到 <code>mInboundQueue</code>（等待 <code>InputDispatcher</code> 分发）<ul><li><code>InputDevice</code> 将 <code>RawEvent</code> 交由各种 <code>InputMapper</code> 处理，例如：<code>KeyboardInputMapper</code> 将 <code>RawEvent</code> 包装为 <code>NotifyKeyArgs</code>，<code>TouchInputMapper</code> 将 <code>RawEvent</code> 包装为 <code>NotifyMotionArgs</code></li><li><code>InputDispatcher.notifyXXX</code> 将各种 <code>NotifyXXXArgs</code> 包装为 <code>XXXEntry</code> 放入 <code>mInboundQueue</code></li></ul></li></ol><p>这里需要补充下 Native Looper 不同于 Java Looper 的地方：提供了监听文件描述符的机制</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param fd       需要监听的文件描述符</span><br><span class="hljs-comment"> * @param ident    表示为当前发生事件的标识符，必须 &gt;= 0，或者为 POLL_CALLBACK(-2) 如果指定了 callback</span><br><span class="hljs-comment"> * @param events   表示为要监听的文件类型，默认是 EVENT_INPUT</span><br><span class="hljs-comment"> * @param callback 当有事件发生时，会回调该 callback 函数</span><br><span class="hljs-comment"> * @param data</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 主要做了两件事：</span><br><span class="hljs-comment"> * 1，把输入参数构造成 Request，添加到 mRequests</span><br><span class="hljs-comment"> * 2，将 fd 添加到 epoll</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> ident, <span class="hljs-keyword">int</span> events, Looper_callbackFunc callback, <span class="hljs-keyword">void</span>* data)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> ident, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-keyword">void</span>* data)</span></span>;<br></code></pre></div></td></tr></table></figure><p>它有两种使用方式：</p><ul><li>指定 callback 来处理事件 : 当该文件描述符上有事件到来时，该 callback 会被执行；调用 <code>Looper.wake()</code> 也会触发 callback 执行</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// pollAll() -&gt; pollOnce() -&gt; pollInner()</span><br><br><span class="hljs-keyword">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis)<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; eventCount; i++) &#123;<br>    <span class="hljs-keyword">int</span> fd = eventItems[i].data.fd;<br>    <span class="hljs-keyword">uint32_t</span> epollEvents = eventItems[i].events;<br>    <span class="hljs-keyword">if</span> (fd == mWakeEventFd.<span class="hljs-built_in">get</span>()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">ssize_t</span> requestIndex = mRequests.<span class="hljs-built_in">indexOfKey</span>(fd);<br>        <span class="hljs-keyword">if</span> (requestIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-built_in">pushResponse</span>(events, mRequests.<span class="hljs-built_in">valueAt</span>(requestIndex));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mResponses.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    Response&amp; response = mResponses.<span class="hljs-built_in">editItemAt</span>(i);<br>    <span class="hljs-keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;<br>        <span class="hljs-keyword">int</span> fd = response.request.fd;<br>        <span class="hljs-keyword">int</span> events = response.events;<br>        <span class="hljs-keyword">void</span>* data = response.request.data;<br>        <span class="hljs-keyword">int</span> callbackResult = response.request.callback-&gt;<span class="hljs-built_in">handleEvent</span>(fd, events, data);<br>        <span class="hljs-keyword">if</span> (callbackResult == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">removeFd</span>(fd, response.request.seq);<br>        &#125;<br>        <span class="hljs-comment">// Clear the callback reference in the response structure promptly because we</span><br>        <span class="hljs-comment">// will not clear the response vector itself until the next poll.</span><br>        response.request.callback.<span class="hljs-built_in">clear</span>();<br>        result = POLL_CALLBACK;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>通过指定的 ident 来处理事件：当该文件描述符有数据到来时，<code>pollOnce()</code> 会返回一个 ident，调用者会判断该 ident 是否等于自己需要处理的事件 ident，如果是的话，则开始处理事件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// pollAll() -&gt; pollOnce()</span><br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">while</span> (mResponseIndex &lt; mResponses.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">const</span> Response&amp; response = mResponses.<span class="hljs-built_in">itemAt</span>(mResponseIndex++);<br>        <span class="hljs-keyword">int</span> ident = response.request.ident;<br>        <span class="hljs-keyword">if</span> (ident &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> fd = response.request.fd;<br>            <span class="hljs-keyword">int</span> events = response.events;<br>            <span class="hljs-keyword">void</span>* data = response.request.data;<br>            <span class="hljs-keyword">if</span> (outFd != <span class="hljs-literal">nullptr</span>) *outFd = fd;<br>            <span class="hljs-keyword">if</span> (outEvents != <span class="hljs-literal">nullptr</span>) *outEvents = events;<br>            <span class="hljs-keyword">if</span> (outData != <span class="hljs-literal">nullptr</span>) *outData = data;<br>            <span class="hljs-keyword">return</span> ident;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="ui-如何接收和处理-input"><a href="#ui-如何接收和处理-input" class="headerlink" title="ui 如何接收和处理 input"></a>ui 如何接收和处理 input</h2><p>在分析事件分发的逻辑之前，我们先看看 ui 线程是怎么接收 input 事件的</p><p><img src="../../../../image/2020-10-20-anr/input_channel.png" alt="input_channel.png"></p><p>可以看到在 native 层打开了一对 socket，server socket fd 给 <code>InputDispatcher</code> 线程，client socket fd 给 ui 线程（<code>ViewRootImpl.mInputChannel</code>），也就是说它们之间通过 socket 双向通讯</p><p><img src="../../../../image/2020-10-20-anr/ui_thread.png" alt="ui_thread.png"></p><ol><li>接收：在 native 层用 Native Looper 监听 client socket fd（epoll），封装成 <code>InputMessage</code> 传递给 java 层处理</li><li>经过一个 <code>InputStage</code> 责任链的处理，最终到达我们最熟悉的 <code>View.dispatchTouchEvent</code></li><li>响应：ui 线程在消费完 input event 后，通过双向的 socket 告知 dispatcher 线程；如果此时 client socket 不可写，则将响应保存起来，等待下次 client socket 可写时</li><li>dispatcher - ui 这一段分发过程实际上是异步的，那么整个事件分发的过程也就是异步的，这是 ANR 产生的前提</li></ol><h2 id="input-的生命周期"><a href="#input-的生命周期" class="headerlink" title="input 的生命周期"></a>input 的生命周期</h2><p><img src="../../../../image/2020-10-20-anr/input_dispatcher.png" alt="input_dispatcher.png"></p><p>一个 input event 的生命流程大概是这样的：</p><ul><li><code>InputReader</code> 放入 <code>InputDispatcher.mInboundQueue</code> 等待分发</li><li><code>InputDispatcher</code> 将其移入 window 对应的 <code>Connection→outboundQueue</code> 等待发送</li><li>发送成功后，移入 <code>Connection→waitQueue</code> 等待 ui 线程的确认应答</li><li>收到确认应答，将 input event 移出 <code>Connection→waitQueue</code></li></ul><p>产生 ANR 的逻辑就在 <code>dispatchKeyLocked</code>（分发一个 input event 的过程）</p><p><img src="../../../../image/2020-10-20-anr/anr.jpg" alt="anr.jpg"></p><p>1，<code>findFocusedWindowTargetsLocked</code> 找到 input event 的分发 window 对象，然后 <code>checkWindowReadyForMoreInputLocked</code> 检查 widnow 是否可以接收 input event，这里截取一段检查逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// outboundQueue 不为空说明此 window 仍有 input event 未发送，waitQueue 不为空说明有 input event 在消费中（未收到消费完成的响应）</span><br><span class="hljs-comment">// 也就是说 input event 必须是按顺序分发和消费的，不能乱序</span><br><span class="hljs-keyword">if</span> (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;<br>    <span class="hljs-keyword">if</span> (!connection-&gt;outboundQueue.<span class="hljs-built_in">isEmpty</span>() || !connection-&gt;waitQueue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Waiting to send key event because the %s window has not &quot;</span><br>                            <span class="hljs-string">&quot;finished processing all of the input events that were previously &quot;</span><br>                            <span class="hljs-string">&quot;delivered to it.  Outbound queue length: %d.  Wait queue length: &quot;</span><br>                            <span class="hljs-string">&quot;%d.&quot;</span>,<br>                            targetType, connection-&gt;outboundQueue.<span class="hljs-built_in">count</span>(),<br>                            connection-&gt;waitQueue.<span class="hljs-built_in">count</span>());<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!connection-&gt;waitQueue.<span class="hljs-built_in">isEmpty</span>() &amp;&amp;<br>        currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime + STREAM_AHEAD_EVENT_TIMEOUT) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Waiting to send non-key event because the %s window has not &quot;</span><br>                            <span class="hljs-string">&quot;finished processing certain input events that were delivered to &quot;</span><br>                            <span class="hljs-string">&quot;it over &quot;</span><br>                            <span class="hljs-string">&quot;%0.1fms ago.  Wait queue length: %d.  Wait queue head age: &quot;</span><br>                            <span class="hljs-string">&quot;%0.1fms.&quot;</span>,<br>                            targetType, STREAM_AHEAD_EVENT_TIMEOUT * <span class="hljs-number">0.000001f</span>,<br>                            connection-&gt;waitQueue.<span class="hljs-built_in">count</span>(),<br>                            (currentTime - connection-&gt;waitQueue.head-&gt;deliveryTime) *<br>                                    <span class="hljs-number">0.000001f</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2，最后走到 <code>AppErrors.handleShowAnrUi</code> 里就是弹出 ANR dialog 的地方</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>三个线程，<code>InputReader</code> 负责监听 input fd，<code>InputDispatcher</code> 负责分发给 ui，ui 消费并反馈给 <code>InputDispatcher</code></li><li><code>InputReader</code> 和 <code>InputDispatcher</code> 在同一进程，<code>mInboundQueue</code> 加锁使用即可；<code>InputDispatcher</code> 和 ui 在不同的进程，通过 socket 通讯</li><li>事件分发是一个异步的过程，所以它会在 <code>mInboundQueue</code>（待分发）、<code>outboundQueue</code>（待发送） 和 <code>waitQueue</code>（待响应） 之间流转</li><li>input event 必须按顺序分发和消费，一个 input event 在分发前必须等待上一个 input event 的响应，如果等待时间超过 5s 则发生 ANR</li><li>ANR dialog 是在 AMS 进程弹出的</li></ol><p>还学到了什么</p><p><code>epoll</code>（或者说 IO 多路复用）ui 线程是通过 socket 与 <code>InputDispatcher</code> 线程交互的，它既要等待 input event（不能阻塞）又要处理 ui 相关工作，靠的就是 epoll；具体来说是 native Looper，因为 epoll 可以同时监听多个 fd；用一个 wakeUpFd + messageQueue，当 enqueueMessage 时往 wakeUpFd 写入，从而唤醒线程处理 message；添加 socket fd，当 socket 可读时，唤醒线程处理 socket 过来的消息，而且还可以同时处理 message 和 socket</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://gityuan.com/2017/01/01/input-anr/">Input系统-ANR原理分析</a></li><li><a href="http://gityuan.com/2019/04/06/android-anr/">彻底理解安卓应用无响应机制</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂事件分发，手势冲突和滑动冲突</title>
    <link href="/2020/10/04/dispatchtouchevent/"/>
    <url>/2020/10/04/dispatchtouchevent/</url>
    
    <content type="html"><![CDATA[<p>手势冲突是 android 开发中经常遇到的一类问题了，网上讲解此问题的文章也很多，但是大都浅显地过一遍事件分发的调用栈，然后给出一个调用栈流程图；要不就是使用日志大法，用日志来验证自己的想法，完全没有参考价值；这里根据事件分发相关源码，记录下我的理解。</p><p><code>MotionEvent</code> 里定义的 <code>ACTION_XXX</code> 还不少有 10 多个，看起来情况很复杂的样子，实际上只需要关注三个：<code>ACTION_DOWN</code>，<code>ACTION_MOVE</code> 和 <code>ACTION_UP</code>，而且在一个手势里它们的顺序是：<code>ACTION_DOWN</code> → <code>ACTION_MOVE</code> → <code>ACTION_MOVE</code> → … → <code>ACTION_UP</code>。</p><h2 id="跟踪源码的调用栈"><a href="#跟踪源码的调用栈" class="headerlink" title="跟踪源码的调用栈"></a>跟踪源码的调用栈</h2><ul><li><code>Window.Callback.dispatchTouchEvent</code>（<code>Activity.dispatchTouchEvent</code> 实现了它，在 <code>Activity.attach</code> 里通过 <code>Window.setCallback</code> 设置进去）</li><li><code>Window.superDispatchTouchEvent</code>（实现在 <code>PhoneWindow.superDispatchTouchEvent</code>）</li><li><code>DecorView.superDispatchTouchEvent</code></li><li><code>ViewGroup.dispatchTouchEvent</code></li><li><code>ViewGroup.onInterceptTouchEvent</code></li><li><code>View.dispatchTouchEvent</code></li><li><code>View.onTouchEvent</code></li><li><code>ViewGroup.onTouchEvent</code></li><li><code>Activity.onTouchEvent</code></li></ul><p>网上大部分文章到此就结束了，实际上重点应该在 <code>ViewGroup.dispatchTouchEvent</code>，里面是事件分发的核心逻辑，我把它切分为三个阶段：</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DOWN 会被拦截，后续的 MOVE 和 UP 如果有 touch target 也会被拦截</span><br><span class="hljs-comment">// Check for interception.</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// 可以通过 requestDisallowInterceptTouchEvent 跳过此阶段，</span><br>    <span class="hljs-comment">// 一般是 child 调用 parent.requestDisallowInterceptTouchEvent 来阻止 parent 拦截 touch event</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>        intercepted = onInterceptTouchEvent(ev);<br>        ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 后续的 MOVE 和 UP 没有 touch target 则直接走向 onTouchEvent 也就不需要拦截了</span><br>    <span class="hljs-comment">// There are no touch targets and this action is not an initial down</span><br>    <span class="hljs-comment">// so this view group continues to intercept touches.</span><br>    intercepted = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 收到 CANCEL 或者 onInterceptTouchEvent 返回 true，则不分发 DOWN 给 children</span><br><span class="hljs-comment">// 导致 children 收不到 DOWN 以及没有 touch target</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="hljs-keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)<br>        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;<br>        <span class="hljs-comment">// ... 按顺序分发 ACTION_DOWN，child index(in children array) 越大优先级越高，child z value 越大优先级越高</span><br>        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br>            <span class="hljs-comment">// ... touch 是否落在 child 的矩形区域内</span><br>            <span class="hljs-keyword">if</span> (!child.canReceivePointerEvents()<br>                || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>)) &#123;<br>                ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// ... 将 touch event 坐标转换为 child 区域坐标，分发给 child；当有第一个 child 消费时，记录起来并中断剩下的分发过程</span><br>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) &#123;<br>                <span class="hljs-comment">// ...</span><br>                newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>                alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果没有 touch target，则走自己的 View.dispatchTouchEvent 流程（相当于流向 onTouchEvent）</span><br><span class="hljs-comment">// Dispatch to touch targets.</span><br><span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// No touch targets so treat this as an ordinary view.</span><br>    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>, TouchTarget.ALL_POINTER_IDS);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 分发给 touch target</span><br>    <span class="hljs-comment">// 但如果 onInterceptTouchEvent 返回 true，则发送 CANCEL 给 touch target，后续将不再流向 touch target，而是直接流向 onTouchEvent</span><br>    <span class="hljs-comment">// onInterceptTouchEvent 拦截的那个 touch 不会流向 onTouchEvent</span><br>    TouchTarget predecessor = <span class="hljs-keyword">null</span>;<br>    TouchTarget target = mFirstTouchTarget;<br>    <span class="hljs-keyword">while</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> TouchTarget next = target.next;<br>        <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<br>            handled = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)<br>                    || intercepted;<br>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,<br>                    target.child, target.pointerIdBits)) &#123;<br>                handled = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cancelChild) &#123;<br>                <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-keyword">null</span>) &#123;<br>                    mFirstTouchTarget = next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    predecessor.next = next;<br>                &#125;<br>                target.recycle();<br>                target = next;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        predecessor = target;<br>        target = next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结-dispatchTouchEvent"><a href="#总结-dispatchTouchEvent" class="headerlink" title="总结 dispatchTouchEvent"></a>总结 <code>dispatchTouchEvent</code></h2><ul><li><code>onInterceptTouchEvent</code> 总是会收到 DOWN，但不一定会收到后续的 MOVE 和 UP（没有 touch target 的话，就不需要拦截了，直接走到 <code>onTouchEvent</code> 去了）</li><li>只有在第一个 DOWN 时，才会分发给所有的 children，找到第一个消费的 child（就是 touch target，后续的 MOVE 和 UP 只分发给它）</li><li><code>onInterceptTouchEvent</code> 返回 true 会导致 touch target 置空（并收到 CANCEL），这样后续的 MOVE 和 UP 因为没有 touch target 而直接走向 <code>onTouchEvent</code></li><li>child 通过 <code>requestDisallowInterceptTouchEvent</code> 告知 parent 不要拦截事件流，交由 child 处理</li></ul><h2 id="常见滑动效果的实现"><a href="#常见滑动效果的实现" class="headerlink" title="常见滑动效果的实现"></a>常见滑动效果的实现</h2><p>了解 <code>dispatchTouchEvent</code> 后，我们看看常用的具有滑动效果的 widget 是怎么处理 touch event 的，参考 <code>ViewPager</code> 和 <code>RecyclerView</code>，代码比较多，这里就不贴了，总结下其套路：</p><ul><li>在 <code>onInterceptTouchEvent</code> 和 <code>onTouchEvent</code> 这两个方法里介入</li><li><code>onInterceptTouchEvent</code> 只监听不拦截 DOWN；拦截 DOWN 会导致 children 接收不到 DOWN，那么它们的 OnClick 和 OnLongClick 就无法触发；更复杂的情况是 children 里也包含具有滑动效果的 widget</li><li><code>onTouchEvent</code> 返回 true 做一个兜底方案；万一没有 child 消费 touch（一般情况是没有 <code>OnClickListener</code>），而自己也不消费 touch 的话，就会没有 touch target，后续的 touch event 会直接流向 parent.<code>onTouchEvent</code>，我们想拦截也拦截不了</li><li>在 <code>onInterceptTouchEvent</code> 里监听和拦截（满足情况下）MOVE，<code>onTouchEvent</code> 里也要消费 MOVE（没有 child 消费 touch 的话，后续的 touch 就直接流向 <code>onTouchEvent</code> 了）</li><li><code>ACTION_MOVE</code> 不会直接触发滑动，而是与 <code>ACTION_DOWN</code> 的点有了一定长度的距离后才触发，这个距离叫 touch slop（<code>ViewConfiguration#getScaledTouchSlop</code>），用以消除抖动，使滑动效果更加顺滑</li></ul><p>记住上面的关键点，基本上就可以解决大部分手势冲突，并能够开发稳健的具有手势的 <code>ViewGroup</code> 了；但实际开发中，有一个问题是更加常见的：滑动冲突。在引入嵌套滑动之前，说说为什么 <code>dispatchTouchEvent</code> 很难解决滑动冲突。滑动一般是由 MOVE &gt; touch slop 触发，这样 parent 总是会优先触发而 child 总是会被屏蔽，而且只能由 child 发起 <code>requestDisallowInterceptTouchEvent</code> 告知 parent 不要拦截，从 parent 的视角看，没有其他办法主动得知 child 的需求，而大多数滑动冲突是需要在 parent 里解决的（脑补淘宝、京东这类 app 的首页）。</p><h2 id="引入-NestedScrollingChild-和-NestedScrollingParent-解决滑动冲突"><a href="#引入-NestedScrollingChild-和-NestedScrollingParent-解决滑动冲突" class="headerlink" title="引入 NestedScrollingChild 和 NestedScrollingParent 解决滑动冲突"></a>引入 <code>NestedScrollingChild</code> 和 <code>NestedScrollingParent</code> 解决滑动冲突</h2><p>上面我们在分析 <code>ViewPager</code> 和 <code>RecyclerView</code> 的与滚动相关的代码时了解到，<code>ACTION_MOVE</code> 会产生 scroll 和 fling 的动量 dy（垂直方向），全部由自己消费掉（View.scrollBy）就会产生滑动的效果；而嵌套滑动引入了协商机制，对于动量 dy：</p><ol><li>先给 parent 消费，parent 可以根据自身情况，选择不消费、消费一部分或者消费全部，此时 dy = dy - consumed</li><li>child 根据滋生情况，消费剩下的 dy（全部 or 部分），此时 dy = dy - consumed</li><li>如果还有 dy 剩余（dy &gt; 0），则把剩余的 dy 的处置权交由 parent</li></ol><p>对于上述流程，android 提供了实现：NestedScrollingChildHelper，我们在实现 NestedScrollingChild 时，只需把方法代理至 helper 即可实现通用的 child 逻辑</p><p>具体 api 调用流如下图：</p><p><img src="../../../../image/2020-10-04-dispatchtouchevent/01.jpg" alt="01.jpg"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><p><img src="../../../../image/2020-10-04-dispatchtouchevent/02.jpeg" alt="02.jpeg"></p><p>这里以常见的三段式布局为例子看下嵌套滑动怎么用；上图是淘宝首页，由 head、bar 和 list 三个部分组成，bar 在滑动时会粘连在顶部</p><ol><li>当 touch 落在 list 上时，由 list 产生动量 dy，在 list 消费 dy 前，先给 parent 消费，parent 完全消费 dy，scroll 三个 child 直到 head 不可见</li><li>list 因为 dy 被 parent 消费掉而不产生滑动，直到 head 不可见才有剩下的 dy 用以消费，产生滑动</li><li>当 touch 落在 head 和 bar 上时，由 parent 产生动量 dy；此时 parent 才是 child，而 list 是 parent（明确谁是 child，谁是 parent，view tree 结构上的父子关系不一定是嵌套滑动里的父子关系，动量产生者才是 child，child 主动分发动量）</li><li>parent 先消费 dy 直到 head 不可见，然后分发给 list</li><li>fling 同理</li></ol><h3 id="更复杂的布局"><a href="#更复杂的布局" class="headerlink" title="更复杂的布局"></a>更复杂的布局</h3><p><img src="../../../../image/2020-10-04-dispatchtouchevent/03.jpg" alt="03.jpg"></p><p>结合上述的所有办法，解决更加复杂的页面；上图是糖纸的首页，最外层是 <code>ViewPager</code>，然后是 refresh layout 加上三段式的布局，head 里又有可以左右滑动的 banner 和卡片列表，还有可以上下滑动的滚动资讯条，我们一个个解决：</p><ul><li>banner 是可以左右滑动的，会与 <code>ViewPager</code> 冲突；我的期望是当 touch 落在 banner 上时，左右滑动完全交由 banner 处理，所以给 <code>ViewPager</code> 添加一个 freeze 方法（当 ViewPager is freeze 时不拦截 touch，此时不能使用 <code>requestDisallowInterceptTouchEvent</code> 否则上下滑动被屏蔽）；而上下滑动距离又会引起 refresh 和三段布局的滑动，需在 banner 触发左右滑动时，调用 <code>requestDisallowInterceptTouchEvent</code> 让 parents 不在拦截 touch</li><li>上下滚动的咨询条，同 banner 的处理方式，只不过它只需解决 refresh 和三段布局的上下滑动冲突即可：它自己完全消费动量 dy</li><li>左右滑动的卡片列表同 banner</li><li><code>SwipeRefreshLayout</code> 看下述源码可以看到是由 touch event 和 nested scroll 两种方式触发，touch event 不够灵活屏蔽掉，选用 nested scroll；<code>dispatchNestedPreScroll</code>、<code>dispatchNestedScroll</code>、<code>dispatchNestedPreFling</code> 和 <code>dispatchNestedFling</code> 正常触发，<code>startNestedScroll</code> 则在 scrollY == 0 时触发，这样就只在滚动到顶的时候才触发 refresh。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 显示 loading</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startDragging</span><span class="hljs-params">(<span class="hljs-keyword">float</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> yDiff = y - mInitialDownY;<br>    <span class="hljs-keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123;<br>        mInitialMotionY = mInitialDownY + mTouchSlop;<br>        mIsBeingDragged = <span class="hljs-keyword">true</span>;<br>        mProgress.setAlpha(STARTING_PROGRESS_ALPHA);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由 touch event 触发 loading</span><br><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>    pointerIndex = ev.findPointerIndex(mActivePointerId);<br>    <span class="hljs-keyword">if</span> (pointerIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        Log.e(LOG_TAG, <span class="hljs-string">&quot;Got ACTION_MOVE event but have an invalid active pointer id.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> y = ev.getY(pointerIndex);<br>    startDragging(y);<br><br>    <span class="hljs-keyword">if</span> (mIsBeingDragged) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;<br>        <span class="hljs-keyword">if</span> (overscrollTop &gt; <span class="hljs-number">0</span>) &#123;<br>            moveSpinner(overscrollTop);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 由 nested scroll 触发 loading</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View target, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dyConsumed,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dyUnconsumed)</span> </span>&#123;<br>    <span class="hljs-comment">// Dispatch up to the nested parent first</span><br>    dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,<br>            mParentOffsetInWindow);<br><br>    <span class="hljs-comment">// This is a bit of a hack. Nested scrolling works from the bottom up, and as we are</span><br>    <span class="hljs-comment">// sometimes between two nested scrolling views, we need a way to be able to know when any</span><br>    <span class="hljs-comment">// nested scrolling parent has stopped handling events. We do that by using the</span><br>    <span class="hljs-comment">// &#x27;offset in window &#x27;functionality to see if we have been moved from the event.</span><br>    <span class="hljs-comment">// This is a decent indication of whether we should take over the event stream or not.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dy = dyUnconsumed + mParentOffsetInWindow[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span> &amp;&amp; !canChildScrollUp()) &#123;<br>        mTotalUnconsumed += Math.abs(dy);<br>        moveSpinner(mTotalUnconsumed);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TouchEvent</tag>
      
      <tag>Motion</tag>
      
      <tag>NestedScrolling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官家常之Handler、MessageQueue 和 Looper</title>
    <link href="/2020/09/27/handler-messagequeue-looper/"/>
    <url>/2020/09/27/handler-messagequeue-looper/</url>
    
    <content type="html"><![CDATA[<p><code>MessageQueue</code> 是个单向链表，按 <code>Message.when</code> 自然序排</p><p>它有类似于「生产者 - 消费者」模型的阻塞队列：没有 <code>Message</code> 时，阻塞直到新 <code>Message</code> 入队；否则阻塞到下一个 <code>Message.when</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这里会阻塞</span><br>nativePollOnce(ptr, nextPollTimeoutMillis);<br><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>            <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>            <span class="hljs-comment">// 阻塞一段时间，直到时间到达下一个 message.when</span><br>            nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Got a message.</span><br>            mBlocked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                prevMsg.next = msg.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mMessages = msg.next;<br>            &#125;<br>            msg.next = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>            msg.markInUse();<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No more messages.</span><br>        <span class="hljs-comment">// 没有 Message，阻塞直到 enqueueMessage 时被唤醒</span><br>        nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// ... ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 查看 c 层源码，可以看到 nativePollOnce 是通过 epoll 实现的</span><br><br><span class="hljs-comment">// 阻塞</span><br>MessageQueue.nativePollOnce -&gt;<br>android_os_MessageQueue_nativePollOnce -&gt;<br>NativeMessageQueue::pollOnce -&gt;<br>Looper::pollOnce -&gt;<br>Looper::pollInner -&gt;<br><span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<br><br><span class="hljs-comment">// 唤醒</span><br>MessageQueue.enqueueMessage -&gt;<br>MessageQueue.nativeWake -&gt;<br>android_os_MessageQueue_nativeWake -&gt;<br>NativeMessageQueue::wake -&gt;<br>Looper::wake -&gt;<br><span class="hljs-built_in">write</span>(mWakeEventFd.<span class="hljs-built_in">get</span>(), &amp;inc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uint64_t</span>));<br></code></pre></div></td></tr></table></figure><p>与 <code>NativeMessageQueue</code>、<code>NativeLooper</code> 的关系</p><ol><li>每个 <code>MessageQueue</code> 持有一个 <code>NativeMessageQueue</code>，而 <code>NativeMessageQueue</code> 又持有当前线程的 <code>NativeLooper</code></li><li>关键的阻塞和唤醒函数都是由 <code>NativeLooper</code> 实现的，也就是 <code>epoll</code> 实现的阻塞和唤醒；只不过这个线程在 <code>native</code> 层进行 loop poll 操作<ul><li><code>MessageQueue.nativePollOnce</code> → <code>NativeMessageQueue.pollOnce</code> → <code>NativeLooper.pollOnce</code></li><li><code>MessageQueue.nativeWake</code> → <code>NativeMessageQueue.wake</code> → <code>NativeLooper.wake</code></li></ul></li></ol><p>同步栅栏（<code>SyncBarrier</code>）</p><p>开启同步栅栏后，“栅栏”将会把 sync message 过滤掉，仅处理 async message，是一种提高 <code>Message</code> 优先级的方法</p><p><code>postSyncBarrier</code> 开启同步栅栏，<code>removeSyncBarrier</code> 关闭同步栅栏，“栅栏”就是一个 target == null 的 <code>Message</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Message msg = mMessages;    <span class="hljs-comment">// head of linked list</span><br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// it is a barrier</span><br>    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        prevMsg = msg;<br>        msg = msg.next;<br>    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主线程 <code>Looper</code> 与子线程 <code>Looper</code> 有什么不同？</p><p>主要区别在于 main looper <code>queue.mQuitAllowed == false</code>，即不允许 <code>looper.quit</code> 退出</p><p><code>Looper.quit()</code> 和 <code>Looper.quitSafely()</code> 有什么区别？</p><p><code>quit</code> 直接回收所有 message；而 <code>quitSafely</code> 则只回收 future message（还未到执行时间），继续执行完所有已到时间的 message 才结束</p><p>既然可以存在多个 <code>Handler</code> 往 <code>MessageQueue</code> 中添加数据（发消息时各个 <code>Handler</code> 可能处于不同线程），那它内部是如何确保线程安全的？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 加了锁</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// ... ...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Looper.loop()</code> 为什么不会导致死循环？</p><p>queue 是个阻塞队列，（当前时间点）没有 message 时，会阻塞 thread 而不消耗 cpu；当有新 message 入队时，会唤醒 thread；参考上面阻塞和唤醒的代码片段</p><p><code>Handler </code>造成泄露的原因</p><p>非静态内部类会持有一个外部类的隐式引用，比如下述写法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Handler handler = <span class="hljs-keyword">new</span> Handler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;&#125;<br>&#125;;<br><br>handler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>那么我们可以追溯出一条完整的 gc root path：</p><p>activity → handler/runnable → message(target/callback) → queue → looper → class looper(static field sThreadLocal) → thread</p><p>解决办法：使用 <code>WeakReference</code></p><p>tip:</p><p>可以在 <a href="https://cs.android.com/android">https://cs.android.com/android</a> 用类名、方法名等 symbol 搜索 aosp 代码，简单方便；各种 symbol 之间还有关联，可以点击跳转</p>]]></content>
    
    
    
    <tags>
      
      <tag>Handler</tag>
      
      <tag>Looper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git log命令全解析，打log还能这么随心所欲！</title>
    <link href="/2020/09/15/git-log/"/>
    <url>/2020/09/15/git-log/</url>
    
    <content type="html"><![CDATA[<p><code>git log</code> 命令非常强大而好用，在复杂系统的版本管理中扮演着重要的角色，但默认的 <code>git log</code> 命令显示出的东西实在太丑，不好好打扮一下根本没法见人，打扮好了用 <code>alias</code> 命令拍个照片，就正式出道了！</p><p>下面先详细而系统地介绍 <code>git log</code> 的所有配置知识（用我一向简洁清晰的表述方式），熟悉了这些东西，你就可以自由配置自己美丽的 <code>git log</code> 了～<br>最后上个干货，直接给一个我打扮好的 <code>alias</code> 配置，懒人直接跳到最后吧 ！</p><p><code>git log</code> 用于查询版本的历史，命令形式如下：<code>git log [&lt;options&gt;] [&lt;since&gt;..&lt;until&gt;] [[--] &lt;path&gt;...]</code></p><h2 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h2><ul><li>如果不带任何参数，它会列出所有历史记录，最近的排在最上方，显示提交对象的哈希值，作者、提交日期、和提交说明</li><li>如果记录过多，则按Page Up、Page Down、↓、↑来控制显示</li><li>按q退出历史记录列表</li></ul><h2 id="显示参数"><a href="#显示参数" class="headerlink" title="显示参数"></a>显示参数</h2><ul><li><code>p</code>：按补丁显示每个更新间的差异，比下一条 <code>-stat</code> 命令信息更全</li><li><code>-stat</code>：显示每次更新的修改文件的统计信息，每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计</li><li><code>-shortstat</code>：只显示 <code>-stat</code> 中最后的行数添加修改删除统计</li><li><code>-name-only</code>：尽在已修改的提交信息后显示文件清单</li><li><code>-name-status</code>：显示新增、修改和删除的文件清单</li><li><code>-abbrev-commit</code>：仅显示SHA-1的前几个字符，而非所有的40个字符</li><li><code>-relative-date</code>：使用较短的相对时间显示（例如：”two weeks ago”）</li><li><code>-graph</code>：显示 ASCII 图形表示的分支合并历史</li><li><code>-pretty＝</code>：使用其他格式显示历史提交信息，可选项有：<code>oneline</code>, <code>short</code>, <code>medium</code>, <code>full</code>, <code>fuller</code>, <code>email</code>, <code>raw</code> 以及 <code>format</code>，默认为 <code>medium</code>，如：<ul><li><code>-pretty=oneline</code>：一行显示，只显示哈希值和提交说明（<code>--online</code> 本身也可以作为单独的属性）</li><li><code>-pretty=format:</code>：控制显示的记录格式，如：<ul><li><code>%H</code> 提交对象（commit）的完整哈希字串</li><li><code>%h</code> 提交对象的简短哈希字串</li><li><code>%T</code> 树对象（tree）的完整哈希字串</li><li><code>%t</code> 树对象的简短哈希字串</li><li><code>%P</code> 父对象（parent）的完整哈希字串</li><li><code>%p</code> 父对象的简短哈希字串</li><li><code>%an</code> 作者（author）的名字</li><li><code>%ae</code> 作者的电子邮件地址</li><li><code>%ad</code> 作者修订日期（可以用 -date= 选项定制格式）</li><li><code>%ar</code> 作者修订日期，按多久以前的方式显示</li><li><code>%cn</code> 提交者(committer)的名字<ul><li>作者和提交者的区别不知道是啥？</li><li>作者与提交者的关系：作者是程序的修改者，提交者是代码提交人（自己的修改不提交是怎么能让别人拉下来再提交的？）</li><li>其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者（soga）</li></ul></li><li><code>%ce</code> 提交者的电子邮件地址</li><li><code>%cd</code> 提交日期（可以用 <code>-date=</code> 选项定制格式）</li><li><code>%cr</code> 提交日期，按多久以前的方式显示</li><li><code>%s</code> 提交说明</li></ul></li><li>带颜色的 <code>--pretty=format:</code>，这个另外写出来分析；以这句为例：<code>%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;</code>，它的效果是 <img src="../../../../image/2020-09-15-git-log/1.png" alt="1.png">；先断句：[<code>%Cred%h</code>]，[<code>%Creset -</code>]，[<code>%C(yellow)%d</code>]，[<code>%Cblue%s</code>]，[<code>%Cgreen(%cd)</code>]，[<code>%C(bold blue)&lt;%an&gt;</code>]；然后就是很明显能得到的规律了：一个颜色＋一个内容，颜色以 <code>％C</code> 开头，后边接几种颜色，还可以设置字体，如果要设置字体的话，要一块加个括号，能设置的颜色值包括：<code>reset</code>（默认的灰色），<code>normal</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code>。字体属性则有 <code>bold</code>, <code>dim</code>, <code>ul</code>, <code>blink</code>, <code>reverse</code>；内容可以是占位元字符，也可以是直接显示的普通字符。</li></ul></li><li><code>-date=(relative|local|default|iso|rfc|short|raw)</code>：定制后边如果出现 <code>%ad</code> 或 <code>%cd</code> 时的日期格式<ul><li>有几个默认选项<ol><li><code>-date=relative</code>：shows dates relative to the current time, e.g. “2 hours ago”.</li><li><code>-date=local</code>：shows timestamps in user’s local timezone.</li><li><code>-date=iso</code> (or <code>--date=iso8601</code>)：shows timestamps in ISO 8601 format.</li><li><code>-date=rfc</code> (or <code>--date=rfc2822</code>)：shows timestamps in RFC 2822 format,often found in E-mail messages.</li><li><code>-date=short</code>：shows only date but not time, in YYYY-MM-DD format.这个挺好用</li><li><code>-date=raw</code>：shows the date in the internal raw git format %s %z format.</li><li><code>-date=default</code>：shows timestamps in the original timezone (either committer’s or author’s).</li></ol></li><li>也可以自定义格式（需要git版本2.6.0以上），比如 <code>--date=format:&#39;%Y-%m-%d %H:%M:%S&#39;</code> 会格式化成：2016-01-13 11:32:13，其他的格式化占位符如下：<ol><li><code>%a</code>：Abbreviated weekday name</li><li><code>%A</code>：Full weekday name</li><li><code>%b</code>：Abbreviated month name</li><li><code>%B</code>：Full month name</li><li><code>%c</code>：Date and time representation appropriate for locale</li><li><code>%d</code>：Day of month as decimal number (01 – 31)</li><li><code>%H</code>： Hour in 24-hour format (00 – 23)</li><li><code>%I</code>：Hour in 12-hour format (01 – 12)</li><li><code>%j</code>：Day of year as decimal number (001 – 366)</li><li><code>%m</code>：Month as decimal number (01 – 12)</li><li><code>%M</code>：Minute as decimal number (00 – 59)</li><li><code>%p</code>：Current locale’s A.M./P.M. indicator for 12-hour clock</li><li><code>%S</code>：Second as decimal number (00 – 59)</li><li><code>%U</code>：Week of year as decimal number, with Sunday as first day of week (00 – 53)</li><li><code>%w</code>：Weekday as decimal number (0 – 6; Sunday is 0)</li><li><code>%W</code>：Week of year as decimal number, with Monday as first day of week (00 – 53)</li><li><code>%x</code>：Date representation for current locale</li><li><code>%X</code>：Time representation for current locale</li><li><code>%y</code>：Year without century, as decimal number (00 – 99)</li><li><code>%Y</code>：Year with century, as decimal number</li><li><code>%z</code>, <code>%Z</code>：Either the time-zone name or time zone abbreviation, depending on registry settings; no characters if time zone is unknown</li><li><code>%%</code>：Percent sign</li></ol></li></ul></li></ul><h2 id="筛选参数"><a href="#筛选参数" class="headerlink" title="筛选参数"></a>筛选参数</h2><ol><li>按数量<ol><li>n：显示前n条log</li></ol></li><li>按日期<ol><li><code>-after=</code><ol><li>比如 <code>git log --after=&quot;2014-7-1”</code>，显示2014年7月1号之后的commit(包含7月1号)</li><li>后边的日期还可以用相对时间表示，比如”1 week ago”和”yesterday”，比如 <code>git log --after=&quot;yesterday&quot;</code></li><li>这里的格式可以是什么？</li></ol></li><li><code>-before=</code><ol><li>同上</li><li>另外这两条命令可以同时使用表示时间段，比如 <code>git log --after=&quot;2014-7-1&quot; --before=&quot;2014-7-4&quot;</code></li><li>另外 <code>--since</code> <code>--until</code> 和 <code>--after`` --before</code> 是一个意思，都可以用</li></ol></li></ol></li><li>按作者<ol><li><code>-author=</code><ol><li>比如 <code>git log --author=“John&quot;</code>，显示John贡献的commit</li><li>注意：作者名不需要精确匹配，只需要包含就行了</li><li>而且：可以使用正则表达式，比如 <code>git log --author=&quot;John\|Mary”</code>，搜索Marry和John贡献的commit</li><li>而且：这个 <code>--author</code> 不仅包含名还包含email, 所以你可以用这个搜索email</li></ol></li></ol></li><li>按commit描述<ol><li><code>-grep=</code><ol><li>比如：<code>git log --grep=&quot;JRA-224&quot;</code></li><li>而且：可以传入-i用来忽略大小写</li><li>注意：如果想同时使用 <code>--grep</code> 和 <code>--author</code>，必须在附加一个 <code>--all-match</code> 参数</li></ol></li></ol></li><li>按文件<ol><li>（空格）或［没有］<ol><li>有时你可能只对某个文件的修改感兴趣, 你只想查看跟某个文件相关的历史信息, 你只需要插入你感兴趣文件的路径［对，是路径，所以经常是不太好用］就可以了</li><li>比如：<code>git log -- foo.py bar.py</code>，只返回和 foo.py 或 bar.py 相关的 commit</li><li>这里的–是告诉 Git 后面的参数是文件路径而不是 branch name. 如果后面的文件路径不会和某个 branch 产生混淆, 你可以省略 <code>--</code>，比如 <code>git log foo.py</code></li><li>另外，后边的路径还支持正则，比如：<code>git log *install.md</code> 是，指定项目路径下的所有以 install.md 结尾的文件的提交历史</li><li>另外，文件名应该放到参数的最后位置，通常在前面加上 <code>--</code> 并用空格隔开表示是文件</li><li>另外，<code>git log file/</code> 查看 file 文件夹下所有文件的提交记录</li></ol></li></ol></li><li>按分支<ol><li><ol><li><code>-branchName</code> branchName为任意一个分支名字，查看某个分支上的提交记录</li><li>需要放到参数中的最后位置处</li><li>如果分支名与文件名相同，系统会提示错 误，可通过–选项来指定给定的参数是分支名还是文件名<ol><li>比如：在当前分支中有一个名为v1的文件，同时还存在一个名为v1的分支</li><li><code>git log v1 --</code> 此时的v1代表的是分支名字（－－后边是空的）</li><li><code>git log -- v1</code> 此时的v1代表的是名为v1的文件</li><li><code>git log v1 －－ v1</code> 代表v1分支下的v1文件</li></ol></li></ol></li></ol></li><li>按内容<ol><li><code>-S&quot;&lt;&gt;&quot;</code>、<code>-G&quot;&lt;&gt;&quot;</code><ol><li>有时你想搜索和新增或删除某行代码相关的commit. 可以使用这条命令</li><li>假设你想知道Hello, World!这句话是什么时候加入到项目里去的，可以用：<code>git log -S&quot;Hello,World!&quot;</code></li><li>另外：如果你想使用正则表达式去匹配而不是字符串, 那么你可以使用-G代替-S.</li><li>这是一个非常有用的debug工具, 使用他你可以定位所有跟某行代码相关的commit. 甚至可以查看某行是什么时候被copy的, 什么时候移到另外一个文件中去的</li><li>注：-S后没有”=”，与查询内容之间也没有空格符</li></ol></li></ol></li><li>按范围<ol><li><code>git log &lt;since&gt;..&lt;until&gt;</code><ol><li>这个命令可以查看某个范围的commit</li><li>这个命令非常有用当你使用branch做为range参数的时候. 能很方便的显示2个branch之间的不同</li><li>比如：<code>git log master..feature</code>，<code>master..feature</code> 这个range包含了在feature有而在master没有的所有commit，同样，如果是feature..master包含所有master有但是feature没有的commit</li><li>另外，如果是三个点，表示或的意思：<code>git log master...test</code> 查询master或test分支中的提交记录</li></ol></li></ol></li><li>过滤掉 merge commit<ol><li><code>-no-merges</code><ol><li>默认情况下 <code>git log</code> 会输出 merge commit. 你可以通过 <code>--no-merges</code> 标记来过滤掉 merge commit，<code>git log --no-merges</code></li><li>另外，如果你只对 merge commit 感兴趣可以使用 <code>—merges</code>，<code>git log --merges</code></li></ol></li></ol></li><li>按标签tag<ol><li><code>git log v1.0</code><ol><li>直接这样是查询标签之前的commit</li><li>加两个点 <code>git log v1.0..</code> 查询从v1.0以后的提交历史记录(不包含v1.0)</li></ol></li></ol></li><li>按commit<ol><li><code>git log commit</code> ：查询commit之前的记录，包含commit</li><li><code>git log commit1 commit2</code>：查询commit1与commit2之间的记录，包括commit1和commit2</li><li><code>git log commit1..commit2</code>：同上，但是不包括commit1<ol><li>其中，commit可以是提交哈希值的简写模式，也可以使用HEAD代替<ol><li>HEAD代表最后一次提交，HEAD^为最后一个提交的父提交，等同于HEAD～1</li><li>HEAD～2代表倒数第二次提交</li></ol></li></ol></li></ol></li></ol><h2 id="最后干货，你会喜欢的"><a href="#最后干货，你会喜欢的" class="headerlink" title="最后干货，你会喜欢的~"></a>最后干货，你会喜欢的~</h2><p>下面第一条的效果是这样：<br><img src="../../../../image/2020-09-15-git-log/2.png" alt="2.png"></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global alias.lm  <span class="hljs-string">&quot;log --no-merges --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;你的名字！自己修改！&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br>git config --global alias.lms  <span class="hljs-string">&quot;log --no-merges --color --stat --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;你的名字！自己修改！&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br>git config --global [alias.ls](http://alias.ls/) <span class="hljs-string">&quot;log --no-merges --color --graph --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br>git config --global alias.lss <span class="hljs-string">&quot;log --no-merges --color --stat --graph --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/bellkosmos/p/5923439.html">git log命令全解析，打log还能这么随心所欲！</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 的 merge, rebase 和 squash</title>
    <link href="/2020/09/05/merge-rebase-squash/"/>
    <url>/2020/09/05/merge-rebase-squash/</url>
    
    <content type="html"><![CDATA[<p>在团队合作中，毫无疑问，我们需要一个版本管理工具，相对于 SVN 这种在我们看来是老古董的工具，Git 在年轻化的团队中更受欢迎。并不仅仅是跟着大神们（Linux系）的路子在走，所以感觉很牛逼，而是 Git 真的很牛逼，当然，牛逼的同时你需要的学习曲线也是很陡的。<br>这几天我就遇到了一个问题，其实也不是遇到问题，而是遇到了疑惑，那就是我在 github 系统中 <code>merge</code> 同时的 PR 的时候发现有好几个选项，但是，却说不清楚这几个选项分别代表什么含义，所以就稍微花了点时间了解了下，顺带做个总结。<br>在 merge pr 的时候，默认是有三种选项的，分别是</p><ul><li>普通的 merge</li><li>rebase merge</li><li>squash merge</li></ul><p>这其实对应于我们在合并分支的时候的几种方式，所以我就以本地分支的形式来说说有啥区别。</p><p>假设我们一开始的 <code>master</code> 分支上已经有了几个提交，就像这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/00.png" alt="00.png"></p><p>然后，我们切出一条开发的分支，进行了一些 Feature 的开发，然后我们的分支可能就是这种情况：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/01.png" alt="01.png"></p><p>这种情况还好，也比较常遇到，但是，现在问题来了，如果在这个时候 <code>master</code> 有了一些新提交（可能是其他分支合并进来的），那么这个时候情形就成了这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/02.png" alt="02.png"></p><p>这个情况很有趣，但是我们不讨论，因为这和我们今天的主题无关，以后可以另外开一个话题来说，今天要说的是第二个情况。<br>说到合并分支，可能我们最熟悉的操作是这样的：</p><ol><li>先切换到目标分支（<code>master</code>）</li><li>执行命令： <code>git merge devel</code></li><li>删除旧分支（可以在上面一同做）： <code>git branch -D devel</code></li><li>提交到远程分支： <code>git push origin master</code></li></ol><p>好像这样没啥问题的样子，但是这样操作之后，你知道结果是怎么样吗？假设合并之前的这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/03.png" alt="03.png"></p><p>我们这么一番操作之后，那么最后我们的分支的历史将会是这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/04.png" alt="04.png"></p><p>是的，看上去很不错，也是一条直直的 commit line，我们在 <code>devel</code> 分支中的 commit 也是一个不差得保留在了 <code>master</code> 中。但是，很多时候，我们并不需要那么多的 commit，假设你给一个开源项目提交一个 Bug Fixes，然后一个简单的修改因为你的粗心大意 pr 了十几个 commit 过去，如果作者给你 <code>merge</code> 了，这就在这个项目的历史长河中增加了十几个 commit 啊，以后的人看 commit history 估计都崩溃了吧；同时，对于你自己管理的项目来说，当你 <code>merge</code> 之后发现有问题，想回滚都蛋疼！</p><p>在使用 git 的过程中，可能你遇到过想要合并多个 commit 为一个，然后很多人会告诉你用 <code>git commit --amend</code>，然后你发现里面有你的多个 commit 历史，你可以通过 <code>pick</code> 选择，<code>squash</code> 合并等等。同样得，<code>merge</code> 的时候也可以这么干，你只需要这么简单的两步：</p><ol><li>切换到目标分支： <code>git checkout master</code></li><li>以 squash 的形式 merge： <code>git merge --squash devel</code></li></ol><p>你会发现，在 <code>master</code> 分支上居然有未提交的修改，然后你就需要在 <code>master</code> 上主动提交了修改，注意，这里是你 commit 的，也就是改变了 commit 的 <code>author</code>。结果是这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/05.png" alt="05.png"></p><p>这里好了，比前面普通的 <code>merge</code> 来说，我们只有一个 commit 了，不管在分支中 commit 了多少，这里都只有一个！</p><p>但是，作为处女座的程序员肯定是不能忍受目前的情况的，因为我们既想合并 commits，又想保留作者的信息，那么有没有什么好办法呢？肯定是有的啦，这个时候我们可以尝试一下 <code>rebase</code>，操作步骤是这样的：</p><ol><li>先切换到 <code>devel</code> 分支（不一样咯）： <code>git checkout devel</code></li><li>变基： <code>git rebase -i master</code></li><li>切换回目标分支： <code>git checkout master</code></li><li>合并: <code>git merge devel</code></li></ol><p>这里完成了第二步之后我想你应该大概知道发生了什么事了，我们在 <code>devel</code> 里面对照 <code>master</code> 进行了变基，所谓的变基其实就是找到两个分支共同的祖先，然后在当前分支上合并从共同祖先到现在的所有 commit，所以我们在第二步的时候会选择怎么处理这些 commit，然后我们就得到了一个从公共 commit 到现在的单个 commit，这个时候别人讲我们这个 commit 合并到 <code>master</code> 也只会在 <code>master</code> 上留下一个 commit 记录，就像这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/06.png" alt="06.png"></p><p>虽然这个 commit history 线看上去很不错，而且也比较符合实际情况，但是我们需要注意到的有点就是分支上的开发者需要自己执行变基操作，从而导致他的原始 commit history 变化了（可以理解成被合并了）。</p><p>相比一下前面三种方式，我们可以总结出一些东西：</p><ol><li><code>rebase</code> 可以尽可能保持 <code>master</code> 分支干净整洁，并且易于识别 <code>author</code></li><li><code>squash</code> 也可以保持 <code>master</code> 分支干净，但是 <code>master</code> 中 <code>author</code> 都是 <code>maintainer</code>，而不是原 <code>owner</code></li><li><code>merge</code> 不能保持 <code>master</code> 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好</li></ol><p>参考</p><ol><li><a href="https://liqiang.io/post/difference-between-merge-squash-and-rebase">merge squash 和 merge rebase 区别</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[code {    color: #e83e8c;}.post-content {    padding-left: 3%;    padding-right: 3%;}]]></content>
    
  </entry>
  
  
  
</search>
