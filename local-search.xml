<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Binder IPC 内存模型</title>
    <link href="/2022/12/29/binder-memory/"/>
    <url>/2022/12/29/binder-memory/</url>
    
    <content type="html"><![CDATA[<h1 id="指导思想"><a href="#指导思想" class="headerlink" title="指导思想"></a>指导思想</h1><p>进程 A 通过 <code>binder_transaction</code> 往进程 B 传输数据的过程，其中步骤 4、5、6 和 7 是一页一页地循环执行:</p><ol><li><p>准备需要发送的数据, 数据存放在进程 A 的用户空间中</p></li><li><p>进程 A 通过系统调用进入 binder driver 的代码逻辑中</p></li><li><p>在 binder driver 代码中, 找到与所发送数据大小匹配的进程 B 的 <code>binder_buffer</code>, 该 buffer 此时只有虚拟地址尚未映射物理页（指向进程 B 的用户空间）</p></li><li><p>为此次数据传输分配物理页</p></li><li><p>建立进程 B 的 binder buffer 里虚拟页与刚分配物理页的映射关系</p></li><li><p>通过 <code>kmap</code> 为物理页映射一个内核空间的虚拟页</p></li><li><p><code>copy_ from_user</code> 将进程 A 用户空间的数据写入刚刚映射的内核空间虚拟页中</p></li><li><p>根据映射关系, 刚刚写入的数据现在可以通过进程 B 的 binder buffer 的虚拟地址读出</p></li></ol><h2 id="一次拷贝"><a href="#一次拷贝" class="headerlink" title="一次拷贝"></a>一次拷贝</h2><p>传统 IPC 一般是进程 A 执行系统调用陷入内核，将数据从进程 A 内存空间拷贝至内核，进程 B 为了读取数据需要执行系统调用陷入内核，内核将数据拷贝至进程 B 内存空间，那么一共是两次内存拷贝和两次用户态内核态切换</p><p>Binder IPC 的第一次内存拷贝同传统 IPC，也是将数据从从进程 A 内存空间拷贝至内核，但 Binder IPC 不需要第二次内存拷贝，因为它将进程 B 内存空间里指向数据的虚存映射至内核里保存数据的内核物理内存，这里进程 B 读取到的数据其实是第一次拷贝至内核的那份数据，所以是一次内存拷贝和两次用户态内核态切换</p><p>注意这里说的只需 <em>一次拷贝</em> 指的是一次 Binder IPC，而一次 Binder 方法调用也即 Binder RPC 需要两次 IPC：发送请求和接收响应，所以一次 Binder RPC 其实包含了两次 IPC 也即两次内存拷贝（四次用户态内核态的切换）</p><h1 id="client-write-request"><a href="#client-write-request" class="headerlink" title="client write request"></a>client write request</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:system/libhwbinder/include/hwbinder/IPCThreadState.h</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPCThreadState</span>&#123;           <span class="hljs-keyword">private</span>:            Parcel              mIn;   <span class="hljs-comment">// binder driver 写入，应用进程读取并处理的内存区域，对应 binder_thread_read</span>            Parcel              mOut;  <span class="hljs-comment">// 应用进程写入，binder driver 读取并处理的内存区域，对应 binder_thread_write</span>&#125;;<span class="hljs-comment">// http://www.aospxref.com/android-13.0.0_r3/xref/frameworks/native/libs/binder/IPCThreadState.cpp</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::transact</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> handle,</span></span><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data <span class="hljs-comment">/* 参数被打包进这里 */</span>,</span></span><span class="hljs-params"><span class="hljs-function">                                  Parcel* reply <span class="hljs-comment">/* 用以接收响应数据 */</span>, <span class="hljs-type">uint32_t</span> flags)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 将 [BC_TRANSACTION][binder_transaction_data] 写入 mOut</span>    <span class="hljs-comment">// mOut 是 client 进程内的一块内存区域</span>    err = <span class="hljs-built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// 将 request 发送给 binder driver 并等待 response</span>    err = <span class="hljs-built_in">waitForResponse</span>(reply);    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> err;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::writeTransactionData</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd <span class="hljs-comment">/* BC_TRANSACTION */</span>, <span class="hljs-type">uint32_t</span> binderFlags,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int32_t</span> handle, <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, <span class="hljs-type">status_t</span>* statusBuffer)</span></span><span class="hljs-function"></span>&#123;    binder_transaction_data tr;    tr.target.ptr = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span>    tr.target.handle = handle;    tr.code = code;    tr.flags = binderFlags;    tr.cookie = <span class="hljs-number">0</span>;    tr.sender_pid = <span class="hljs-number">0</span>;    tr.sender_euid = <span class="hljs-number">0</span>;    <span class="hljs-type">const</span> <span class="hljs-type">status_t</span> err = data.<span class="hljs-built_in">errorCheck</span>();    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;        tr.data_size = data.<span class="hljs-built_in">ipcDataSize</span>();      <span class="hljs-comment">// 存放参数的内存区域大小</span>        tr.data.ptr.buffer = data.<span class="hljs-built_in">ipcData</span>();    <span class="hljs-comment">// 其实就是 Parcel 存放数据的内存块的起始地址</span>        tr.offsets_size = data.<span class="hljs-built_in">ipcObjectsCount</span>()*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>);        tr.data.ptr.offsets = data.<span class="hljs-built_in">ipcObjects</span>();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusBuffer) &#123;        tr.flags |= TF_STATUS_CODE;        *statusBuffer = err;        tr.data_size = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">status_t</span>);        tr.data.ptr.buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(statusBuffer);        tr.offsets_size = <span class="hljs-number">0</span>;        tr.data.ptr.offsets = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">return</span> (mLastError = err);    &#125;    <span class="hljs-comment">// mOut 写入 [BC_TRANSACTION][binder_transaction_data]</span><span class="hljs-comment">// 对应章节【指导思想】里的步骤一</span>    mOut.<span class="hljs-built_in">writeInt32</span>(cmd);    mOut.<span class="hljs-built_in">write</span>(&amp;tr, <span class="hljs-built_in">sizeof</span>(tr));    <span class="hljs-keyword">return</span> NO_ERROR;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::waitForResponse</span><span class="hljs-params">(Parcel *reply, <span class="hljs-type">status_t</span> *acquireResult)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">uint32_t</span> cmd;    <span class="hljs-type">int32_t</span> err;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> ((err=<span class="hljs-built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>;        err = mIn.<span class="hljs-built_in">errorCheck</span>();        <span class="hljs-keyword">if</span> (err &lt; NO_ERROR) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span> (mIn.<span class="hljs-built_in">dataAvail</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        cmd = (<span class="hljs-type">uint32_t</span>)mIn.<span class="hljs-built_in">readInt32</span>();        <span class="hljs-keyword">switch</span> (cmd) &#123;        <span class="hljs-keyword">case</span> BR_FAILED_REPLY:        <span class="hljs-keyword">case</span> BR_FROZEN_REPLY:        <span class="hljs-keyword">case</span> BR_ACQUIRE_RESULT:        <span class="hljs-keyword">case</span> BR_REPLY:        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 将 request 发送给 binder driver 并接收 response</span><span class="hljs-comment">// ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, binder_write_read)</span><span class="hljs-comment">// [write_buffer, write_size] 是 request</span><span class="hljs-comment">// [read_buffer, read_size] 是 response</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::talkWithDriver</span><span class="hljs-params">(<span class="hljs-type">bool</span> doReceive)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -EBADF;    &#125;    binder_write_read bwr;    <span class="hljs-comment">// Is the read buffer empty?</span>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> needRead = mIn.<span class="hljs-built_in">dataPosition</span>() &gt;= mIn.<span class="hljs-built_in">dataSize</span>();    <span class="hljs-comment">// We don&#x27;t want to write anything if we are still reading</span>    <span class="hljs-comment">// from data left in the input buffer and the caller</span>    <span class="hljs-comment">// has requested to read the next data.</span>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="hljs-built_in">dataSize</span>() : <span class="hljs-number">0</span>;    bwr.write_size = outAvail;                    <span class="hljs-comment">// mOut 内存区域大小，也即参数包大小</span>    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>)mOut.<span class="hljs-built_in">data</span>();    <span class="hljs-comment">// mOut 地址，存放打包好的请求参数</span>    <span class="hljs-comment">// This is what we&#x27;ll read.</span>    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;        bwr.read_size = mIn.<span class="hljs-built_in">dataCapacity</span>();        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>)mIn.<span class="hljs-built_in">data</span>();    &#125; <span class="hljs-keyword">else</span> &#123;        bwr.read_size = <span class="hljs-number">0</span>;        bwr.read_buffer = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// Return immediately if there is nothing to do.</span>    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> NO_ERROR;    bwr.write_consumed = <span class="hljs-number">0</span>;    bwr.read_consumed = <span class="hljs-number">0</span>;    <span class="hljs-type">status_t</span> err;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)  <span class="hljs-comment">// 对应章节【指导思想】里的步骤二</span>            err = NO_ERROR;        <span class="hljs-keyword">else</span>            err = -errno;        <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;            err = -EBADF;        &#125;    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span> </span>&#123;...&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = _IOC_SIZE(cmd);<span class="hljs-type">void</span> __user *ubuf = (<span class="hljs-type">void</span> __user *)arg;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> bwr;<span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> binder_write_read)) &#123;ret = -EINVAL;<span class="hljs-keyword">goto</span> out;&#125;    <span class="hljs-comment">// 将 binder_write_read 从用户空间拷贝一份至内核空间</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="hljs-built_in">sizeof</span>(bwr))) &#123;ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;    <span class="hljs-comment">// 先处理应用进程的请求 write_buffer</span><span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_write</span>(proc, thread,  bwr.write_buffer,  bwr.write_size,  &amp;bwr.write_consumed);<span class="hljs-built_in">trace_binder_write_done</span>(ret);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;bwr.read_consumed = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;<span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);<span class="hljs-built_in">trace_binder_read_done</span>(ret);<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))<span class="hljs-built_in">binder_wakeup_proc_ilocked</span>(proc);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;<span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,     <span class="hljs-string">&quot;%d:%d wrote %lld of %lld, read return %lld of %lld\n&quot;</span>,     proc-&gt;pid, thread-&gt;pid,     (u64)bwr.write_consumed, (u64)bwr.write_size,     (u64)bwr.read_consumed, (u64)bwr.read_size);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr))) &#123;ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;out:<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_size_t</span> *consumed)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">uint32_t</span> cmd;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_context</span> *context = proc-&gt;context;<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;<span class="hljs-type">void</span> __user *ptr = buffer + *consumed;<span class="hljs-type">void</span> __user *end = buffer + size;<span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;<span class="hljs-type">int</span> ret;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-built_in">trace_binder_command</span>(cmd);<span class="hljs-keyword">if</span> (_IOC_NR(cmd) &lt; <span class="hljs-built_in">ARRAY_SIZE</span>(binder_stats.bc)) &#123;<span class="hljs-built_in">atomic_inc</span>(&amp;binder_stats.bc[_IOC_NR(cmd)]);<span class="hljs-built_in">atomic_inc</span>(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]);<span class="hljs-built_in">atomic_inc</span>(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]);&#125;<span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-keyword">case</span> BC_TRANSACTION:<span class="hljs-keyword">case</span> BC_REPLY: &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> tr;            <span class="hljs-comment">// 将 binder_transaction_data 从用户空间拷贝至内核空间</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;tr, ptr, <span class="hljs-built_in">sizeof</span>(tr)))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(tr);<span class="hljs-built_in">binder_transaction</span>(proc, thread, &amp;tr,   cmd == BC_REPLY, <span class="hljs-number">0</span>);<span class="hljs-keyword">break</span>;&#125;        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_transaction</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_transaction_data *tr, <span class="hljs-type">int</span> reply,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">binder_size_t</span> extra_buffers_size)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction</span> *t;<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *user_buffer = (<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)tr-&gt;data.ptr.buffer;    <span class="hljs-comment">// 用户空间的数据块地址</span><span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 从进程 B 的用以 binder 数据传输的虚存里找一块满足大小的虚存块 binder_buffer.user_data 用以存放 request</span><span class="hljs-comment">// 这里就会发生物理页的分配了，binder 在内核分配物理页，并将进程 B 的虚存会映射至内核物理页</span><span class="hljs-comment">// 这样进程 B 就可以直接读取 request 而无需进行一次内核态至用户态的内存拷贝</span><span class="hljs-comment">// 参看章节【映射进程虚存与内核内存】</span><span class="hljs-comment">// 这里对应章节【指导思想】里的步骤三、四、五和六</span>t-&gt;buffer = <span class="hljs-built_in">binder_alloc_new_buf</span>(&amp;target_proc-&gt;alloc, tr-&gt;data_size,tr-&gt;offsets_size, extra_buffers_size,!reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY), current-&gt;tgid);<span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 将 request 从进程 A （tr-&gt;data.ptr.offsets）拷贝至进程 B（t-&gt;buffer-&gt;user_data）</span><span class="hljs-comment">// 这里就是 binder ipc 中发生的唯一一次数据拷贝</span><span class="hljs-comment">// 因为进程 B 的虚存地址实际上是映射至内核物理内存，所以 request 实际上是从进程 A 拷贝至内核，进程 B 读取的是内核物理内存空间</span><span class="hljs-comment">// 对应章节【指导思想】里的步骤七</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">binder_alloc_copy_user_to_buffer</span>(&amp;target_proc-&gt;alloc,t-&gt;buffer,<span class="hljs-built_in">ALIGN</span>(tr-&gt;data_size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *)),(<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)tr-&gt;data.ptr.offsets,tr-&gt;offsets_size)) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction with invalid offsets ptr\n&quot;</span>,proc-&gt;pid, thread-&gt;pid);return_error = BR_FAILED_REPLY;return_error_param = -EFAULT;return_error_line = __LINE__;<span class="hljs-keyword">goto</span> err_copy_data_failed;&#125;<span class="hljs-comment">// ...</span>off_start_offset = <span class="hljs-built_in">ALIGN</span>(tr-&gt;data_size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));buffer_offset = off_start_offset;off_end_offset = off_start_offset + tr-&gt;offsets_size;sg_buf_offset = <span class="hljs-built_in">ALIGN</span>(off_end_offset, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));sg_buf_end_offset = sg_buf_offset + extra_buffers_size -<span class="hljs-built_in">ALIGN</span>(secctx_sz, <span class="hljs-built_in">sizeof</span>(u64));off_min = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;     buffer_offset += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>)) &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object_header</span> *hdr;<span class="hljs-type">size_t</span> object_size;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object</span> object;<span class="hljs-type">binder_size_t</span> object_offset;<span class="hljs-type">binder_size_t</span> copy_size;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">binder_alloc_copy_from_buffer</span>(&amp;target_proc-&gt;alloc,  &amp;object_offset,  t-&gt;buffer,  buffer_offset,  <span class="hljs-built_in">sizeof</span>(object_offset))) &#123;<span class="hljs-built_in">binder_txn_error</span>(<span class="hljs-string">&quot;%d:%d copy offset from buffer failed\n&quot;</span>,thread-&gt;pid, proc-&gt;pid);return_error = BR_FAILED_REPLY;return_error_param = -EINVAL;return_error_line = __LINE__;<span class="hljs-keyword">goto</span> err_bad_offset;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Copy the source user buffer up to the next object</span><span class="hljs-comment"> * that will be processed.</span><span class="hljs-comment"> */</span>copy_size = object_offset - user_offset;<span class="hljs-keyword">if</span> (copy_size &amp;&amp; (user_offset &gt; object_offset ||<span class="hljs-built_in">binder_alloc_copy_user_to_buffer</span>(&amp;target_proc-&gt;alloc,t-&gt;buffer, user_offset,user_buffer + user_offset,copy_size))) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction with invalid data ptr\n&quot;</span>,proc-&gt;pid, thread-&gt;pid);return_error = BR_FAILED_REPLY;return_error_param = -EFAULT;return_error_line = __LINE__;<span class="hljs-keyword">goto</span> err_copy_data_failed;&#125;object_size = <span class="hljs-built_in">binder_get_object</span>(target_proc, user_buffer,t-&gt;buffer, object_offset, &amp;object);<span class="hljs-keyword">if</span> (object_size == <span class="hljs-number">0</span> || object_offset &lt; off_min) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\n&quot;</span>,  proc-&gt;pid, thread-&gt;pid,  (u64)object_offset,  (u64)off_min,  (u64)t-&gt;buffer-&gt;data_size);return_error = BR_FAILED_REPLY;return_error_param = -EINVAL;return_error_line = __LINE__;<span class="hljs-keyword">goto</span> err_bad_offset;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Set offset to the next buffer fragment to be</span><span class="hljs-comment"> * copied</span><span class="hljs-comment"> */</span>user_offset = object_offset + object_size;hdr = &amp;object.hdr;off_min = object_offset + object_size;<span class="hljs-keyword">switch</span> (hdr-&gt;type) &#123;<span class="hljs-keyword">case</span> BINDER_TYPE_BINDER:<span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE:<span class="hljs-keyword">case</span> BINDER_TYPE_FD:<span class="hljs-keyword">case</span> BINDER_TYPE_PTR:<span class="hljs-comment">// ...</span>&#125;&#125;<span class="hljs-comment">/* Done processing objects, copy the rest of the buffer */</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">binder_alloc_copy_user_to_buffer</span>(&amp;target_proc-&gt;alloc,t-&gt;buffer, user_offset,user_buffer + user_offset,tr-&gt;data_size - user_offset)) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction with invalid data ptr\n&quot;</span>,proc-&gt;pid, thread-&gt;pid);return_error = BR_FAILED_REPLY;return_error_param = -EFAULT;return_error_line = __LINE__;<span class="hljs-keyword">goto</span> err_copy_data_failed;&#125;<span class="hljs-comment">// ...</span>&#125;</code></pre></div><h1 id="server-read-request"><a href="#server-read-request" class="headerlink" title="server read request"></a>server read request</h1><p>在上一章节 <a href="#client-write-request">client write request</a> 里，binder 已经把 request 从 client 进程拷贝至内核，并将 server 进程内的一块虚存映射至内核里的 request，下面看看 server 收到了什么、如何处理 request 数据</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 在【Binder IPC 线程调度模型】里讲过：</span><span class="hljs-comment">// server binder 线程先往 binder 发送数据（binder_thread_write），如果有的话</span><span class="hljs-comment">// 然后读取 binder 发送过来的数据（binder_thread_read），如果没有数据需要处理则 binder 线程会阻塞在 binder_wait_for_work（让渡 CPU）</span><span class="hljs-comment">// 那么 binder 将 request（BINDER_WORK_TRANSACTION） 发送至 server 进程的 todo list，server binder 线程将被唤醒</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-comment">/* 应用进程内存地址，实际上是 IPCThreadState-&gt;mIn 这块内存空间，看 talkWithDriver */</span></span></span><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">size_t</span> size,                    <span class="hljs-comment">/* IPCThreadState-&gt;mIn 的大小 */</span></span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_size_t</span> *consumed         <span class="hljs-comment">/* 输出，表示往 binder_buffer 里写入了多少内容 */</span>, </span></span><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">int</span> non_block)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;  <span class="hljs-comment">// 应用进程的 IPCThreadState-&gt;mIn 这块内存空间</span><span class="hljs-type">void</span> __user *ptr = buffer + *consumed;                          <span class="hljs-comment">// 应用进程的 IPCThreadState-&gt;mIn 这块内存空间</span><span class="hljs-type">void</span> __user *end = buffer + size;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> wait_for_proc_work;<span class="hljs-keyword">if</span> (*consumed == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(BR_NOOP, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);&#125;retry:<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);wait_for_proc_work = <span class="hljs-built_in">binder_available_for_proc_work_ilocked</span>(thread);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;<span class="hljs-built_in">trace_binder_wait_for_work</span>(wait_for_proc_work,   !!thread-&gt;transaction_stack,   !<span class="hljs-built_in">binder_worklist_empty</span>(proc, &amp;thread-&gt;todo));<span class="hljs-keyword">if</span> (wait_for_proc_work) &#123;<span class="hljs-keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |BINDER_LOOPER_STATE_ENTERED))) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;</span>,proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);<span class="hljs-built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="hljs-number">2</span>);&#125;<span class="hljs-built_in">trace_android_vh_binder_restore_priority</span>(<span class="hljs-literal">NULL</span>, current);<span class="hljs-built_in">binder_restore_priority</span>(thread, &amp;proc-&gt;default_priority);&#125;<span class="hljs-keyword">if</span> (non_block) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_has_work</span>(thread, wait_for_proc_work))ret = -EAGAIN;&#125; <span class="hljs-keyword">else</span> &#123;ret = <span class="hljs-built_in">binder_wait_for_work</span>(thread, wait_for_proc_work);  <span class="hljs-comment">// binder thread 将在这里被唤醒并继续</span>&#125;thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">return</span> ret;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data_secctx</span> tr;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> *trd = &amp;tr.transaction_data;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction</span> *t = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_work</span> *w = <span class="hljs-literal">NULL</span>;<span class="hljs-type">size_t</span> trsize = <span class="hljs-built_in">sizeof</span>(*trd);w = <span class="hljs-built_in">binder_dequeue_work_head_ilocked</span>(list);<span class="hljs-keyword">switch</span> (w-&gt;type) &#123;<span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION: &#123;    <span class="hljs-comment">// 收到 binder 给的 request</span><span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);t = <span class="hljs-built_in">container_of</span>(w, <span class="hljs-keyword">struct</span> binder_transaction, work);&#125; <span class="hljs-keyword">break</span>;<span class="hljs-comment">// ...</span>trd-&gt;data_size = t-&gt;buffer-&gt;data_size;trd-&gt;offsets_size = t-&gt;buffer-&gt;offsets_size;<span class="hljs-comment">// 在章节【client write request】里的 binder_transaction 里说过</span><span class="hljs-comment">// binder_transaction-&gt;binder_buffer 是从进程 B 的空闲虚存空间里 binder_alloc-&gt;free_buffers 挑选的满足大小的一块虚存</span><span class="hljs-comment">// 也即 binder_transaction-&gt;binder_buffer-&gt;user_data 指向 server 进程内的虚存</span><span class="hljs-comment">// 而这块虚存映射到内核内存空间里的物理内存（request 拷贝了一次到内核）</span>trd-&gt;data.ptr.buffer = (<span class="hljs-type">uintptr_t</span>)t-&gt;buffer-&gt;user_data;trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.buffer +<span class="hljs-built_in">ALIGN</span>(t-&gt;buffer-&gt;data_size,    <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));tr.secctx = t-&gt;security_ctx;<span class="hljs-keyword">if</span> (t-&gt;security_ctx) &#123;cmd = BR_TRANSACTION_SEC_CTX;trsize = <span class="hljs-built_in">sizeof</span>(tr);&#125;<span class="hljs-comment">// 往应用进程内存地址 buffer 写入 BR_TRANSACTION，实际上是应用进程的 IPCThreadState-&gt;mIn 这块内存空间</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr)) &#123;<span class="hljs-keyword">if</span> (t_from)<span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);<span class="hljs-built_in">binder_cleanup_transaction</span>(t, <span class="hljs-string">&quot;put_user failed&quot;</span>,   BR_FAILED_REPLY);<span class="hljs-keyword">return</span> -EFAULT;&#125;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-comment">// 往应用进程内存地址 buffer 写入 binder_transaction_data</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ptr, &amp;tr, trsize)) &#123;<span class="hljs-keyword">if</span> (t_from)<span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);<span class="hljs-built_in">binder_cleanup_transaction</span>(t, <span class="hljs-string">&quot;copy_to_user failed&quot;</span>,   BR_FAILED_REPLY);<span class="hljs-keyword">return</span> -EFAULT;&#125;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::waitForResponse</span><span class="hljs-params">(Parcel *reply, <span class="hljs-type">status_t</span> *acquireResult)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">uint32_t</span> cmd;    <span class="hljs-type">int32_t</span> err;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> ((err=<span class="hljs-built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// binder 给过来的数据被写入至 IPCThreadState-&gt;mIn</span>        err = mIn.<span class="hljs-built_in">errorCheck</span>();        <span class="hljs-keyword">if</span> (err &lt; NO_ERROR) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span> (mIn.<span class="hljs-built_in">dataAvail</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        cmd = (<span class="hljs-type">uint32_t</span>)mIn.<span class="hljs-built_in">readInt32</span>();        <span class="hljs-keyword">switch</span> (cmd) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">default</span>:            err = <span class="hljs-built_in">executeCommand</span>(cmd);            <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;            <span class="hljs-keyword">break</span>;        &#125;    &#125;finish:    <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;        <span class="hljs-keyword">if</span> (acquireResult) *acquireResult = err;        <span class="hljs-keyword">if</span> (reply) reply-&gt;<span class="hljs-built_in">setError</span>(err);        mLastError = err;        <span class="hljs-built_in">logExtendedError</span>();    &#125;    <span class="hljs-keyword">return</span> err;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::executeCommand</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd)</span></span><span class="hljs-function"></span>&#123;    BBinder* obj;    RefBase::weakref_type* refs;    <span class="hljs-type">status_t</span> result = NO_ERROR;    <span class="hljs-keyword">switch</span> ((<span class="hljs-type">uint32_t</span>)cmd) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">case</span> BR_TRANSACTION_SEC_CTX:    <span class="hljs-keyword">case</span> BR_TRANSACTION:        &#123;            binder_transaction_data_secctx tr_secctx;            binder_transaction_data&amp; tr = tr_secctx.transaction_data;            <span class="hljs-keyword">if</span> (cmd == (<span class="hljs-type">int</span>) BR_TRANSACTION_SEC_CTX) &#123;                result = mIn.<span class="hljs-built_in">read</span>(&amp;tr_secctx, <span class="hljs-built_in">sizeof</span>(tr_secctx));            &#125; <span class="hljs-keyword">else</span> &#123;                result = mIn.<span class="hljs-built_in">read</span>(&amp;tr, <span class="hljs-built_in">sizeof</span>(tr));                tr_secctx.secctx = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-built_in">ALOG_ASSERT</span>(result == NO_ERROR,                <span class="hljs-string">&quot;Not enough command data for brTRANSACTION&quot;</span>);            <span class="hljs-keyword">if</span> (result != NO_ERROR) <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// tr.data.ptr.buffer 是此应用进程的虚存地址，实际映射至内核物理内存里保存的 request 拷贝</span><span class="hljs-comment">// 用 Parcel 包装 tr.data.ptr.buffer 这块地址，然后交由 binder server impl 按照 aidl 协议逐个读取参数</span>            Parcel buffer;            buffer.<span class="hljs-built_in">ipcSetDataReference</span>(                <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(tr.data.ptr.buffer),                tr.data_size,                <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),                tr.offsets_size/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>), freeBuffer);            <span class="hljs-comment">// ...</span><span class="hljs-comment">// 还记得 BBinder 吗？赶紧回顾下【Binder IPC 过程中常用的对象和类】</span>Parcel reply;            <span class="hljs-keyword">if</span> (tr.target.ptr) &#123;                <span class="hljs-comment">// We only have a weak reference on the target object, so we must first try to</span>                <span class="hljs-comment">// safely acquire a strong reference before doing anything else with it.</span>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(                        tr.target.ptr)-&gt;<span class="hljs-built_in">attemptIncStrong</span>(<span class="hljs-keyword">this</span>)) &#123;                    error = <span class="hljs-built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="hljs-built_in">transact</span>(tr.code, buffer,                            &amp;reply, tr.flags);                    <span class="hljs-built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="hljs-built_in">decStrong</span>(<span class="hljs-keyword">this</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    error = UNKNOWN_TRANSACTION;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                error = the_context_object-&gt;<span class="hljs-built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);            &#125;            <span class="hljs-comment">// 如果不是 one way 还需要将 response/reply 发送给 client</span>            <span class="hljs-keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">LOG_ONEWAY</span>(<span class="hljs-string">&quot;Sending reply to %d!&quot;</span>, mCallingPid);                <span class="hljs-keyword">if</span> (error &lt; NO_ERROR) reply.<span class="hljs-built_in">setError</span>(error);                <span class="hljs-comment">// b/238777741: clear buffer before we send the reply.</span>                <span class="hljs-comment">// Otherwise, there is a race where the client may</span>                <span class="hljs-comment">// receive the reply and send another transaction</span>                <span class="hljs-comment">// here and the space used by this transaction won&#x27;t</span>                <span class="hljs-comment">// be freed for the client.</span>                buffer.<span class="hljs-built_in">setDataSize</span>(<span class="hljs-number">0</span>);                <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> kForwardReplyFlags = TF_CLEAR_BUF;                <span class="hljs-built_in">sendReply</span>(reply, (tr.flags &amp; kForwardReplyFlags));            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//...</span>&#125;<span class="hljs-type">status_t</span> IPCThreadState::<span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-type">bool</span> doReceive)&#123;    <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -EBADF;    &#125;    binder_write_read bwr;    <span class="hljs-comment">// Is the read buffer empty?</span>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> needRead = mIn.<span class="hljs-built_in">dataPosition</span>() &gt;= mIn.<span class="hljs-built_in">dataSize</span>();    <span class="hljs-comment">// We don&#x27;t want to write anything if we are still reading</span>    <span class="hljs-comment">// from data left in the input buffer and the caller</span>    <span class="hljs-comment">// has requested to read the next data.</span>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="hljs-built_in">dataSize</span>() : <span class="hljs-number">0</span>;    bwr.write_size = outAvail;    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>)mOut.<span class="hljs-built_in">data</span>();    <span class="hljs-comment">// binder_write_read.read_buffer 实际上指向 mIn</span>    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;        bwr.read_size = mIn.<span class="hljs-built_in">dataCapacity</span>();        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>)mIn.<span class="hljs-built_in">data</span>();    &#125; <span class="hljs-keyword">else</span> &#123;        bwr.read_size = <span class="hljs-number">0</span>;        bwr.read_buffer = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// Return immediately if there is nothing to do.</span>    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> NO_ERROR;    bwr.write_consumed = <span class="hljs-number">0</span>;    bwr.read_consumed = <span class="hljs-number">0</span>;    <span class="hljs-type">status_t</span> err;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)            err = NO_ERROR;        <span class="hljs-keyword">else</span>            err = -errno;        <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;            err = -EBADF;        &#125;    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);<span class="hljs-comment">// ...</span>&#125;</code></pre></div><h1 id="映射进程虚存与内核内存"><a href="#映射进程虚存与内核内存" class="headerlink" title="映射进程虚存与内核内存"></a>映射进程虚存与内核内存</h1><p><code>binder_alloc_new_buf</code> 寻找一块满足大小的进程虚存 <code>binder_buffer.user_data</code>，这块虚存是在进程在 mmap binder fd 时分配的，但当时并未给这块虚存映射物理页，参看 <a href="#binder_mmap">binder_mmap</a></p><p>同时会将这块虚存<a href="#%E5%88%86%E9%85%8D%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5">映射至内核物理内存</a>，将 request 拷贝至这里，然后 server 可以直接读取而不用将 request 拷贝至进程 B</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder_alloc.c</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * binder_alloc_new_buf() - Allocate a new binder buffer</span><span class="hljs-comment"> * @alloc:              binder_alloc for this proc</span><span class="hljs-comment"> * @data_size:          size of user data buffer</span><span class="hljs-comment"> * @offsets_size:       user specified buffer offset</span><span class="hljs-comment"> * @extra_buffers_size: size of extra space for meta-data (eg, security context)</span><span class="hljs-comment"> * @is_async:           buffer for async transaction</span><span class="hljs-comment"> * @pid:pid to attribute allocation to (used for debugging)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Allocate a new buffer given the requested sizes. Returns</span><span class="hljs-comment"> * the kernel version of the buffer pointer. The size allocated</span><span class="hljs-comment"> * is the sum of the three given sizes (each rounded up to</span><span class="hljs-comment"> * pointer-sized boundary)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Return:The allocated buffer or %NULL if error</span><span class="hljs-comment"> */</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *<span class="hljs-built_in">binder_alloc_new_buf</span>(<span class="hljs-keyword">struct</span> binder_alloc *alloc,   <span class="hljs-type">size_t</span> data_size,   <span class="hljs-type">size_t</span> offsets_size,   <span class="hljs-type">size_t</span> extra_buffers_size,   <span class="hljs-type">int</span> is_async,   <span class="hljs-type">int</span> pid)&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *buffer;<span class="hljs-built_in">mutex_lock</span>(&amp;alloc-&gt;mutex);buffer = <span class="hljs-built_in">binder_alloc_new_buf_locked</span>(alloc, data_size, offsets_size,     extra_buffers_size, is_async, pid);<span class="hljs-built_in">mutex_unlock</span>(&amp;alloc-&gt;mutex);<span class="hljs-keyword">return</span> buffer;&#125;<span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *<span class="hljs-built_in">binder_alloc_new_buf_locked</span>(<span class="hljs-keyword">struct</span> binder_alloc *alloc,<span class="hljs-type">size_t</span> data_size,<span class="hljs-type">size_t</span> offsets_size,<span class="hljs-type">size_t</span> extra_buffers_size,<span class="hljs-type">int</span> is_async,<span class="hljs-type">int</span> pid)&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> *n = alloc-&gt;free_buffers.rb_node;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *buffer;<span class="hljs-type">size_t</span> buffer_size;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> *best_fit = <span class="hljs-literal">NULL</span>;<span class="hljs-type">void</span> __user *has_page_addr;<span class="hljs-type">void</span> __user *end_page_addr;<span class="hljs-type">size_t</span> size, data_offsets_size;<span class="hljs-type">int</span> ret;<span class="hljs-built_in">mmap_read_lock</span>(alloc-&gt;mm);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_alloc_get_vma</span>(alloc)) &#123;<span class="hljs-built_in">mmap_read_unlock</span>(alloc-&gt;mm);<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_USER_ERROR,   <span class="hljs-string">&quot;%d: binder_alloc_buf, no vma\n&quot;</span>,   alloc-&gt;pid);<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-ESRCH);&#125;<span class="hljs-built_in">mmap_read_unlock</span>(alloc-&gt;mm);data_offsets_size = <span class="hljs-built_in">ALIGN</span>(data_size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *)) +<span class="hljs-built_in">ALIGN</span>(offsets_size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));<span class="hljs-keyword">if</span> (data_offsets_size &lt; data_size || data_offsets_size &lt; offsets_size) &#123;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,<span class="hljs-string">&quot;%d: got transaction with invalid size %zd-%zd\n&quot;</span>,alloc-&gt;pid, data_size, offsets_size);<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-EINVAL);&#125;size = data_offsets_size + <span class="hljs-built_in">ALIGN</span>(extra_buffers_size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));<span class="hljs-keyword">if</span> (size &lt; data_offsets_size || size &lt; extra_buffers_size) &#123;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,<span class="hljs-string">&quot;%d: got transaction with invalid extra_buffers_size %zd\n&quot;</span>,alloc-&gt;pid, extra_buffers_size);<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-EINVAL);&#125;<span class="hljs-keyword">if</span> (is_async &amp;&amp;    alloc-&gt;free_async_space &lt; size + <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> binder_buffer)) &#123;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,     <span class="hljs-string">&quot;%d: binder_alloc_buf size %zd failed, no async space left\n&quot;</span>,      alloc-&gt;pid, size);<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-ENOSPC);&#125;<span class="hljs-comment">/* Pad 0-size buffers so they get assigned unique addresses */</span>size = <span class="hljs-built_in">max</span>(size, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));    <span class="hljs-comment">// 对应章节【指导思想】里的步骤三</span>    <span class="hljs-comment">// 从目标进程（server）的空闲虚拟地址区间集合里（binder_alloc-&gt;free_buffers）找一块满足大小的（&gt;= size）binder_buffer 出来</span><span class="hljs-comment">// </span><span class="hljs-comment">// 空闲虚拟地址集合 binder_alloc-&gt;free_buffers 是一棵红黑树（平衡的二叉树），左孩子的地址空间比父亲小，右孩子比父亲大</span>    <span class="hljs-comment">// struct rb_node &#123;</span>    <span class="hljs-comment">// unsigned long  __rb_parent_color;</span>    <span class="hljs-comment">// struct rb_node *rb_right;</span>    <span class="hljs-comment">// struct rb_node *rb_left;</span>    <span class="hljs-comment">// &#125; __attribute__((aligned(sizeof(long))));</span><span class="hljs-comment">// </span><span class="hljs-comment">// 搜索二叉树，找到最匹配 size 大小的 buffer</span><span class="hljs-comment">// 从章节【binder_mmap】可知 binder_alloc-&gt;free_buffers 里默认会初始化一个 1M 大小的应用进程可用虚存</span><span class="hljs-keyword">while</span> (n) &#123;buffer = <span class="hljs-built_in">rb_entry</span>(n, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);  <span class="hljs-comment">// 从 rb_node 取出 binder_buffer 类型的 entry</span><span class="hljs-built_in">BUG_ON</span>(!buffer-&gt;free);buffer_size = <span class="hljs-built_in">binder_alloc_buffer_size</span>(alloc, buffer);<span class="hljs-keyword">if</span> (size &lt; buffer_size) &#123;  <span class="hljs-comment">// 如果 buffer 大小满足 size 要求则选中（best_fit）然后继续往左下走寻找更接近 size 的 buffer</span>best_fit = n;n = n-&gt;rb_left;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &gt; buffer_size)  <span class="hljs-comment">// buffer 大小不满足 size 要求，得继续往右下走找更大的 buffer</span>n = n-&gt;rb_right;<span class="hljs-keyword">else</span> &#123;                          <span class="hljs-comment">// buffer 大小刚好匹配 size，完美，无需继续寻找了</span>best_fit = n;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">// 没有满足 size 大小要求的空闲 binder_buffer 则返回错误码</span><span class="hljs-comment">// 此时说明 request or reponse 大小超过为 binder transaction 分配的虚存大小，会报以下错误：</span><span class="hljs-comment">// JavaBinder: !!! FAILED BINDER TRANSACTION !!! (parcel size = 2001452)</span><span class="hljs-keyword">if</span> (best_fit == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-type">size_t</span> allocated_buffers = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> largest_alloc_size = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> total_alloc_size = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> free_buffers = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> largest_free_size = <span class="hljs-number">0</span>;<span class="hljs-type">size_t</span> total_free_size = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (n = <span class="hljs-built_in">rb_first</span>(&amp;alloc-&gt;allocated_buffers); n != <span class="hljs-literal">NULL</span>;     n = <span class="hljs-built_in">rb_next</span>(n)) &#123;buffer = <span class="hljs-built_in">rb_entry</span>(n, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);buffer_size = <span class="hljs-built_in">binder_alloc_buffer_size</span>(alloc, buffer);allocated_buffers++;total_alloc_size += buffer_size;<span class="hljs-keyword">if</span> (buffer_size &gt; largest_alloc_size)largest_alloc_size = buffer_size;&#125;<span class="hljs-keyword">for</span> (n = <span class="hljs-built_in">rb_first</span>(&amp;alloc-&gt;free_buffers); n != <span class="hljs-literal">NULL</span>;     n = <span class="hljs-built_in">rb_next</span>(n)) &#123;buffer = <span class="hljs-built_in">rb_entry</span>(n, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);buffer_size = <span class="hljs-built_in">binder_alloc_buffer_size</span>(alloc, buffer);free_buffers++;total_free_size += buffer_size;<span class="hljs-keyword">if</span> (buffer_size &gt; largest_free_size)largest_free_size = buffer_size;&#125;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_USER_ERROR,   <span class="hljs-string">&quot;%d: binder_alloc_buf size %zd failed, no address space\n&quot;</span>,   alloc-&gt;pid, size);<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_USER_ERROR,   <span class="hljs-string">&quot;allocated: %zd (num: %zd largest: %zd), free: %zd (num: %zd largest: %zd)\n&quot;</span>,   total_alloc_size, allocated_buffers,   largest_alloc_size, total_free_size,   free_buffers, largest_free_size);<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-ENOSPC);&#125;<span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>) &#123;buffer = <span class="hljs-built_in">rb_entry</span>(best_fit, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);buffer_size = <span class="hljs-built_in">binder_alloc_buffer_size</span>(alloc, buffer);&#125;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,     <span class="hljs-string">&quot;%d: binder_alloc_buf size %zd got buffer %pK size %zd\n&quot;</span>,      alloc-&gt;pid, size, buffer, buffer_size);    <span class="hljs-comment">// 将应用进程虚存地址空间 [buffer-&gt;user_data, end_page_addr] 映射内核物理内存地址空间</span><span class="hljs-comment">// 这样应用进程写入此虚存空间的数据就有物理内存来存放了，并且是直接写入至 binder，无需从用户态拷贝至内核态</span><span class="hljs-comment">// 这里会真正进行内核物理页的分配，参看章节【分配内核物理页】</span><span class="hljs-comment">// 对应章节【指导思想】里的步骤四、五和六</span>has_page_addr = (<span class="hljs-type">void</span> __user *)(((<span class="hljs-type">uintptr_t</span>)buffer-&gt;user_data + buffer_size) &amp; PAGE_MASK);<span class="hljs-built_in">WARN_ON</span>(n &amp;&amp; buffer_size != size);end_page_addr =(<span class="hljs-type">void</span> __user *)<span class="hljs-built_in">PAGE_ALIGN</span>((<span class="hljs-type">uintptr_t</span>)buffer-&gt;user_data + size);<span class="hljs-keyword">if</span> (end_page_addr &gt; has_page_addr)end_page_addr = has_page_addr;ret = <span class="hljs-built_in">binder_update_page_range</span>(alloc, <span class="hljs-number">1</span>, (<span class="hljs-type">void</span> __user *)<span class="hljs-built_in">PAGE_ALIGN</span>((<span class="hljs-type">uintptr_t</span>)buffer-&gt;user_data), end_page_addr);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(ret);<span class="hljs-keyword">if</span> (buffer_size != size) &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *new_buffer;new_buffer = <span class="hljs-built_in">kzalloc</span>(<span class="hljs-built_in">sizeof</span>(*buffer), GFP_KERNEL);<span class="hljs-keyword">if</span> (!new_buffer) &#123;<span class="hljs-built_in">pr_err</span>(<span class="hljs-string">&quot;%s: %d failed to alloc new buffer struct\n&quot;</span>,       __func__, alloc-&gt;pid);<span class="hljs-keyword">goto</span> err_alloc_buf_struct_failed;&#125;new_buffer-&gt;user_data = (u8 __user *)buffer-&gt;user_data + size;<span class="hljs-built_in">list_add</span>(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);new_buffer-&gt;free = <span class="hljs-number">1</span>;<span class="hljs-built_in">binder_insert_free_buffer</span>(alloc, new_buffer);&#125;<span class="hljs-built_in">rb_erase</span>(best_fit, &amp;alloc-&gt;free_buffers);buffer-&gt;free = <span class="hljs-number">0</span>;buffer-&gt;allow_user_free = <span class="hljs-number">0</span>;<span class="hljs-built_in">binder_insert_allocated_buffer_locked</span>(alloc, buffer);<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,     <span class="hljs-string">&quot;%d: binder_alloc_buf size %zd got %pK\n&quot;</span>,      alloc-&gt;pid, size, buffer);buffer-&gt;data_size = data_size;buffer-&gt;offsets_size = offsets_size;buffer-&gt;async_transaction = is_async;buffer-&gt;extra_buffers_size = extra_buffers_size;buffer-&gt;pid = pid;buffer-&gt;oneway_spam_suspect = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (is_async) &#123;alloc-&gt;free_async_space -= size + <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> binder_buffer);<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,     <span class="hljs-string">&quot;%d: binder_alloc_buf size %zd async free %zd\n&quot;</span>,      alloc-&gt;pid, size, alloc-&gt;free_async_space);<span class="hljs-keyword">if</span> (alloc-&gt;free_async_space &lt; alloc-&gt;buffer_size / <span class="hljs-number">10</span>) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Start detecting spammers once we have less than 20%</span><span class="hljs-comment"> * of async space left (which is less than 10% of total</span><span class="hljs-comment"> * buffer size).</span><span class="hljs-comment"> */</span>buffer-&gt;oneway_spam_suspect = <span class="hljs-built_in">debug_low_async_space_locked</span>(alloc, pid);&#125; <span class="hljs-keyword">else</span> &#123;alloc-&gt;oneway_spam_detected = <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> buffer;err_alloc_buf_struct_failed:<span class="hljs-built_in">binder_update_page_range</span>(alloc, <span class="hljs-number">0</span>, (<span class="hljs-type">void</span> __user *) <span class="hljs-built_in">PAGE_ALIGN</span>((<span class="hljs-type">uintptr_t</span>)buffer-&gt;user_data), end_page_addr);<span class="hljs-keyword">return</span> <span class="hljs-built_in">ERR_PTR</span>(-ENOMEM);&#125;</code></pre></div><h1 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h1><p><code>open_driver(driver)</code> 得到 binder fd 后会执行 <code>binder_mmap</code> 分配所需的内存空间：</p><ol><li><p>应用进程分配 1M 的虚存至 <code>ProcessState.mVMStart</code>，这块虚存是还没有映射任何物理内存的</p></li><li><p>binder driver 初始化 <code>binder_alloc-&gt;free_buffers</code>，它代表空闲可用的应用进程虚存块，也即上面第一步分配的这块虚存；它是一棵红黑树，<code>binder_buffer-&gt;user_data</code> 记录了起始地址，节点间的起始地址差表示此节点的空间大小，最后一个节点表示应用进程开辟的虚存空间还剩余的大小</p></li><li><p>此时 binder driver 并没有相应地为此应用进程分配虚存</p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// ProcessState 是进程内单例，负责初始化应用进程与 binder driver 的连接（fd）</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/ProcessState.cpp</span>ProcessState::<span class="hljs-built_in">ProcessState</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver)          <span class="hljs-comment">// driver 参数是指 binder 的路径：/dev/binder</span>    : <span class="hljs-built_in">mDriverName</span>(<span class="hljs-built_in">String8</span>(driver))                      <span class="hljs-comment">// 记录 binder 路径</span>    , <span class="hljs-built_in">mDriverFD</span>(<span class="hljs-built_in">open_driver</span>(driver))                    <span class="hljs-comment">// 打开 binder 并记录下它的 fd</span>    , <span class="hljs-built_in">mVMStart</span>(MAP_FAILED)                              <span class="hljs-comment">// mmap 分配的一块内存空间，后续会用到</span>    , <span class="hljs-built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)    , <span class="hljs-built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)    , <span class="hljs-built_in">mExecutingThreadsCount</span>(<span class="hljs-number">0</span>)    , <span class="hljs-built_in">mWaitingForThreads</span>(<span class="hljs-number">0</span>)    , <span class="hljs-built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)    , <span class="hljs-built_in">mStarvationStartTimeMs</span>(<span class="hljs-number">0</span>)    , <span class="hljs-built_in">mThreadPoolStarted</span>(<span class="hljs-literal">false</span>)    , <span class="hljs-built_in">mThreadPoolSeq</span>(<span class="hljs-number">1</span>)    , <span class="hljs-built_in">mCallRestriction</span>(CallRestriction::NONE)&#123;    <span class="hljs-keyword">if</span> (mDriverFD &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span><span class="hljs-comment">// 应用进程开辟了 1M 的虚拟地址空间，用以 binder 间传输数据</span><span class="hljs-comment">// 注意此时只是在应用进程开辟了 1M 的虚拟内存，并没有映射物理内存</span>        mVMStart = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">nullptr</span>, BINDER_VM_SIZE <span class="hljs-comment">/* 1M */</span>, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (mVMStart == MAP_FAILED) &#123;            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="hljs-built_in">c_str</span>());            <span class="hljs-built_in">close</span>(mDriverFD);            mDriverFD = <span class="hljs-number">-1</span>;            mDriverName.<span class="hljs-built_in">clear</span>();        &#125;    &#125;&#125;<span class="hljs-comment">// 大概 1M 左右</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)</span><span class="hljs-comment">// 来到内核 binder driver 的 mmap 处理函数</span><span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;<span class="hljs-keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)<span class="hljs-keyword">return</span> -EINVAL;<span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_OPEN_CLOSE,     <span class="hljs-string">&quot;%s: %d %lx-%lx (%ld K) vma %lx pagep %lx\n&quot;</span>,     __func__, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end,     (vma-&gt;vm_end - vma-&gt;vm_start) / SZ_1K, vma-&gt;vm_flags,     (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">pgprot_val</span>(vma-&gt;vm_page_prot));<span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;<span class="hljs-built_in">pr_err</span>(<span class="hljs-string">&quot;%s: %d %lx-%lx %s failed %d\n&quot;</span>, __func__,       proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, <span class="hljs-string">&quot;bad vm_flags&quot;</span>, -EPERM);<span class="hljs-keyword">return</span> -EPERM;&#125;vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP;vma-&gt;vm_flags &amp;= ~VM_MAYWRITE;vma-&gt;vm_ops = &amp;binder_vm_ops;vma-&gt;vm_private_data = proc;<span class="hljs-keyword">return</span> <span class="hljs-built_in">binder_alloc_mmap_handler</span>(&amp;proc-&gt;alloc, vma);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * binder_alloc_mmap_handler() - map virtual address space for proc</span><span class="hljs-comment"> * @alloc:alloc structure for this proc</span><span class="hljs-comment"> * @vma:vma passed to mmap()</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Called by binder_mmap() to initialize the space specified in</span><span class="hljs-comment"> * vma for allocating binder buffers</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Return:</span><span class="hljs-comment"> *      0 = success</span><span class="hljs-comment"> *      -EBUSY = address space already mapped</span><span class="hljs-comment"> *      -ENOMEM = failed to map memory to given address space</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder_alloc.c</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binder_alloc_mmap_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_alloc *alloc,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ret;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *failure_string;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *buffer;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(vma-&gt;vm_mm != alloc-&gt;mm)) &#123;ret = -EINVAL;failure_string = <span class="hljs-string">&quot;invalid vma-&gt;vm_mm&quot;</span>;<span class="hljs-keyword">goto</span> err_invalid_mm;&#125;<span class="hljs-built_in">mutex_lock</span>(&amp;binder_alloc_mmap_lock);<span class="hljs-keyword">if</span> (alloc-&gt;buffer_size) &#123;ret = -EBUSY;failure_string = <span class="hljs-string">&quot;already mapped&quot;</span>;<span class="hljs-keyword">goto</span> err_already_mapped;&#125;<span class="hljs-comment">// vm_start 是应用进程虚拟地址空间的起始地址，vm_end 是结束地址</span><span class="hljs-comment">// vma-&gt;vm_end - vma-&gt;vm_start 就是应用进程内这块虚拟地址的大小，上面说过是 1M</span><span class="hljs-comment">// alloc-&gt;buffer      是应用进程的虚拟地址</span><span class="hljs-comment">// alloc-&gt;buffer_size 是这块内存空间的大小</span>alloc-&gt;buffer_size = <span class="hljs-built_in">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, vma-&gt;vm_end - vma-&gt;vm_start,   SZ_4M);<span class="hljs-built_in">mutex_unlock</span>(&amp;binder_alloc_mmap_lock);alloc-&gt;buffer = (<span class="hljs-type">void</span> __user *)vma-&gt;vm_start;    <span class="hljs-comment">// kcalloc — allocate memory for an array. The memory is set to zero.</span>    <span class="hljs-comment">// void* kcalloc (size_t n /* number of elements */, size_t size /* element size */, gfp_t flags);</span><span class="hljs-comment">// </span><span class="hljs-comment">// binder_alloc.pages 表示内核物理页，此时只是初始化了这个数组（索引表示第几页），并没有分配物理页</span><span class="hljs-comment">// 应用进程与 binder 进行数据传输时，会分配物理页并将应用进程虚存映射至此物理页，参看章节【分配内核物理页】</span>alloc-&gt;pages = <span class="hljs-built_in">kcalloc</span>(alloc-&gt;buffer_size / PAGE_SIZE,       <span class="hljs-built_in">sizeof</span>(alloc-&gt;pages[<span class="hljs-number">0</span>]),       GFP_KERNEL);<span class="hljs-keyword">if</span> (alloc-&gt;pages == <span class="hljs-literal">NULL</span>) &#123;ret = -ENOMEM;failure_string = <span class="hljs-string">&quot;alloc page array&quot;</span>;<span class="hljs-keyword">goto</span> err_alloc_pages_failed;&#125;    <span class="hljs-comment">// 初始化 binder driver fd 时就已经放了一个 binder_buffer 至 alloc-&gt;free_buffers</span>buffer = <span class="hljs-built_in">kzalloc</span>(<span class="hljs-built_in">sizeof</span>(*buffer), GFP_KERNEL);<span class="hljs-keyword">if</span> (!buffer) &#123;ret = -ENOMEM;failure_string = <span class="hljs-string">&quot;alloc buffer struct&quot;</span>;<span class="hljs-keyword">goto</span> err_alloc_buf_struct_failed;&#125;buffer-&gt;user_data = alloc-&gt;buffer;          <span class="hljs-comment">// binder_buffer 也记录了应用进程的虚存起始地址</span><span class="hljs-built_in">list_add</span>(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers);  <span class="hljs-comment">// alloc-&gt;buffers, list of all buffers for this proc</span>buffer-&gt;free = <span class="hljs-number">1</span>;<span class="hljs-built_in">binder_insert_free_buffer</span>(alloc, buffer);   <span class="hljs-comment">// alloc-&gt;free_buffers, rb tree of buffers available for allocation sorted by size</span>alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="hljs-number">2</span>;alloc-&gt;vma_addr = vma-&gt;vm_start;           <span class="hljs-comment">// 应用进程的虚存起始地址</span><span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// alloc-&gt;free_buffers 是一棵红黑树（平衡的二叉树）</span><span class="hljs-comment">// 左孩子内存空间较小，右孩子内存空间较大，这里的内存是用户进程的虚存</span><span class="hljs-comment">//</span><span class="hljs-comment">// 但 binder_buffer-&gt;user_data 只记录了虚存起始地址，并没有字段记录大小</span><span class="hljs-comment">// 这块地址的大小跟 binder_buffer 在红黑树上的位置有关，看 binder_alloc_buffer_size</span><span class="hljs-comment">// </span><span class="hljs-comment">// 1，如果 binder_buffer 是最后一个节点，那么它表示应用进程开辟的虚存空间还剩余的大小</span><span class="hljs-comment">// 2，否则此节点与下一节点的起始地址差（binder_buffer-&gt;user_data）就是此节点的空间大小</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_insert_free_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_alloc *alloc,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> binder_buffer *new_buffer)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> **p = &amp;alloc-&gt;free_buffers.rb_node;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_node</span> *parent = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *buffer;<span class="hljs-type">size_t</span> buffer_size;<span class="hljs-type">size_t</span> new_buffer_size;<span class="hljs-built_in">BUG_ON</span>(!new_buffer-&gt;free);new_buffer_size = <span class="hljs-built_in">binder_alloc_buffer_size</span>(alloc, new_buffer);<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,     <span class="hljs-string">&quot;%d: add free buffer, size %zd, at %pK\n&quot;</span>,      alloc-&gt;pid, new_buffer_size, new_buffer);<span class="hljs-keyword">while</span> (*p) &#123;parent = *p;buffer = <span class="hljs-built_in">rb_entry</span>(parent, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);<span class="hljs-built_in">BUG_ON</span>(!buffer-&gt;free);buffer_size = <span class="hljs-built_in">binder_alloc_buffer_size</span>(alloc, buffer);<span class="hljs-keyword">if</span> (new_buffer_size &lt; buffer_size)p = &amp;parent-&gt;rb_left;<span class="hljs-keyword">else</span>p = &amp;parent-&gt;rb_right;&#125;<span class="hljs-built_in">rb_link_node</span>(&amp;new_buffer-&gt;rb_node, parent, p);<span class="hljs-built_in">rb_insert_color</span>(&amp;new_buffer-&gt;rb_node, &amp;alloc-&gt;free_buffers);&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title">binder_alloc_buffer_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_alloc *alloc,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_buffer *buffer)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">list_is_last</span>(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers))<span class="hljs-keyword">return</span> alloc-&gt;buffer + alloc-&gt;buffer_size - buffer-&gt;user_data;<span class="hljs-keyword">return</span> <span class="hljs-built_in">binder_buffer_next</span>(buffer)-&gt;user_data - buffer-&gt;user_data;&#125;</code></pre></div><h1 id="分配内核物理页"><a href="#分配内核物理页" class="headerlink" title="分配内核物理页"></a>分配内核物理页</h1><blockquote><p><code>struct vm_area_struct</code></p><p>This struct describes a virtual memory area. There is one of these per VM-area/task. A VM area is any part of the process virtual memory space that has a special rule for the page-fault handlers (ie a shared library, the executable area etc).</p><p>虚存管理的最基本的管理单元，描述了一段连续的、具有相同访问属性的虚存空间，该虚存空间的大小为物理内存页面的整数倍</p></blockquote><blockquote><p><code>int vm_insert_page(struct vm_area_struct *vma, unsigned long addr, struct page *page)</code></p><p>vma - user vma to map to, addr - target user address of this page, page - source kernel page</p><p>This allows drivers to insert individual pages they’ve allocated into a user vma.</p><p>一般用在驱动的 mmap 操作里，建立内核物理内存与用户虚拟地址空间的映射关系；驱动的常见套路是不会立即为用户虚拟地址空间分配物理内存，而是当访问虚拟地址空间时产生缺页中断，此时才真正地为缺页分配物理内存</p></blockquote><p><a href="#binder_mmap">binder_mmap</a> 应用进程已经开辟了一块虚存用以与 binder 进行数据传输，但并没有为它映射物理页，直到真正访问这块虚存时才会在内核分配物理页</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 为 [start, end] 映射内核物理页（binder_proc.pages）</span><span class="hljs-comment">// [start, end] 是一块应用进程的虚拟地址空间，它是在初始化 binder driver fd 时分配的，参见【binder_mmap】章节</span><span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder_alloc.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_update_page_range</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_alloc *alloc, <span class="hljs-type">int</span> allocate <span class="hljs-comment">/* true - 映射物理页，false - 取消映射 */</span>,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span> __user *start, <span class="hljs-type">void</span> __user *end)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">void</span> __user *page_addr;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> user_page_addr;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_lru_page</span> *page;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">vm_area_struct</span> *vma = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = <span class="hljs-literal">NULL</span>;<span class="hljs-type">bool</span> need_mm = <span class="hljs-literal">false</span>;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_BUFFER_ALLOC,     <span class="hljs-string">&quot;%d: %s pages %pK-%pK\n&quot;</span>, alloc-&gt;pid,     allocate ? <span class="hljs-string">&quot;allocate&quot;</span> : <span class="hljs-string">&quot;free&quot;</span>, start, end);<span class="hljs-keyword">if</span> (end &lt;= start)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-built_in">trace_binder_update_page_range</span>(alloc, allocate, start, end);<span class="hljs-keyword">if</span> (allocate == <span class="hljs-number">0</span>)<span class="hljs-keyword">goto</span> free_range;    <span class="hljs-comment">// binder_alloc.pages 是 binder_lru_page 类型的数组，表示内核物理内存空间，用以在应用进程和 binder 之间传输数据</span><span class="hljs-comment">// binder 按页大小（PAGE_SIZE）管理这块物理内存空间，数组索引代表第几页，binder_lru_page.page_ptr 指向物理页的地址</span><span class="hljs-comment">// 早在 binder_alloc_mmap_handler() 时就已经按应用进程 mmap 的大小（1M）初始化了这个数组，参看章节【binder_mmap】</span><span class="hljs-comment">// 这里是看虚拟内存空间 [start, end] 有没映射至内核物理地址页，没有的话用 need_mm 标识需要映射</span><span class="hljs-keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;buffer) / PAGE_SIZE];<span class="hljs-keyword">if</span> (!page-&gt;page_ptr) &#123;need_mm = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (need_mm &amp;&amp; <span class="hljs-built_in">mmget_not_zero</span>(alloc-&gt;mm))mm = alloc-&gt;mm;    <span class="hljs-comment">// 通过应用进程虚拟内存起始地址找到这块虚存的描述 vm_area_struct</span><span class="hljs-keyword">if</span> (mm) &#123;<span class="hljs-built_in">mmap_read_lock</span>(mm);vma = <span class="hljs-built_in">vma_lookup</span>(mm, alloc-&gt;vma_addr);&#125;<span class="hljs-keyword">if</span> (!vma &amp;&amp; need_mm) &#123;<span class="hljs-built_in">binder_alloc_debug</span>(BINDER_DEBUG_USER_ERROR,   <span class="hljs-string">&quot;%d: binder_alloc_buf failed to map pages in userspace, no vma\n&quot;</span>,   alloc-&gt;pid);<span class="hljs-keyword">goto</span> err_no_vma;&#125;    <span class="hljs-comment">// 一页页地映射应用进程虚存地址空间 [start, end]</span><span class="hljs-comment">// 这块虚存是在 [alloc-&gt;buffer, alloc-&gt;buffer + alloc.buffer_size] 区间内的，参看章节【binder_mmap】</span><span class="hljs-keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;<span class="hljs-type">int</span> ret;<span class="hljs-type">bool</span> on_lru;<span class="hljs-type">size_t</span> index;        <span class="hljs-comment">// 算出这页虚存对应哪页物理内存</span>index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE;page = &amp;alloc-&gt;pages[index];<span class="hljs-keyword">if</span> (page-&gt;page_ptr) &#123;  <span class="hljs-comment">// 物理页已分配则跳过</span><span class="hljs-built_in">trace_binder_alloc_lru_start</span>(alloc, index);on_lru = <span class="hljs-built_in">list_lru_del</span>(&amp;binder_alloc_lru, &amp;page-&gt;lru);<span class="hljs-built_in">WARN_ON</span>(!on_lru);<span class="hljs-built_in">trace_binder_alloc_lru_end</span>(alloc, index);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WARN_ON</span>(!vma))<span class="hljs-keyword">goto</span> err_page_ptr_cleared;        <span class="hljs-comment">// 真正在内核物理内存空间分配一页物理页</span><span class="hljs-comment">// 对应章节【指导思想】里的步骤四</span><span class="hljs-built_in">trace_binder_alloc_page_start</span>(alloc, index);page-&gt;page_ptr = <span class="hljs-built_in">alloc_page</span>(GFP_KERNEL |    __GFP_HIGHMEM |    __GFP_ZERO);<span class="hljs-keyword">if</span> (!page-&gt;page_ptr) &#123;<span class="hljs-built_in">pr_err</span>(<span class="hljs-string">&quot;%d: binder_alloc_buf failed for page at %pK\n&quot;</span>,alloc-&gt;pid, page_addr);<span class="hljs-keyword">goto</span> err_alloc_page_failed;&#125;page-&gt;alloc = alloc;<span class="hljs-built_in">INIT_LIST_HEAD</span>(&amp;page-&gt;lru);        <span class="hljs-comment">// 然后将应用进程虚存页映射到内核物理页 </span><span class="hljs-comment">// 对应章节【指导思想】里的步骤五</span>user_page_addr = (<span class="hljs-type">uintptr_t</span>)page_addr;ret = <span class="hljs-built_in">vm_insert_page</span>(vma, user_page_addr, page[<span class="hljs-number">0</span>].page_ptr);<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-built_in">pr_err</span>(<span class="hljs-string">&quot;%d: binder_alloc_buf failed to map page at %lx in userspace\n&quot;</span>,       alloc-&gt;pid, user_page_addr);<span class="hljs-keyword">goto</span> err_vm_insert_page_failed;&#125;<span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &gt; alloc-&gt;pages_high)alloc-&gt;pages_high = index + <span class="hljs-number">1</span>;<span class="hljs-built_in">trace_binder_alloc_page_end</span>(alloc, index);&#125;<span class="hljs-keyword">if</span> (mm) &#123;<span class="hljs-built_in">mmap_read_unlock</span>(mm);<span class="hljs-built_in">mmput</span>(mm);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 看下是如何取消映射的</span><span class="hljs-comment">// 依然是按页大小（PAGE_SIZE）遍历应用进程虚存空间 [start, end]，这里是从高地址开始</span>free_range:<span class="hljs-keyword">for</span> (page_addr = end - PAGE_SIZE; <span class="hljs-number">1</span>; page_addr -= PAGE_SIZE) &#123;<span class="hljs-type">bool</span> ret;<span class="hljs-type">size_t</span> index;index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE;page = &amp;alloc-&gt;pages[index];<span class="hljs-built_in">trace_binder_free_lru_start</span>(alloc, index);        <span class="hljs-comment">// list_lru_add 和 list_lru_del 是一套帮助内存 shrink 的 API，目前还没搞清楚它是怎么运行的</span>ret = <span class="hljs-built_in">list_lru_add</span>(&amp;binder_alloc_lru, &amp;page-&gt;lru);<span class="hljs-built_in">WARN_ON</span>(!ret);<span class="hljs-built_in">trace_binder_free_lru_end</span>(alloc, index);<span class="hljs-keyword">if</span> (page_addr == start)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">continue</span>;err_vm_insert_page_failed:__free_page(page-&gt;page_ptr);page-&gt;page_ptr = <span class="hljs-literal">NULL</span>;err_alloc_page_failed:err_page_ptr_cleared:<span class="hljs-keyword">if</span> (page_addr == start)<span class="hljs-keyword">break</span>;&#125;err_no_vma:<span class="hljs-keyword">if</span> (mm) &#123;<span class="hljs-built_in">mmap_read_unlock</span>(mm);<span class="hljs-built_in">mmput</span>(mm);&#125;<span class="hljs-keyword">return</span> vma ? -ENOMEM : -ESRCH;&#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/cyrus-lin/bookmark/issues/46">Binder | 内存拷贝的本质和变迁 - 芦半山 - 稀土掘金</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder IPC 线程调度模型</title>
    <link href="/2022/12/07/binder-threads/"/>
    <url>/2022/12/07/binder-threads/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/2022-12-07-binder-threads/1.png" alt="1.png"></p><h1 id="主线程与普通线程"><a href="#主线程与普通线程" class="headerlink" title="主线程与普通线程"></a>主线程与普通线程</h1><p>Binder 线程可以分为两类：<code>主线程</code> 和 <code>普通线程</code>，它们的区别是：</p><ol><li><p>主线程名称为 <code>Binder_1</code> or <code>Binder:&lt;pid&gt;_1</code>，普通线程则从 2 开始（<code>ProcessState::makeBinderThreadName</code>）</p></li><li><p>主线程在应用进程起来后立刻启动，且不会退出；普通线程由 <a href="#%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B">BR_SPAWN_LOOPER</a> 启动且会被 binder driver 命令 <code>TIMED_OUT</code> 退出（<code>IPCThreadState::joinThreadPool</code>）</p></li><li><p>binder 线程上限（<code>BINDER_SET_MAX_THREADS</code>）只影响普通线程，更确切地说是只影响通过 <code>BR_SPAWN_LOOPER - BC_REGISTER_LOOPER</code> 创建的 binder 线程</p></li></ol><p>Binder 主线程是在其所在进程的初始化流程里启动的，Java 层进程的创建都是通过 <a href="/2021/03/02/how-application-being-created-and-init/">Process.start()</a> 方法，向 Zygote 进程发出创建进程的 socket 消息，Zygote 进程收到消息后会调用 <code>Zygote.forkAndSpecialize()</code> 来 fork 出新进程，在新进程中会调用到 <code>RuntimeInit.nativeZygoteInit()</code> 方法，该方法经过 jni 映射最终会调用到 <code>app_main.cpp</code> 中的 <code>onZygoteInit</code>，那么接下来从这个方法说起</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The main function called when started through the zygote process. This could be unified with</span><span class="hljs-comment"> * main(), if the native code in nativeFinishInit() were rationalized with Zygote startup.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> Runnable <span class="hljs-title">zygoteInit</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSdkVersion, <span class="hljs-type">long</span>[] disabledCompatChanges,</span></span><span class="hljs-params"><span class="hljs-function">        String[] argv, ClassLoader classLoader)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    ZygoteInit.<span class="hljs-built_in">nativeZygoteInit</span>();    <span class="hljs-keyword">return</span> RuntimeInit.<span class="hljs-built_in">applicationInit</span>(targetSdkVersion, disabledCompatChanges, argv,            classLoader);&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/AndroidRuntime.cpp</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="hljs-params">(JNIEnv* env, jobject clazz)</span></span><span class="hljs-function"></span>&#123;    gCurRuntime-&gt;<span class="hljs-built_in">onZygoteInit</span>();  <span class="hljs-comment">// AppRuntime-&gt;onZygoteInit()</span>&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/cmds/app_process/app_main.cpp</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onZygoteInit</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 上面介绍过，ProcessState 是单例模式，初始化实例时会：</span>    <span class="hljs-comment">// 1，打开 binder driver：open(&quot;/dev/binder&quot;) &amp;&amp; mmap</span>    <span class="hljs-comment">// 2，版本查询和校验：BINDER_VERSION</span>    <span class="hljs-comment">// 3，设置线程数：BINDER_SET_MAX_THREADS</span>    <span class="hljs-comment">// ...</span>    sp&lt;ProcessState&gt; proc = ProcessState::<span class="hljs-built_in">self</span>();    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;App process: starting thread pool.\n&quot;</span>);    proc-&gt;<span class="hljs-built_in">startThreadPool</span>();&#125;<span class="hljs-comment">// 开启 binder 主线程执行 binder 消息通讯的 loop：IPCThreadState::self()-&gt;joinThreadPool = talkWithDriver + executeCommand</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/ProcessState.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::startThreadPool</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    AutoMutex _l(mLock);    <span class="hljs-keyword">if</span> (!mThreadPoolStarted) &#123;        mThreadPoolStarted = <span class="hljs-literal">true</span>;        <span class="hljs-built_in">spawnPooledThread</span>(<span class="hljs-literal">true</span>);    &#125;&#125;<span class="hljs-comment">// spawn - 产卵</span><span class="hljs-comment">// spawnPooledThread 是创建 binder 线程的核心函数，它创建新线程执行 IPCThreadState::joinThreadPool</span><span class="hljs-comment">// 新的 binder 线程的生命流程：</span><span class="hljs-comment">// 1，往 binder 发送 BC_ENTER_LOOPER（主线程） or BC_REGISTER_LOOPER（普通线程）</span><span class="hljs-comment">// 2. 主循环：getAndExecuteCommand()</span><span class="hljs-comment">// 3. 退出循环时发送 BC_EXIT_LOOPER 给 binder driver</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::spawnPooledThread</span><span class="hljs-params">(<span class="hljs-type">bool</span> isMain <span class="hljs-comment">/* true 表示主线程 */</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (mThreadPoolStarted) &#123;        String8 name = <span class="hljs-built_in">makeBinderThreadName</span>();  <span class="hljs-comment">// Binder_x or Binder:&lt;pid&gt;_x</span>        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Spawning new pooled thread, name=%s\n&quot;</span>, name.<span class="hljs-built_in">string</span>());        sp&lt;Thread&gt; t = sp&lt;PoolThread&gt;::<span class="hljs-built_in">make</span>(isMain);        t-&gt;<span class="hljs-built_in">run</span>(name.<span class="hljs-built_in">string</span>());        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mThreadCountLock);        mKernelStartedThreads++;        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mThreadCountLock);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PoolThread</span> : <span class="hljs-keyword">public</span> Thread&#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">joinThreadPool</span>(mIsMain);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IPCThreadState::joinThreadPool</span><span class="hljs-params">(<span class="hljs-type">bool</span> isMain)</span>    <span class="hljs-comment">// binder 线程的整个生命流程</span></span><span class="hljs-function"></span>&#123;    mOut.<span class="hljs-built_in">writeInt32</span>(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);    <span class="hljs-type">status_t</span> result;    mIsLooper = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-built_in">processPendingDerefs</span>();        <span class="hljs-comment">// now get the next command to be processed, waiting if necessary</span>        result = <span class="hljs-built_in">getAndExecuteCommand</span>();        <span class="hljs-comment">// Let this thread exit the thread pool if it is no longer</span>        <span class="hljs-comment">// needed and it is not the main process thread.</span>        <span class="hljs-keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;  <span class="hljs-comment">// 可以看到主线程与普通线程的区别之一：主线程永远不会主动退出</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125; <span class="hljs-keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);    mOut.<span class="hljs-built_in">writeInt32</span>(BC_EXIT_LOOPER);    mIsLooper = <span class="hljs-literal">false</span>;    <span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">// 主线程注册（BC_REGISTER_LOOPER）和普通线程注册（BC_ENTER_LOOPER）很类似</span><span class="hljs-comment">// 都是打开标志位 BINDER_LOOPER_STATE_ENTERED or BINDER_LOOPER_STATE_REGISTERED</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_size_t</span> *consumed)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">case</span> BC_REGISTER_LOOPER:<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123;thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d ERROR: BC_REGISTER_LOOPER called after BC_ENTER_LOOPER\n&quot;</span>,proc-&gt;pid, thread-&gt;pid);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proc-&gt;requested_threads == <span class="hljs-number">0</span>) &#123;thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d ERROR: BC_REGISTER_LOOPER called without request\n&quot;</span>,proc-&gt;pid, thread-&gt;pid);&#125; <span class="hljs-keyword">else</span> &#123;proc-&gt;requested_threads--;proc-&gt;requested_threads_started++;&#125;thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> BC_ENTER_LOOPER:<span class="hljs-keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d ERROR: BC_ENTER_LOOPER called after BC_REGISTER_LOOPER\n&quot;</span>,proc-&gt;pid, thread-&gt;pid);&#125;thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;<span class="hljs-keyword">break</span>;&#125;</code></pre></div><h2 id="binder-线程命名"><a href="#binder-线程命名" class="headerlink" title="binder 线程命名"></a>binder 线程命名</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// binder 线程命名规则：Binder_x（如果 &gt;= Android N 则是 Binder:&lt;pid&gt;_x）</span><span class="hljs-comment">// 其中的 x 从 1 开始</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/ProcessState.cpp</span><span class="hljs-function">String8 <span class="hljs-title">ProcessState::makeBinderThreadName</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int32_t</span> s = <span class="hljs-built_in">android_atomic_add</span>(<span class="hljs-number">1</span>, &amp;mThreadPoolSeq);    <span class="hljs-type">pid_t</span> pid = <span class="hljs-built_in">getpid</span>();    std::string_view driverName = mDriverName.<span class="hljs-built_in">c_str</span>();    android::base::<span class="hljs-built_in">ConsumePrefix</span>(&amp;driverName, <span class="hljs-string">&quot;/dev/&quot;</span>);    String8 name;    name.<span class="hljs-built_in">appendFormat</span>(<span class="hljs-string">&quot;%.*s:%d_%X&quot;</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(driverName.<span class="hljs-built_in">length</span>()), driverName.<span class="hljs-built_in">data</span>(), pid,                      s);    <span class="hljs-keyword">return</span> name;&#125;ProcessState::<span class="hljs-built_in">ProcessState</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)      : <span class="hljs-built_in">mDriverName</span>(<span class="hljs-built_in">String8</span>(driver)),        <span class="hljs-built_in">mDriverFD</span>(<span class="hljs-number">-1</span>),        <span class="hljs-built_in">mVMStart</span>(MAP_FAILED),        <span class="hljs-built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER),        <span class="hljs-built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER),        <span class="hljs-built_in">mExecutingThreadsCount</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mWaitingForThreads</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS),        <span class="hljs-built_in">mCurrentThreads</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mKernelStartedThreads</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mStarvationStartTimeMs</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mForked</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mThreadPoolStarted</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mThreadPoolSeq</span>(<span class="hljs-number">1</span>),    <span class="hljs-comment">// binder 线程名的序号从 1 开始</span>        <span class="hljs-built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;<span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="创建普通线程"><a href="#创建普通线程" class="headerlink" title="创建普通线程"></a>创建普通线程</h2><p>流程概览：binder driver 在满足以下条件的情况下，发送 <code>BR_SPAWN_LOOPER</code> 给应用进程，应用进程开启新线程 <code>ProcessState::spawnPooledThread(false)</code> 后，发送 <code>BC_REGISTER_LOOPER</code> 告知 binder driver 线程已启动</p><p>有三种情况可以进入 <code>binder_thread_read</code> done 代码段：</p><ol><li><p>当 binder driver 处理类型为 <code>BINDER_WORK_TRANSACTION</code> 的任务，即 binder driver 收到的命令是 <code>BC_TRANSACTION</code>（client 发送 request 至 binder） or <code>BC_REPLY</code>（server 响应 response 至 binder）</p></li><li><p>当前线程的 return_error 发生 error</p></li><li><p>Binder Driver 向 client 发送死亡通知 <code>BR_DEAD_BINDER</code></p></li></ol><p>按需启动普通 binder 线程的条件：</p><ol><li>进程没有请求创建 binder 线程 <code>proc-&gt;requested_threads == 0</code></li></ol><blockquote><p>@requested_threads: number of binder threads requested but not yet started. In current implementation, can only be 0 or 1.</p></blockquote><p>binder 发送 <code>BR_SPAWN_LOOPER</code> 给应用进程后将 requested_threads 置真，直到应用进程将新线程启动并回复 <code>BC_REGISTER_LOOPER</code> 后才将 requested_threads 置假</p><ol start="2"><li>没有等待/阻塞在进程 todo list 的 client thread，<code>list_empty(&amp;thread-&gt;proc-&gt;waiting_threads)</code></li></ol><blockquote><p>@waiting_threads: threads currently waiting for proc work</p></blockquote><p>参考 <a href="#client-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%BE%8B%E5%AD%90">client 线程调度例子</a> 里的 <code>binder_wait_for_work</code></p><ol start="3"><li>已启动的 binder 线程数小于上限，<code>proc-&gt;requested_threads_started &lt; proc-&gt;max_threads</code></li></ol><p>binder 线程池上限默认 15，可通过 <code>BINDER_SET_MAX_THREADS</code> 修改</p><ol start="4"><li>当前线程已从应用进程收到 <code>BC_ENTER_LOOPER</code> or <code>BC_REGISTER_LOOPER</code>，<code>thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)</code></li></ol><p>参考 <a href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BA%BF%E7%A8%8B">主线程与普通线程</a></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_size_t</span> *consumed, <span class="hljs-type">int</span> non_block)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// ...</span>done:*consumed = ptr - buffer;<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (proc-&gt;requested_threads == <span class="hljs-number">0</span> &amp;&amp;    <span class="hljs-built_in">list_empty</span>(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |     BINDER_LOOPER_STATE_ENTERED)) <span class="hljs-comment">/* the user-space code fails to */</span>     <span class="hljs-comment">/*spawn a new thread if we leave this out */</span>) &#123;proc-&gt;requested_threads++;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(BR_SPAWN_LOOPER, (<span class="hljs-type">uint32_t</span> __user *)buffer))<span class="hljs-keyword">return</span> -EFAULT;<span class="hljs-built_in">binder_stat_br</span>(proc, thread, BR_SPAWN_LOOPER);&#125; <span class="hljs-keyword">else</span><span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 应用进程收到 BR_SPAWN_LOOPER 后启动新的 binder 普通线程，参考【主线程与普通线程】对 spawnPooledThread(false) 的解析</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:system/libhwbinder/IPCThreadState.cpp</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::executeCommand</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">case</span> BR_SPAWN_LOOPER:        mProcess-&gt;<span class="hljs-built_in">spawnPooledThread</span>(<span class="hljs-literal">false</span>);        <span class="hljs-keyword">break</span>;&#125;</code></pre></div><h1 id="client-线程调度例子"><a href="#client-线程调度例子" class="headerlink" title="client 线程调度例子"></a>client 线程调度例子</h1><p>一次事务 <code>binder_thread.transaction_stack</code> 表示：client 发起请求 -&gt; server 处理并返回响应 -&gt; client 收到响应这么一整个流程，类似于一次完整的 HTTP 请求</p><p>client 是单线程即发起 Binder IPC 的那个线程，将 request 添加到目标进程 <code>binder_proc.todo</code> 或者目标线程 <code>binder_thread.todo</code> 的任务列表后，通过 <code>schedule()</code> 让渡出 cpu 资源从而实现 <a href="https://github.com/cyrus-lin/bookmark/issues/45">线程休眠</a>，直到 server 返回响应唤醒它（<code>wake_up</code>）</p><p><code>binder_thread_write</code> 将 request 添加到目标进程/目标线程的 todo 任务队列，<code>binder_thread_read</code> 将休眠此 client 线程直到被 server reponse 唤醒</p><div class="code-wrapper"><pre><code class="hljs cpp">ActivityManager.getRunningAppProcesses                                                 <span class="hljs-comment">// APP 进程 Java 层</span>IServiceManager.Stub.Proxy.getRunningAppProcessesBinderProxy.<span class="hljs-built_in">transact</span>(<span class="hljs-type">int</span> code, Parcel data, Parcel reply, <span class="hljs-type">int</span> flags)BpBinder.<span class="hljs-built_in">transact</span>(<span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)    <span class="hljs-comment">// APP 进程 native 层</span>IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">transact</span>(<span class="hljs-built_in">binderHandle</span>(), code, data, reply, flags)IPCThreadState::<span class="hljs-built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">nullptr</span>)IPCThreadState::<span class="hljs-built_in">waitForResponse</span>(Parcel *reply, <span class="hljs-type">status_t</span> *acquireResult)IPCThreadState::<span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-type">bool</span> doReceive)<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)                                     <span class="hljs-comment">// 陷入内核来到 binder driver</span>binder_ioctl<span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread <span class="hljs-comment">/* 当前线程，此时即是 client 执行 request 的线程 */</span> )</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = _IOC_SIZE(cmd);    <span class="hljs-comment">// sizeof(struct binder_write_read)</span>    <span class="hljs-type">void</span> __user *ubuf = (<span class="hljs-type">void</span> __user *)arg;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> bwr;    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> binder_write_read)) &#123;        ret = -EINVAL;        <span class="hljs-keyword">goto</span> out;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="hljs-built_in">sizeof</span>(bwr))) &#123;  <span class="hljs-comment">// 从用户进程地址空间拷贝 struct binder_write_read 至内核</span>        ret = -EFAULT;        <span class="hljs-keyword">goto</span> out;    &#125;    <span class="hljs-comment">// binder_write_read.write_size &gt; 0 表示用户进程有数据发送到内核驱动</span><span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_write</span>(proc, thread,  bwr.write_buffer,  bwr.write_size,  &amp;bwr.write_consumed);<span class="hljs-built_in">trace_binder_write_done</span>(ret);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;bwr.read_consumed = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;    <span class="hljs-comment">// binder_write_read.read_size &gt; 0 表示用户进程希望内核驱动返回 read_size 大小的数据给他</span><span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);<span class="hljs-built_in">trace_binder_read_done</span>(ret);<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))<span class="hljs-built_in">binder_wakeup_proc_ilocked</span>(proc);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr))) &#123;  <span class="hljs-comment">// 处理成功，将 struct binder_write_read 从内核拷贝/覆盖至用户进程空间</span>        ret = -EFAULT;        <span class="hljs-keyword">goto</span> out;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 将数据 binder_buffer 从用户内存空间发送到内核地址空间</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">binder_uintptr_t</span> binder_buffer,  <span class="hljs-comment">/* binder_write_read.write_buffer */</span> </span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">size_t</span> size,                     <span class="hljs-comment">/* binder_write_read.write_size */</span></span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">binder_size_t</span> *consumed)</span>         <span class="hljs-comment">/* 输出，从 write_buffer 读取了多少数据 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">uint32_t</span> cmd;    <span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;  <span class="hljs-comment">// write_buffer 起始地址</span>    <span class="hljs-type">void</span> __user *ptr = buffer + *consumed;                          <span class="hljs-comment">// 指示器，标识下一次读取的位置</span>    <span class="hljs-type">void</span> __user *end = buffer + size;                               <span class="hljs-comment">// write_buffer 结束地址</span>    <span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))                  <span class="hljs-comment">// 从用户内存空间 write_buffer 拷贝 4 bytes 到 cmd</span>            <span class="hljs-keyword">return</span> -EFAULT;        ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);        <span class="hljs-built_in">trace_binder_command</span>(cmd);        <span class="hljs-keyword">if</span> (_IOC_NR(cmd) &lt; <span class="hljs-built_in">ARRAY_SIZE</span>(binder_stats.bc)) &#123;            binder_stats.bc[_IOC_NR(cmd)]++;            proc-&gt;stats.bc[_IOC_NR(cmd)]++;            thread-&gt;stats.bc[_IOC_NR(cmd)]++;        &#125;        <span class="hljs-keyword">switch</span> (cmd) &#123;                          <span class="hljs-comment">// write 是指将数据从用户内存空间发送到内核内存空间</span>        <span class="hljs-keyword">case</span> BC_TRANSACTION:                    <span class="hljs-comment">// 客户端的请求数据 client request</span>        <span class="hljs-keyword">case</span> BC_REPLY: &#123;                        <span class="hljs-comment">// 服务端的响应数据 server response</span>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> tr;  <span class="hljs-comment">// 它们使用的数据结构都是 binder_transaction_data</span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;tr, ptr, <span class="hljs-built_in">sizeof</span>(tr)))                <span class="hljs-keyword">return</span> -EFAULT;            ptr += <span class="hljs-built_in">sizeof</span>(tr);            binder_transaction**(proc, thread, &amp;tr, cmd == BC_REPLY);            <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-comment">// ...</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_transaction</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">struct</span> binder_transaction_data *tr, </span></span><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">int</span> reply)</span>    <span class="hljs-comment">// false: client request, true: server response</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction</span> *t;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_work</span> *tcomplete;    <span class="hljs-type">binder_size_t</span> *offp, *off_end;    <span class="hljs-type">binder_size_t</span> off_min;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *target_proc;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_thread</span> *target_thread = <span class="hljs-literal">NULL</span>;**    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_node</span> *target_node = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *target_list;    <span class="hljs-type">wait_queue_head_t</span> *target_wait;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction</span> *in_reply_to = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_log_entry</span> *e;    <span class="hljs-type">uint32_t</span> return_error;    e = <span class="hljs-built_in">binder_transaction_log_add</span>(&amp;binder_transaction_log);    e-&gt;call_type = reply ? <span class="hljs-number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);    e-&gt;from_proc = proc-&gt;pid;    e-&gt;from_thread = thread-&gt;pid;    e-&gt;target_handle = tr-&gt;target.handle;    e-&gt;data_size = tr-&gt;data_size;    e-&gt;offsets_size = tr-&gt;offsets_size;        <span class="hljs-keyword">if</span> (reply) &#123;                    <span class="hljs-comment">// BC_REPLY 说明这是一个 Server 发给 Client 的事务处理回复，在 server 端的线程上</span>        <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// BC_TRANSACTION 说明这是一个 Client 发给 Server 的请求事务，在 Client 端线程上</span>        <span class="hljs-keyword">if</span> (tr-&gt;target.handle) &#123;    <span class="hljs-comment">// 确定目标进程 target_proc</span>            <span class="hljs-keyword">struct</span> binder_ref *ref;            ref = <span class="hljs-built_in">binder_get_ref</span>(proc, tr-&gt;target.handle);            <span class="hljs-keyword">if</span> (ref == <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction to invalid handle\n&quot;</span>,                    proc-&gt;pid, thread-&gt;pid);                return_error = BR_FAILED_REPLY;                <span class="hljs-keyword">goto</span> err_invalid_target_handle;            &#125;            target_node = ref-&gt;node;        &#125; <span class="hljs-keyword">else</span> &#123;                     <span class="hljs-comment">// handle == 0 表示是 service manager 进程</span>            target_node = binder_context_mgr_node;            <span class="hljs-keyword">if</span> (target_node == <span class="hljs-literal">NULL</span>) &#123;                return_error = BR_DEAD_REPLY;                <span class="hljs-keyword">goto</span> err_no_context_mgr_node;            &#125;        &#125;        e-&gt;to_node = target_node-&gt;debug_id;        target_proc = target_node-&gt;proc;        <span class="hljs-keyword">if</span> (target_proc == <span class="hljs-literal">NULL</span>) &#123;            return_error = BR_DEAD_REPLY;            <span class="hljs-keyword">goto</span> err_dead_binder;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_binder_transaction</span>(proc-&gt;tsk,                        target_proc-&gt;tsk) &lt; <span class="hljs-number">0</span>) &#123;            return_error = BR_FAILED_REPLY;            <span class="hljs-keyword">goto</span> err_invalid_target_handle;        &#125;        <span class="hljs-comment">// 确定目标线程 target_thread</span>        <span class="hljs-comment">// 非 one_way（需要replay），则从栈顶向下搜索，从历史事务记录中过滤出与目标进程的通讯记录，复用以往使用过的线程</span>        <span class="hljs-keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction</span> *tmp;            tmp = thread-&gt;transaction_stack;            <span class="hljs-keyword">if</span> (tmp-&gt;to_thread != thread) &#123;                <span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\n&quot;</span>,                    proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,                    tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="hljs-number">0</span>,                    tmp-&gt;to_thread ?                    tmp-&gt;to_thread-&gt;pid : <span class="hljs-number">0</span>);                return_error = BR_FAILED_REPLY;                <span class="hljs-keyword">goto</span> err_bad_call_stack;            &#125;            <span class="hljs-keyword">while</span> (tmp) &#123;                <span class="hljs-keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)                    target_thread = tmp-&gt;from;                tmp = tmp-&gt;from_parent;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 找到 target_thread, 则 target_list 和 target_wait 分别初始化为目标线程的 todo 和 wait</span>    <span class="hljs-comment">// 这个意味着 client thread 与目标进程有过通讯记录</span>    <span class="hljs-keyword">if</span> (target_thread) &#123;        e-&gt;to_thread = target_thread-&gt;pid;        target_list = &amp;target_thread-&gt;todo;        target_wait = &amp;target_thread-&gt;wait;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 没有找到 target_thread, 那么 target_list 和 target_wait 分别初始化为目标进程的 todo 和 wait</span>        <span class="hljs-comment">// 这个情况只有BC_TRANSACTION命令才有可能发生</span>        target_list = &amp;target_proc-&gt;todo;        target_wait = &amp;target_proc-&gt;wait;    &#125;    e-&gt;to_proc = target_proc-&gt;pid;        <span class="hljs-comment">// 发送到目标进程 todo 列表的事务，由目标进程处理</span>    t = <span class="hljs-built_in">kzalloc</span>(<span class="hljs-built_in">sizeof</span>(*t), GFP_KERNEL);                     <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>) &#123;        return_error = BR_FAILED_REPLY;        <span class="hljs-keyword">goto</span> err_alloc_t_failed;    &#125;    <span class="hljs-built_in">binder_stats_created</span>(BINDER_STAT_TRANSACTION);    <span class="hljs-comment">// 发送到本线程 todo 列表的任务，该 binder_work 会发送 BR_WORK_TRANSCAION_COMPLETE 给目标进程，告知请求/回复已发送出去</span>    tcomplete = <span class="hljs-built_in">kzalloc</span>(<span class="hljs-built_in">sizeof</span>(*tcomplete), GFP_KERNEL);    <span class="hljs-keyword">if</span> (tcomplete == <span class="hljs-literal">NULL</span>) &#123;        return_error = BR_FAILED_REPLY;        <span class="hljs-keyword">goto</span> err_alloc_tcomplete_failed;    &#125;    <span class="hljs-built_in">binder_stats_created</span>(BINDER_STAT_TRANSACTION_COMPLETE);    <span class="hljs-comment">// 初始化 binder_transaction</span>    <span class="hljs-keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) <span class="hljs-comment">// BC_TRANSACTION 且不是 one way，即需要 replay，则发起线程（from）设为当前线程</span>      t-&gt;from = thread;    <span class="hljs-keyword">else</span>                                     <span class="hljs-comment">// BC_REPLY，from 置为空</span>        t-&gt;from = <span class="hljs-literal">NULL</span>;    t-&gt;sender_euid = <span class="hljs-built_in">task_euid</span>(proc-&gt;tsk);    t-&gt;to_proc = target_proc;    t-&gt;to_thread = target_thread;    t-&gt;code = tr-&gt;code;    t-&gt;flags = tr-&gt;flags;    t-&gt;priority = <span class="hljs-built_in">task_nice</span>(current);    <span class="hljs-built_in">trace_binder_transaction</span>(reply, t, target_node);    t-&gt;buffer = **binder_alloc_buf**(target_proc, tr-&gt;data_size,        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));    <span class="hljs-keyword">if</span> (t-&gt;buffer == <span class="hljs-literal">NULL</span>) &#123;        return_error = BR_FAILED_REPLY;        <span class="hljs-keyword">goto</span> err_binder_alloc_buf_failed;    &#125;    t-&gt;buffer-&gt;allow_user_free = <span class="hljs-number">0</span>;    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;    t-&gt;buffer-&gt;transaction = t;    t-&gt;buffer-&gt;target_node = target_node;    <span class="hljs-built_in">trace_binder_transaction_alloc_buf</span>(t-&gt;buffer);    <span class="hljs-keyword">if</span> (target_node)       <span class="hljs-built_in">binder_inc_node</span>(target_node, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// 做一些内存拷贝工作，从用户内存空间 -&gt; 内核空间</span>    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (reply) &#123;  <span class="hljs-comment">// 事务处理完成，将本次 reply 对应的 transaction 从目标线程（Client）事务栈中移除，并释放其所占用的地址空间</span>        <span class="hljs-built_in">BUG_ON</span>(t-&gt;buffer-&gt;async_transaction != <span class="hljs-number">0</span>);        <span class="hljs-built_in">binder_pop_transaction</span>(target_thread, in_reply_to);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;        <span class="hljs-comment">// 一个 client 到 server 的 transaction，且需要 reply，将本次事务加入到本线程(client)事务栈中</span>        <span class="hljs-built_in">BUG_ON</span>(t-&gt;buffer-&gt;async_transaction != <span class="hljs-number">0</span>);        t-&gt;need_reply = <span class="hljs-number">1</span>;        t-&gt;from_parent = thread-&gt;transaction_stack;        thread-&gt;transaction_stack = t;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">BUG_ON</span>(target_node == <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">BUG_ON</span>(t-&gt;buffer-&gt;async_transaction != <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (target_node-&gt;has_async_transaction) &#123;            target_list = &amp;target_node-&gt;async_todo;            *target_wait = <span class="hljs-literal">NULL</span>;        &#125; <span class="hljs-keyword">else</span>            target_node-&gt;has_async_transaction = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 将事务 binder_transaction 加入至目标进程 or 目标线程的 todo 列表</span>    t-&gt;work.type = BINDER_WORK_TRANSACTION;    <span class="hljs-built_in">list_add_tail</span>(&amp;t-&gt;work.entry, target_list);    <span class="hljs-comment">// 添加一个事务到本线程的 todo 队列中，稍后在处理 todo 队列时（binder_thread_write）</span>    <span class="hljs-comment">// 该 binder_work 会发送 BR_WORK_TRANSCAION_COMPLETE 给目标进程，告知请求/回复已发送出去</span>    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;    <span class="hljs-built_in">list_add_tail</span>(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);    <span class="hljs-comment">// 唤醒休眠在 target_wait 上的线程去处理 todo 列表</span>    <span class="hljs-keyword">if</span> (target_wait)        <span class="hljs-built_in">wake_up_interruptible</span>(target_wait);    <span class="hljs-keyword">return</span>;err_get_unused_fd_failed:err_fget_failed:err_fd_not_allowed:err_binder_get_ref_for_node_failed:err_binder_get_ref_failed:<span class="hljs-comment">// ... 异常处理</span>&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_size_t</span> *consumed, <span class="hljs-type">int</span> non_block)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;<span class="hljs-type">void</span> __user *ptr = buffer + *consumed;<span class="hljs-type">void</span> __user *end = buffer + size;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> wait_for_proc_work;    <span class="hljs-comment">// 当前的写入位置为 bwr.read_buffer 的起始位置，先写入一个 BR_NOOP 命令到 read_buffer 中</span>    <span class="hljs-comment">// 该命令在用户态是一个空操作，什么也不做，主要意义应该是在输出日志等</span><span class="hljs-keyword">if</span> (*consumed == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(BR_NOOP, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);&#125;    <span class="hljs-comment">// !thread-&gt;transaction_stack &amp;&amp; </span>    <span class="hljs-comment">//      binder_worklist_empty_ilocked(&amp;thread-&gt;todo) &amp;&amp; </span>    <span class="hljs-comment">//      (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_ENTERED | BINDER_LOOPER_STATE_REGISTERED))</span>    <span class="hljs-comment">// </span>    <span class="hljs-comment">// 如果线程的事务栈和 todo 列表都为空，表示线程没有任务要做，则去执行线程所在进程的 todo 列表上的任务</span>retry:<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);wait_for_proc_work = <span class="hljs-built_in">binder_available_for_proc_work_ilocked</span>(thread);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;<span class="hljs-built_in">trace_binder_wait_for_work</span>(wait_for_proc_work,   !!thread-&gt;transaction_stack,   !<span class="hljs-built_in">binder_worklist_empty</span>(proc, &amp;thread-&gt;todo));<span class="hljs-keyword">if</span> (wait_for_proc_work) &#123;<span class="hljs-keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |BINDER_LOOPER_STATE_ENTERED))) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;</span>,proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);<span class="hljs-built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="hljs-number">2</span>);&#125;<span class="hljs-built_in">trace_android_vh_binder_restore_priority</span>(<span class="hljs-literal">NULL</span>, current);<span class="hljs-built_in">binder_restore_priority</span>(thread, &amp;proc-&gt;default_priority);&#125;    <span class="hljs-comment">// thread-&gt;process_todo ||</span><span class="hljs-comment">//     thread-&gt;looper_need_return ||</span><span class="hljs-comment">//    (do_proc_work &amp;&amp; !binder_worklist_empty_ilocked(&amp;thread-&gt;proc-&gt;todo))</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// 如上面所说，线程自己的事务栈和 todo 为空，且进程的 todo 也为空，则线程没有任务要执行</span>    <span class="hljs-comment">// 非阻塞的情况下，返回 EAGAIN 让调用者重试</span><span class="hljs-keyword">if</span> (non_block) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_has_work</span>(thread, wait_for_proc_work))ret = -EAGAIN;&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 阻塞情况下，休眠当前线程直到别的线程 wake_up() 唤醒它</span>ret = <span class="hljs-built_in">binder_wait_for_work</span>(thread, wait_for_proc_work);&#125;thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">return</span> ret;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-type">uint32_t</span> cmd;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data_secctx</span> tr;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> *trd = &amp;tr.transaction_data;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_work</span> *w = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> *list = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction</span> *t = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_thread</span> *t_from;<span class="hljs-type">size_t</span> trsize = <span class="hljs-built_in">sizeof</span>(*trd);        <span class="hljs-comment">// 找到 todo 列表：优先处理本线程的 todo 列表，同时也处理进程的 todo 列表</span><span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;thread-&gt;todo))list = &amp;thread-&gt;todo;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo) &amp;&amp;   wait_for_proc_work)list = &amp;proc-&gt;todo;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-comment">/* no data added */</span><span class="hljs-keyword">if</span> (ptr - buffer == <span class="hljs-number">4</span> &amp;&amp; !thread-&gt;looper_need_return)<span class="hljs-keyword">goto</span> retry;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">if</span> (end - ptr &lt; <span class="hljs-built_in">sizeof</span>(tr) + <span class="hljs-number">4</span>) &#123;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">break</span>;&#125;w = <span class="hljs-built_in">binder_dequeue_work_head_ilocked</span>(list);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;thread-&gt;todo))thread-&gt;process_todo = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 上面 binder_thread_write 那里塞了个 BINDER_WORK_TRANSACTION_COMPLETE 到当前线程的 todo 列表里</span>        <span class="hljs-comment">// 这里回写个 BR_TRANSACTION_COMPLETE 到用户空间，然后跳转到 retry 休眠线程</span><span class="hljs-keyword">switch</span> (w-&gt;type) &#123;<span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE:<span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT: &#123;<span class="hljs-keyword">if</span> (proc-&gt;oneway_spam_detection_enabled &amp;&amp;   w-&gt;type == BINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT)cmd = BR_ONEWAY_SPAM_SUSPECT;<span class="hljs-keyword">else</span>cmd = BR_TRANSACTION_COMPLETE;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-built_in">kfree</span>(w);<span class="hljs-built_in">binder_stats_deleted</span>(BINDER_STAT_TRANSACTION_COMPLETE);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-built_in">binder_stat_br</span>(proc, thread, cmd);<span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_TRANSACTION_COMPLETE,     <span class="hljs-string">&quot;%d:%d BR_TRANSACTION_COMPLETE\n&quot;</span>,     proc-&gt;pid, thread-&gt;pid);&#125; <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 在 retry 里休眠的线程，直到被 server 唤醒，当然不一定是刚才那个线程，可能是被别的线程抢到了</span>        <span class="hljs-comment">// server 进程在 binder_thread_write -&gt; binder_transaction 最后会通过 wake_up_interruptible</span>        <span class="hljs-comment">// 唤醒目标线程，也就是 client 发送 request 的那个线程</span>        <span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION: &#123;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);t = <span class="hljs-built_in">container_of</span>(w, <span class="hljs-keyword">struct</span> binder_transaction, work);&#125; <span class="hljs-keyword">break</span>;<span class="hljs-comment">// ... </span>&#125; <span class="hljs-comment">// switch-end</span><span class="hljs-keyword">if</span> (!t)<span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 拿到 binder_transaction 后继续流程</span><span class="hljs-built_in">BUG_ON</span>(t-&gt;buffer == <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_node</span> *target_node = t-&gt;buffer-&gt;target_node;trd-&gt;target.ptr = target_node-&gt;ptr;trd-&gt;cookie =  target_node-&gt;cookie;<span class="hljs-built_in">binder_transaction_priority</span>(thread, t, target_node);cmd = BR_TRANSACTION;&#125; <span class="hljs-keyword">else</span> &#123;trd-&gt;target.ptr = <span class="hljs-number">0</span>;trd-&gt;cookie = <span class="hljs-number">0</span>;cmd = BR_REPLY;&#125;trd-&gt;code = t-&gt;code;trd-&gt;flags = t-&gt;flags;trd-&gt;sender_euid = <span class="hljs-built_in">from_kuid</span>(<span class="hljs-built_in">current_user_ns</span>(), t-&gt;sender_euid);t_from = <span class="hljs-built_in">binder_get_txn_from</span>(t);<span class="hljs-keyword">if</span> (t_from) &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> *sender = t_from-&gt;proc-&gt;tsk;trd-&gt;sender_pid =<span class="hljs-built_in">task_tgid_nr_ns</span>(sender,<span class="hljs-built_in">task_active_pid_ns</span>(current));<span class="hljs-built_in">trace_android_vh_sync_txn_recvd</span>(thread-&gt;task, t_from-&gt;task);&#125; <span class="hljs-keyword">else</span> &#123;trd-&gt;sender_pid = <span class="hljs-number">0</span>;&#125;ret = <span class="hljs-built_in">binder_apply_fd_fixups</span>(proc, t);<span class="hljs-keyword">if</span> (ret) &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_buffer</span> *buffer = t-&gt;buffer;<span class="hljs-type">bool</span> oneway = !!(t-&gt;flags &amp; TF_ONE_WAY);<span class="hljs-type">int</span> tid = t-&gt;debug_id;<span class="hljs-keyword">if</span> (t_from)<span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);buffer-&gt;transaction = <span class="hljs-literal">NULL</span>;<span class="hljs-built_in">binder_cleanup_transaction</span>(t, <span class="hljs-string">&quot;fd fixups failed&quot;</span>,   BR_FAILED_REPLY);<span class="hljs-built_in">binder_free_buf</span>(proc, thread, buffer, <span class="hljs-literal">true</span>);<span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_FAILED_TRANSACTION,     <span class="hljs-string">&quot;%d:%d %stransaction %d fd fixups failed %d/%d, line %d\n&quot;</span>,     proc-&gt;pid, thread-&gt;pid,     oneway ? <span class="hljs-string">&quot;async &quot;</span> :(cmd == BR_REPLY ? <span class="hljs-string">&quot;reply &quot;</span> : <span class="hljs-string">&quot;&quot;</span>),     tid, BR_FAILED_REPLY, ret, __LINE__);<span class="hljs-keyword">if</span> (cmd == BR_REPLY) &#123;cmd = BR_FAILED_REPLY;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-built_in">binder_stat_br</span>(proc, thread, cmd);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">continue</span>;&#125;trd-&gt;data_size = t-&gt;buffer-&gt;data_size;trd-&gt;offsets_size = t-&gt;buffer-&gt;offsets_size;trd-&gt;data.ptr.buffer = (<span class="hljs-type">uintptr_t</span>)t-&gt;buffer-&gt;user_data;trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.buffer +<span class="hljs-built_in">ALIGN</span>(t-&gt;buffer-&gt;data_size,    <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span> *));tr.secctx = t-&gt;security_ctx;<span class="hljs-keyword">if</span> (t-&gt;security_ctx) &#123;cmd = BR_TRANSACTION_SEC_CTX;trsize = <span class="hljs-built_in">sizeof</span>(tr);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr)) &#123;<span class="hljs-keyword">if</span> (t_from)<span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);<span class="hljs-built_in">binder_cleanup_transaction</span>(t, <span class="hljs-string">&quot;put_user failed&quot;</span>,   BR_FAILED_REPLY);<span class="hljs-keyword">return</span> -EFAULT;&#125;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ptr, &amp;tr, trsize)) &#123;<span class="hljs-keyword">if</span> (t_from)<span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);<span class="hljs-built_in">binder_cleanup_transaction</span>(t, <span class="hljs-string">&quot;copy_to_user failed&quot;</span>,   BR_FAILED_REPLY);<span class="hljs-keyword">return</span> -EFAULT;&#125;ptr += trsize;<span class="hljs-built_in">trace_binder_transaction_received</span>(t);<span class="hljs-built_in">binder_stat_br</span>(proc, thread, cmd);<span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_TRANSACTION,     <span class="hljs-string">&quot;%d:%d %s %d %d:%d, cmd %u size %zd-%zd ptr %016llx-%016llx\n&quot;</span>,     proc-&gt;pid, thread-&gt;pid,     (cmd == BR_TRANSACTION) ? <span class="hljs-string">&quot;BR_TRANSACTION&quot;</span> :(cmd == BR_TRANSACTION_SEC_CTX) ?     <span class="hljs-string">&quot;BR_TRANSACTION_SEC_CTX&quot;</span> : <span class="hljs-string">&quot;BR_REPLY&quot;</span>,     t-&gt;debug_id, t_from ? t_from-&gt;proc-&gt;pid : <span class="hljs-number">0</span>,     t_from ? t_from-&gt;pid : <span class="hljs-number">0</span>, cmd,     t-&gt;buffer-&gt;data_size, t-&gt;buffer-&gt;offsets_size,     (u64)trd-&gt;data.ptr.buffer,     (u64)trd-&gt;data.ptr.offsets);<span class="hljs-keyword">if</span> (t_from)<span class="hljs-built_in">binder_thread_dec_tmpref</span>(t_from);t-&gt;buffer-&gt;allow_user_free = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (cmd != BR_REPLY &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;<span class="hljs-built_in">binder_inner_proc_lock</span>(thread-&gt;proc);t-&gt;to_parent = thread-&gt;transaction_stack;t-&gt;to_thread = thread;thread-&gt;transaction_stack = t;<span class="hljs-built_in">binder_inner_proc_unlock</span>(thread-&gt;proc);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">binder_free_transaction</span>(t);&#125;<span class="hljs-keyword">break</span>;&#125; <span class="hljs-comment">// while-end</span>done:*consumed = ptr - buffer;<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (proc-&gt;requested_threads == <span class="hljs-number">0</span> &amp;&amp;    <span class="hljs-built_in">list_empty</span>(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |     BINDER_LOOPER_STATE_ENTERED)) <span class="hljs-comment">/* the user-space code fails to */</span>     <span class="hljs-comment">/*spawn a new thread if we leave this out */</span>) &#123;proc-&gt;requested_threads++;<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-built_in">binder_debug</span>(BINDER_DEBUG_THREADS,     <span class="hljs-string">&quot;%d:%d BR_SPAWN_LOOPER\n&quot;</span>,     proc-&gt;pid, thread-&gt;pid);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(BR_SPAWN_LOOPER, (<span class="hljs-type">uint32_t</span> __user *)buffer))<span class="hljs-keyword">return</span> -EFAULT;<span class="hljs-built_in">binder_stat_br</span>(proc, thread, BR_SPAWN_LOOPER);&#125; <span class="hljs-keyword">else</span><span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// prepare_to_wait + schedule + finish_wait 是一整套线程调度模板（休眠线程）</span><span class="hljs-comment">// see https://github.com/cyrus-lin/bookmark/issues/45</span><span class="hljs-comment">// 它使线程休眠在 binder_thread.wait 上直到别的线程通过 wake_up(head) 唤醒它</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_wait_for_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">bool</span> do_proc_work)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">DEFINE_WAIT</span>(wait);<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = thread-&gt;proc;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-built_in">prepare_to_wait</span>(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE|TASK_FREEZABLE);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">binder_has_work_ilocked</span>(thread, do_proc_work))<span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span> (do_proc_work)<span class="hljs-built_in">list_add</span>(&amp;thread-&gt;waiting_thread_node, &amp;proc-&gt;waiting_threads);<span class="hljs-built_in">trace_android_vh_binder_wait_for_work</span>(do_proc_work, thread, proc);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-built_in">schedule</span>();<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-built_in">list_del_init</span>(&amp;thread-&gt;waiting_thread_node);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">signal_pending</span>(current)) &#123;ret = -EINTR;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-built_in">finish_wait</span>(&amp;thread-&gt;wait, &amp;wait);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><h1 id="binder-线程主例程"><a href="#binder-线程主例程" class="headerlink" title="binder 线程主例程"></a>binder 线程主例程</h1><p>binder 线程（包括主线程和普通线程）的主循环是 <code>getAndExecuteCommand()</code>，它有两个关键方法：<code>talkWithDriver()</code> 和 <code>executeCommand(cmd)</code></p><p><code>talkWithDriver()</code> 发送 <code>BINDER_WRITE_READ</code> 指令，write 是应用进程发送给 binder driver 处理的任务，可能是空的，read 是 binder driver 需要返回给应用进程的数据，此时如果任务队列（<code>binder_thread.todo</code> or <code>binder_proc.todo</code>）为空，会通过 <code>schedule()</code> 让渡出 CPU，也即是让 binder 线程阻塞在这里，所以在 anr 日志里经常看到下面的调用栈：</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-comment">// binder 线程因为任务队列为空，阻塞在 binder_thread_read 方法</span><span class="hljs-string">&quot;Binder_1&quot;</span> <span class="hljs-attr">prio</span><span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-attr">tid</span><span class="hljs-operator">=</span><span class="hljs-number">12</span> Native  | <span class="hljs-attr">group</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;main&quot;</span> sC<span class="hljs-attr">ount</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> dsC<span class="hljs-attr">ount</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-attr">obj</span><span class="hljs-operator">=</span><span class="hljs-number">0x12c7c0a0</span> <span class="hljs-attr">self</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f96828800</span>  | sysT<span class="hljs-attr">id</span><span class="hljs-operator">=</span><span class="hljs-number">1144</span> <span class="hljs-attr">nice</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-attr">cgrp</span><span class="hljs-operator">=</span>default <span class="hljs-attr">sched</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>/<span class="hljs-number">0</span> <span class="hljs-attr">handle</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f9be97000</span>  | <span class="hljs-attr">state</span><span class="hljs-operator">=</span>S <span class="hljs-attr">schedstat</span><span class="hljs-operator">=</span>( <span class="hljs-number">1577699930</span> <span class="hljs-number">1373220151</span> <span class="hljs-number">5401</span> ) <span class="hljs-attr">utm</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> <span class="hljs-attr">stm</span><span class="hljs-operator">=</span><span class="hljs-number">44</span> <span class="hljs-attr">core</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span>  | <span class="hljs-attr">stack</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f89c27000</span><span class="hljs-number">-0x7f89c29000</span> stackS<span class="hljs-attr">ize</span><span class="hljs-operator">=</span><span class="hljs-number">1008</span>KB  | held <span class="hljs-attr">mutexes</span><span class="hljs-operator">=</span><span class="hljs-symbol">  kernel:</span> __switch_to+<span class="hljs-number">0x8c</span>/<span class="hljs-number">0x98</span><span class="hljs-symbol">  kernel:</span> binder_thread_read+<span class="hljs-number">0xe5c</span>/<span class="hljs-number">0x117c</span><span class="hljs-symbol">  kernel:</span> binder_ioctl_write_read+<span class="hljs-number">0x1a8</span>/<span class="hljs-number">0x3c8</span><span class="hljs-symbol">  kernel:</span> binder_ioctl+<span class="hljs-number">0x3c0</span>/<span class="hljs-number">0x688</span><span class="hljs-symbol">  kernel:</span> do_vfs_ioctl+<span class="hljs-number">0x368</span>/<span class="hljs-number">0x588</span><span class="hljs-symbol">  kernel:</span> SyS_ioctl+<span class="hljs-number">0x80</span>/<span class="hljs-number">0x98</span><span class="hljs-symbol">  kernel:</span> cpu_switch_to+<span class="hljs-number">0x48</span>/<span class="hljs-number">0x4c</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#00 pc 00062dc0  /system/lib64/libc.so (__ioctl+4)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#01 pc 000891e8  /system/lib64/libc.so (ioctl+96)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#02 pc 0002993c  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+164)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#03 pc 0002a174  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand()+24)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#04 pc 0002a22c  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+76)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#05 pc 00031bc8  /system/lib64/libbinder.so (???)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#06 pc 0001750c  /system/lib64/libutils.so (android::Thread::_threadLoop(void*)+208)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#07 pc 000947c4  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell(void*)+96)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#08 pc 00016d4c  /system/lib64/libutils.so (???)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#09 pc 0001f000  /system/lib64/libc.so (__pthread_start(void*)+52)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#10 pc 0001b340  /system/lib64/libc.so (__start_thread+16)</span>  (no managed stack frames)<span class="hljs-string">&quot;Binder_2&quot;</span> <span class="hljs-attr">prio</span><span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-attr">tid</span><span class="hljs-operator">=</span><span class="hljs-number">13</span> Native  | <span class="hljs-attr">group</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;main&quot;</span> sC<span class="hljs-attr">ount</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> dsC<span class="hljs-attr">ount</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-attr">obj</span><span class="hljs-operator">=</span><span class="hljs-number">0x12c970a0</span> <span class="hljs-attr">self</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f9ccb5800</span>  | sysT<span class="hljs-attr">id</span><span class="hljs-operator">=</span><span class="hljs-number">1146</span> <span class="hljs-attr">nice</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-attr">cgrp</span><span class="hljs-operator">=</span>default <span class="hljs-attr">sched</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>/<span class="hljs-number">0</span> <span class="hljs-attr">handle</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f9be7c000</span>  | <span class="hljs-attr">state</span><span class="hljs-operator">=</span>S <span class="hljs-attr">schedstat</span><span class="hljs-operator">=</span>( <span class="hljs-number">1579795734</span> <span class="hljs-number">1531888975</span> <span class="hljs-number">5458</span> ) <span class="hljs-attr">utm</span><span class="hljs-operator">=</span><span class="hljs-number">117</span> <span class="hljs-attr">stm</span><span class="hljs-operator">=</span><span class="hljs-number">40</span> <span class="hljs-attr">core</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span>  | <span class="hljs-attr">stack</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f89b2a000</span><span class="hljs-number">-0x7f89b2c000</span> stackS<span class="hljs-attr">ize</span><span class="hljs-operator">=</span><span class="hljs-number">1008</span>KB  | held <span class="hljs-attr">mutexes</span><span class="hljs-operator">=</span><span class="hljs-symbol">  kernel:</span> __switch_to+<span class="hljs-number">0x8c</span>/<span class="hljs-number">0x98</span><span class="hljs-symbol">  kernel:</span> binder_thread_read+<span class="hljs-number">0xe5c</span>/<span class="hljs-number">0x117c</span><span class="hljs-symbol">  kernel:</span> binder_ioctl_write_read+<span class="hljs-number">0x1a8</span>/<span class="hljs-number">0x3c8</span><span class="hljs-symbol">  kernel:</span> binder_ioctl+<span class="hljs-number">0x3c0</span>/<span class="hljs-number">0x688</span><span class="hljs-symbol">  kernel:</span> do_vfs_ioctl+<span class="hljs-number">0x368</span>/<span class="hljs-number">0x588</span><span class="hljs-symbol">  kernel:</span> SyS_ioctl+<span class="hljs-number">0x80</span>/<span class="hljs-number">0x98</span><span class="hljs-symbol">  kernel:</span> cpu_switch_to+<span class="hljs-number">0x48</span>/<span class="hljs-number">0x4c</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#00 pc 00062dc0  /system/lib64/libc.so (__ioctl+4)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#01 pc 000891e8  /system/lib64/libc.so (ioctl+96)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#02 pc 0002993c  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+164)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#03 pc 0002a174  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand()+24)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#04 pc 0002a22c  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+76)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#05 pc 00031bc8  /system/lib64/libbinder.so (???)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#06 pc 0001750c  /system/lib64/libutils.so (android::Thread::_threadLoop(void*)+208)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#07 pc 000947c4  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell(void*)+96)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#08 pc 00016d4c  /system/lib64/libutils.so (???)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#09 pc 0001f000  /system/lib64/libc.so (__pthread_start(void*)+52)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#10 pc 0001b340  /system/lib64/libc.so (__start_thread+16)</span>  (no managed stack frames)<span class="hljs-string">&quot;Binder_5&quot;</span> <span class="hljs-attr">prio</span><span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-attr">tid</span><span class="hljs-operator">=</span><span class="hljs-number">65</span> Native  | <span class="hljs-attr">group</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;main&quot;</span> sC<span class="hljs-attr">ount</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> dsC<span class="hljs-attr">ount</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-attr">obj</span><span class="hljs-operator">=</span><span class="hljs-number">0x131ed100</span> <span class="hljs-attr">self</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f96834000</span>  | sysT<span class="hljs-attr">id</span><span class="hljs-operator">=</span><span class="hljs-number">2014</span> <span class="hljs-attr">nice</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-attr">cgrp</span><span class="hljs-operator">=</span>default <span class="hljs-attr">sched</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>/<span class="hljs-number">0</span> <span class="hljs-attr">handle</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f86ceb000</span>  | <span class="hljs-attr">state</span><span class="hljs-operator">=</span>S <span class="hljs-attr">schedstat</span><span class="hljs-operator">=</span>( <span class="hljs-number">1519499135</span> <span class="hljs-number">1394211486</span> <span class="hljs-number">5073</span> ) <span class="hljs-attr">utm</span><span class="hljs-operator">=</span><span class="hljs-number">109</span> <span class="hljs-attr">stm</span><span class="hljs-operator">=</span><span class="hljs-number">42</span> <span class="hljs-attr">core</span><span class="hljs-operator">=</span><span class="hljs-number">0</span> HZ=<span class="hljs-number">100</span>  | <span class="hljs-attr">stack</span><span class="hljs-operator">=</span><span class="hljs-number">0x7f83adc000</span><span class="hljs-number">-0x7f83ade000</span> stackS<span class="hljs-attr">ize</span><span class="hljs-operator">=</span><span class="hljs-number">1008</span>KB  | held <span class="hljs-attr">mutexes</span><span class="hljs-operator">=</span><span class="hljs-symbol">  kernel:</span> __switch_to+<span class="hljs-number">0x8c</span>/<span class="hljs-number">0x98</span><span class="hljs-symbol">  kernel:</span> binder_thread_read+<span class="hljs-number">0xe5c</span>/<span class="hljs-number">0x117c</span><span class="hljs-symbol">  kernel:</span> binder_ioctl_write_read+<span class="hljs-number">0x1a8</span>/<span class="hljs-number">0x3c8</span><span class="hljs-symbol">  kernel:</span> binder_ioctl+<span class="hljs-number">0x3c0</span>/<span class="hljs-number">0x688</span><span class="hljs-symbol">  kernel:</span> do_vfs_ioctl+<span class="hljs-number">0x368</span>/<span class="hljs-number">0x588</span><span class="hljs-symbol">  kernel:</span> SyS_ioctl+<span class="hljs-number">0x80</span>/<span class="hljs-number">0x98</span><span class="hljs-symbol">  kernel:</span> cpu_switch_to+<span class="hljs-number">0x48</span>/<span class="hljs-number">0x4c</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#00 pc 00062dc0  /system/lib64/libc.so (__ioctl+4)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#01 pc 000891e8  /system/lib64/libc.so (ioctl+96)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#02 pc 0002993c  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+164)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#03 pc 0002a174  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand()+24)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#04 pc 0002a22c  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+76)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#05 pc 00031bc8  /system/lib64/libbinder.so (???)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#06 pc 0001750c  /system/lib64/libutils.so (android::Thread::_threadLoop(void*)+208)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#07 pc 000947c4  /system/lib64/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell(void*)+96)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#08 pc 00016d4c  /system/lib64/libutils.so (???)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#09 pc 0001f000  /system/lib64/libc.so (__pthread_start(void*)+52)</span><span class="hljs-symbol">  native:</span> <span class="hljs-meta">#10 pc 0001b340  /system/lib64/libc.so (__start_thread+16)</span>  (no managed stack frames)</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/IPCThreadState.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IPCThreadState::joinThreadPool</span><span class="hljs-params">(<span class="hljs-type">bool</span> isMain <span class="hljs-comment">/* true - 主线程*/</span> )</span></span><span class="hljs-function"></span>&#123;    mOut.<span class="hljs-built_in">writeInt32</span>(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);    <span class="hljs-type">status_t</span> result;    mIsLooper = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-built_in">processPendingDerefs</span>();        <span class="hljs-comment">// now get the next command to be processed, waiting if necessary</span>        result = <span class="hljs-built_in">getAndExecuteCommand</span>();        <span class="hljs-comment">// Let this thread exit the thread pool if it is no longer</span>        <span class="hljs-comment">// needed and it is not the main process thread.</span>        <span class="hljs-keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125; <span class="hljs-keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);    mOut.<span class="hljs-built_in">writeInt32</span>(BC_EXIT_LOOPER);    mIsLooper = <span class="hljs-literal">false</span>;    <span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-literal">false</span>);&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::getAndExecuteCommand</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">status_t</span> result;    <span class="hljs-type">int32_t</span> cmd;    result = <span class="hljs-built_in">talkWithDriver</span>();    <span class="hljs-keyword">if</span> (result &gt;= NO_ERROR) &#123;        <span class="hljs-type">size_t</span> IN = mIn.<span class="hljs-built_in">dataAvail</span>();        <span class="hljs-keyword">if</span> (IN &lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int32_t</span>)) <span class="hljs-keyword">return</span> result;        cmd = mIn.<span class="hljs-built_in">readInt32</span>();        <span class="hljs-comment">// ...</span>        result = <span class="hljs-built_in">executeCommand</span>(cmd);<span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// write 指 binder driver 需要处理的数据，read 指应用进程想要收到的数据</span><span class="hljs-comment">// 发送 BINDER_WRITE_READ 给 binder driver</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::talkWithDriver</span><span class="hljs-params">(<span class="hljs-type">bool</span> doReceive <span class="hljs-comment">/* default true */</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -EBADF;    &#125;    binder_write_read bwr;    <span class="hljs-comment">// Is the read buffer empty?</span>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> needRead = mIn.<span class="hljs-built_in">dataPosition</span>() &gt;= mIn.<span class="hljs-built_in">dataSize</span>();    <span class="hljs-comment">// We don&#x27;t want to write anything if we are still reading</span>    <span class="hljs-comment">// from data left in the input buffer and the caller</span>    <span class="hljs-comment">// has requested to read the next data.</span>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="hljs-built_in">dataSize</span>() : <span class="hljs-number">0</span>;    bwr.write_size = outAvail;    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>)mOut.<span class="hljs-built_in">data</span>();    <span class="hljs-comment">// This is what we&#x27;ll read.</span>    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;        bwr.read_size = mIn.<span class="hljs-built_in">dataCapacity</span>();        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>)mIn.<span class="hljs-built_in">data</span>();    &#125; <span class="hljs-keyword">else</span> &#123;        bwr.read_size = <span class="hljs-number">0</span>;        bwr.read_buffer = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// Return immediately if there is nothing to do.</span>    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> NO_ERROR;    bwr.write_consumed = <span class="hljs-number">0</span>;    bwr.read_consumed = <span class="hljs-number">0</span>;    <span class="hljs-type">status_t</span> err;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)            err = NO_ERROR;        <span class="hljs-keyword">else</span>            err = -errno;        <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;            err = -EBADF;        &#125;    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);<span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 进入内核，具体是 binder driver</span><span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd <span class="hljs-comment">/* BINDER_WRITE_READ */</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ret;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_thread</span> *thread;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = _IOC_SIZE(cmd);<span class="hljs-type">void</span> __user *ubuf = (<span class="hljs-type">void</span> __user *)arg;<span class="hljs-built_in">binder_selftest_alloc</span>(&amp;proc-&gt;alloc);<span class="hljs-built_in">trace_binder_ioctl</span>(cmd, arg);ret = <span class="hljs-built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">goto</span> err_unlocked;thread = <span class="hljs-built_in">binder_get_thread</span>(proc);<span class="hljs-keyword">if</span> (thread == <span class="hljs-literal">NULL</span>) &#123;ret = -ENOMEM;<span class="hljs-keyword">goto</span> err;&#125;<span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-keyword">case</span> BINDER_WRITE_READ:ret = <span class="hljs-built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">goto</span> err;<span class="hljs-keyword">break</span>;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = _IOC_SIZE(cmd);<span class="hljs-type">void</span> __user *ubuf = (<span class="hljs-type">void</span> __user *)arg;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> bwr;<span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> binder_write_read)) &#123;ret = -EINVAL;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="hljs-built_in">sizeof</span>(bwr))) &#123;ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;    <span class="hljs-comment">// binder 首先处理应用进程发送过来的数据</span><span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_write</span>(proc, thread,  bwr.write_buffer,  bwr.write_size,  &amp;bwr.write_consumed);<span class="hljs-built_in">trace_binder_write_done</span>(ret);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;bwr.read_consumed = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;    <span class="hljs-comment">// 然后返回应用进程想要的数据</span><span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);<span class="hljs-built_in">trace_binder_read_done</span>(ret);<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))<span class="hljs-built_in">binder_wakeup_proc_ilocked</span>(proc);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">binder_size_t</span> *consumed, <span class="hljs-type">int</span> non_block)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;<span class="hljs-type">void</span> __user *ptr = buffer + *consumed;<span class="hljs-type">void</span> __user *end = buffer + size;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> wait_for_proc_work;<span class="hljs-keyword">if</span> (*consumed == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">put_user</span>(BR_NOOP, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);&#125;retry:<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);wait_for_proc_work = <span class="hljs-built_in">binder_available_for_proc_work_ilocked</span>(thread);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;<span class="hljs-built_in">trace_binder_wait_for_work</span>(wait_for_proc_work,   !!thread-&gt;transaction_stack,   !<span class="hljs-built_in">binder_worklist_empty</span>(proc, &amp;thread-&gt;todo));<span class="hljs-keyword">if</span> (wait_for_proc_work) &#123;<span class="hljs-comment">// 在章节【主线程与普通线程】里讲过，应用进程将 binder 线程起起来后会发送 BC_ENTER_LOOPER | BC_REGISTER_LOOPER 给 binder driver</span><span class="hljs-comment">// 从而打开 BINDER_LOOPER_STATE_ENTERED | BINDER_LOOPER_STATE_REGISTERED 标志位</span><span class="hljs-comment">// BINDER_LOOPER_STATE_ENTERED 表示主线程，BINDER_LOOPER_STATE_REGISTERED 表示普通线程</span><span class="hljs-keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |BINDER_LOOPER_STATE_ENTERED))) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;</span>,proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);<span class="hljs-built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="hljs-number">2</span>);&#125;<span class="hljs-built_in">trace_android_vh_binder_restore_priority</span>(<span class="hljs-literal">NULL</span>, current);<span class="hljs-built_in">binder_restore_priority</span>(thread, &amp;proc-&gt;default_priority);&#125;<span class="hljs-keyword">if</span> (non_block) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_has_work</span>(thread, wait_for_proc_work))ret = -EAGAIN;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 当前线程让渡出 CPU 直到 todo 列表里有任务，在章节【binder 线程主例程】里介绍过此函数以及对应的</span><span class="hljs-comment">// prepare_to_wait &amp; schedule &amp; finish_wait 进程/线程调度 API</span>ret = <span class="hljs-built_in">binder_wait_for_work</span>(thread, wait_for_proc_work);&#125;thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;<span class="hljs-comment">// ...</span>&#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/49830c3473b7">Binder驱动之设备控制 binder_ioctl – 一</a></li><li><a href="https://www.jianshu.com/p/12bec1b16a5b">Binder驱动之设备控制 binder_ioctl – 二</a></li><li><a href="https://www.jianshu.com/p/4be292a51388">Binder驱动之设备控制 binder_ioctl – 三</a></li><li><a href="http://gityuan.com/2016/10/29/binder-thread-pool/">进程的Binder线程池工作过程 - Gityuan</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder IPC 过程中常用的对象和类</title>
    <link href="/2022/12/06/binder-objects/"/>
    <url>/2022/12/06/binder-objects/</url>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><img src="../../../../image/2022-12-05-binder-objects/objects.webp" alt="Binder 类图"></p><p><img src="../../../../image/2022-12-05-binder-objects/ipc.webp" alt="Binder IPC 流程图"></p><p><img src="/image/2022-12-05-binder-objects/all.webp" alt="Big Picture"></p><h2 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h2><p><code>BpBinder</code></p><p>client native proxy，客户端 native 层的 binder ipc 代理（IBinder），它最重要的是持有 server 端句柄 handle，handle == 0 表示 service manager，其他的需要通过 service manager 查询得到，参看 <a href="../../../../2022/10/26/binder-servicemanager/#%E4%BB%A5-AMS-%E4%B8%BA%E4%BE%8B">AMS的例子</a></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// BpBindere 会直接用 server handle 调用 IPCThreadState::transact() 与 binder driver 进行通讯</span>BpBinder::transact--IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">transact</span>(<span class="hljs-built_in">binderHandle</span>() <span class="hljs-comment">/* 0 */</span>, code, data, reply, flags)----IPCThreadState::<span class="hljs-built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">nullptr</span>)----IPCThreadState::<span class="hljs-built_in">waitForResponse</span>(Parcel *reply, <span class="hljs-type">status_t</span> *acquireResult)------IPCThreadState::<span class="hljs-built_in">talkWithDriver</span>(<span class="hljs-type">bool</span> doReceive)--------<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code></pre></div><p><code>BinderProxy</code></p><p>client java proxy，客户端 java 层的 binder ipc 代理（IBinder），是 BpBinder 在 java 层的体现，参看 <a href="../../../../2022/10/26/binder-servicemanager/#%E6%9A%B4%E9%9C%B2%E8%87%AA%E5%B7%B1">AMS的例子</a></p><p><code>IActivityManager.Stub.asInterface(IBinder)</code></p><p>client 通过此方法获得一个实现了 IActivityManager 的代理，IBinder 可以是 Stub 子类（本地），也可以是 BinderProxy（IPC）</p><p><code>IServiceManager.Stub.Proxy</code></p><p>它实现了契约接口 IServiceManager，需要一个 BinderProxy 作为底层实现，它将参数打包为 Parcel 交由 BinderProxy 处理，并从 BinderProxy 返回的 Parcel 里读取返回值，参看 <a href="../../../../2022/10/26/binder-servicemanager/#%E4%BB%A5-AMS-%E4%B8%BA%E4%BE%8B">AMS的例子</a></p><h2 id="server-端"><a href="#server-端" class="headerlink" title="server 端"></a>server 端</h2><p><code>IActivityManager.Stub extends android.os.Binder</code></p><p>server java impl，server 端对契约接口的实现继承自 Stub 类（IBinder），实现约定好的业务方法（java 层）</p><p><code>BBinder &amp; JavaBBinder</code></p><p>server native ref，server 端的业务实现 Stub 类在 native 层的体现（IBinder），<code>Binder.mObject</code> 指向 native 层的 <code>JavaBBinderHolder</code>，从 holder 可以获取 JavaBBinder（BBinder 的子类），binder ipc 序列化 <code>IBInder</code> 时，如果是 <code>BpBinder</code> 则写入 handle 即可，如果是 <code>BBinder</code> 则写入此对象的地址，那么 server 端在收到 RPC 请求时就可以通过对象地址找到 BBinder -&gt; JavaBBinder -&gt; Stub 类 -&gt; 调用指定的方法，参看 <a href="../../../../2022/10/26/binder-servicemanager/#%E4%BB%A5-AMS-%E4%B8%BA%E4%BE%8B">AMS的例子</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>IActivityManager</code></p><p>约定了 client 与 server 之间数据交互（RPC）的契约（contract）的 java interface</p><p><code>ServiceManager</code></p><p>server 通过它进行服务注册 <code>addService(String name, IBinder service)</code>，client 通过他获得通讯句柄 <code>getService(String name)</code></p><p><code>ProcessState</code></p><p>进程内单例，负责打开 binder driver 文件描述符，并进行 mmap 操作</p><p><code>IPCThreadState</code></p><p>线程私有（ThreadLocal），负责与 binder driver 通讯，实现了 binder ipc 大部分的底层逻辑，它有很多种使用方式：</p><p>1，<code>IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</code></p><p>最简单、最常用的方式，需要一个从 <a href="../../../../2022/10/26/binder-servicemanager/">service manager</a> 获取的 server 端句柄，直接向 server 端发送请求并等待响应</p><p>2，<code>IPCThreadState::handlePolledCommands()</code></p><p>当 binder fd 上有事件发生时调用此方法让 IPCThreadState 处理 binder driver 过来的数据，参见 <a href="../../../../2022/10/26/binder-servicemanager/#%E5%BC%80%E5%A7%8B-binder-%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF">service manager 处理 binder 消息的循环</a></p><p>3，<code>IPCThreadState::joinThreadPool(bool isMain)</code></p><p>使当前线程进入 talkWithDriver() + executeCommand(mIn.readInt32()) 的消息处理循环</p><p>4，<code>ProcessState::startThreadPool()</code></p><p>则会开一个新线程执行消息处理循环（ProcessState 是进程内单例所以只会开一个消息循环线程），参见 <a href="#Zygote-amp-system-server">Zygote &amp; system server</a></p><h1 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h1><ul><li>打开 binder driver 文件描述符 <code>open(&quot;/dev/binder&quot;)</code></li><li>进行初始化操作 <code>ioctl</code>：版本校验 <code>BINDER_VERSION</code>、设置默认线程数量 <code>DEFAULT_MAX_BINDER_THREADS</code> 等</li><li>初始化所需内存空间 mmap</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/ProcessState.cpp</span><span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::self</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">init</span>(kDefaultDriver <span class="hljs-comment">/* /dev/binder */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/*requireDefault*/</span>);&#125;<span class="hljs-comment">// ProcessState 是全局单例模式（gProcess）</span><span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver, <span class="hljs-type">bool</span> requireDefault)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (driver == <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">l</span><span class="hljs-params">(gProcessMutex)</span></span>;        <span class="hljs-keyword">if</span> (gProcess) &#123;            <span class="hljs-built_in">verifyNotForked</span>(gProcess-&gt;mForked);        &#125;        <span class="hljs-keyword">return</span> gProcess;    &#125;    [[clang::no_destroy]] <span class="hljs-type">static</span> std::once_flag gProcessOnce;    std::<span class="hljs-built_in">call_once</span>(gProcessOnce, [&amp;]()&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">access</span>(driver, R_OK) == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Binder driver %s is unavailable. Using /dev/binder instead.&quot;</span>, driver);            driver = <span class="hljs-string">&quot;/dev/binder&quot;</span>;        &#125;        <span class="hljs-comment">// we must install these before instantiating the gProcess object,</span>        <span class="hljs-comment">// otherwise this would race with creating it, and there could be the</span>        <span class="hljs-comment">// possibility of an invalid gProcess object forked by another thread</span>        <span class="hljs-comment">// before these are installed</span>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_atfork</span>(ProcessState::onFork, ProcessState::parentPostFork,                                 ProcessState::childPostFork);        <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(ret != <span class="hljs-number">0</span>, <span class="hljs-string">&quot;pthread_atfork error %s&quot;</span>, <span class="hljs-built_in">strerror</span>(ret));        std::lock_guard&lt;std::mutex&gt; <span class="hljs-built_in">l</span>(gProcessMutex);        gProcess = sp&lt;ProcessState&gt;::<span class="hljs-built_in">make</span>(driver);    &#125;);    <span class="hljs-keyword">if</span> (requireDefault) &#123;        <span class="hljs-comment">// Detect if we are trying to initialize with a different driver, and</span>        <span class="hljs-comment">// consider that an error. ProcessState will only be initialized once above.</span>        <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(gProcess-&gt;<span class="hljs-built_in">getDriverName</span>() != driver,                            <span class="hljs-string">&quot;ProcessState was already initialized with %s,&quot;</span>                            <span class="hljs-string">&quot; can&#x27;t initialize with %s.&quot;</span>,                            gProcess-&gt;<span class="hljs-built_in">getDriverName</span>().<span class="hljs-built_in">c_str</span>(), driver);    &#125;    <span class="hljs-built_in">verifyNotForked</span>(gProcess-&gt;mForked);    <span class="hljs-keyword">return</span> gProcess;&#125;<span class="hljs-comment">// 构造 ProcessState 的时候就会打开 binder：open(&quot;/dev/binder&quot;) &amp;&amp; mmap</span><span class="hljs-comment">// http://www.aospxref.com/android-13.0.0_r3/xref/frameworks/native/libs/binder/ProcessState.cpp#ProcessState</span>ProcessState::<span class="hljs-built_in">ProcessState</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)      : <span class="hljs-built_in">mDriverName</span>(<span class="hljs-built_in">String8</span>(driver)),        <span class="hljs-built_in">mDriverFD</span>(<span class="hljs-number">-1</span>),        <span class="hljs-built_in">mVMStart</span>(MAP_FAILED),        <span class="hljs-built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER),        <span class="hljs-built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER),        <span class="hljs-built_in">mExecutingThreadsCount</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mWaitingForThreads</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS),        <span class="hljs-built_in">mStarvationStartTimeMs</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mForked</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mThreadPoolStarted</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mThreadPoolSeq</span>(<span class="hljs-number">1</span>),        <span class="hljs-built_in">mCallRestriction</span>(CallRestriction::NONE) &#123;    base::Result&lt;<span class="hljs-type">int</span>&gt; opened = <span class="hljs-built_in">open_driver</span>(driver);    <span class="hljs-keyword">if</span> (opened.<span class="hljs-built_in">ok</span>()) &#123;        <span class="hljs-comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span>        mVMStart = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE,                        opened.<span class="hljs-built_in">value</span>(), <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (mVMStart == MAP_FAILED) &#123;            <span class="hljs-built_in">close</span>(opened.<span class="hljs-built_in">value</span>());            <span class="hljs-comment">// *sigh*</span>            opened = base::<span class="hljs-built_in">Error</span>()                    &lt;&lt; <span class="hljs-string">&quot;Using &quot;</span> &lt;&lt; driver &lt;&lt; <span class="hljs-string">&quot; failed: unable to mmap transaction memory.&quot;</span>;            mDriverName.<span class="hljs-built_in">clear</span>();        &#125;    &#125;    <span class="hljs-keyword">if</span> (opened.<span class="hljs-built_in">ok</span>()) &#123;        mDriverFD = opened.<span class="hljs-built_in">value</span>();    &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> base::Result&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">open_driver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)</span> </span>&#123;    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(driver, O_RDWR | O_CLOEXEC);    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">ErrnoError</span>() &lt;&lt; <span class="hljs-string">&quot;Opening &#x27;&quot;</span> &lt;&lt; driver &lt;&lt; <span class="hljs-string">&quot;&#x27; failed&quot;</span>;    &#125;    <span class="hljs-type">int</span> vers = <span class="hljs-number">0</span>;    <span class="hljs-type">status_t</span> result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-built_in">close</span>(fd);        <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">ErrnoError</span>() &lt;&lt; <span class="hljs-string">&quot;Binder ioctl to obtain version failed&quot;</span>;    &#125;    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;        <span class="hljs-built_in">close</span>(fd);        <span class="hljs-keyword">return</span> base::<span class="hljs-built_in">Error</span>() &lt;&lt; <span class="hljs-string">&quot;Binder driver protocol(&quot;</span> &lt;&lt; vers                             &lt;&lt; <span class="hljs-string">&quot;) does not match user space protocol(&quot;</span>                             &lt;&lt; BINDER_CURRENT_PROTOCOL_VERSION                             &lt;&lt; <span class="hljs-string">&quot;)! ioctl() return value: &quot;</span> &lt;&lt; result;    &#125;    <span class="hljs-type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;    result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));    &#125;    <span class="hljs-type">uint32_t</span> enable = DEFAULT_ENABLE_ONEWAY_SPAM_DETECTION;    result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_ENABLE_ONEWAY_SPAM_DETECTION, &amp;enable);    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-built_in">ALOGE_IF</span>(ProcessState::<span class="hljs-built_in">isDriverFeatureEnabled</span>(                     ProcessState::DriverFeature::ONEWAY_SPAM_DETECTION),                 <span class="hljs-string">&quot;Binder ioctl to enable oneway spam detection failed: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));    &#125;    <span class="hljs-keyword">return</span> fd;&#125;</code></pre></div><h1 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h1><p><code>IPCThreadState</code> 是线程私有的，它依靠全局单例 <code>ProcessState</code> 打开 binder driver 得到 binder fd</p><blockquote><p>pthread_getspecific, pthread_setspecific — thread-specific data management</p><p>The pthread_getspecific() function shall return the value currently bound to the specified key on behalf of the calling thread.</p><p>The pthread_setspecific() function shall associate a thread-specific value with a key obtained via a previous call to pthread_key_create().  Different threads may bind different values to the same key. </p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/BpBinder.cpp</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BpBinder::transact</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">status_t</span> status;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(<span class="hljs-built_in">isRpcBinder</span>())) &#123;            status = <span class="hljs-built_in">rpcSession</span>()-&gt;<span class="hljs-built_in">transact</span>(sp&lt;IBinder&gt;::<span class="hljs-built_in">fromExisting</span>(<span class="hljs-keyword">this</span>), code, data, reply,                                            flags);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (!kEnableKernelIpc) &#123;                <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;Binder kernel driver disabled at build time&quot;</span>);                <span class="hljs-keyword">return</span> INVALID_OPERATION;            &#125;            <span class="hljs-comment">// binderHandle() 是 server 句柄，比如 servicemanager 就是 0</span>            <span class="hljs-comment">// IPCThreadState::self() 返回线程本地/线程私有的 IPCThreadState 实例</span>            status = IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">transact</span>(<span class="hljs-built_in">binderHandle</span>(), code, data, reply, flags);        &#125;        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// IPCThreadState 是线程私有的</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/IPCThreadState.cpp</span><span class="hljs-function">IPCThreadState* <span class="hljs-title">IPCThreadState::self</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (gHaveTLS.<span class="hljs-built_in">load</span>(std::memory_order_acquire)) &#123;restart:        <span class="hljs-type">const</span> <span class="hljs-type">pthread_key_t</span> k = gTLS;        IPCThreadState* st = (IPCThreadState*)<span class="hljs-built_in">pthread_getspecific</span>(k);        <span class="hljs-keyword">if</span> (st) <span class="hljs-keyword">return</span> st;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPCThreadState;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/IPCThreadState.cpp</span>IPCThreadState::<span class="hljs-built_in">IPCThreadState</span>()      : <span class="hljs-built_in">mProcess</span>(ProcessState::<span class="hljs-built_in">self</span>()),        <span class="hljs-built_in">mServingStackPointer</span>(<span class="hljs-literal">nullptr</span>),        <span class="hljs-built_in">mServingStackPointerGuard</span>(<span class="hljs-literal">nullptr</span>),        <span class="hljs-built_in">mWorkSource</span>(kUnsetWorkSource),        <span class="hljs-built_in">mPropagateWorkSource</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mIsLooper</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mIsFlushing</span>(<span class="hljs-literal">false</span>),        <span class="hljs-built_in">mStrictModePolicy</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mLastTransactionBinderFlags</span>(<span class="hljs-number">0</span>),        <span class="hljs-built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction) &#123;    <span class="hljs-built_in">pthread_setspecific</span>(gTLS, <span class="hljs-keyword">this</span>);    <span class="hljs-built_in">clearCaller</span>();    mIn.<span class="hljs-built_in">setDataCapacity</span>(<span class="hljs-number">256</span>);    mOut.<span class="hljs-built_in">setDataCapacity</span>(<span class="hljs-number">256</span>);&#125;<span class="hljs-comment">// http://www.aospxref.com/android-13.0.0_r3/xref/frameworks/native/libs/binder/IPCThreadState.cpp</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::transact</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> handle,</span></span><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data,</span></span><span class="hljs-params"><span class="hljs-function">                                  Parcel* reply, <span class="hljs-type">uint32_t</span> flags)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 将 [BC_TRANSACTION][binder_transaction_data] 写入 mOut</span>    <span class="hljs-comment">// mOut 是 client 进程内的一块内存区域</span>    err = <span class="hljs-built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// 将 request 发送给 binder driver 并等待 response</span>    err = <span class="hljs-built_in">waitForResponse</span>(reply);    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> err;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::writeTransactionData</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd, <span class="hljs-type">uint32_t</span> binderFlags,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int32_t</span> handle, <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, <span class="hljs-type">status_t</span>* statusBuffer)</span></span><span class="hljs-function"></span>&#123;    binder_transaction_data tr;    tr.target.ptr = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span>    tr.target.handle = handle;    tr.code = code;    tr.flags = binderFlags;    tr.cookie = <span class="hljs-number">0</span>;    tr.sender_pid = <span class="hljs-number">0</span>;    tr.sender_euid = <span class="hljs-number">0</span>;    <span class="hljs-type">const</span> <span class="hljs-type">status_t</span> err = data.<span class="hljs-built_in">errorCheck</span>();    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;        tr.data_size = data.<span class="hljs-built_in">ipcDataSize</span>();        tr.data.ptr.buffer = data.<span class="hljs-built_in">ipcData</span>();        tr.offsets_size = data.<span class="hljs-built_in">ipcObjectsCount</span>()*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>);        tr.data.ptr.offsets = data.<span class="hljs-built_in">ipcObjects</span>();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusBuffer) &#123;        tr.flags |= TF_STATUS_CODE;        *statusBuffer = err;        tr.data_size = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">status_t</span>);        tr.data.ptr.buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(statusBuffer);        tr.offsets_size = <span class="hljs-number">0</span>;        tr.data.ptr.offsets = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">return</span> (mLastError = err);    &#125;    mOut.<span class="hljs-built_in">writeInt32</span>(cmd);    mOut.<span class="hljs-built_in">write</span>(&amp;tr, <span class="hljs-built_in">sizeof</span>(tr));    <span class="hljs-keyword">return</span> NO_ERROR;&#125;<span class="hljs-comment">// 处理 response</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::waitForResponse</span><span class="hljs-params">(Parcel *reply, <span class="hljs-type">status_t</span> *acquireResult)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">uint32_t</span> cmd;    <span class="hljs-type">int32_t</span> err;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> ((err=<span class="hljs-built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>;        err = mIn.<span class="hljs-built_in">errorCheck</span>();        <span class="hljs-keyword">if</span> (err &lt; NO_ERROR) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span> (mIn.<span class="hljs-built_in">dataAvail</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        cmd = (<span class="hljs-type">uint32_t</span>)mIn.<span class="hljs-built_in">readInt32</span>();        <span class="hljs-keyword">switch</span> (cmd) &#123;        <span class="hljs-keyword">case</span> BR_FAILED_REPLY:        <span class="hljs-keyword">case</span> BR_FROZEN_REPLY:        <span class="hljs-keyword">case</span> BR_ACQUIRE_RESULT:        <span class="hljs-keyword">case</span> BR_REPLY:        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 将 request 发送给 binder driver 并接收 response</span><span class="hljs-comment">// ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, binder_write_read)</span><span class="hljs-comment">// [write_buffer, write_size] 是 request</span><span class="hljs-comment">// [read_buffer, read_size] 是 response</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::talkWithDriver</span><span class="hljs-params">(<span class="hljs-type">bool</span> doReceive)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -EBADF;    &#125;    binder_write_read bwr;    <span class="hljs-comment">// Is the read buffer empty?</span>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> needRead = mIn.<span class="hljs-built_in">dataPosition</span>() &gt;= mIn.<span class="hljs-built_in">dataSize</span>();    <span class="hljs-comment">// We don&#x27;t want to write anything if we are still reading</span>    <span class="hljs-comment">// from data left in the input buffer and the caller</span>    <span class="hljs-comment">// has requested to read the next data.</span>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="hljs-built_in">dataSize</span>() : <span class="hljs-number">0</span>;    bwr.write_size = outAvail;    bwr.write_buffer = (<span class="hljs-type">uintptr_t</span>)mOut.<span class="hljs-built_in">data</span>();    <span class="hljs-comment">// This is what we&#x27;ll read.</span>    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;        bwr.read_size = mIn.<span class="hljs-built_in">dataCapacity</span>();        bwr.read_buffer = (<span class="hljs-type">uintptr_t</span>)mIn.<span class="hljs-built_in">data</span>();    &#125; <span class="hljs-keyword">else</span> &#123;        bwr.read_size = <span class="hljs-number">0</span>;        bwr.read_buffer = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// Return immediately if there is nothing to do.</span>    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> NO_ERROR;    bwr.write_consumed = <span class="hljs-number">0</span>;    bwr.read_consumed = <span class="hljs-number">0</span>;    <span class="hljs-type">status_t</span> err;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)            err = NO_ERROR;        <span class="hljs-keyword">else</span>            err = -errno;        <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;            err = -EBADF;        &#125;    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="Zygote-amp-system-server"><a href="#Zygote-amp-system-server" class="headerlink" title="Zygote &amp; system server"></a>Zygote &amp; system server</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Main entry of app process.</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/cmds/app_process/app_main.cpp</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">bool</span> zygote = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span> (i &lt; argc) &#123;        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg = argv[i++];        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(arg, <span class="hljs-string">&quot;--zygote&quot;</span>) == <span class="hljs-number">0</span>) &#123;            zygote = <span class="hljs-literal">true</span>;            niceName = ZYGOTE_NICE_NAME;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (zygote) &#123;        runtime.<span class="hljs-built_in">start</span>(<span class="hljs-string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);  <span class="hljs-comment">// 启动虚拟机，并调用 ZygoteInit.main(String argv[])</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 主要做四件事：</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 1、注册 socket（通过 socket 让 zygote 进程 fork 出其他 app 进程）</span><span class="hljs-comment"> * 2、预加载资源</span><span class="hljs-comment"> * 3、启动 system_server</span><span class="hljs-comment"> * 4、启动消息循环</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,</span><span class="hljs-comment"> * and handles other tasks related to preparing the process for forking into applications</span><span class="hljs-comment"> */</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-built_in">main</span>(String[] argv) &#123;    <span class="hljs-comment">// ...</span>    boolean startSystemServer = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argv.length; i++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;start-system-server&quot;</span>.<span class="hljs-built_in">equals</span>(argv[i])) &#123;            startSystemServer = <span class="hljs-literal">true</span>;        &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (startSystemServer) &#123;        Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// fork 出 system_server 进程并进入其逻辑</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> Runnable <span class="hljs-title">forkSystemServer</span><span class="hljs-params">(String abiList, String socketName,</span></span><span class="hljs-params"><span class="hljs-function">        ZygoteServer zygoteServer)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">/* Request to fork the system server process */</span>    pid = Zygote.forkSystemServer(            parsedArgs.mUid, parsedArgs.mGid,            parsedArgs.mGids,            parsedArgs.mRuntimeFlags,            null,            parsedArgs.mPermittedCapabilities,            parsedArgs.mEffectiveCapabilities);    <span class="hljs-comment">/* For child process */</span>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasSecondZygote</span>(abiList)) &#123;            <span class="hljs-built_in">waitForSecondaryZygote</span>(socketName);        &#125;        zygoteServer.<span class="hljs-built_in">closeServerSocket</span>();        <span class="hljs-keyword">return</span> <span class="hljs-built_in">handleSystemServerProcess</span>(parsedArgs);    &#125;    <span class="hljs-keyword">return</span> null;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> Runnable <span class="hljs-title">handleSystemServerProcess</span><span class="hljs-params">(ZygoteArguments parsedArgs)</span> </span>&#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Pass the remaining arguments to SystemServer.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> ZygoteInit.<span class="hljs-built_in">zygoteInit</span>(parsedArgs.mTargetSdkVersion,                parsedArgs.mDisabledCompatChanges,                parsedArgs.mRemainingArgs, cl);    &#125;    <span class="hljs-comment">/* should never reach here */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * The main function called when started through the zygote process. This could be unified with</span><span class="hljs-comment"> * main(), if the native code in nativeFinishInit() were rationalized with Zygote startup.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> Runnable <span class="hljs-title">zygoteInit</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSdkVersion, <span class="hljs-type">long</span>[] disabledCompatChanges,</span></span><span class="hljs-params"><span class="hljs-function">        String[] argv, ClassLoader classLoader)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    ZygoteInit.<span class="hljs-built_in">nativeZygoteInit</span>();    <span class="hljs-keyword">return</span> RuntimeInit.<span class="hljs-built_in">applicationInit</span>(targetSdkVersion, disabledCompatChanges, argv,            classLoader);&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/AndroidRuntime.cpp</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="hljs-params">(JNIEnv* env, jobject clazz)</span></span><span class="hljs-function"></span>&#123;    gCurRuntime-&gt;<span class="hljs-built_in">onZygoteInit</span>();  <span class="hljs-comment">// AppRuntime-&gt;onZygoteInit()</span>&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/cmds/app_process/app_main.cpp</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onZygoteInit</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 上面介绍过，ProcessState 是单例模式，初始化实例时会：</span>    <span class="hljs-comment">// 1，打开 binder driver：open(&quot;/dev/binder&quot;) &amp;&amp; mmap</span>    <span class="hljs-comment">// 2，版本查询和校验：BINDER_VERSION</span>    <span class="hljs-comment">// 3，设置线程数：BINDER_SET_MAX_THREADS</span>    <span class="hljs-comment">// ...</span>    sp&lt;ProcessState&gt; proc = ProcessState::<span class="hljs-built_in">self</span>();    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;App process: starting thread pool.\n&quot;</span>);    proc-&gt;<span class="hljs-built_in">startThreadPool</span>();&#125;<span class="hljs-comment">// 开启一个子线程执行 binder 消息通讯的 loop：IPCThreadState::self()-&gt;joinThreadPool = talkWithDriver + executeCommand</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/ProcessState.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::startThreadPool</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    AutoMutex _l(mLock);    <span class="hljs-keyword">if</span> (!mThreadPoolStarted) &#123;        <span class="hljs-keyword">if</span> (mMaxThreads == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Extra binder thread started, but 0 threads requested. Do not use &quot;</span>                  <span class="hljs-string">&quot;*startThreadPool when zero threads are requested.&quot;</span>);        &#125;        mThreadPoolStarted = <span class="hljs-literal">true</span>;        <span class="hljs-built_in">spawnPooledThread</span>(<span class="hljs-literal">true</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessState::spawnPooledThread</span><span class="hljs-params">(<span class="hljs-type">bool</span> isMain <span class="hljs-comment">/* true */</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (mThreadPoolStarted) &#123;        String8 name = <span class="hljs-built_in">makeBinderThreadName</span>();        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Spawning new pooled thread, name=%s\n&quot;</span>, name.<span class="hljs-built_in">string</span>());        sp&lt;Thread&gt; t = sp&lt;PoolThread&gt;::<span class="hljs-built_in">make</span>(isMain);        t-&gt;<span class="hljs-built_in">run</span>(name.<span class="hljs-built_in">string</span>());        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mThreadCountLock);        mKernelStartedThreads++;        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mThreadCountLock);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PoolThread</span> : <span class="hljs-keyword">public</span> Thread&#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">joinThreadPool</span>(mIsMain <span class="hljs-comment">/* true */</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IPCThreadState::joinThreadPool</span><span class="hljs-params">(<span class="hljs-type">bool</span> isMain)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// mOut 是给 binder driver 读取的区域，此时是 BC_ENTER_LOOPER</span>    mOut.<span class="hljs-built_in">writeInt32</span>(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);    mIsLooper = <span class="hljs-literal">true</span>;    <span class="hljs-type">status_t</span> result;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-comment">// now get the next command to be processed, waiting if necessary</span>        result = <span class="hljs-built_in">getAndExecuteCommand</span>();        <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::getAndExecuteCommand</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span>    result = <span class="hljs-built_in">talkWithDriver</span>();    cmd = mIn.<span class="hljs-built_in">readInt32</span>()    result = <span class="hljs-built_in">executeCommand</span>(cmd);&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入 Binder 之 servicemanager 进程</title>
    <link href="/2022/10/26/binder-servicemanager/"/>
    <url>/2022/10/26/binder-servicemanager/</url>
    
    <content type="html"><![CDATA[<h1 id="主例程"><a href="#主例程" class="headerlink" title="主例程"></a>主例程</h1><p><code>servicemanager</code> 进程是由 init 进程通过 <a href="https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/servicemanager.rc">servicemanager.rc</a> 配置文件启动的，其所在的可执行文件在 <code>system/bin/servicemanager</code>，对应的源文件是 <a href="https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/main.cpp">/platform/frameworks/native/cmds/servicemanager/main.cpp</a></p><div class="code-wrapper"><pre><code class="hljs rc">service servicemanager /system/bin/servicemanager    class core animation    user system    group system readproc    critical    onrestart restart apexd    onrestart restart audioserver    onrestart restart gatekeeperd    onrestart class_restart main    onrestart class_restart hal    onrestart class_restart early_hal    writepid /dev/cpuset/system-background/tasks    shutdown critical</code></pre></div><p>servicemanager 是 Binder IPC 过程中的守护进程，是一个具体的服务，其功能主要是 <code>查询</code> 和 <code>注册服务</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/main.cpp</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; [binder driver]&quot;</span>;    &#125;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver = argc == <span class="hljs-number">2</span> ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;/dev/binder&quot;</span>;    <span class="hljs-comment">// binder IPC 的默认地址是 /dev/binder</span>    <span class="hljs-comment">// 初始化 binder 连接</span>    sp&lt;ProcessState&gt; ps = ProcessState::<span class="hljs-built_in">initWithDriver</span>(driver);    ps-&gt;<span class="hljs-built_in">setThreadPoolMaxThreadCount</span>(<span class="hljs-number">0</span>);    <span class="hljs-comment">// ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads)</span>    ps-&gt;<span class="hljs-built_in">setCallRestriction</span>(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);    <span class="hljs-comment">// 注册成为 binder 的服务管理器（ContextManager），id == 0，handle == 0</span>    sp&lt;ServiceManager&gt; manager = sp&lt;ServiceManager&gt;::<span class="hljs-built_in">make</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Access&gt;());    <span class="hljs-keyword">if</span> (!manager-&gt;<span class="hljs-built_in">addService</span>(<span class="hljs-string">&quot;manager&quot;</span>, manager, <span class="hljs-literal">false</span> <span class="hljs-comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).<span class="hljs-built_in">isOk</span>()) &#123;        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Could not self register servicemanager&quot;</span>;    &#125;    <span class="hljs-comment">// IPCThreadState 实例是线程本地变量（thread local），通过 IPCThreadState::self() 获得</span>    <span class="hljs-comment">// cpp 通过 pthread_getspecific(key) 和 pthread_setspecific(key, value) 设置/获取线程本地变量</span>    IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setTheContextObject</span>(manager);    ps-&gt;<span class="hljs-built_in">becomeContextManager</span>();    <span class="hljs-comment">// BINDER_SET_CONTEXT_MGR_EXT</span>    <span class="hljs-comment">// 开始主循环：提供注册&amp;查询服务</span>    sp&lt;Looper&gt; looper = Looper::<span class="hljs-built_in">prepare</span>(<span class="hljs-literal">false</span> <span class="hljs-comment">/*allowNonCallbacks*/</span>);    BinderCallback::<span class="hljs-built_in">setupTo</span>(looper);    ClientCallbackCallback::<span class="hljs-built_in">setupTo</span>(looper, manager);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;        looper-&gt;<span class="hljs-built_in">pollAll</span>(<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-comment">// should not be reached</span>    <span class="hljs-keyword">return</span> EXIT_FAILURE;&#125;</code></pre></div><h1 id="初始化-binder-连接"><a href="#初始化-binder-连接" class="headerlink" title="初始化 binder 连接"></a>初始化 binder 连接</h1><ol><li>通过系统调用 <code>open</code> 打开 <code>/dev/binder</code> 得到 binder 驱动的文件描述符 fd</li><li>通过 <code>ioctl</code> 与 binder 驱动交互进行一系列的初始化操作<ol><li>BINDER_VERSION 版本校验</li><li>BINDER_SET_MAX_THREADS 设置 binder 驱动线程池的容量</li><li>BINDER_ENABLE_ONEWAY_SPAM_DETECTION</li><li>…</li></ol></li><li>通过 <code>mmap</code> 在 servicemanager 进程分配一块虚存用以后续使用（对应 binder 驱动的 <code>binder_mmap</code>）</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/libs/binder/ProcessState.cpp</span><span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::initWithDriver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* driver)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">init</span>(driver, <span class="hljs-literal">true</span> <span class="hljs-comment">/*requireDefault*/</span>); &#125;<span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver, <span class="hljs-type">bool</span> requireDefault)</span> </span>&#123;...&#125;ProcessState::<span class="hljs-built_in">ProcessState</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver)          <span class="hljs-comment">// driver 参数是指 binder 的路径：/dev/binder</span>    : <span class="hljs-built_in">mDriverName</span>(<span class="hljs-built_in">String8</span>(driver))                      <span class="hljs-comment">// 记录 binder 路径</span>    , <span class="hljs-built_in">mDriverFD</span>(<span class="hljs-built_in">open_driver</span>(driver))                    <span class="hljs-comment">// 打开 binder 并记录下它的 fd</span>    , <span class="hljs-built_in">mVMStart</span>(MAP_FAILED)                              <span class="hljs-comment">// mmap 分配的一块内存空间，后续会用到</span>    , <span class="hljs-built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)    , <span class="hljs-built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)    , <span class="hljs-built_in">mExecutingThreadsCount</span>(<span class="hljs-number">0</span>)    , <span class="hljs-built_in">mWaitingForThreads</span>(<span class="hljs-number">0</span>)    , <span class="hljs-built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)    , <span class="hljs-built_in">mStarvationStartTimeMs</span>(<span class="hljs-number">0</span>)    , <span class="hljs-built_in">mThreadPoolStarted</span>(<span class="hljs-literal">false</span>)    , <span class="hljs-built_in">mThreadPoolSeq</span>(<span class="hljs-number">1</span>)    , <span class="hljs-built_in">mCallRestriction</span>(CallRestriction::NONE)&#123;    <span class="hljs-keyword">if</span> (mDriverFD &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span>        mVMStart = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (mVMStart == MAP_FAILED) &#123;            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="hljs-built_in">c_str</span>());            <span class="hljs-built_in">close</span>(mDriverFD);            mDriverFD = <span class="hljs-number">-1</span>;            mDriverName.<span class="hljs-built_in">clear</span>();        &#125;    &#125;&#125;<span class="hljs-comment">// 打开 binder driver 得到 fd，同时会通过 ioctl 设置一些初始参数</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">open_driver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver <span class="hljs-comment">/* /dev/binder */</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(driver, O_RDWR | O_CLOEXEC);               <span class="hljs-comment">// 打开 binder driver 得到其 fd，后续通过 ioctl 与 binder driver 通讯</span>    <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">int</span> vers = <span class="hljs-number">0</span>;        <span class="hljs-type">status_t</span> result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);  <span class="hljs-comment">// 校验 binder driver 版本</span>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));            <span class="hljs-built_in">close</span>(fd);            fd = <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;          <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);            <span class="hljs-built_in">close</span>(fd);            fd = <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;      <span class="hljs-comment">// 使用 ioctl 设置 binder 的线程池数量</span>        result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);          <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));        &#125;        <span class="hljs-type">uint32_t</span> enable = DEFAULT_ENABLE_ONEWAY_SPAM_DETECTION;        result = <span class="hljs-built_in">ioctl</span>(fd, BINDER_ENABLE_ONEWAY_SPAM_DETECTION, &amp;enable);        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;Binder ioctl to enable oneway spam detection failed: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="hljs-built_in">strerror</span>(errno));    &#125;    <span class="hljs-keyword">return</span> fd;&#125;</code></pre></div><h1 id="注册为服务管理器"><a href="#注册为服务管理器" class="headerlink" title="注册为服务管理器"></a>注册为服务管理器</h1><ol><li>通过 <code>ioctl(BINDER_SET_CONTEXT_MGR_EXT)</code> 在 binder driver 将自己注册为服务管理器 <code>binder_context_mgr_node</code>，handle == 0</li><li>将 <code>ServiceManager</code> 注册为本地进程响应 binder 消息的服务管理器：<code>IPCThreadState::self()-&gt;setTheContextObject(manager)</code></li><li>将 <code>ServiceManager</code> 实例自己给自己注册为 <code>manager</code></li><li>服务管理器的作用后面会讲到，主要是处理 handle == 0 的情况，client 查找 server 时得先有 service_manager 标识</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// ServiceManager 内部维护了一个 map：mNameToService，string -&gt; IBinder</span><span class="hljs-comment">// 这里将自己添加进去：manager -&gt; ServiceManager</span><span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/ServiceManager.cpp</span><span class="hljs-function">Status <span class="hljs-title">ServiceManager::addService</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> std::string&amp; name   <span class="hljs-comment">/* manager */</span>, </span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; binder <span class="hljs-comment">/* this */</span>, </span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> allowIsolated        <span class="hljs-comment">/* false */</span>, </span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int32_t</span> dumpPriority      <span class="hljs-comment">/* IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT */</span></span></span><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;    <span class="hljs-keyword">auto</span> ctx = mAccess-&gt;<span class="hljs-built_in">getCallingContext</span>();    <span class="hljs-comment">// apps cannot add services</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">multiuser_get_app_id</span>(ctx.uid) &gt;= AID_APP) &#123;        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">fromExceptionCode</span>(Status::EX_SECURITY);    &#125;    <span class="hljs-keyword">if</span> (!mAccess-&gt;<span class="hljs-built_in">canAdd</span>(ctx, name)) &#123;        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">fromExceptionCode</span>(Status::EX_SECURITY);    &#125;    <span class="hljs-keyword">if</span> (binder == <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">fromExceptionCode</span>(Status::EX_ILLEGAL_ARGUMENT);    &#125;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidServiceName</span>(name)) &#123;        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Invalid service name: &quot;</span> &lt;&lt; name;        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">fromExceptionCode</span>(Status::EX_ILLEGAL_ARGUMENT);    &#125;    <span class="hljs-comment">// implicitly unlinked when the binder is removed</span>    <span class="hljs-keyword">if</span> (binder-&gt;<span class="hljs-built_in">remoteBinder</span>() != <span class="hljs-literal">nullptr</span> &amp;&amp;        binder-&gt;<span class="hljs-built_in">linkToDeath</span>(sp&lt;ServiceManager&gt;::<span class="hljs-built_in">fromExisting</span>(<span class="hljs-keyword">this</span>)) != OK) &#123;        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Could not linkToDeath when adding &quot;</span> &lt;&lt; name;        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">fromExceptionCode</span>(Status::EX_ILLEGAL_STATE);    &#125;    <span class="hljs-comment">// Overwrite the old service if it exists</span>    mNameToService[name] = Service &#123;        .binder = binder,        .allowIsolated = allowIsolated,        .dumpPriority = dumpPriority,        .debugPid = ctx.debugPid,    &#125;;    <span class="hljs-keyword">auto</span> it = mNameToRegistrationCallback.<span class="hljs-built_in">find</span>(name);    <span class="hljs-keyword">if</span> (it != mNameToRegistrationCallback.<span class="hljs-built_in">end</span>()) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123;            mNameToService[name].guaranteeClient = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// permission checked in registerForNotifications</span>            cb-&gt;<span class="hljs-built_in">onRegistration</span>(name, binder);        &#125;    &#125;    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">ok</span>();&#125;<span class="hljs-comment">// 发送消息 BINDER_SET_CONTEXT_MGR_EXT 给 binder，使自己成为服务管理器</span><span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/libs/binder/ProcessState.cpp</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProcessState::becomeContextManager</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    AutoMutex _l(mLock);    flat_binder_object obj &#123;        .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX,    &#125;;    <span class="hljs-type">int</span> result = <span class="hljs-built_in">ioctl</span>(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj);    <span class="hljs-comment">// fallback to original method</span>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">android_errorWriteLog</span>(<span class="hljs-number">0x534e4554</span>, <span class="hljs-string">&quot;121035042&quot;</span>);        <span class="hljs-type">int</span> unused = <span class="hljs-number">0</span>;        result = <span class="hljs-built_in">ioctl</span>(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);    &#125;    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Binder ioctl to become context manager failed: %s\n&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));    &#125;    <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/tags/android-13.0.0_r0.20/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">flat_binder_object</span> fbo;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;fbo, ubuf, <span class="hljs-built_in">sizeof</span>(fbo))) &#123;ret = -EINVAL;<span class="hljs-keyword">goto</span> err;&#125;ret = <span class="hljs-built_in">binder_ioctl_set_ctx_mgr</span>(filp, &amp;fbo);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">goto</span> err;<span class="hljs-keyword">break</span>;&#125;    <span class="hljs-comment">// ...</span>&#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_set_ctx_mgr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> flat_binder_object *fbo)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_context</span> *context = proc-&gt;context;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_node</span> *new_node;new_node = <span class="hljs-built_in">binder_new_node</span>(proc, fbo);<span class="hljs-built_in">binder_node_lock</span>(new_node);new_node-&gt;local_weak_refs++;new_node-&gt;local_strong_refs++;new_node-&gt;has_strong_ref = <span class="hljs-number">1</span>;new_node-&gt;has_weak_ref = <span class="hljs-number">1</span>;context-&gt;binder_context_mgr_node = new_node;<span class="hljs-built_in">binder_node_unlock</span>(new_node);<span class="hljs-built_in">binder_put_node</span>(new_node);&#125;</code></pre></div><h1 id="开始-binder-消息循环"><a href="#开始-binder-消息循环" class="headerlink" title="开始 binder 消息循环"></a>开始 binder 消息循环</h1><ol><li><p><code>epoll</code> 监听 driver fd，当 binder 发消息过来时（<code>Looper::EVENT_INPUT</code>）主动调用 <code>IPCThreadState::self()-&gt;handlePolledCommands()</code> 处理 binder 消息</p></li><li><p><code>ServiceManager</code> 继承自 <code>BnServiceManager</code> 得到 <code>onTransact</code> 方法，BnServiceManager 是类似于 AIDL 这样的机制自动生成的代码，根据 aidl code 调用对应的业务方法，并从 <code>Parcel</code> 解包请求参数，将响应打包至 <code>Parcel</code></p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/main.cpp</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 开始主循环</span>    sp&lt;Looper&gt; looper = Looper::<span class="hljs-built_in">prepare</span>(<span class="hljs-literal">false</span> <span class="hljs-comment">/*allowNonCallbacks*/</span>);    BinderCallback::<span class="hljs-built_in">setupTo</span>(looper);    ClientCallbackCallback::<span class="hljs-built_in">setupTo</span>(looper, manager);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;        looper-&gt;<span class="hljs-built_in">pollAll</span>(<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-comment">// should not be reached</span>    <span class="hljs-keyword">return</span> EXIT_FAILURE;&#125;<span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/main.cpp</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderCallback</span> : <span class="hljs-keyword">public</span> LooperCallback &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> sp&lt;BinderCallback&gt; <span class="hljs-title">setupTo</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;        sp&lt;BinderCallback&gt; cb = sp&lt;BinderCallback&gt;::<span class="hljs-built_in">make</span>();        <span class="hljs-type">int</span> binder_fd = <span class="hljs-number">-1</span>;        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setupPolling</span>(&amp;binder_fd);    <span class="hljs-comment">// 获得已打开的 binder driver fd</span>        <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(binder_fd &lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Failed to setupPolling: %d&quot;</span>, binder_fd);        <span class="hljs-type">int</span> ret = looper-&gt;<span class="hljs-built_in">addFd</span>(binder_fd,                   <span class="hljs-comment">// binder 发消息过来时回调 handlePolledCommands</span>                                Looper::POLL_CALLBACK,                                Looper::EVENT_INPUT,                                cb,                                <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/*data*/</span>);        <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(ret != <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Failed to add binder FD to Looper&quot;</span>);        <span class="hljs-keyword">return</span> cb;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* fd */</span>, <span class="hljs-type">int</span> <span class="hljs-comment">/* events */</span>, <span class="hljs-type">void</span>* <span class="hljs-comment">/* data */</span>)</span> <span class="hljs-keyword">override</span> </span>&#123;        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">handlePolledCommands</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// Continue receiving callbacks.</span>    &#125;&#125;;<span class="hljs-comment">// binder 有消息过来，需要处理</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/IPCThreadState.cpp</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::handlePolledCommands</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span>    result = <span class="hljs-built_in">getAndExecuteCommand</span>();&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::getAndExecuteCommand</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span>    result = <span class="hljs-built_in">talkWithDriver</span>();    cmd = mIn.<span class="hljs-built_in">readInt32</span>()    result = <span class="hljs-built_in">executeCommand</span>(cmd);&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::executeCommand</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">switch</span> ((<span class="hljs-type">uint32_t</span>)cmd) &#123;    <span class="hljs-keyword">case</span> BR_TRANSACTION_SEC_CTX:    <span class="hljs-keyword">case</span> BR_TRANSACTION:        &#123;            binder_transaction_data_secctx tr_secctx;            binder_transaction_data&amp; tr = tr_secctx.transaction_data;            <span class="hljs-keyword">if</span> (cmd == (<span class="hljs-type">int</span>) BR_TRANSACTION_SEC_CTX) &#123;                result = mIn.<span class="hljs-built_in">read</span>(&amp;tr_secctx, <span class="hljs-built_in">sizeof</span>(tr_secctx));            &#125; <span class="hljs-keyword">else</span> &#123;                result = mIn.<span class="hljs-built_in">read</span>(&amp;tr, <span class="hljs-built_in">sizeof</span>(tr));                tr_secctx.secctx = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span> (tr.target.ptr) &#123;                <span class="hljs-comment">// ...</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// client 想要访问 service_manager 只需要构造一个 BpBinder(handle = 0)</span>                <span class="hljs-comment">// binder driver 遇到 handle == 0 会交由注册的服务管理器处理（也就是 service_manager）</span>                <span class="hljs-comment">// 在 service_manager 进程内响应 binder 消息时，遇到 handle == 0 又会交由 the_context_object 处理</span>                <span class="hljs-comment">// 它其实是 ServiceManager 实例，上一章节讲过</span>                error = the_context_object-&gt;<span class="hljs-built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);            &#125;            <span class="hljs-comment">// 返回响应数据</span>            <span class="hljs-keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">sendReply</span>(reply, (tr.flags &amp; kForwardReplyFlags));                <span class="hljs-comment">// ...</span>            &#125;&#125;<span class="hljs-comment">// BnServiceManager 看起来跟 AIDL 一样是自动生成的代码</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/cmds/servicemanager/ServiceManager.h</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> : <span class="hljs-keyword">public</span> os::BnServiceManager, <span class="hljs-keyword">public</span> IBinder::DeathRecipient &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">binder::Status <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-function">binder::Status <span class="hljs-title">checkService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-function">binder::Status <span class="hljs-title">addService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; binder,</span></span><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">bool</span> allowIsolated, <span class="hljs-type">int32_t</span> dumpPriority)</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-comment">// ...                              </span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_recovery_x86_64_silvermont_shared/gen/aidl/android/os/BnServiceManager.h</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BnServiceManager</span> : <span class="hljs-keyword">public</span> ::android::BnInterface&lt;IServiceManager&gt; &#123;<span class="hljs-keyword">public</span>:  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_getService = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_checkService = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">1</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_addService = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">2</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_listServices = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">3</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_registerForNotifications = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">4</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_unregisterForNotifications = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">5</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_isDeclared = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">6</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_getDeclaredInstances = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">7</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_updatableViaApex = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">8</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_getConnectionInfo = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">9</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_registerClientCallback = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">10</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_tryUnregisterService = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">11</span>;  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> TRANSACTION_getServiceDebugInfo = ::android::IBinder::FIRST_CALL_TRANSACTION + <span class="hljs-number">12</span>;  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BnServiceManager</span><span class="hljs-params">()</span></span>;  ::<span class="hljs-function">android::<span class="hljs-type">status_t</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _aidl_code, <span class="hljs-type">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="hljs-type">uint32_t</span> _aidl_flags)</span> <span class="hljs-keyword">override</span></span>;&#125;;  <span class="hljs-comment">// class BnServiceManager</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_x86_64_silvermont_shared_fuzzer/gen/aidl/android/os/IServiceManager.cpp</span>::<span class="hljs-function">android::<span class="hljs-type">status_t</span> <span class="hljs-title">BnServiceManager::onTransact</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _aidl_code, <span class="hljs-type">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="hljs-type">uint32_t</span> _aidl_flags)</span> </span>&#123;  ::android::<span class="hljs-type">status_t</span> _aidl_ret_status = ::android::OK;  <span class="hljs-keyword">switch</span> (_aidl_code) &#123;  <span class="hljs-keyword">case</span> BnServiceManager::TRANSACTION_getService:  &#123;    ::std::string in_name;    ::android::sp&lt;::android::IBinder&gt; _aidl_return;    <span class="hljs-keyword">if</span> (!(_aidl_data.<span class="hljs-built_in">checkInterface</span>(<span class="hljs-keyword">this</span>))) &#123;      _aidl_ret_status = ::android::BAD_TYPE;      <span class="hljs-keyword">break</span>;    &#125;    ::android::binder::ScopedTrace _aidl_trace(ATRACE_TAG_AIDL, <span class="hljs-string">&quot;AIDL::cpp::IServiceManager::getService::cppServer&quot;</span>);    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readUtf8FromUtf16</span>(&amp;in_name);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> st = _aidl_data.<span class="hljs-built_in">enforceNoDataAvail</span>(); !st.<span class="hljs-built_in">isOk</span>()) &#123;      _aidl_ret_status = st.<span class="hljs-built_in">writeToParcel</span>(_aidl_reply);      <span class="hljs-keyword">break</span>;    &#125;    ::android::binder::Status _aidl_status(<span class="hljs-built_in">getService</span>(in_name, &amp;_aidl_return));    _aidl_ret_status = _aidl_status.<span class="hljs-built_in">writeToParcel</span>(_aidl_reply);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (!_aidl_status.<span class="hljs-built_in">isOk</span>()) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_reply-&gt;<span class="hljs-built_in">writeStrongBinder</span>(_aidl_return);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> BnServiceManager::TRANSACTION_addService:  &#123;    ::std::string in_name;    ::android::sp&lt;::android::IBinder&gt; in_service;    <span class="hljs-type">bool</span> in_allowIsolated;    <span class="hljs-type">int32_t</span> in_dumpPriority;    <span class="hljs-keyword">if</span> (!(_aidl_data.<span class="hljs-built_in">checkInterface</span>(<span class="hljs-keyword">this</span>))) &#123;      _aidl_ret_status = ::android::BAD_TYPE;      <span class="hljs-keyword">break</span>;    &#125;    ::android::binder::ScopedTrace _aidl_trace(ATRACE_TAG_AIDL, <span class="hljs-string">&quot;AIDL::cpp::IServiceManager::addService::cppServer&quot;</span>);    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readUtf8FromUtf16</span>(&amp;in_name);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readStrongBinder</span>(&amp;in_service);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readBool</span>(&amp;in_allowIsolated);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_data.<span class="hljs-built_in">readInt32</span>(&amp;in_dumpPriority);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> st = _aidl_data.<span class="hljs-built_in">enforceNoDataAvail</span>(); !st.<span class="hljs-built_in">isOk</span>()) &#123;      _aidl_ret_status = st.<span class="hljs-built_in">writeToParcel</span>(_aidl_reply);      <span class="hljs-keyword">break</span>;    &#125;    ::android::binder::Status _aidl_status(<span class="hljs-built_in">addService</span>(in_name, in_service, in_allowIsolated, in_dumpPriority));    _aidl_ret_status = _aidl_status.<span class="hljs-built_in">writeToParcel</span>(_aidl_reply);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (!_aidl_status.<span class="hljs-built_in">isOk</span>()) &#123;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// ...</span></code></pre></div><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><h2 id="暴露自己"><a href="#暴露自己" class="headerlink" title="暴露自己"></a>暴露自己</h2><p>看看其他进程（client）是如何使用 servicemanager 提供的查询服务的，随便找个 biner ipc 比如 <code>ActivityManager.getRunningAppProcesses()</code> 开始深入下去：</p><ol><li><p>内部是调用了 <code>IActivityManager.getRunningAppProcesses()</code>，<code>IActivityManager</code> 明显是个 binder ipc，它的 binder client proxy 是从 <code>ServiceManager.getService</code> 获取的</p></li><li><p><code>ServiceManager</code> 内部调用了 <code>IServiceManager.getService</code>，看起来 <code>IServiceManager</code> 又是个 binder ipc，它的 proxy 是从 <code>BinderInternal.getContextObject()</code> 获得的</p></li><li><p>往下看发现 <code>IServiceManager</code> 的 proxy 实际上是个 handle == 0 的 <code>BpBinder</code>（binder client 包括 java 层的 <code>BinderProxy</code> 和 native 层的 <code>BpBinder</code>）</p></li><li><p>binder ipc 过程中，client 通过 <code>ioctl(binder_fd, BC_TRANSACTION, binder_transaction_data)</code> 将 request 发送给 binder driver，再由 binder driver 根据 <code>binder_transaction_data.target.handle</code> 字段找到对应的 server 将 request 转发给它，具体流程是 <code>binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write -&gt; binder_transaction</code></p></li><li><p>在 <code>binder_transaction</code> 可以看到如果发现 handle == 0 则取 <code>binder_context_mgr_node</code> 作为 target server，而在章节 <a href="#%E6%B3%A8%E5%86%8C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8">注册为服务管理器</a> 有说到 servicemanager 进程会通过 <code>BINDER_SET_CONTEXT_MGR_EXT/binder_ioctl_set_ctx_mgr</code> 把自己注册至 <code>binder_context_mgr_node</code></p></li></ol><p>整理下逻辑：app 进行 binder ipc 时需要得到 target server handle，可以通过 <code>ServiceManager.getService</code> 查询得到，这个 ipc 方法最终会调用 servicemanager 进程提供的查询功能；而 servicemanager 早已在 binder driver 里把自己注册为服务管理器（<code>binder_context_mgr_node</code>，handle == 0），这样 app 进程就无需再进行查找即可调用 <code>ServiceManager</code></p><p><img src="../../../../image/2022-10-26-binder-servicemanager/getservice.webp" alt="ServiceManager.getService()"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManager</span> &#123;    <span class="hljs-keyword">public</span> List&lt;RunningAppProcessInfo&gt; <span class="hljs-title function_">getRunningAppProcesses</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> getService().getRunningAppProcesses();        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();        &#125;    &#125;    <span class="hljs-comment">// IActivityManager 看起来像是 aidl 生成的 java interface</span>    <span class="hljs-comment">// 一搜果然没有 IActivityManager.java 只有 frameworks/base/core/java/android/app/IActivityManager.aidl</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title function_">getService</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ServiceManager.getService(Context.ACTIVITY_SERVICE);                    <span class="hljs-keyword">final</span> <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> IActivityManager.Stub.asInterface(b);  <span class="hljs-comment">// 获得 client proxy，真正与 server 通讯的是 b</span>                                                                                       <span class="hljs-comment">// 参考【深入 Binder 之 AIDL】</span>                    <span class="hljs-keyword">return</span> am;                &#125;            &#125;;        &#125;<span class="hljs-comment">// 看看如何获取 IActivityManager client binder</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IBinder <span class="hljs-title function_">getService</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">IBinder</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> sCache.get(name);            <span class="hljs-keyword">if</span> (service != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span> service;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> Binder.allowBlocking(rawGetService(name));            &#125;        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            Log.e(TAG, <span class="hljs-string">&quot;error in getService&quot;</span>, e);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IBinder <span class="hljs-title function_">rawGetService</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> sStatLogger.getTime();        <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> getIServiceManager().getService(name);  <span class="hljs-comment">// IServiceManager? 看起来又是一个 aidl，又是一个 binder ipc</span>        <span class="hljs-comment">// ...                                                         // 即是 IActivityManager client binder 是从 IServiceManager server 获得的</span>        <span class="hljs-keyword">return</span> binder;    &#125;<span class="hljs-comment">// 有了上面的经验就可以很快地知道 IServiceManager.Stub.asInterface(remote) 返回的是 IServiceManager client proxy</span><span class="hljs-comment">// 真正的通讯是由 BinderInternal.getContextObject() 得到的 client binder 实现的</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IServiceManager <span class="hljs-title function_">getIServiceManager</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (sServiceManager != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> sServiceManager;        &#125;        <span class="hljs-comment">// Find the service manager</span>        sServiceManager = ServiceManagerNative                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));        <span class="hljs-keyword">return</span> sServiceManager;    &#125;            &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceManager ServiceManagerNative.asInterface(IBinder obj) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceManagerProxy</span>(obj);&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManagerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IServiceManager</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceManagerProxy</span><span class="hljs-params">(IBinder remote)</span> &#123;        mRemote = remote;        mServiceManager = IServiceManager.Stub.asInterface(remote);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> IBinder BinderInternal.getContextObject();</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// frameworks/base/core/jni/android_util_Binder.cpp</span><span class="hljs-function"><span class="hljs-type">static</span> jobject <span class="hljs-title">android_os_BinderInternal_getContextObject</span><span class="hljs-params">(JNIEnv* env, jobject clazz)</span></span><span class="hljs-function"></span>&#123;    sp&lt;IBinder&gt; b = ProcessState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">getContextObject</span>(<span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// If the argument is a JavaBBinder, return the Java object that was used to create it.</span>    <span class="hljs-comment">// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the</span>    <span class="hljs-comment">// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">javaObjectForIBinder</span>(env, b);  <span class="hljs-comment">// 返回 java 层的 BinderProxy 实例</span>&#125;<span class="hljs-comment">// frameworks/native/libs/binder/ProcessState.cpp</span><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ProcessState::getContextObject</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; <span class="hljs-comment">/*caller*/</span>)</span></span><span class="hljs-function"></span>&#123;    sp&lt;IBinder&gt; context = <span class="hljs-built_in">getStrongProxyForHandle</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> context;&#125;<span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ProcessState::getStrongProxyForHandle</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> handle)</span>  <span class="hljs-comment">// handle == 0</span></span><span class="hljs-function"></span>&#123;    sp&lt;IBinder&gt; result;    AutoMutex _l(mLock);    <span class="hljs-keyword">if</span> (handle == <span class="hljs-number">0</span> &amp;&amp; the_context_object != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> the_context_object;    handle_entry* e = <span class="hljs-built_in">lookupHandleLocked</span>(handle);  <span class="hljs-comment">// 有个成员属性 Vector&lt;handle_entry&gt; mHandleToObject 用以缓存 IBinder</span>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">nullptr</span>) &#123;                            <span class="hljs-comment">// 当 handle 所在位置为空时会创建一个新的 entry 实例返回</span>        IBinder* b = e-&gt;binder;                    <span class="hljs-comment">// 此时 b == null</span>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">nullptr</span> || !e-&gt;refs-&gt;<span class="hljs-built_in">attemptIncWeak</span>(<span class="hljs-keyword">this</span>)) &#123;            <span class="hljs-comment">//...</span>            sp&lt;BpBinder&gt; b = BpBinder::PrivateAccessor::<span class="hljs-built_in">create</span>(handle);  <span class="hljs-comment">// 这里的 IBinder 是 BpBinder，而且是 handle == 0 的 BpBinder</span>            e-&gt;binder = b.<span class="hljs-built_in">get</span>();            <span class="hljs-keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="hljs-built_in">getWeakRefs</span>();            result = b;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// This little bit of nastyness is to allow us to add a primary</span>            <span class="hljs-comment">// reference to the remote proxy when this team doesn&#x27;t have one</span>            <span class="hljs-comment">// but another team is sending the handle to us.</span>            result.force_set(b);            e-&gt;refs-&gt;<span class="hljs-built_in">decWeak</span>(<span class="hljs-keyword">this</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">// 从【深入 Binder 之架构篇】知道 BpBinder 是 native client，负责：</span><span class="hljs-comment">// 从 servicemanager 查找 service handle，然后将 request 发送给 binder driver，由 binder driver 转发 request 给目标 server</span><span class="hljs-comment">// 但 servicemanager handler 又得从哪里获取呢？答案很简单，它的 handle == 0，无需通过查找获得，只要 handle == 0 就表示 server 是 service manager</span><span class="hljs-comment">// 看看在 binder driver 里是如何处理 handle == 0 的情况得</span><span class="hljs-comment">// https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-keyword">case</span> BINDER_WRITE_READ:ret = <span class="hljs-built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">goto</span> err;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> BINDER_SET_MAX_THREADS:<span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_proc</span> *proc = filp-&gt;private_data;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = _IOC_SIZE(cmd);<span class="hljs-type">void</span> __user *ubuf = (<span class="hljs-type">void</span> __user *)arg;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> bwr;<span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> binder_write_read)) &#123;ret = -EINVAL;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="hljs-built_in">sizeof</span>(bwr))) &#123;ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;<span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_write</span>(proc, thread,  bwr.write_buffer,  bwr.write_size,  &amp;bwr.write_consumed);<span class="hljs-built_in">trace_binder_write_done</span>(ret);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;bwr.read_consumed = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;<span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>)        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_uintptr_t</span> binder_buffer, <span class="hljs-type">size_t</span> size,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_size_t</span> *consumed)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">uint32_t</span> cmd;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_context</span> *context = proc-&gt;context;<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;<span class="hljs-type">void</span> __user *ptr = buffer + *consumed;<span class="hljs-type">void</span> __user *end = buffer + size;<span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;<span class="hljs-type">int</span> ret;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-keyword">case</span> BC_TRANSACTION:<span class="hljs-keyword">case</span> BC_REPLY: &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> tr;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;tr, ptr, <span class="hljs-built_in">sizeof</span>(tr)))<span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(tr);<span class="hljs-built_in">binder_transaction</span>(proc, thread, &amp;tr, cmd == BC_REPLY, <span class="hljs-number">0</span>);<span class="hljs-keyword">break</span>;&#125;        <span class="hljs-comment">// ...</span>&#125;*consumed = ptr - buffer;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_transaction</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_transaction_data *tr, <span class="hljs-type">int</span> reply,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">binder_size_t</span> extra_buffers_size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// ...</span><span class="hljs-keyword">if</span> (reply) &#123;<span class="hljs-comment">// server response -&gt; client ...</span>&#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// client request -&gt; server</span><span class="hljs-keyword">if</span> (tr-&gt;target.handle) &#123;  <span class="hljs-comment">// handle &gt; 0 的情况下，根据 handle 查找出 server/target</span><span class="hljs-keyword">struct</span> binder_ref *ref;<span class="hljs-built_in">binder_proc_lock</span>(proc);ref = <span class="hljs-built_in">binder_get_ref_olocked</span>(proc, tr-&gt;target.handle,     <span class="hljs-literal">true</span>);<span class="hljs-keyword">if</span> (ref) &#123;target_node = <span class="hljs-built_in">binder_get_node_refs_for_txn</span>(ref-&gt;node, &amp;target_proc,&amp;return_error);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction to invalid handle, %u\n&quot;</span>,  proc-&gt;pid, thread-&gt;pid, tr-&gt;target.handle);return_error = BR_FAILED_REPLY;&#125;<span class="hljs-built_in">binder_proc_unlock</span>(proc);&#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// handle == 0 说明 server/target 是 service manager，它保存在 binder_context_mgr_node</span><span class="hljs-built_in">mutex_lock</span>(&amp;context-&gt;context_mgr_node_lock);target_node = context-&gt;binder_context_mgr_node;<span class="hljs-keyword">if</span> (target_node)target_node = <span class="hljs-built_in">binder_get_node_refs_for_txn</span>(target_node, &amp;target_proc,&amp;return_error);<span class="hljs-keyword">else</span>return_error = BR_DEAD_REPLY;<span class="hljs-built_in">mutex_unlock</span>(&amp;context-&gt;context_mgr_node_lock);<span class="hljs-keyword">if</span> (target_node &amp;&amp; target_proc-&gt;pid == proc-&gt;pid) &#123;<span class="hljs-built_in">binder_user_error</span>(<span class="hljs-string">&quot;%d:%d got transaction to context manager from process owning it\n&quot;</span>,  proc-&gt;pid, thread-&gt;pid);return_error = BR_FAILED_REPLY;return_error_param = -EINVAL;return_error_line = __LINE__;<span class="hljs-keyword">goto</span> err_invalid_target_handle;&#125;&#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h2 id="以-AMS-为例"><a href="#以-AMS-为例" class="headerlink" title="以 AMS 为例"></a>以 AMS 为例</h2><p>以 <code>ActivityManagerService</code> 为例看看 server 端是如何使用 service_manager 提供的注册服务的</p><ol><li><p>AMS 是运行在 system_server 进程内的一个 java 对象，system_server 进程里还注册了许多其他服务如：WINDOW_SERVICE、INPUT_SERVICE，它们也是一个个的 java 对象，由 system_server 的 binder loop 分发消息给它们处理</p></li><li><p>AMS 使用 <code>ServiceManager.addService(Context.ACTIVITY_SERVICE...)</code> 将自己注册到 service_manager 进程，service_manager 不需要查询它是固定的 <code>BpBinder(handle == 0)</code></p></li><li><p>AMS 对象的内存地址（cookie）在 binder driver 被转换为一个 int 类型的 handle 注册进 service_manager，app 进程查询得到的也是 handle 而不是 cookie</p></li><li><p>当 app 进程通过 handle 进行 rpc 调用时，request 在 binder 又被从 handle 转换为 cookie，从而 server 端能够直接用 cookie 定位到服务对象</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// // https://cs.android.com/android/platform/superproject/+/master:frameworks/base/services/java/com/android/server/SystemServer.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">// Start services.</span>        <span class="hljs-keyword">try</span> &#123;            t.traceBegin(<span class="hljs-string">&quot;StartServices&quot;</span>);            startBootstrapServices(t);            startCoreServices(t);            startOtherServices(t);            startApexServices(t);        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">// Loop forever.</span>        Looper.loop();        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startBootstrapServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">// Set up the Application instance for the system process and get started.</span>        t.traceBegin(<span class="hljs-string">&quot;SetSystemProcess&quot;</span>);        mActivityManagerService.setSystemProcess();        t.traceEnd();        <span class="hljs-comment">// ...</span>    &#125;    &#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IActivityManager</span>.Stub &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSystemProcess</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="hljs-built_in">this</span>, <span class="hljs-comment">/* allowIsolated= */</span> <span class="hljs-literal">true</span>,                    DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);            ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);            ServiceManager.addService(<span class="hljs-string">&quot;meminfo&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemBinder</span>(<span class="hljs-built_in">this</span>), <span class="hljs-comment">/* allowIsolated= */</span> <span class="hljs-literal">false</span>,                    DUMP_FLAG_PRIORITY_HIGH);            ServiceManager.addService(<span class="hljs-string">&quot;gfxinfo&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphicsBinder</span>(<span class="hljs-built_in">this</span>));            ServiceManager.addService(<span class="hljs-string">&quot;dbinfo&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DbBinder</span>(<span class="hljs-built_in">this</span>));            mAppProfiler.setCpuInfoService();            ServiceManager.addService(<span class="hljs-string">&quot;permission&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionController</span>(<span class="hljs-built_in">this</span>));            ServiceManager.addService(<span class="hljs-string">&quot;processinfo&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessInfoService</span>(<span class="hljs-built_in">this</span>));            ServiceManager.addService(<span class="hljs-string">&quot;cacheinfo&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheBinder</span>(<span class="hljs-built_in">this</span>));            <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-comment">// getIServiceManager() 得到了 IServiceManager 的实现，但却是层层代理：</span><span class="hljs-comment">// ServiceManagerProxy -&gt; IServiceManager.Stub.Proxy -&gt; BinderProxy -&gt; 持有真正的实现，native 层的 BpBinder(handle == 0)</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/ServiceManager.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addService</span><span class="hljs-params">(String name, IBinder service, <span class="hljs-type">boolean</span> allowIsolated,</span><span class="hljs-params">            <span class="hljs-type">int</span> dumpPriority)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            getIServiceManager().addService(name, service, allowIsolated, dumpPriority);        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            Log.e(TAG, <span class="hljs-string">&quot;error in addService&quot;</span>, e);        &#125;    &#125;&#125;<span class="hljs-comment">// 此时 service 是 ActivityManagerService，它是 Binder</span><span class="hljs-comment">// 看下它是怎么序列化的，而 service_manager 又是如何应用它的</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">android</span>.os.IServiceManager &#123;    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addService</span><span class="hljs-params">(java.lang.String name, android.os.IBinder service, <span class="hljs-type">boolean</span> allowIsolated, <span class="hljs-type">int</span> dumpPriority)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException    &#123;      android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();      android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();      <span class="hljs-keyword">try</span> &#123;        _data.writeInterfaceToken(DESCRIPTOR);        _data.writeString(name);        _data.writeStrongBinder(service);        _data.writeBoolean(allowIsolated);        _data.writeInt(dumpPriority);        <span class="hljs-type">boolean</span> <span class="hljs-variable">_status</span> <span class="hljs-operator">=</span> mRemote.transact(Stub.TRANSACTION_addService, _data, _reply, <span class="hljs-number">0</span>);        _reply.readException();      &#125;      <span class="hljs-keyword">finally</span> &#123;        _reply.recycle();        _data.recycle();      &#125;    &#125;&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/Parcel.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeStrongBinder</span><span class="hljs-params">(IBinder val)</span> &#123;    nativeWriteStrongBinder(mNativePtr, val);&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_Parcel.cpp</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">android_os_Parcel_writeStrongBinder</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span>&#123;    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);    <span class="hljs-keyword">if</span> (parcel != NULL) &#123;        const <span class="hljs-type">status_t</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object) <span class="hljs-comment">/* JavaBBinder */</span>);        <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;            signalExceptionForError(env, clazz, err);        &#125;    &#125;&#125;<span class="hljs-comment">// AMS 是 Binder，Binder.mObject 指向 native 层的 JavaBBinderHolder</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_util_Binder.cpp</span>sp&lt;IBinder&gt; <span class="hljs-title function_">ibinderForJavaObject</span><span class="hljs-params">(JNIEnv* env, jobject obj)</span>&#123;    <span class="hljs-comment">// Instance of Binder?</span>    <span class="hljs-keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;        JavaBBinderHolder* jbh = (JavaBBinderHolder*)            env-&gt;GetLongField(obj, gBinderOffsets.mObject);        <span class="hljs-keyword">return</span> jbh-&gt;get(env, obj);  <span class="hljs-comment">// JavaBBinder</span>    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/Parcel.cpp</span>status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123;    <span class="hljs-keyword">return</span> flattenBinder(val);&#125;status_t Parcel::flattenBinder(const sp&lt;IBinder&gt;&amp; binder) &#123;    BBinder* local = nullptr;    <span class="hljs-keyword">if</span> (binder) local = binder-&gt;localBinder();  <span class="hljs-comment">// JavaBBinder 返回 this</span>    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 如果 binder 是一个远程的代理，则序列化为 int 类型的 handle 即可</span>    flat_binder_object obj;..    <span class="hljs-keyword">if</span> (!local) &#123;  <span class="hljs-comment">// 比如 BpBinder 它只有 server handle</span>        const <span class="hljs-type">int32_t</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> proxy ? proxy-&gt;getPrivateAccessor().binderHandle() : <span class="hljs-number">0</span>;        obj.hdr.type = BINDER_TYPE_HANDLE;        obj.binder = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span>        obj.flags = <span class="hljs-number">0</span>;        obj.handle = handle;        obj.cookie = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 如果 binder 是本地实例（BBinder），则序列化为其内存地址</span>        <span class="hljs-comment">// java Binder.mObject 是 native JavaBBinderHolder，它持有 JavaBBinder，而 JavaBBinder 继承自 BBinder</span>        <span class="hljs-comment">// ActivityManagerService 继承自 IActivityManager.Stub，它又继承自 Binder</span>        obj.hdr.type = BINDER_TYPE_BINDER;        obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs());        obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local);  <span class="hljs-comment">// cookie 是 IBinder 在 server/client 进程内的内存地址</span>        <span class="hljs-comment">// ...</span>        <span class="hljs-type">status_t</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> writeObject(obj, <span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">// 由 system_server 进程陷入内核来到 binder driver</span>BpBinder::transact--IPCThreadState::self()-&gt;transact(binderHandle() <span class="hljs-comment">/* 0 */</span>, code, data, reply, flags)----IPCThreadState::writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr)----IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)------IPCThreadState::talkWithDriver(bool doReceive)--------ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)<span class="hljs-comment">// binder driver 遇到 handle == 0 的情况会转发给服务管理器，而它正是 service_manager 进程</span>binder_ioctl--binder_ioctl_write_read----binder_thread_write(BC_TRANSACTION/BC_REPLY)------binder_transaction<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">binder_transaction</span><span class="hljs-params">(struct binder_proc *proc,</span><span class="hljs-params">       struct binder_thread *thread,</span><span class="hljs-params">       struct binder_transaction_data *tr, <span class="hljs-type">int</span> reply,</span><span class="hljs-params">       binder_size_t extra_buffers_size)</span>&#123;    <span class="hljs-comment">// ...</span><span class="hljs-keyword">if</span> (tr-&gt;target.handle) &#123;<span class="hljs-comment">// ...</span>&#125; <span class="hljs-keyword">else</span> &#123;mutex_lock(&amp;context-&gt;context_mgr_node_lock);target_node = context-&gt;binder_context_mgr_node;<span class="hljs-keyword">if</span> (target_node)target_node = binder_get_node_refs_for_txn(target_node, &amp;target_proc,&amp;return_error);<span class="hljs-keyword">else</span>return_error = BR_DEAD_REPLY;mutex_unlock(&amp;context-&gt;context_mgr_node_lock);        <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 然而 service_manager 进程获得 system_server 进程内的 AMS 对象地址并没有啥用处，跨进程内存是被隔离的</span>    <span class="hljs-comment">// app 进程通过 service_manager 拿到 system_server 进程内的 AMS 对象地址同样也没啥用处，万一 AMS 对象的地址变了呢</span>    <span class="hljs-comment">// 所以 binder driver 在这里有个很重要的转换过程</span>    <span class="hljs-comment">// AMS 注册时给 binder 的是 BINDER_TYPE_BINDER + cookie（ServiceManager 内存地址），被 binder 转换为 BINDER_TYPE_HANDLE + handle 交给 service_manager</span>    <span class="hljs-comment">// 那么 app 从 service_manager 查询得到的也是 handle</span>    <span class="hljs-comment">// app 通过这个 handle 进行 ipc rpc 调用时，又被 binder 转换为 cookie 发给 server 进程，使其通过内存地址定位到服务对象</span><span class="hljs-keyword">switch</span> (hdr-&gt;type) &#123;<span class="hljs-keyword">case</span> BINDER_TYPE_BINDER:<span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;struct flat_binder_object *fp;fp = to_flat_binder_object(hdr);ret = binder_translate_binder(fp, t, thread);&#125; <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE:<span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;struct flat_binder_object *fp;fp = to_flat_binder_object(hdr);ret = binder_translate_handle(fp, t, thread);&#125; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binder_translate_binder</span><span class="hljs-params">(struct flat_binder_object *fp,</span><span class="hljs-params">   struct binder_transaction *t,</span><span class="hljs-params">   struct binder_thread *thread)</span>&#123;struct binder_node *node;struct binder_proc *proc = thread-&gt;proc;struct binder_proc *target_proc = t-&gt;to_proc;struct binder_ref_data rdata;<span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;node = binder_get_node(proc, fp-&gt;binder);ret = binder_inc_ref_for_node(target_proc, node,fp-&gt;hdr.type == BINDER_TYPE_BINDER,&amp;thread-&gt;todo, &amp;rdata);<span class="hljs-keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)fp-&gt;hdr.type = BINDER_TYPE_HANDLE;<span class="hljs-keyword">else</span>fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;fp-&gt;binder = <span class="hljs-number">0</span>;fp-&gt;handle = rdata.desc;fp-&gt;cookie = <span class="hljs-number">0</span>;trace_binder_transaction_node_to_ref(t, node, &amp;rdata);binder_debug(BINDER_DEBUG_TRANSACTION,     <span class="hljs-string">&quot;        node %d u%016llx -&gt; ref %d desc %d\n&quot;</span>,     node-&gt;debug_id, (u64)node-&gt;ptr,     rdata.debug_id, rdata.desc);done:binder_put_node(node);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-comment">// 在 service_manager 进程里来到上章节的 binder 消息循环，遇到 handle == 0 交给进程内的上下文管理器处理：ProcessState::becomeContextManager</span><span class="hljs-comment">// 它就是 ServiceManager</span>status_t IPCThreadState::executeCommand(int32_t cmd)&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">case</span> BR_TRANSACTION_SEC_CTX:    <span class="hljs-keyword">case</span> BR_TRANSACTION:        <span class="hljs-keyword">if</span> (tr.target.ptr) &#123;            <span class="hljs-comment">// ...</span>        &#125; <span class="hljs-keyword">else</span> &#123;            error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);        &#125;        <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 从 Parcel 里解包出各个类型的参数，重点看 in_service</span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_x86_64_silvermont_shared_fuzzer/gen/aidl/android/os/IServiceManager.cpp</span>::android::status_t BnServiceManager::onTransact(uint32_t _aidl_code, const ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, uint32_t _aidl_flags) &#123;  ::android::<span class="hljs-type">status_t</span> <span class="hljs-variable">_aidl_ret_status</span> <span class="hljs-operator">=</span> ::android::OK;  <span class="hljs-keyword">switch</span> (_aidl_code) &#123;  <span class="hljs-keyword">case</span> BnServiceManager::TRANSACTION_addService:  &#123;    ::std::string in_name;    ::android::sp&lt;::android::IBinder&gt; in_service;    bool in_allowIsolated;    int32_t in_dumpPriority;    <span class="hljs-keyword">if</span> (!(_aidl_data.checkInterface(<span class="hljs-built_in">this</span>))) &#123;      _aidl_ret_status = ::android::BAD_TYPE;      <span class="hljs-keyword">break</span>;    &#125;    ::android::binder::ScopedTrace <span class="hljs-title function_">_aidl_trace</span><span class="hljs-params">(ATRACE_TAG_AIDL, <span class="hljs-string">&quot;AIDL::cpp::IServiceManager::addService::cppServer&quot;</span>)</span>;    _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_service);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_data.readBool(&amp;in_allowIsolated);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    _aidl_ret_status = _aidl_data.readInt32(&amp;in_dumpPriority);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-type">auto</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> _aidl_data.enforceNoDataAvail(); !st.isOk()) &#123;      _aidl_ret_status = st.writeToParcel(_aidl_reply);      <span class="hljs-keyword">break</span>;    &#125;    ::android::binder::Status <span class="hljs-title function_">_aidl_status</span><span class="hljs-params">(addService(in_name, in_service, in_allowIsolated, in_dumpPriority)</span>);    _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply);    <span class="hljs-keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span> (!_aidl_status.isOk()) &#123;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// ...</span><span class="hljs-comment">// 注意此时 service_manager 拿到的已经不是 cookie（服务对象的内存地址），而是经过 binder 转换的 handle </span><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/Parcel.cpp</span>status_t Parcel::readStrongBinder(sp&lt;IBinder&gt;* val) const&#123;    <span class="hljs-type">status_t</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> readNullableStrongBinder(val);    <span class="hljs-keyword">if</span> (status == OK &amp;&amp; !val-&gt;get()) &#123;        ALOGW(<span class="hljs-string">&quot;Expecting binder but got null!&quot;</span>);        status = UNEXPECTED_NULL;    &#125;    <span class="hljs-keyword">return</span> status;&#125;status_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) const&#123;    <span class="hljs-keyword">return</span> unflattenBinder(val);&#125;status_t Parcel::unflattenBinder(sp&lt;IBinder&gt;* out) const&#123;    <span class="hljs-comment">// ...</span>    const flat_binder_object* flat = readObject(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">if</span> (flat) &#123;        <span class="hljs-keyword">switch</span> (flat-&gt;hdr.type) &#123;            <span class="hljs-keyword">case</span> BINDER_TYPE_BINDER: &#123;                sp&lt;IBinder&gt; binder =                        sp&lt;IBinder&gt;::fromExisting(reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie));                <span class="hljs-keyword">return</span> finishUnflattenBinder(binder, out);            &#125;            <span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE: &#123;                sp&lt;IBinder&gt; binder =                    ProcessState::self()-&gt;getStrongProxyForHandle(flat-&gt;handle);                <span class="hljs-keyword">return</span> finishUnflattenBinder(binder, out);            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><ol><li><p>通过 <code>epoll(binder_driver_fd)</code> 响应 binder driver 发来的消息</p></li><li><p>client 进程查询 service handle 时，通过将 request handle 置为 0 来标识 target/server 是 servicemanager 进程（详见上一章节<a href="#%E6%9A%B4%E9%9C%B2%E8%87%AA%E5%B7%B1">暴露自己</a>）</p></li><li><p>处理 binder driver 消息的逻辑在 <code>IPCThreadState</code>，对于 target handle == 0 的情况，使用 <code>the_context_object</code> 来处理消息，而 <code>the_context_object</code> 在 <a href="#%E4%B8%BB%E4%BE%8B%E7%A8%8B">主例程</a> 里被设置为 <code>ServiceManager</code></p></li><li><p>查询的逻辑就是从 string -&gt; IBinder 的 Map 里根据 service name 找到对应的 IBinder 并返回</p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/cmds/servicemanager/main.cpp</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderCallback</span> : <span class="hljs-keyword">public</span> LooperCallback &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> sp&lt;BinderCallback&gt; <span class="hljs-title">setupTo</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;        sp&lt;BinderCallback&gt; cb = sp&lt;BinderCallback&gt;::<span class="hljs-built_in">make</span>();        <span class="hljs-type">int</span> binder_fd = <span class="hljs-number">-1</span>;        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setupPolling</span>(&amp;binder_fd);    <span class="hljs-comment">// 获得已打开的 binder driver fd</span>        <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(binder_fd &lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Failed to setupPolling: %d&quot;</span>, binder_fd);        <span class="hljs-type">int</span> ret = looper-&gt;<span class="hljs-built_in">addFd</span>(binder_fd,                   <span class="hljs-comment">// 当有数据时回调 handlePolledCommands</span>                                Looper::POLL_CALLBACK,                                Looper::EVENT_INPUT,                                cb,                                <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/*data*/</span>);        <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(ret != <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Failed to add binder FD to Looper&quot;</span>);        <span class="hljs-keyword">return</span> cb;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/* fd */</span>, <span class="hljs-type">int</span> <span class="hljs-comment">/* events */</span>, <span class="hljs-type">void</span>* <span class="hljs-comment">/* data */</span>)</span> <span class="hljs-keyword">override</span> </span>&#123;        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">handlePolledCommands</span>();        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// Continue receiving callbacks.</span>    &#125;&#125;;<span class="hljs-comment">// https://android.googlesource.com/platform/frameworks/native/+/refs/tags/android-mainline-12.0.0_r114/libs/binder/IPCThreadState.cpp</span><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::setupPolling</span><span class="hljs-params">(<span class="hljs-type">int</span>* fd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> -EBADF;    &#125;    mOut.<span class="hljs-built_in">writeInt32</span>(BC_ENTER_LOOPER);<span class="hljs-comment">// mOut 是发送给 binder driver 的内存区域</span>                                     <span class="hljs-comment">// 在【深入 Binder 之架构篇】介绍过 BC_ENTER_LOOPER：告知 binder driver 应用线程进入 Looper</span>    <span class="hljs-built_in">flushCommands</span>();                 <span class="hljs-comment">// talkWithDriver(false)，通过 ioctl 与 binder 通讯，mOut 是请求数据，mIn 保存响应数据，详见【深入 Binder 之客户端】</span>    *fd = mProcess-&gt;mDriverFD;       <span class="hljs-comment">// 返回 binder fd</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::handlePolledCommands</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">status_t</span> result;    <span class="hljs-keyword">do</span> &#123;        result = <span class="hljs-built_in">getAndExecuteCommand</span>();    &#125; <span class="hljs-keyword">while</span> (mIn.<span class="hljs-built_in">dataPosition</span>() &lt; mIn.<span class="hljs-built_in">dataSize</span>());    <span class="hljs-built_in">processPendingDerefs</span>();    <span class="hljs-built_in">flushCommands</span>();    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::getAndExecuteCommand</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">status_t</span> result;    <span class="hljs-type">int32_t</span> cmd;    result = <span class="hljs-built_in">talkWithDriver</span>();    <span class="hljs-keyword">if</span> (result &gt;= NO_ERROR) &#123;        <span class="hljs-type">size_t</span> IN = mIn.<span class="hljs-built_in">dataAvail</span>();        <span class="hljs-keyword">if</span> (IN &lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int32_t</span>)) <span class="hljs-keyword">return</span> result;        cmd = mIn.<span class="hljs-built_in">readInt32</span>();        <span class="hljs-built_in">IF_LOG_COMMANDS</span>() &#123;            alog &lt;&lt; <span class="hljs-string">&quot;Processing top-level Command: &quot;</span>                 &lt;&lt; <span class="hljs-built_in">getReturnString</span>(cmd) &lt;&lt; endl;        &#125;        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mProcess-&gt;mThreadCountLock);        mProcess-&gt;mExecutingThreadsCount++;        <span class="hljs-keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads &amp;&amp;                mProcess-&gt;mStarvationStartTimeMs == <span class="hljs-number">0</span>) &#123;            mProcess-&gt;mStarvationStartTimeMs = <span class="hljs-built_in">uptimeMillis</span>();        &#125;        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mProcess-&gt;mThreadCountLock);        result = <span class="hljs-built_in">executeCommand</span>(cmd);        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mProcess-&gt;mThreadCountLock);        mProcess-&gt;mExecutingThreadsCount--;        <span class="hljs-keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;                mProcess-&gt;mStarvationStartTimeMs != <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">int64_t</span> starvationTimeMs = <span class="hljs-built_in">uptimeMillis</span>() - mProcess-&gt;mStarvationStartTimeMs;            <span class="hljs-keyword">if</span> (starvationTimeMs &gt; <span class="hljs-number">100</span>) &#123;                <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;binder thread pool (%zu threads) starved for %&quot;</span> PRId64 <span class="hljs-string">&quot; ms&quot;</span>,                      mProcess-&gt;mMaxThreads, starvationTimeMs);            &#125;            mProcess-&gt;mStarvationStartTimeMs = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// Cond broadcast can be expensive, so don&#x27;t send it every time a binder</span>        <span class="hljs-comment">// call is processed. b/168806193</span>        <span class="hljs-keyword">if</span> (mProcess-&gt;mWaitingForThreads &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">pthread_cond_broadcast</span>(&amp;mProcess-&gt;mThreadCountDecrement);        &#125;        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mProcess-&gt;mThreadCountLock);    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">IPCThreadState::executeCommand</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> cmd)</span></span><span class="hljs-function"></span>&#123;    BBinder* obj;    RefBase::weakref_type* refs;    <span class="hljs-type">status_t</span> result = NO_ERROR;    <span class="hljs-keyword">switch</span> ((<span class="hljs-type">uint32_t</span>)cmd) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">case</span> BR_TRANSACTION_SEC_CTX:    <span class="hljs-keyword">case</span> BR_TRANSACTION:        &#123;            binder_transaction_data_secctx tr_secctx;            binder_transaction_data&amp; tr = tr_secctx.transaction_data;            <span class="hljs-keyword">if</span> (cmd == (<span class="hljs-type">int</span>) BR_TRANSACTION_SEC_CTX) &#123;                result = mIn.<span class="hljs-built_in">read</span>(&amp;tr_secctx, <span class="hljs-built_in">sizeof</span>(tr_secctx));            &#125; <span class="hljs-keyword">else</span> &#123;                result = mIn.<span class="hljs-built_in">read</span>(&amp;tr, <span class="hljs-built_in">sizeof</span>(tr));                tr_secctx.secctx = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-built_in">ALOG_ASSERT</span>(result == NO_ERROR,                <span class="hljs-string">&quot;Not enough command data for brTRANSACTION&quot;</span>);            <span class="hljs-keyword">if</span> (result != NO_ERROR) <span class="hljs-keyword">break</span>;            Parcel buffer;            buffer.<span class="hljs-built_in">ipcSetDataReference</span>(                <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(tr.data.ptr.buffer),                tr.data_size,                <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),                tr.offsets_size/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>), freeBuffer);            <span class="hljs-type">const</span> <span class="hljs-type">void</span>* origServingStackPointer = mServingStackPointer;            mServingStackPointer = &amp;origServingStackPointer; <span class="hljs-comment">// anything on the stack</span>            <span class="hljs-type">const</span> <span class="hljs-type">pid_t</span> origPid = mCallingPid;            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* origSid = mCallingSid;            <span class="hljs-type">const</span> <span class="hljs-type">uid_t</span> origUid = mCallingUid;            <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> origStrictModePolicy = mStrictModePolicy;            <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> origTransactionBinderFlags = mLastTransactionBinderFlags;            <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> origWorkSource = mWorkSource;            <span class="hljs-type">const</span> <span class="hljs-type">bool</span> origPropagateWorkSet = mPropagateWorkSource;            <span class="hljs-comment">// Calling work source will be set by Parcel#enforceInterface. Parcel#enforceInterface</span>            <span class="hljs-comment">// is only guaranteed to be called for AIDL-generated stubs so we reset the work source</span>            <span class="hljs-comment">// here to never propagate it.</span>            <span class="hljs-built_in">clearCallingWorkSource</span>();            <span class="hljs-built_in">clearPropagateWorkSource</span>();            mCallingPid = tr.sender_pid;            mCallingSid = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(tr_secctx.secctx);            mCallingUid = tr.sender_euid;            mLastTransactionBinderFlags = tr.flags;            <span class="hljs-comment">// ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d sid %s uid %d\n&quot;, mCallingPid,</span>            <span class="hljs-comment">//    (mCallingSid ? mCallingSid : &quot;&lt;N/A&gt;&quot;), mCallingUid);</span>            Parcel reply;            <span class="hljs-type">status_t</span> error;            <span class="hljs-built_in">IF_LOG_TRANSACTIONS</span>() &#123;                TextOutput::Bundle _b(alog);                alog &lt;&lt; <span class="hljs-string">&quot;BR_TRANSACTION thr &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)<span class="hljs-built_in">pthread_self</span>()                    &lt;&lt; <span class="hljs-string">&quot; / obj &quot;</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="hljs-string">&quot; / code &quot;</span>                    &lt;&lt; <span class="hljs-built_in">TypeCode</span>(tr.code) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; indent &lt;&lt; buffer                    &lt;&lt; dedent &lt;&lt; endl                    &lt;&lt; <span class="hljs-string">&quot;Data addr = &quot;</span>                    &lt;&lt; <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(tr.data.ptr.buffer)                    &lt;&lt; <span class="hljs-string">&quot;, offsets addr=&quot;</span>                    &lt;&lt; <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;            &#125;            <span class="hljs-keyword">if</span> (tr.target.ptr) &#123;                <span class="hljs-comment">// We only have a weak reference on the target object, so we must first try to</span>                <span class="hljs-comment">// safely acquire a strong reference before doing anything else with it.</span>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(                        tr.target.ptr)-&gt;<span class="hljs-built_in">attemptIncStrong</span>(<span class="hljs-keyword">this</span>)) &#123;                    error = <span class="hljs-built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="hljs-built_in">transact</span>(tr.code, buffer,                            &amp;reply, tr.flags);                    <span class="hljs-built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="hljs-built_in">decStrong</span>(<span class="hljs-keyword">this</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    error = UNKNOWN_TRANSACTION;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 在上一章节【暴露自己】说过 servicemanager 进程的 handle == 0，那么 tr.target.ptr == null</span>                <span class="hljs-comment">// 那么在 servicemanager 进程（服务端）里会使用 the_context_object 来处理 request</span>                <span class="hljs-comment">// 而在章节【主例程】里有说，这个 the_context_object 其实被设置为了 ServiceManager</span>                <span class="hljs-comment">// IPCThreadState::self()-&gt;setTheContextObject(manager);</span>                error = the_context_object-&gt;<span class="hljs-built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);            &#125;            <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/master:frameworks/native/cmds/servicemanager/ServiceManager.cpp</span><span class="hljs-function">Status <span class="hljs-title">ServiceManager::getService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> </span>&#123;    *outBinder = <span class="hljs-built_in">tryGetService</span>(name, <span class="hljs-literal">true</span>);    <span class="hljs-comment">// returns ok regardless of result for legacy reasons</span>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">ok</span>();&#125;<span class="hljs-comment">// ServiceManager 内部维护了一个 map：mNameToService，string -&gt; IBinder</span><span class="hljs-comment">// 查找过程主要就是根据 name 找到对应的 IBinder，以及做一些权限检查</span><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ServiceManager::tryGetService</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">bool</span> startIfNotFound)</span> </span>&#123;    <span class="hljs-keyword">auto</span> ctx = mAccess-&gt;<span class="hljs-built_in">getCallingContext</span>();    sp&lt;IBinder&gt; out;    Service* service = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = mNameToService.<span class="hljs-built_in">find</span>(name); it != mNameToService.<span class="hljs-built_in">end</span>()) &#123;        service = &amp;(it-&gt;second);        <span class="hljs-keyword">if</span> (!service-&gt;allowIsolated) &#123;            <span class="hljs-type">uid_t</span> appid = <span class="hljs-built_in">multiuser_get_app_id</span>(ctx.uid);            <span class="hljs-type">bool</span> isIsolated = appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END;            <span class="hljs-keyword">if</span> (isIsolated) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;            &#125;        &#125;        out = service-&gt;binder;    &#125;    <span class="hljs-keyword">if</span> (!mAccess-&gt;<span class="hljs-built_in">canFind</span>(ctx, name)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    &#125;    <span class="hljs-keyword">if</span> (!out &amp;&amp; startIfNotFound) &#123;        <span class="hljs-built_in">tryStartService</span>(name);    &#125;    <span class="hljs-keyword">if</span> (out) &#123;        <span class="hljs-comment">// Setting this guarantee each time we hand out a binder ensures that the client-checking</span>        <span class="hljs-comment">// loop knows about the event even if the client immediately drops the service</span>        service-&gt;guaranteeClient = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> out;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入 Binder 之架构篇</title>
    <link href="/2022/06/15/binder-arch/"/>
    <url>/2022/06/15/binder-arch/</url>
    
    <content type="html"><![CDATA[<p>学习 binder 我感觉得从上到下：先对 binder 架构/理论有个大概的认识、对 binder 里的数据结构有个印象，再深入代码细节；整个 binder 涉及到应用侧和驱动侧、app 侧和 framework 侧、java 层和 native 层，代码量巨大而且跨度很大，只有对整个 binder 架构有清晰的认识才不会迷失在细节里</p><h1 id="Linux-设备"><a href="#Linux-设备" class="headerlink" title="Linux 设备"></a>Linux 设备</h1><p><img src="../../../../image/2022-06-15-binder-arch/devices.jpg" alt="devices.jpg"></p><p>linux 系统将设备分为3类：字符设备、块设备和网络设备：</p><ol><li><p><code>字符设备</code> 是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后顺序。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和 LED 设备等</p></li><li><p><code>块设备</code> 是指可以从设备的任意位置读取一定长度数据的设备。块设备包括硬盘、磁盘、U 盘和 SD 卡等</p></li></ol><p>每个字符设备或块设备都在 <code>/dev</code> 目录下对应一个设备文件，linux 用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备和块设备；驱动调用的实质，就是通过设备文件找到与之对应设备号的设备，再通过设备初始化时绑定的操作函数对硬件进行控制</p><h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>字符设备、字符设备驱动与用户空间访问该设备的程序三者之间的关系如下图：</p><ul><li>使用 cdev 结构体来描述字符设备</li><li>通过其成员 dev_t 来定义设备号（分为主、次设备号）以确定字符设备的唯一性</li><li>通过其成员 file_operations 来定义字符设备驱动提供给 VFS 的接口函数，如常见的 open()、read()、write() 等</li></ul><p><img src="../../../../image/2022-06-15-binder-arch/device_driver.jpg" alt="device_driver.jpg"></p><p>在 Linux 字符设备驱动中：</p><ul><li>模块加载函数通过 register_chrdev_region 或 alloc_chrdev_region 来静态或者动态获取设备号</li><li>通过 cdev_init 建立 cdev 与 file_operations 之间的连接，通过 cdev_add 向系统添加一个 cdev 以完成注册</li><li>模块卸载函数通过 cdev_del 来注销 cdev，通过 unregister_chrdev_region 来释放设备号</li></ul><p><img src="../../../../image/2022-06-15-binder-arch/chrdev.jpg" alt="chrdev.jpg"></p><h2 id="杂项设备"><a href="#杂项设备" class="headerlink" title="杂项设备"></a>杂项设备</h2><p>杂项设备也是在嵌入式系统中用得比较多的一种设备驱动，使用 <code>misc_register(struct miscdevice *misc)</code> 注册杂项设备，<code>misc_deregister(struct miscdevice *misc)</code> 释放杂项设备</p><p>在 Linux 内核的 include/linux 目录下有 Miscdevice.h 文件，要把自己定义的 misc device 设备定义在这里。其实是因为这些字符设备不符合预先确定的字符设备范畴，所有这些设备采用主编号 10 ，一起归于 misc device，其实 misc_register 就是用主标号 10 调用 register_chrdev() 的，也就是说 misc device 就是特殊的字符设备，可自动生成设备节点</p><p>misc device 是特殊字符设备，注册驱动程序时采用 misc_register 函数注册，此函数中会自动创建设备节点（即设备文件），无需 mknod 指令手动创建设备文件</p><p>杂项字符设备和一般字符设备的区别：</p><ol><li>一般字符设备首先申请设备号，但是杂项字符设备的主设备号为 10 次设备号通过结构体 miscdevice 中的 minor 来设置</li><li>一般字符设备要创建设备文件，但是杂项字符设备在注册时会自动创建</li><li>一般字符设备要分配一个 cdev（字符设备），但是杂项字符设备只要创建 miscdevice 结构体即可</li><li>一般字符设备需要初始化 cdev，即给字符设备设置对应的操作函数集 file_operation，但是杂项字符设备在结构体 miscdevice 中定义</li><li>一般字符设备使用注册函数 cdev_add 而杂项字符设备使用 misc_register 来注册</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">miscdevice</span>&#123;　　<span class="hljs-type">int</span> minor;                          <span class="hljs-comment">// 杂项设备的此设备号(如果设置为 MISC_DYNAMIC_MINOR，表示系统自动分配未使用的 minor)</span>　　<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;　　<span class="hljs-type">const</span> stuct file_operations *fops;  <span class="hljs-comment">// 驱动主题函数入口指针</span>　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> list;　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *parent;　　<span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *<span class="hljs-keyword">this</span> device;　　<span class="hljs-type">const</span> <span class="hljs-type">char</span> *nodename;              <span class="hljs-comment">// 在 /dev 目录下面创建的设备驱动节点</span>　　<span class="hljs-type">mode_t</span> mode;&#125;;</code></pre></div><h2 id="常见的设备列表"><a href="#常见的设备列表" class="headerlink" title="常见的设备列表"></a>常见的设备列表</h2><table><thead><tr><th>主设备号</th><th>次设备号</th><th>文件名</th><th>设备类型</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>/dev/null</td><td>char</td><td>空设备。任何写入都将被直接丢弃(但返回”成功”)；任何读取都将得到 EOF (文件结束标志)</td></tr><tr><td>4</td><td>0</td><td>/dev/tty0</td><td>char</td><td>当前虚拟控制台</td></tr><tr><td></td><td>1</td><td>/dev/tty1</td><td>char</td><td>第 1 个虚拟控制台</td></tr><tr><td>8</td><td>0</td><td>/dev/sda</td><td>block</td><td>第 1 个磁盘</td></tr><tr><td></td><td>16</td><td>/dev/sdb</td><td>block</td><td>第 2 个磁盘</td></tr><tr><td></td><td>32</td><td>/dev/sdc</td><td>block</td><td>第 3 个磁盘</td></tr><tr><td>10</td><td>1</td><td>/dev/psaux</td><td>char</td><td>PS/2 鼠标</td></tr><tr><td></td><td>156</td><td>/dev/lcd</td><td>char</td><td>液晶(LCD)显示屏</td></tr></tbody></table><h1 id="Binder-也是设备"><a href="#Binder-也是设备" class="headerlink" title="Binder 也是设备"></a>Binder 也是设备</h1><p>Binder 以杂项设备（misc device，是特殊的字符设备）进行注册，作为虚拟字符设备没有直接操作硬件，只是对设备内存的处理，Binder 驱动的主要方法有：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">binder_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <span class="hljs-comment">// 驱动的初始化</span></span><span class="hljs-function"><span class="hljs-title">device_initcall</span><span class="hljs-params">(binder_init)</span></span>;<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> binder_fops = &#123;.owner = THIS_MODULE,.poll = binder_poll,.unlocked_ioctl = binder_ioctl,  <span class="hljs-comment">// syscall ioctl 的回调，客户端主要通过此方法与 binder 驱动交互</span>.compat_ioctl = compat_ptr_ioctl,.mmap = binder_mmap,             <span class="hljs-comment">// syscall mmap 的回调，与 binder 交互前需要分配一块物理内存地址存放 IPC 数据（参数和返回值）</span>.open = binder_open,             <span class="hljs-comment">// syscall open 的回调，与 binder 交互前需要 open(&quot;/dev/binder&quot;) 拿到 binder fd</span>.flush = binder_flush,.release = binder_release,&#125;;</code></pre></div><p>Binder Driver 是 Android 专用的，但底层的驱动架构与 Linux 设备驱动一样，用户态的程序调用 Kernel 层驱动是需要陷入内核态进行系统调用（syscall）</p><p>比如打开 Binder Driver 方法的调用链是 <code>open() -&gt; __open() -&gt; binder_open()</code></p><ol><li>open() 为用户空间的方法</li><li>_open() 是系统调用中相应的处理方法</li><li>通过查找，对应调用到内核 Binder Driver 的 binder_open 方法</li></ol><p><img src="../../../../image/2022-06-15-binder-arch/systemcall.png" alt="systemcall.png"></p><h2 id="Binder-在-IPC-中的位置"><a href="#Binder-在-IPC-中的位置" class="headerlink" title="Binder 在 IPC 中的位置"></a>Binder 在 IPC 中的位置</h2><p>Client 进程通过 RPC(Remote Procedure Call Protocol) 与 Server 通信的过程，可以简单的分为三层：驱动层、IPC 层和业务层</p><ul><li>demo() 是 client 和 server 共同协商好的统一方法</li><li>RPC 数据、code、handle 和协议这四项组成了 IPC 的层的数据，通过 IPC 层进行数据传输</li><li>而真正在 Client 和 Server 两端建立通信的基础设施是 Binder Driver</li></ul><p><img src="../../../../image/2022-06-15-binder-arch/binderdriver_frame.png" alt="binderdriver_frame.png"></p><h1 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h1><ul><li><p>从 IPC 角度看，Binder 是 Android 中一种跨进程通信方式，这种通信方式是 Android 独有的</p></li><li><p>从 Android APP 层面看，Binder 是客户端和服务端进行 IPC 通信的媒介，例如当 bindService 的时候，服务端就会返回一个包含服务端业务调用的 Binder 对象，通过这个 Binder 对象客户端可以获取服务端提供的服务或者数据，归属于属于 RPC</p></li><li><p>从 Android Framework 层面看，Binder 是各种 Manager(ActivityManager、WindowManager 等) 和相应 XXXManagerService 的桥梁</p></li><li><p>从 Android Native 层面看，Binder 是创建 ServiceManager 以及 BpBinder/BBinder 模型，搭建与 binder 驱动的桥梁</p></li><li><p>从 Android Driver 层面看，Binder 是一个虚拟的字符设备，它的设备驱动路径是 <code>/dev/binder</code></p></li></ul><p><img src="../../../../image/2022-06-15-binder-arch/java_binder_frame.png" alt="java_binder_frame.png"></p><p>Binder 在整个 Android 系统中具有重要的作用，在 native 层有一套完整的 binder 通信的 C/S 架构：<code>BpBinder</code> 作为客户端，<code>BBinder</code> 作为服务端</p><p>java 层也有一套镜像功能的 binder C/S 架构，通过 JNI 和 native binder 相对应，并且最终都是交给 native binder 来完成的</p><p><img src="../../../../image/2022-06-15-binder-arch/java_binder_framework_class.jpg" alt="java_binder_framework_class.jpg"></p><h1 id="通讯模型"><a href="#通讯模型" class="headerlink" title="通讯模型"></a>通讯模型</h1><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><blockquote><p>ioctl - control device <br><br></p><p><code>int ioctl(int fd, unsigned long request, ...);</code><br><br></p><p>The ioctl() system call manipulates the underlying device<br>parameters of special files.  In particular, many operating<br>characteristics of character special files (e.g., terminals) may<br>be controlled with ioctl() requests.  The argument <code>fd</code> must be an<br>open file descriptor.<br><br></p><p>The second argument is a <code>device-dependent request code</code>.  The<br>third argument is <code>an untyped pointer to memory</code>.<br><br></p><p>Ioctl command values are 32-bit constants.  In principle these<br>constants are completely arbitrary, but people have tried to<br>build some structure into them.<br><br></p><p>Later (0.98p5) some more information was built into the number.<br>One has 2 direction bits (00: none, 01: write, 10: read, 11:<br>read/write) followed by 14 size bits (giving the size of the<br>argument), followed by an 8-bit type (collecting the ioctls in<br>groups for a common purpose or a common driver), and an 8-bit<br>serial number.<br><br></p><p>The macros describing this structure live in &lt;asm/ioctl.h&gt; and<br>are _IO(type,nr) and {_IOR,_IOW,_IOWR}(type,nr,size).  They use<br>sizeof(size) so that size is a misnomer here: this third argument<br>is a data type.</p></blockquote><p>Linux 下用户空间通过系统调用 <code>ioctl</code> 与设备驱动进行交互，也就说当想用 binder 实现 IPC 通讯时得通过 ioctl 进行，例如 <code>ioctl(binder_fd, BINDER_WRITE_READ, p_bwr)</code></p><ul><li><code>BINDER_WRITE_READ</code> 告诉 binder 收发 IPC 数据</li><li><code>p_bwr</code> 是一个指向 <code>struct binder_write_read</code> 的指针，结构体包含需要发送的数据的地址和长度，以及需要将数据接收放在哪里</li></ul><p>完整的 binder ioctl 命令如下：</p><table><thead><tr><th>ioctl命令</th><th>数据类型</th><th>操作</th></tr></thead><tbody><tr><td>BINDER_WRITE_READ</td><td>struct binder_write_read</td><td>收发 Binder IPC 数据（最主要、最常用的命令）</td></tr><tr><td>BINDER_SET_MAX_THREADS</td><td>__u32</td><td>设置 Binder 线程最大个数</td></tr><tr><td>BINDER_SET_CONTEXT_MGR</td><td>__s32</td><td>设置 service manager 节点（也即是经常用到的 services 注册表）</td></tr><tr><td>BINDER_THREAD_EXIT</td><td>__s32</td><td>释放 Binder 线程</td></tr><tr><td>BINDER_VERSION</td><td>struct binder_version</td><td>获取 Binder 版本信息</td></tr><tr><td>BINDER_GET_NODE_DEBUG_INFO</td><td>struct binder_node_debug_info</td><td>获取 binder debug 信息</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-keyword">case</span> BINDER_WRITE_READ:<span class="hljs-built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);<span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR:<span class="hljs-built_in">binder_ioctl_set_ctx_mgr</span>(filp, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> BINDER_THREAD_EXIT:<span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT:<span class="hljs-keyword">case</span> BINDER_SET_MAX_THREADS:<span class="hljs-keyword">case</span> BINDER_VERSION:<span class="hljs-keyword">case</span> BINDER_GET_NODE_INFO_FOR_REF:<span class="hljs-keyword">case</span> BINDER_GET_NODE_DEBUG_INFO:<span class="hljs-keyword">case</span> BINDER_FREEZE:<span class="hljs-keyword">case</span> BINDER_GET_FROZEN_INFO:<span class="hljs-keyword">case</span> BINDER_ENABLE_ONEWAY_SPAM_DETECTION:<span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h2><p>ioctl 命令 <code>BINDER_WRITE_READ</code> 对应的处理器方法是 <code>binder_ioctl_write_read</code>，对应的数据结构/内存布局是 <code>struct binder_write_read</code>（ioctl 第三个参数指针指向的内存）</p><p>处理器的整个逻辑也很简单：</p><ul><li>如果 <code>write_buffer</code> 有数据就用 <code>binder_thread_write</code> 处理，write_buffer 是紧凑的布局 <code>[BC_][struct][BC_][struct][BC_][struct]...</code></li><li>如果 <code>read_buffer</code> 有数据就用 <code>binder_thread_read</code> 处理</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/external/kernel-headers/+/refs/tags/android-mainline-12.0.0_r114/original/uapi/linux/android/binder.h</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> &#123;<span class="hljs-type">binder_size_t</span>write_size;    <span class="hljs-comment">/* bytes to write */</span><span class="hljs-type">binder_size_t</span>write_consumed;<span class="hljs-comment">/* bytes consumed by driver */</span><span class="hljs-type">binder_uintptr_t</span>write_buffer;   <span class="hljs-comment">/* client/server 发送给 driver 的数据 */</span><span class="hljs-type">binder_size_t</span>read_size;    <span class="hljs-comment">/* bytes to read */</span><span class="hljs-type">binder_size_t</span>read_consumed;<span class="hljs-comment">/* bytes consumed by driver */</span><span class="hljs-type">binder_uintptr_t</span>read_buffer;    <span class="hljs-comment">/* client/server 接收来自 driver 的数据 */</span>&#125;;<span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">struct</span> binder_thread *thread)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_write_read</span> bwr;<span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_write</span>(proc, thread,  bwr.write_buffer,  bwr.write_size,  &amp;bwr.write_consumed);<span class="hljs-built_in">trace_binder_write_done</span>(ret);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;bwr.read_consumed = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;<span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) &#123;ret = <span class="hljs-built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);<span class="hljs-built_in">trace_binder_read_done</span>(ret);<span class="hljs-built_in">binder_inner_proc_lock</span>(proc);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))<span class="hljs-built_in">binder_wakeup_proc_ilocked</span>(proc);<span class="hljs-built_in">binder_inner_proc_unlock</span>(proc);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="hljs-built_in">sizeof</span>(bwr)))ret = -EFAULT;<span class="hljs-keyword">goto</span> out;&#125;&#125;<span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// https://android.googlesource.com/kernel/common/+/refs/heads/android12-5.10-lts/drivers/android/binder.c</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binder_thread_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc, <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_uintptr_t</span> binder_buffer,  <span class="hljs-comment">// 对应 binder_write_read.write_buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">size_t</span> size,                     <span class="hljs-comment">// 对应 binder_write_read.write_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">binder_size_t</span> *consumed          <span class="hljs-comment">// 对应 binder_write_read.write_consumed</span></span></span><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<span class="hljs-type">uint32_t</span> cmd;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_context</span> *context = proc-&gt;context;<span class="hljs-type">void</span> __user *buffer = (<span class="hljs-type">void</span> __user *)(<span class="hljs-type">uintptr_t</span>)binder_buffer;<span class="hljs-type">void</span> __user *ptr = buffer + *consumed;<span class="hljs-type">void</span> __user *end = buffer + size;<span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;<span class="hljs-type">int</span> ret;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_user</span>(cmd, (<span class="hljs-type">uint32_t</span> __user *)ptr))  <span class="hljs-comment">// 32 bits 的 BC 命令</span><span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>);<span class="hljs-keyword">switch</span> (cmd) &#123;<span class="hljs-keyword">case</span> BC_TRANSACTION:        <span class="hljs-keyword">case</span> BC_REPLY: &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> tr;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;tr, ptr, <span class="hljs-built_in">sizeof</span>(tr)))  <span class="hljs-comment">// 命令后紧跟着对应的结构体</span><span class="hljs-keyword">return</span> -EFAULT;ptr += <span class="hljs-built_in">sizeof</span>(tr);<span class="hljs-built_in">binder_transaction</span>(proc, thread, &amp;tr,   cmd == BC_REPLY, <span class="hljs-number">0</span>);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> BC_INCREFS:<span class="hljs-keyword">case</span> BC_ACQUIRE:<span class="hljs-keyword">case</span> BC_RELEASE:<span class="hljs-keyword">case</span> BC_DECREFS:<span class="hljs-keyword">case</span> BC_INCREFS_DONE:<span class="hljs-keyword">case</span> BC_ACQUIRE_DONE:<span class="hljs-comment">// ...</span>&#125;*consumed = ptr - buffer;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>Binder IPC 通信至少是两个进程的交互，一次完整的 Binder 通信过程如下</p><ul><li>BINDER_COMMAND_PROTOCOL：binder 请求码，以 BC_ 开头，简称 <code>BC</code> 码，表示将数据从 client/server 传递到 Binder Driver</li><li> BINDER_RETURN_PROTOCOL：binder 响应码，以 BR_ 开头，简称 <code>BR</code> 码，表示将数据从 Binder Driver 传递到 client/server</li><li>client 进程执行 binder_thread_write，根据 BC 命令生成相应的 binder_work</li><li>server 进程执行 binder_thread_read，根据 binder_work_type 类型生成 BR，发送到用户空间处理</li></ul><p><img src="../../../../image/2022-06-15-binder-arch/bindermodel.png" alt="bindermodel.png"></p><p>请求码是在 <code>binder_driver_command_protocol</code> 中定义的，用于应用程序向 binder 驱动设备发送请求消息，应用程序包含 Client 和 Server 端，以 BC_ 开头，总共 19 条</p><table><thead><tr><th>请求码</th><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>BC_TRANSACTION</td><td>binder_transaction_data</td><td>Client 向 Binder 驱动发送的请求数据</td></tr><tr><td>BC_REPLY</td><td>binder_transaction_data</td><td>Server 向 Binder 驱动发送的回复数据</td></tr><tr><td>BC_ACQUIRE_RESULT</td><td>__s32</td><td>暂时不支持</td></tr><tr><td>BC_FREE_BUFFER</td><td>binder_uintptr_t</td><td>释放内存</td></tr><tr><td>BC_INCREFS</td><td>__u32</td><td>binder_ref 弱引用加1操作（这些请求码的作用是对 binder 的强/弱引用的计数操作，用于实现强/弱指针的功能）</td></tr><tr><td>BC_ACQUIRE</td><td>__u32</td><td>binder_ref 弱引用减1操作</td></tr><tr><td>BC_RELEASE</td><td>__u32</td><td>binder_ref 强引用加1操作</td></tr><tr><td>BC_DECREFS</td><td>__u32</td><td>binder_ref 强引用减1操作</td></tr><tr><td>BC_INCREFS_DONE</td><td>binder_ptr_cookie</td><td>binder_node 强引用减1操作</td></tr><tr><td>BC_ACQUIRE_DONE</td><td>binder_ptr_cookie</td><td>binder_node 弱引用减1操作</td></tr><tr><td>BC_ATTEMPT_ACQUIRE</td><td>binder_pri_desc</td><td>暂时不支持</td></tr><tr><td>BC_REGISTER_LOOPER</td><td>无参数</td><td>创建新的 Looper 线程</td></tr><tr><td>BC_ENTER_LOOPER</td><td>无参数</td><td>应用线程进入 Looper</td></tr><tr><td>BC_EXIT_LOOPER</td><td>无参数</td><td>应用线程退出 Looper</td></tr><tr><td>BC_REQUEST_DEATH_NOTIFICATION</td><td>binder_handle_cookie</td><td>注册死亡通知</td></tr><tr><td>BC_CLEAR_DEATH_NOTIFICATION</td><td>binder_handle_cookie</td><td>取消注册的死亡通知</td></tr><tr><td>BC_DEAD_BINDER_DONE</td><td>binder_uintptr_t</td><td>已经完成的死亡通知</td></tr><tr><td>BC_TRANSACTION_SG</td><td>binder_transaction_data_sg</td><td>Client 向 Binder 驱动发送的 Command</td></tr><tr><td>BC_REPLY_SG</td><td>binder_transaction_data_sg</td><td>Server 向 Binder 驱动发送的 Command</td></tr></tbody></table><p>响应码在 <code>binder_driver_return_protocol</code> 中定义，是 binder 设备向应用程序回复的消息，应用程序包括 client 和 server 端，以 BR_ 开头，总共 18 条</p><table><thead><tr><th>响应码</th><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>BR_ERROR</td><td>__s32</td><td>操作发送错误</td></tr><tr><td>BR_OK</td><td>无参数</td><td>操作完成</td></tr><tr><td>BR_TRANSACTION</td><td>binder_transaction_data</td><td>Binder 驱动向 Server 发送的请求数据</td></tr><tr><td>BR_REPLY</td><td>binder_transaction_data</td><td>Binder 驱动向 Client 发送的回复数据</td></tr><tr><td>BR_ACQUIRE_RESULT</td><td>__s32</td><td>暂时不支持</td></tr><tr><td>BR_DEAD_REPLY</td><td>无参数</td><td>回复失败，线程或节点为空</td></tr><tr><td>BR_TRANSACTION_COMPLETE</td><td>无参数</td><td>对请求发送的成功反馈</td></tr><tr><td>BR_INCREFS</td><td>binder_ptr_cookie</td><td>binder_ref 弱引用加1操作</td></tr><tr><td>BR_ACQUIRE</td><td>binder_ptr_cookie</td><td>binder_ref 弱引用减1操作</td></tr><tr><td>BR_RELEASE</td><td>binder_ptr_cookie</td><td>binder_ref 强引用加1操作</td></tr><tr><td>BR_DECREFS</td><td>binder_ptr_cookie</td><td>binder_ref 强引用减1操作</td></tr><tr><td>BR_ATTEMPT_ACQUIRE</td><td>binder_pri_ptr_cookie</td><td>暂时不支持</td></tr><tr><td>BR_NOOP</td><td>无参数</td><td>不做任何事情</td></tr><tr><td>BR_SPAWN_LOOPER</td><td>无参数</td><td>创建新的 Looper 线程</td></tr><tr><td>BR_FINISHED</td><td>无参数</td><td>暂时不支持</td></tr><tr><td>BR_DEAD_BINDER</td><td>binder_uintptr_t</td><td>Binder 驱动向 client 发送死亡通知</td></tr><tr><td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td><td>binder_uintptr_t</td><td>清除死亡通知</td></tr><tr><td>BR_FAILED_REPLY</td><td>无参数</td><td>回复失败，transaction 出错导致</td></tr></tbody></table><h2 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h2><p>Binder 作为一种高效的 IPC 方式，在进程间进行数据传递自然是最核心的任务，所以 <code>_TRANSACTION_</code> 相关的命令是最常使用、最重要的命令，对应方法 <code>binder_transaction</code>，对应结构体 <code>binder_transaction_data</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// https://android.googlesource.com/platform/external/kernel-headers/+/refs/tags/android-mainline-12.0.0_r114/original/uapi/linux/android/binder.h</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_transaction_data</span> &#123;<span class="hljs-comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span><span class="hljs-comment"> * identifying the target and contents of the transaction.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">union</span> &#123;__u32handle;<span class="hljs-comment">/* target descriptor of command transaction */</span><span class="hljs-type">binder_uintptr_t</span> ptr;<span class="hljs-comment">/* target descriptor of return transaction */</span>&#125; target;<span class="hljs-type">binder_uintptr_t</span>cookie;<span class="hljs-comment">/* target object cookie */</span>__u32code;<span class="hljs-comment">/* transaction command */</span><span class="hljs-comment">/* General information about the transaction. */</span>__u32        flags;<span class="hljs-type">pid_t</span>sender_pid;<span class="hljs-type">uid_t</span>sender_euid;<span class="hljs-type">binder_size_t</span>data_size;<span class="hljs-comment">/* number of bytes of data */</span><span class="hljs-type">binder_size_t</span>offsets_size;<span class="hljs-comment">/* number of bytes of offsets */</span><span class="hljs-comment">/* If this transaction is inline, the data immediately</span><span class="hljs-comment"> * follows here; otherwise, it ends with a pointer to</span><span class="hljs-comment"> * the data buffer.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">union</span> &#123;<span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">/* transaction data */</span><span class="hljs-type">binder_uintptr_t</span>buffer;<span class="hljs-comment">/* offsets from buffer to flat_binder_object structs */</span><span class="hljs-type">binder_uintptr_t</span>offsets;&#125; ptr;__u8buf[<span class="hljs-number">8</span>];&#125; data;&#125;;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">binder_transaction</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> binder_proc *proc,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_thread *thread,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">struct</span> binder_transaction_data *tr, <span class="hljs-type">int</span> reply,</span></span><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">binder_size_t</span> extra_buffers_size)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;     buffer_offset += <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">binder_size_t</span>)) &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object_header</span> *hdr;<span class="hljs-type">size_t</span> object_size;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">binder_object</span> object;<span class="hljs-type">binder_size_t</span> object_offset;<span class="hljs-type">binder_size_t</span> copy_size;object_size = <span class="hljs-built_in">binder_get_object</span>(target_proc, user_buffer,t-&gt;buffer, object_offset, &amp;object);hdr = &amp;object.hdr;<span class="hljs-keyword">switch</span> (hdr-&gt;type) &#123;    <span class="hljs-comment">// 传输各种类型的数据</span><span class="hljs-keyword">case</span> BINDER_TYPE_PTR:<span class="hljs-keyword">case</span> BINDER_TYPE_BINDER:<span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_BINDER:<span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE:<span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_HANDLE:<span class="hljs-keyword">case</span> BINDER_TYPE_FD:<span class="hljs-keyword">case</span> BINDER_TYPE_FDA:<span class="hljs-comment">// ...</span>    &#125;    &#125;&#125;</code></pre></div><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>binder_mmap 是 Binder 进程间通信的高效的核心机制所在，其模型如下：</p><p><img src="../../../../image/2022-06-15-binder-arch/memory_model.png" alt="memory_model.png"></p><p>一般的 IPC 需要 client 进程空间拷贝到内核空间，再由内核空间拷贝到 server 进程空间，共发生两次内存拷贝；而 Binder IPC 整个过程只发生一次内存拷贝：</p><ul><li>虚拟进程地址空间（vm_area_struct）和虚拟内核地址空间（vm_struct）都映射到同一块物理内存空间</li><li>当 client 与 server 发送数据时，client 作为数据发送端，先从自己的进程空间把 IPC 通信数据 copy_from_user 拷贝到内核空间</li><li>而 server 作为数据接收端与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量获取内存地址</li></ul><p><img src="../../../../image/2022-06-15-binder-arch/memory_mapping.png" alt="memory_mapping.png"></p><p>对于进程和内核虚拟地址映射到同一个物理内存的操作（通过地址偏移量来实现）是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。为什么不直接让发送端和接收端直接映射到同一块物理空间，那样连一次复制的操作都不需要，0 次复制那就和 Linux 标准内核的共享内存 IPC 没有区别了，对于共享内存虽然效率高，但是对于多进程同步的问题比较复杂，而管道/消息队列等 IPC 需要复制两次，效率较低。总之Android 选择 Binder 是基于速度和安全性的考虑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B65-binder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/">深入理解 Binder 机制 5 - binder 驱动分析 - Skytoby</a></li><li><a href="https://skytoby.github.io/2020/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B66-%E6%80%BB%E7%BB%93%E7%AF%87/">深入理解 Binder 机制 6 - 总结篇 - Skytoby</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入 Binder 之 AIDL</title>
    <link href="/2022/06/08/binder-aidl/"/>
    <url>/2022/06/08/binder-aidl/</url>
    
    <content type="html"><![CDATA[<p>应用层从 <a href="https://developer.android.com/guide/components/aidl">AIDL</a> 说起，AIDL 全称 <code>Android Interface Definition Language</code>，是一个用以描述/定义 <code>接口</code> 的文本文件，有着与 java 类似的简单语法</p><p>下面是一个非常简单的 AIDL 文件，位于 <code>&#123;projectPath&#125;/app/src/main/aidl/work/dalvik/binder/example/IAidlExampleInterface.aidl</code>，一般不与 java/kotlin 代码同目录，它定义了一个返回所在进程 ID 的方法：<code>getPid()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// IAidlExampleInterface.aidl</span><span class="hljs-keyword">package</span> work.dalvik.binder.example;<span class="hljs-comment">// Declare any non-default types here with import statements</span><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAidlExampleInterface</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-title function_">getPid</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 获取进程 ID</span>&#125;</code></pre></div><p>上面所说的 <code>接口</code> 往往是 IPC 方法调用，当然也可以是本进程内的方法调用，实现这个接口的叫 <code>服务端</code>，那么调用接口的就是 <code>客户端</code></p><p>使用 AIDL 时，服务端和客户端都有一份这个 AIDL 文件，执行一下 Android Studio 菜单：Build - Make Project，就会生成对应的 java 代码如下，主要有四个：</p><ol><li><p>java 接口类 IAidlExampleInterface，包含了 AIDL 文件里定义的接口方法，相当于把 AIDL 翻译为 java 代码</p></li><li><p>Stub 类，服务端用，服务端的接口实现需要继承自 Stub 成为 Binder</p></li><li><p>Stub.asInterface() 方法，客户端用，将拿到的 IBinder 对象包装为 IAidlExampleInterface 对象，这样客户端才能调用 <code>getPid()</code> 方法</p><ol><li><p>如果客户端和服务端在同一进程，asInterface() 返回服务端实现接口的那个对象</p></li><li><p>如果不在同一进程，需要 IPC，则返回 Proxy 实例，Proxy 实际上是把方法调用代理给客户端拿到的 IBinder 对象，也就是说此时是 IBinder 对象在实现接口</p></li></ol></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAidlExampleInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.IInterface &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPid</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">work</span>.dalvik.binder.example.IAidlExampleInterface &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> work.dalvik.binder.example.IAidlExampleInterface <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> &#123; ... &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">work</span>.dalvik.binder.example.IAidlExampleInterface &#123;            Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125;            <span class="hljs-comment">// ...</span>        &#125;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>注册两个 Service，一个运行在 app 进程，一个运行在 <code>:child</code> 子进程，从日志可以看到：</p><ol><li><p>app 进程 ID 为 13070，:child 子进程 ID 为 13122</p></li><li><p>客户端和服务端同一进程的情况下，客户端拿到的 IBinder 对象和 asInterface() 返回的接口实现都是服务端里创建的 AidlExampleImpl 对象</p></li><li><p>不在同一进程的情况下，客户端 asInterface() 返回的是 Proxy 对象，这个 Proxy 对象其实并没有实现接口逻辑，而是把方法调用代理至客户端拿到的 BinderProxy 对象</p></li></ol><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AidlExampleImpl</span>: <span class="hljs-type">IAidlExampleInterface.Stub</span>() &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPid</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>  = Process.myPid()&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseService</span> : <span class="hljs-type">Service</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBinder = AidlExampleImpl()    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: IBinder = mBinder&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleService</span>: <span class="hljs-type">BaseService</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildService</span>: <span class="hljs-type">BaseService</span>()&lt;service android:name=<span class="hljs-string">&quot;.ChildService&quot;</span>    android:enabled=<span class="hljs-string">&quot;true&quot;</span>    android:exported=<span class="hljs-string">&quot;false&quot;</span>    android:process=<span class="hljs-string">&quot;:child&quot;</span>    /&gt;&lt;service android:name=<span class="hljs-string">&quot;.ExampleService&quot;</span>    android:enabled=<span class="hljs-string">&quot;true&quot;</span>    android:exported=<span class="hljs-string">&quot;false&quot;</span>    /&gt;<span class="hljs-keyword">val</span> conn = <span class="hljs-keyword">object</span> : ServiceConnection &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>, service: <span class="hljs-type">IBinder</span>)</span></span> &#123;        <span class="hljs-keyword">val</span> binder = IAidlExampleInterface.Stub.asInterface(service)        Log.d(<span class="hljs-string">&quot;cyrus&quot;</span>, <span class="hljs-string">&quot;my pid: <span class="hljs-subst">$&#123;Process.myPid()&#125;</span>, service pid: <span class="hljs-subst">$&#123;binder.pid&#125;</span>, <span class="hljs-subst">$&#123;binder.javaClass&#125;</span>, <span class="hljs-subst">$&#123;service.javaClass&#125;</span>&quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?)</span></span> &#123;&#125;&#125;bindService(Intent(<span class="hljs-keyword">this</span>, ExampleService::<span class="hljs-keyword">class</span>.java), conn, Context.BIND_AUTO_CREATE)bindService(Intent(<span class="hljs-keyword">this</span>, ChildService::<span class="hljs-keyword">class</span>.java), conn, Context.BIND_AUTO_CREATE)<span class="hljs-comment">// my pid: 13070, service pid: 13070, class work.dalvik.binder.example.AidlExampleImpl, class work.dalvik.binder.example.AidlExampleImpl</span><span class="hljs-comment">// my pid: 13070, service pid: 13122, class work.dalvik.binder.example.IAidlExampleInterface$Stub$Proxy, class android.os.BinderProxy</span></code></pre></div><p>服务端的接口实现是继承自 Stub 的，<code>queryLocalInterface()</code> 和 <code>asInterface()</code> 返回的都是自己，所以同进程的情况下客户端拿到的 IBinder 和 asInterface() 返回的都是服务端对象</p><p>不同进程的情况下客户端拿到的 IBinder 是 BinderProxy，<code>BinderProxy.queryLocalInterface</code> 直接返回 null 导致 asInterface 返回 Proxy 实例，Proxy 实例把接口调用代理给 BinderProxy 实例，最终接口调用在 BinderProxy.transactNative() 进入 native 层</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> work.dalvik.binder.example.IAidlExampleInterface <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> &#123;  <span class="hljs-keyword">if</span> ((obj==<span class="hljs-literal">null</span>)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;  android.os.<span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(DESCRIPTOR);  <span class="hljs-keyword">if</span> (((iin!=<span class="hljs-literal">null</span>)&amp;&amp;(iin <span class="hljs-keyword">instanceof</span> work.dalvik.binder.example.IAidlExampleInterface))) &#123;  <span class="hljs-comment">// 同进程</span>    <span class="hljs-keyword">return</span> ((work.dalvik.binder.example.IAidlExampleInterface)iin);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">work</span>.dalvik.binder.example.IAidlExampleInterface.Stub.Proxy(obj);             <span class="hljs-comment">// 不同进程</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBinder</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> IInterface <span class="hljs-title function_">queryLocalInterface</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String descriptor)</span> &#123;        <span class="hljs-keyword">if</span> (mDescriptor != <span class="hljs-literal">null</span> &amp;&amp; mDescriptor.equals(descriptor)) &#123;            <span class="hljs-keyword">return</span> mOwner;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachInterface</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> IInterface owner, <span class="hljs-meta">@Nullable</span> String descriptor)</span> &#123;        mOwner = owner;        mDescriptor = descriptor;    &#125;            &#125;<span class="hljs-comment">// 服务端继承自 Stub 并将 mOwner 指向自己，将 mDescriptor 指向常量 DESCRIPTOR（接口的全限定名称）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">work</span>.dalvik.binder.example.IAidlExampleInterface &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">DESCRIPTOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;work.dalvik.binder.example.IAidlExampleInterface&quot;</span>;  <span class="hljs-comment">/** Construct the stub at attach it to the interface. */</span>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stub</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">this</span>.attachInterface(<span class="hljs-built_in">this</span>, DESCRIPTOR);  &#125;&#125;<span class="hljs-comment">// BinderProxy 主要是将方法调用转换为 transact 调用，类似于 RPC 的概念</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBinder</span> &#123;    <span class="hljs-keyword">public</span> IInterface <span class="hljs-title function_">queryLocalInterface</span><span class="hljs-params">(String descriptor)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, Parcel data, Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> transactNative(code, data, reply, flags);        &#125; ...    &#125;    <span class="hljs-comment">// 不同进程的情况下，客户端的接口调用在这里进入 native 层</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transactNative</span><span class="hljs-params">(<span class="hljs-type">int</span> code, Parcel data, Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException;     &#125;<span class="hljs-comment">// Proxy 如它的名称一样就是个代理模式，将所有方法调用代理至 remote</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">work</span>.dalvik.binder.example.IAidlExampleInterface&#123;  <span class="hljs-keyword">private</span> android.os.IBinder mRemote;  Proxy(android.os.IBinder remote)  &#123;    mRemote = remote;  &#125;  <span class="hljs-comment">// 把接口调用代理至 remote，也即是 BinderProxy</span>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPid</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException  &#123;    android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();    android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();    <span class="hljs-type">int</span> _result;    <span class="hljs-keyword">try</span> &#123;      _data.writeInterfaceToken(DESCRIPTOR);      <span class="hljs-type">boolean</span> <span class="hljs-variable">_status</span> <span class="hljs-operator">=</span> mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, <span class="hljs-number">0</span>);      <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> getDefaultImpl().getPid();      &#125;      _reply.readException();      _result = _reply.readInt();    &#125;    <span class="hljs-keyword">finally</span> &#123;      _reply.recycle();      _data.recycle();    &#125;    <span class="hljs-keyword">return</span> _result;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MMKV - 高效的本地 Key-Value 存储</title>
    <link href="/2022/06/01/mmkv/"/>
    <url>/2022/06/01/mmkv/</url>
    
    <content type="html"><![CDATA[<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h1><p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> 在进程的虚拟地址空间开辟一块区域，这块区域映射文件在磁盘上的物理地址，是将内存地址空间映射到磁盘地址空间的一种方法</p><p>读/写操作访问虚拟地址空间这一段映射地址，通过查询页表发现这一段地址并不在物理页面上（因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中），因此引发缺页异常，内核发起请求调页过程。调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用 nopage 函数把所缺的页从磁盘装入到主存中。</p><p>之后如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程；修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用 <code>msync()</code> 来强制同步, 这样所写的内容就能立即保存到文件里了</p><p>它的优点有：</p><ol><li><p>常规文件操作需要从磁盘到页缓存再到用户主存的 <strong>两次数据拷贝</strong>，而 mmap 操控文件只需要从磁盘到用户主存的 <strong>一次数据拷贝</strong> 过程</p></li><li><p>实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p></li><li><p>提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。如果进程 A 和进程 B 都映射了区域 C，当 A 第一次读取 C 时通过缺页从磁盘复制文件页到内存中；但当 B 再读 C 的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p></li><li><p>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件 I/O 操作，极大影响效率。这个问题可以通过 mmap 映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap 都可以发挥其功效。</p></li></ol><h1 id="MemoryFile"><a href="#MemoryFile" class="headerlink" title="MemoryFile"></a>MemoryFile</h1><p><a href="https://github.com/Tencent/MMKV">MMKV</a> 使用 <code>MemoryFile</code> 包装 mmap 相关逻辑</p><blockquote><p>使用 mmap 需要注意的一个关键点是，mmap 映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap 从磁盘到虚拟地址空间的映射也必须是页。</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryFile</span> &#123;    File m_diskFile;    <span class="hljs-comment">// 磁盘上的文件</span>    <span class="hljs-type">void</span> *m_ptr;        <span class="hljs-comment">// 映射到文件物理地址的区域（在内存地址空间里），它的起始地址</span>    <span class="hljs-type">size_t</span> m_size;      <span class="hljs-comment">// 内存空间区域的大小</span>&#125;<span class="hljs-keyword">using</span> MMKVFileHandle_t = HANDLE;<span class="hljs-keyword">using</span> MMKVPath_t = std::wstring;<span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> &#123;    MMKVPath_t m_path;        <span class="hljs-comment">// 文件路径</span>    MMKVFileHandle_t m_fd;    <span class="hljs-comment">// 打开的文件描述符</span>&#125;<span class="hljs-comment">// 通过系统调用 open 打开文件拿到文件描述符 fd，并用系统调用 fstat 拿到文件大小，然后 mmap 这整个文件获得映射区域的内存地址</span><span class="hljs-keyword">using</span> MMKVPath_t = std::wstring;MemoryFile::<span class="hljs-built_in">MemoryFile</span>(MMKVPath_t path) : <span class="hljs-built_in">m_diskFile</span>(std::<span class="hljs-built_in">move</span>(path), OpenFlag::ReadWrite | OpenFlag::Create), <span class="hljs-built_in">m_ptr</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">m_size</span>(<span class="hljs-number">0</span>) &#123;    <span class="hljs-built_in">reloadFromFile</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MemoryFile::reloadFromFile</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!m_diskFile.<span class="hljs-built_in">open</span>()) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to open:%s, %s&quot;</span>, m_diskFile.m_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">strerror</span>(errno));    &#125; <span class="hljs-keyword">else</span> &#123;        FileLock <span class="hljs-built_in">fileLock</span>(m_diskFile.m_fd);        <span class="hljs-function">InterProcessLock <span class="hljs-title">lock</span><span class="hljs-params">(&amp;fileLock, ExclusiveLockType)</span></span>;        <span class="hljs-built_in">SCOPED_LOCK</span>(&amp;lock);        mmkv::<span class="hljs-built_in">getFileSize</span>(m_diskFile.m_fd, m_size);        <span class="hljs-keyword">if</span> (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != <span class="hljs-number">0</span>)) &#123;    <span class="hljs-comment">// 确保文件大小是内存页大小的整数倍</span>            <span class="hljs-type">size_t</span> roundSize = ((m_size / DEFAULT_MMAP_SIZE) + <span class="hljs-number">1</span>) * DEFAULT_MMAP_SIZE;            <span class="hljs-built_in">truncate</span>(roundSize);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">mmap</span>();            <span class="hljs-keyword">if</span> (!ret) &#123;                <span class="hljs-built_in">doCleanMemoryCache</span>(<span class="hljs-literal">true</span>);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">File::open</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    m_fd = ::<span class="hljs-built_in">open</span>(m_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">OpenFlag2NativeFlag</span>(m_flag), S_IRWXU);    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to open [%s], %d(%s)&quot;</span>, m_path.<span class="hljs-built_in">c_str</span>(), errno, <span class="hljs-built_in">strerror</span>(errno));        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">MMKVInfo</span>(<span class="hljs-string">&quot;open fd[%p], %s&quot;</span>, m_fd, m_path.<span class="hljs-built_in">c_str</span>());    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">getFileSize</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">size_t</span> &amp;size)</span> </span>&#123;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> st = &#123;&#125;;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd, &amp;st) != <span class="hljs-number">-1</span>) &#123;        size = (<span class="hljs-type">size_t</span>) st.st_size;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MemoryFile::mmap</span><span class="hljs-params">()</span> </span>&#123;    m_ptr = (<span class="hljs-type">char</span> *) ::<span class="hljs-built_in">mmap</span>(m_ptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_diskFile.m_fd, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (m_ptr == MAP_FAILED) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to mmap [%s], %s&quot;</span>, m_diskFile.m_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">strerror</span>(errno));        m_ptr = <span class="hljs-literal">nullptr</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h1 id="Encoding-数据格式"><a href="#Encoding-数据格式" class="headerlink" title="Encoding - 数据格式"></a>Encoding - 数据格式</h1><p>在 <a href="../../../../2022/05/16/sharedpreferences/">深入 SharedPreferences：架构、缺点和优化</a> 研究过 <code>SharedPreferences</code> 本质上是内存中的 <code>HashMap</code> 和磁盘上的 XML 文件，Java HashMap 提供了 CURD Api，持久化时序列化为 XML 格式，本质上是以字符串存储</p><p>但在 MMKV 里面对的是一整块内存区域，怎么对这块区域进行 CURD 操作呢？怎么实现 Key-Value Mapping 呢？</p><p>在内存空间里，MMKV 使用 <code>std::unordered_map</code> 这一数据结构实现 Key-Value Mapping，而 Key-Value 对的内容则是以一种很紧凑的格式存储在 mmap 开辟的内存区域</p><div class="code-wrapper"><pre><code class="hljs fortran">[(key-<span class="hljs-built_in">size</span>)(key-<span class="hljs-keyword">data</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-built_in">size</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-keyword">data</span>)][(key-<span class="hljs-built_in">size</span>)(key-<span class="hljs-keyword">data</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-built_in">size</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-keyword">data</span>)]...</code></pre></div><p>因为 mmap 内存区域是对文件物理地址的映射，所以持久化在磁盘上的格式也是上面这种紧凑格式</p><h1 id="Varints-变长的-size"><a href="#Varints-变长的-size" class="headerlink" title="Varints - 变长的 size"></a>Varints - 变长的 size</h1><p>上面的 <code>key-size</code> 和 <code>value-size</code> 分别表示 key 和 value 的长度，这两个字段所占大小是可变的，具体规则如下：</p><ol><li><p>先读取一个字节（8 bits），如果 &gt; 0（第一个 bit 是 0）则余下 7 bits 就表示其值，返回</p></li><li><p>否则说明余下 7 bits 不能完整地表示值，把这 7 bits 作为低 7 位存储在 <code>result</code>，继续找值的高位</p></li><li><p>读取一个字节，如果 &gt; 0 则余下 7 bits 作为 <code>result</code> 的高 7 位，与上面获得的低 7 位共 14 bits 就是值，返回</p></li><li><p>否则又继续找下 7 bits…</p></li><li><p>也就是每次读取一个字节，第一个 bit 表示需不需要读取下一个字节（0 - 不需要，1 - 需要），剩下 7 bits 构成了值的一部分</p></li></ol><p>下面的 <code>pbRawVarint32Size</code> 和 <code>readRawVarint32</code> 就是在计算变长的 size 字段到底有几个字节的长度，上面这个算法是参考 <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Protocol Buffers - Base 128 Varints</a></p><h1 id="Put-写操作"><a href="#Put-写操作" class="headerlink" title="Put - 写操作"></a>Put - 写操作</h1><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MMKV</span> implements SharedPreferences, SharedPreferences.Editor &#123;    @<span class="hljs-function">Override</span><span class="hljs-function">    <span class="hljs-keyword">public</span> Editor <span class="hljs-title">putString</span><span class="hljs-params">(String key, @Nullable String value)</span> </span>&#123;        <span class="hljs-built_in">encodeString</span>(nativeHandle, key, value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> native boolean <span class="hljs-title">encodeString</span><span class="hljs-params">(<span class="hljs-type">long</span> handle, String key, @Nullable String value)</span></span>;    &#125;<span class="hljs-function">MMKV_JNI jboolean <span class="hljs-title">encodeString</span><span class="hljs-params">(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue)</span> </span>&#123;    MMKV *kv = <span class="hljs-built_in">reinterpret_cast</span>&lt;MMKV *&gt;(handle);    <span class="hljs-keyword">if</span> (kv &amp;&amp; oKey) &#123;        string key = <span class="hljs-built_in">jstring2string</span>(env, oKey);        <span class="hljs-keyword">if</span> (oValue) &#123;            string value = <span class="hljs-built_in">jstring2string</span>(env, oValue);            <span class="hljs-keyword">return</span> (jboolean) kv-&gt;<span class="hljs-built_in">set</span>(value, key);        &#125; <span class="hljs-keyword">else</span> &#123;            kv-&gt;<span class="hljs-built_in">removeValueForKey</span>(key);            <span class="hljs-keyword">return</span> (jboolean) <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> (jboolean) <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::set</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;value, MMKVKey_t key)</span> </span>&#123;    <span class="hljs-comment">// using MMKVKey_t = const std::string &amp;;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isKeyEmpty</span>(key)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">setDataForKey</span>(<span class="hljs-built_in">MMBuffer</span>((<span class="hljs-type">void</span> *) value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">length</span>(), MMBufferNoCopy), key, <span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::setDataForKey</span><span class="hljs-params">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class="hljs-type">bool</span> isDataHolder)</span> </span>&#123;    <span class="hljs-keyword">if</span> ((!isDataHolder &amp;&amp; data.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) || <span class="hljs-built_in">isKeyEmpty</span>(key)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">SCOPED_LOCK</span>(m_lock);    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-built_in">checkLoadData</span>();    &#123;        <span class="hljs-keyword">auto</span> itr = m_dic-&gt;<span class="hljs-built_in">find</span>(key);    <span class="hljs-comment">// using MMKVMap = std::unordered_map&lt;std::string, mmkv::KeyValueHolder&gt;;</span>        <span class="hljs-keyword">if</span> (itr != m_dic-&gt;<span class="hljs-built_in">end</span>()) &#123;      <span class="hljs-comment">// mmkv::MMKVMap *m_dic;</span>            <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">appendDataWithKey</span>(data, itr-&gt;second, isDataHolder);            <span class="hljs-keyword">if</span> (!ret.first) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            itr-&gt;second = std::<span class="hljs-built_in">move</span>(ret.second);        &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// key 不存在的情况</span>            <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">appendDataWithKey</span>(data, key, isDataHolder);            <span class="hljs-keyword">if</span> (!ret.first) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            m_dic-&gt;<span class="hljs-built_in">emplace</span>(key, std::<span class="hljs-built_in">move</span>(ret.second));        &#125;    &#125;    m_hasFullWriteback = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">KVHolderRet_t <span class="hljs-title">MMKV::appendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class="hljs-type">bool</span> isDataHolder)</span> </span>&#123;    <span class="hljs-comment">// key 不存在的情况</span>    <span class="hljs-keyword">auto</span> keyData = <span class="hljs-built_in">MMBuffer</span>((<span class="hljs-type">void</span> *) key.<span class="hljs-built_in">data</span>(), key.<span class="hljs-built_in">size</span>(), MMBufferNoCopy);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(keyData.<span class="hljs-built_in">length</span>()));&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MMBuffer</span> &#123;    <span class="hljs-comment">// MMBuffer 代表一块内存区域</span>    <span class="hljs-type">size_t</span> size;    <span class="hljs-comment">// 内存区域的大小</span>    <span class="hljs-type">void</span> *ptr;      <span class="hljs-comment">// 内存区域的起始地址</span>&#125;<span class="hljs-comment">// 写操作 isDataHolder 总是 true，isDataHolder 为 false 表示删除 key，后面会讲到</span><span class="hljs-function">KVHolderRet_t</span><span class="hljs-function"><span class="hljs-title">MMKV::doAppendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, <span class="hljs-type">const</span> MMBuffer &amp;keyData, <span class="hljs-type">bool</span> isDataHolder, <span class="hljs-type">uint32_t</span> originKeyLength)</span> </span>&#123;    <span class="hljs-keyword">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class="hljs-built_in">length</span>());    <span class="hljs-comment">// 对于 key 不存在的情况，isKeyEncoded == false</span>    <span class="hljs-keyword">auto</span> keyLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(keyData.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">auto</span> valueLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(data.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">if</span> (isDataHolder) &#123;        valueLength += <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);    &#125;    <span class="hljs-comment">// size needed to encode the key</span>    <span class="hljs-type">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class="hljs-built_in">pbRawVarint32Size</span>(keyLength));    <span class="hljs-comment">// size needed to encode the value</span>    size += valueLength + <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-type">bool</span> hasEnoughSize = <span class="hljs-built_in">ensureMemorySize</span>(size);    <span class="hljs-keyword">if</span> (!hasEnoughSize || !<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());    &#125;    <span class="hljs-comment">// writeRawData 写入数据内容，writeData 先写入数据长度再写入数据内容</span>    <span class="hljs-comment">// 对于 key 不存在的情况，isKeyEncoded == false，isDataHolder == true</span>    <span class="hljs-comment">// 那么写入的顺序是：写入 key 长度，写入 key 内容，写入 value 长度，写入 value 内容</span>    <span class="hljs-comment">// 正如上面数据格式里描述的一样</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (isKeyEncoded) &#123;            m_output-&gt;<span class="hljs-built_in">writeRawData</span>(keyData);        &#125; <span class="hljs-keyword">else</span> &#123;            m_output-&gt;<span class="hljs-built_in">writeData</span>(keyData);        &#125;        <span class="hljs-keyword">if</span> (isDataHolder) &#123;            m_output-&gt;<span class="hljs-built_in">writeRawVarint32</span>((<span class="hljs-type">int32_t</span>) valueLength);        &#125;        m_output-&gt;<span class="hljs-built_in">writeData</span>(data); <span class="hljs-comment">// note: write size of data</span>    &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;e) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;%s&quot;</span>, e.<span class="hljs-built_in">what</span>());        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());    &#125;    <span class="hljs-comment">// 返回一个 pair，first 表示操作成功 or 失败</span>    <span class="hljs-comment">// second 记录了这个 Key-Value 对在内存和文件的偏移量，以及 key 和 value 的大小</span>    <span class="hljs-comment">// 这样就能够通过 key 找到 KeyValueHolder 并快速地定位出 value 所在内存地址</span>    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(m_actualSize);    <span class="hljs-keyword">auto</span> ptr = (<span class="hljs-type">uint8_t</span> *) m_file-&gt;<span class="hljs-built_in">getMemory</span>() + Fixed32Size + m_actualSize;    m_actualSize += size;    <span class="hljs-built_in">updateCRCDigest</span>(ptr, size);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">true</span>, <span class="hljs-built_in">KeyValueHolder</span>(originKeyLength, valueLength, offset));&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyValueHolder</span> &#123;    <span class="hljs-type">uint16_t</span> keySize;      <span class="hljs-comment">// key 的大小</span>    <span class="hljs-type">uint32_t</span> valueSize;    <span class="hljs-comment">// value 的大小</span>    <span class="hljs-type">uint32_t</span> offset;       <span class="hljs-comment">// 相对于 mmap 内存区域的偏移量，也是这个 Key-Value 对在文件内的偏移量（这样才能从文件恢复）</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CodedOutputData::writeData</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;value)</span> </span>&#123;    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">writeRawVarint32</span>((<span class="hljs-type">int32_t</span>) value.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">writeRawData</span>(value);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CodedOutputData::writeRawData</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data)</span> </span>&#123;    <span class="hljs-type">size_t</span> numberOfBytes = data.<span class="hljs-built_in">length</span>();    <span class="hljs-keyword">if</span> (m_position + numberOfBytes &gt; m_size) &#123;        <span class="hljs-keyword">auto</span> msg = <span class="hljs-string">&quot;m_position: &quot;</span> + <span class="hljs-built_in">to_string</span>(m_position) + <span class="hljs-string">&quot;, numberOfBytes: &quot;</span> + <span class="hljs-built_in">to_string</span>(numberOfBytes) +                   <span class="hljs-string">&quot;, m_size: &quot;</span> + <span class="hljs-built_in">to_string</span>(m_size);        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(msg);    &#125;    <span class="hljs-built_in">memcpy</span>(m_ptr + m_position, data.<span class="hljs-built_in">getPtr</span>(), numberOfBytes);    m_position += numberOfBytes;&#125;</code></pre></div><h1 id="Update-修改的情况"><a href="#Update-修改的情况" class="headerlink" title="Update - 修改的情况"></a>Update - 修改的情况</h1><p>在上面的基本流程里，如果 key 存在则进行修改操作，但此时存在一个问题，Key-Value 对是紧凑地排列在一块连续的内存区域上的，如果改变某个 value 的长度那后面的内容对应地需要整体前移或后移，这样修改的代价就会变得很大</p><p>所以 MMKV 采取一个用空间换时间的策略：不修改原有的 Key-Value 对，而是将新的 Key-Value 对附加（append）到末尾（当然此时 key 是一样的）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 修改/更新的情况下，从词典里找到已存在的键值对 KeyValueHolder</span><span class="hljs-comment">// 新增的情况，第二个参数是 MMKVKey_t key</span><span class="hljs-function">KVHolderRet_t <span class="hljs-title">MMKV::appendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, <span class="hljs-type">const</span> KeyValueHolder &amp;kvHolder, <span class="hljs-type">bool</span> isDataHolder)</span> </span>&#123;    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-type">uint32_t</span> keyLength = kvHolder.keySize;    <span class="hljs-comment">// size needed to encode the key</span>    <span class="hljs-type">size_t</span> rawKeySize = keyLength + <span class="hljs-built_in">pbRawVarint32Size</span>(keyLength);    <span class="hljs-comment">// ensureMemorySize() might change kvHolder.offset, so have to do it early</span>    &#123;        <span class="hljs-keyword">auto</span> valueLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(data.<span class="hljs-built_in">length</span>());        <span class="hljs-keyword">if</span> (isDataHolder) &#123;            valueLength += <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);        &#125;        <span class="hljs-keyword">auto</span> size = rawKeySize + valueLength + <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);        <span class="hljs-type">bool</span> hasEnoughSize = <span class="hljs-built_in">ensureMemorySize</span>(size);        <span class="hljs-keyword">if</span> (!hasEnoughSize) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());        &#125;    &#125;    <span class="hljs-comment">// 跟新增的情况一样进入 doAppendDataWithKey，但有所不同</span>    <span class="hljs-comment">// keyLength 指的是 key data size，跟新增时一样</span>    <span class="hljs-comment">// 第二个参数 MMBuffer keyData 它指向 key 在 mmap 内存区域的起始地址，size 是整个 key entry 的长度（包含 key data size 部分）</span>    <span class="hljs-keyword">auto</span> basePtr = (<span class="hljs-type">uint8_t</span> *) m_file-&gt;<span class="hljs-built_in">getMemory</span>() + Fixed32Size;    <span class="hljs-function">MMBuffer <span class="hljs-title">keyData</span><span class="hljs-params">(basePtr + kvHolder.offset, rawKeySize, MMBufferNoCopy)</span></span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">doAppendDataWithKey</span>(data, keyData, isDataHolder, keyLength);&#125;<span class="hljs-comment">// 修改时 isDataHolder 也是 true</span><span class="hljs-function">KVHolderRet_t <span class="hljs-title">MMKV::doAppendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, <span class="hljs-type">const</span> MMBuffer &amp;keyData, <span class="hljs-type">bool</span> isDataHolder, <span class="hljs-type">uint32_t</span> originKeyLength)</span> </span>&#123;    <span class="hljs-keyword">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class="hljs-built_in">length</span>());    <span class="hljs-comment">// 修改时 isKeyEncoded == true，原因是 keyData 包含了 key data size 部分</span>    <span class="hljs-keyword">auto</span> keyLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(keyData.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">auto</span> valueLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(data.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">if</span> (isDataHolder) &#123;        valueLength += <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);    &#125;    <span class="hljs-comment">// size needed to encode the key</span>    <span class="hljs-type">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class="hljs-built_in">pbRawVarint32Size</span>(keyLength));    <span class="hljs-comment">// size needed to encode the value</span>    size += valueLength + <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-type">bool</span> hasEnoughSize = <span class="hljs-built_in">ensureMemorySize</span>(size);    <span class="hljs-keyword">if</span> (!hasEnoughSize || !<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());    &#125;    <span class="hljs-comment">// 这里可以看到修改已有的 Key-Value 并不会真正地去 mmap 内存区域里做修改操作，</span>    <span class="hljs-comment">// 而是将修改后的 Key-Value append 至 mmap 内存区域尾部，也即是 append 到磁盘文件尾部</span>    <span class="hljs-comment">// isKeyEncoded == true，用 writeRawData 将 keyData 对应的整块内存写入，keyData 是从 dic 里查找出来的，包含完整的 key data size 和 key data</span>    <span class="hljs-comment">// 然后写 value data size 和 value data</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (isKeyEncoded) &#123;            m_output-&gt;<span class="hljs-built_in">writeRawData</span>(keyData);        &#125; <span class="hljs-keyword">else</span> &#123;            m_output-&gt;<span class="hljs-built_in">writeData</span>(keyData);        &#125;        <span class="hljs-keyword">if</span> (isDataHolder) &#123;            m_output-&gt;<span class="hljs-built_in">writeRawVarint32</span>((<span class="hljs-type">int32_t</span>) valueLength);        &#125;        m_output-&gt;<span class="hljs-built_in">writeData</span>(data); <span class="hljs-comment">// note: write size of data</span>    &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;e) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;%s&quot;</span>, e.<span class="hljs-built_in">what</span>());        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());    &#125;    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(m_actualSize);    <span class="hljs-keyword">auto</span> ptr = (<span class="hljs-type">uint8_t</span> *) m_file-&gt;<span class="hljs-built_in">getMemory</span>() + Fixed32Size + m_actualSize;    m_actualSize += size;    <span class="hljs-built_in">updateCRCDigest</span>(ptr, size);    <span class="hljs-comment">// 返回一个新的 KeyValueHolder 实例，指向刚刚 append 的 Key-Value 对在 mmap 内存区域的地址，但 key 部分跟旧的是一样的</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">true</span>, <span class="hljs-built_in">KeyValueHolder</span>(originKeyLength, valueLength, offset));&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::setDataForKey</span><span class="hljs-params">(MMBuffer &amp;&amp;data, MMKVKey_t key, <span class="hljs-type">bool</span> isDataHolder)</span> </span>&#123;    <span class="hljs-keyword">if</span> ((!isDataHolder &amp;&amp; data.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) || <span class="hljs-built_in">isKeyEmpty</span>(key)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">SCOPED_LOCK</span>(m_lock);    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-built_in">checkLoadData</span>();    &#123;        <span class="hljs-keyword">auto</span> itr = m_dic-&gt;<span class="hljs-built_in">find</span>(key);    <span class="hljs-comment">// using MMKVMap = std::unordered_map&lt;std::string, mmkv::KeyValueHolder&gt;;</span>        <span class="hljs-keyword">if</span> (itr != m_dic-&gt;<span class="hljs-built_in">end</span>()) &#123;      <span class="hljs-comment">// mmkv::MMKVMap *m_dic;</span>            <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">appendDataWithKey</span>(data, itr-&gt;second, isDataHolder);            <span class="hljs-keyword">if</span> (!ret.first) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            itr-&gt;second = std::<span class="hljs-built_in">move</span>(ret.second);        &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// key 不存在的情况</span>            <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">appendDataWithKey</span>(data, key, isDataHolder);            <span class="hljs-keyword">if</span> (!ret.first) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-comment">// 更新词典，后续通过这个 key 找到的就是 append 至内存区域末尾的最新的 value 值</span>            m_dic-&gt;<span class="hljs-built_in">emplace</span>(key, std::<span class="hljs-built_in">move</span>(ret.second));        &#125;    &#125;    m_hasFullWriteback = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h1 id="Remove-删除操作"><a href="#Remove-删除操作" class="headerlink" title="Remove - 删除操作"></a>Remove - 删除操作</h1><p>上面聊过由于 Key-Value 对是以下面这种紧凑的格式一个个排列在一起的，如果修改操作改变了已有的某个 Value 的长度，那么后面的数据就要整块前移或者后移</p><p>删除操作也是一样的，将某个 Key-Value 对删除后，那么后面的 Key-Value 对也要整体前移，这样删除操作的效率就会很低，所以 MMKV 把删除操作改为 append 一个相同 key 但 value data size 为 0 的新项，并从词典里移除此 key 对应的项</p><div class="code-wrapper"><pre><code class="hljs fortran">[(key-<span class="hljs-built_in">size</span>)(key-<span class="hljs-keyword">data</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-built_in">size</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-keyword">data</span>)][(key-<span class="hljs-built_in">size</span>)(key-<span class="hljs-keyword">data</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-built_in">size</span>)(<span class="hljs-keyword">value</span>-<span class="hljs-keyword">data</span>)]...</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MMKV</span> implements SharedPreferences, SharedPreferences.Editor &#123;    @<span class="hljs-function">Override</span><span class="hljs-function">    <span class="hljs-keyword">public</span> Editor <span class="hljs-title">remove</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-built_in">removeValueForKey</span>(key);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">removeValueForKey</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-built_in">removeValueForKey</span>(nativeHandle, key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> native <span class="hljs-type">void</span> <span class="hljs-title">removeValueForKey</span><span class="hljs-params">(<span class="hljs-type">long</span> handle, String key)</span></span>;  &#125;<span class="hljs-function">MMKV_EXPORT <span class="hljs-type">void</span> <span class="hljs-title">removeValueForKey</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle, <span class="hljs-type">char</span> *oKey)</span> </span>&#123;    MMKV *kv = <span class="hljs-built_in">static_cast</span>&lt;MMKV *&gt;(handle);    <span class="hljs-keyword">if</span> (kv &amp;&amp; oKey) &#123;        <span class="hljs-function">string <span class="hljs-title">key</span><span class="hljs-params">(oKey)</span></span>;        kv-&gt;<span class="hljs-built_in">removeValueForKey</span>(key);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MMKV::removeValueForKey</span><span class="hljs-params">(MMKVKey_t key)</span> </span>&#123;    <span class="hljs-comment">// using MMKVKey_t = const std::string &amp;;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isKeyEmpty</span>(key)) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">SCOPED_LOCK</span>(m_lock);    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-built_in">checkLoadData</span>();    <span class="hljs-built_in">removeDataForKey</span>(key);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::removeDataForKey</span><span class="hljs-params">(MMKVKey_t key)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isKeyEmpty</span>(key)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    &#123;        <span class="hljs-keyword">auto</span> itr = m_dic-&gt;<span class="hljs-built_in">find</span>(key);        <span class="hljs-keyword">if</span> (itr != m_dic-&gt;<span class="hljs-built_in">end</span>()) &#123;            m_hasFullWriteback = <span class="hljs-literal">false</span>;            <span class="hljs-type">static</span> MMBuffer nan;      <span class="hljs-comment">// size == 0，ptr == null</span>            <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">appendDataWithKey</span>(nan, itr-&gt;second);            <span class="hljs-keyword">if</span> (ret.first) &#123;                m_dic-&gt;<span class="hljs-built_in">erase</span>(itr);    <span class="hljs-comment">// 对于 mmap 内存区域是 append 一个 empty value 的项，对于用以 mapping 的词典是移除此项</span>            &#125;            <span class="hljs-keyword">return</span> ret.first;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">// 删除操作下 isDataHolder == false，data.size == 0，data.ptr == null</span><span class="hljs-function">KVHolderRet_t <span class="hljs-title">MMKV::appendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, MMKVKey_t key, <span class="hljs-type">bool</span> isDataHolder)</span> </span>&#123;    <span class="hljs-keyword">auto</span> keyData = <span class="hljs-built_in">MMBuffer</span>((<span class="hljs-type">void</span> *) key.<span class="hljs-built_in">data</span>(), key.<span class="hljs-built_in">size</span>(), MMBufferNoCopy);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">doAppendDataWithKey</span>(data, keyData, isDataHolder, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(keyData.<span class="hljs-built_in">length</span>()));&#125;<span class="hljs-function">KVHolderRet_t</span><span class="hljs-function"><span class="hljs-title">MMKV::doAppendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, <span class="hljs-type">const</span> MMBuffer &amp;keyData, <span class="hljs-type">bool</span> isDataHolder, <span class="hljs-type">uint32_t</span> originKeyLength)</span> </span>&#123;    <span class="hljs-keyword">auto</span> isKeyEncoded = (originKeyLength &lt; keyData.<span class="hljs-built_in">length</span>());    <span class="hljs-comment">// 删除的情况下，isKeyEncoded == true</span>    <span class="hljs-keyword">auto</span> keyLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(keyData.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">auto</span> valueLength = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(data.<span class="hljs-built_in">length</span>());    <span class="hljs-keyword">if</span> (isDataHolder) &#123;        valueLength += <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);    &#125;    <span class="hljs-comment">// size needed to encode the key</span>    <span class="hljs-type">size_t</span> size = isKeyEncoded ? keyLength : (keyLength + <span class="hljs-built_in">pbRawVarint32Size</span>(keyLength));    <span class="hljs-comment">// size needed to encode the value</span>    size += valueLength + <span class="hljs-built_in">pbRawVarint32Size</span>(valueLength);    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-type">bool</span> hasEnoughSize = <span class="hljs-built_in">ensureMemorySize</span>(size);    <span class="hljs-keyword">if</span> (!hasEnoughSize || !<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());    &#125;    <span class="hljs-comment">// writeRawData 写入数据内容，writeData 先写入数据长度再写入数据内容</span>    <span class="hljs-comment">// 在删除操作里，isKeyEncoded == true，isDataHolder == false</span>    <span class="hljs-comment">// key 包含 size 和 data，原封不动写入</span>    <span class="hljs-comment">// value 写入 size 0，没有 data</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (isKeyEncoded) &#123;            m_output-&gt;<span class="hljs-built_in">writeRawData</span>(keyData);        &#125; <span class="hljs-keyword">else</span> &#123;            m_output-&gt;<span class="hljs-built_in">writeData</span>(keyData);        &#125;        <span class="hljs-keyword">if</span> (isDataHolder) &#123;            m_output-&gt;<span class="hljs-built_in">writeRawVarint32</span>((<span class="hljs-type">int32_t</span>) valueLength);        &#125;        m_output-&gt;<span class="hljs-built_in">writeData</span>(data); <span class="hljs-comment">// note: write size of data</span>    &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;e) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;%s&quot;</span>, e.<span class="hljs-built_in">what</span>());        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, <span class="hljs-built_in">KeyValueHolder</span>());    &#125;    <span class="hljs-keyword">auto</span> offset = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(m_actualSize);    <span class="hljs-keyword">auto</span> ptr = (<span class="hljs-type">uint8_t</span> *) m_file-&gt;<span class="hljs-built_in">getMemory</span>() + Fixed32Size + m_actualSize;    m_actualSize += size;    <span class="hljs-built_in">updateCRCDigest</span>(ptr, size);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">true</span>, <span class="hljs-built_in">KeyValueHolder</span>(originKeyLength, valueLength, offset));&#125;</code></pre></div><h1 id="Get-查找操作"><a href="#Get-查找操作" class="headerlink" title="Get - 查找操作"></a>Get - 查找操作</h1><p>查询操作比较简单：</p><ol><li><p>根据 string key 从词典里查找出 KeyValueHolder</p></li><li><p>KeyValueHolder.offset 是键值对在 mmap 内存区域的偏移量，加上内存区域的起始地址即可定位出键值对在虚拟内存中的起始地址</p></li><li><p>加上 key size 和 key data 的偏移量就是 value 的内存地址</p></li><li><p>再加上 value size 的偏移量就是 value data 的内存地址</p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MMKV</span> implements SharedPreferences, SharedPreferences.Editor &#123;    @Nullable    @<span class="hljs-function">Override</span><span class="hljs-function">    <span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">(String key, @Nullable String defValue)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeString</span>(nativeHandle, key, defValue);    &#125;    @<span class="hljs-function">Nullable</span><span class="hljs-function">    <span class="hljs-keyword">private</span> native String <span class="hljs-title">decodeString</span><span class="hljs-params">(<span class="hljs-type">long</span> handle, String key, @Nullable String defaultValue)</span></span>;&#125;<span class="hljs-function">MMKV_JNI jstring <span class="hljs-title">decodeString</span><span class="hljs-params">(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue)</span> </span>&#123;    MMKV *kv = <span class="hljs-built_in">reinterpret_cast</span>&lt;MMKV *&gt;(handle);    <span class="hljs-keyword">if</span> (kv &amp;&amp; oKey) &#123;        string key = <span class="hljs-built_in">jstring2string</span>(env, oKey);        string value;        <span class="hljs-type">bool</span> hasValue = kv-&gt;<span class="hljs-built_in">getString</span>(key, value);        <span class="hljs-keyword">if</span> (hasValue) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">string2jstring</span>(env, value);        &#125;    &#125;    <span class="hljs-keyword">return</span> oDefaultValue;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::getString</span><span class="hljs-params">(MMKVKey_t key, string &amp;result)</span> </span>&#123;           <span class="hljs-comment">// using MMKVKey_t = const std::string &amp;;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isKeyEmpty</span>(key)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">SCOPED_LOCK</span>(m_lock);    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">getDataForKey</span>(key);    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-function">CodedInputData <span class="hljs-title">input</span><span class="hljs-params">(data.getPtr(), data.length())</span></span>;  <span class="hljs-comment">// 包含了 value size 和 value data</span>            result = input.<span class="hljs-built_in">readString</span>();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;exception) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;%s&quot;</span>, exception.<span class="hljs-built_in">what</span>());        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function">MMBuffer <span class="hljs-title">MMKV::getDataForKey</span><span class="hljs-params">(MMKVKey_t key)</span> </span>&#123;    <span class="hljs-built_in">checkLoadData</span>();    &#123;        <span class="hljs-keyword">auto</span> itr = m_dic-&gt;<span class="hljs-built_in">find</span>(key);        <span class="hljs-keyword">if</span> (itr != m_dic-&gt;<span class="hljs-built_in">end</span>()) &#123;            <span class="hljs-keyword">auto</span> basePtr = (<span class="hljs-type">uint8_t</span> *) (m_file-&gt;<span class="hljs-built_in">getMemory</span>()) + Fixed32Size;  <span class="hljs-comment">// mmap 内存区域的起始地址</span>            <span class="hljs-keyword">return</span> itr-&gt;second.<span class="hljs-built_in">toMMBuffer</span>(basePtr);  <span class="hljs-comment">// 加上 offset 就是键值对的内存地址，加上 key size 和 key value 偏移量则是 value 的内存地址                          </span>        &#125;    &#125;    MMBuffer nan;    <span class="hljs-keyword">return</span> nan;&#125;<span class="hljs-function">string <span class="hljs-title">CodedInputData::readString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int32_t</span> size = <span class="hljs-built_in">readRawVarint32</span>();                         <span class="hljs-comment">// 计算变长的 size 值，在上面的章节中有讲过计算过程</span>    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">length_error</span>(<span class="hljs-string">&quot;InvalidProtocolBuffer negativeSize&quot;</span>);    &#125;    <span class="hljs-keyword">auto</span> s_size = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(size);    <span class="hljs-keyword">if</span> (s_size &lt;= m_size - m_position) &#123;        <span class="hljs-function">string <span class="hljs-title">result</span><span class="hljs-params">((<span class="hljs-type">char</span> *) (m_ptr + m_position), s_size)</span></span>;  <span class="hljs-comment">// 加上 value size 的偏移量就是 value data，作为 string 返回</span>        m_position += s_size;        <span class="hljs-keyword">return</span> result;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;InvalidProtocolBuffer truncatedMessage&quot;</span>);    &#125;&#125;<span class="hljs-comment">// 在章节 [Varints - 变长的 size] 里讲过，一个字节里，高 1 位表示是否需要读取下一个字节来解析，低 7 位存储数值</span><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">CodedInputData::readRawVarint32</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int8_t</span> tmp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readRawByte</span>();    <span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> tmp;    &#125;    <span class="hljs-type">int32_t</span> result = tmp &amp; <span class="hljs-number">0x7f</span>;    <span class="hljs-keyword">if</span> ((tmp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readRawByte</span>()) &gt;= <span class="hljs-number">0</span>) &#123;        result |= tmp &lt;&lt; <span class="hljs-number">7</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        result |= (tmp &amp; <span class="hljs-number">0x7f</span>) &lt;&lt; <span class="hljs-number">7</span>;        <span class="hljs-keyword">if</span> ((tmp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readRawByte</span>()) &gt;= <span class="hljs-number">0</span>) &#123;            result |= tmp &lt;&lt; <span class="hljs-number">14</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            result |= (tmp &amp; <span class="hljs-number">0x7f</span>) &lt;&lt; <span class="hljs-number">14</span>;            <span class="hljs-keyword">if</span> ((tmp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readRawByte</span>()) &gt;= <span class="hljs-number">0</span>) &#123;                result |= tmp &lt;&lt; <span class="hljs-number">21</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                result |= (tmp &amp; <span class="hljs-number">0x7f</span>) &lt;&lt; <span class="hljs-number">21</span>;                result |= (tmp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readRawByte</span>()) &lt;&lt; <span class="hljs-number">28</span>;                <span class="hljs-keyword">if</span> (tmp &lt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// discard upper 32 bits</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">readRawByte</span>() &gt;= <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">return</span> result;                        &#125;                    &#125;                    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;InvalidProtocolBuffer malformed varint32&quot;</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h1 id="loadFromFile-构建索引词典"><a href="#loadFromFile-构建索引词典" class="headerlink" title="loadFromFile - 构建索引词典"></a>loadFromFile - 构建索引词典</h1><p>MMKV 依靠 <code>std::unordered_map</code> 词典数据结构提供 Key-Value 映射和查找服务，但这个词典结构只存在于内存里并没有实现持久化，所以当第一次打开某个 MMKV 数据文件时，需要将文件从头到尾扫描解析一遍，以构建和还原整个词典数据结构</p><p>从下面的结构可以看出，<code>reloadFromFile</code> 的过程并不需要将 mmap 映射内存区域的所有页都加载进内存，只需要根据 key size 和 value size 跳跃式地访问内存页即可，所需信息包括：</p><ol><li>offset - 键值对在 mmap 映射文件里的偏移量</li><li>keySize - key 大小，它是一个变长的数值</li><li>keyData - 作为 string 用以查找</li><li>valueSize - value 的大小</li><li>valueData 在被访问前是不需要加载进内存的，所以会有大量的虚拟页无需分配</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyValueHolder</span> &#123;    <span class="hljs-type">uint16_t</span> computedKVSize; <span class="hljs-comment">// internal use only</span>    <span class="hljs-type">uint16_t</span> keySize;    <span class="hljs-type">uint32_t</span> valueSize;    <span class="hljs-type">uint32_t</span> offset;&#125;;<span class="hljs-keyword">using</span> MMKVMap = std::unordered_map&lt;std::string, mmkv::KeyValueHolder&gt;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MMKV</span> &#123;    mmkv::MMKVMap *m_dic;&#125;</code></pre></div><p>与 SharedPreferences 的区别：</p><ol><li><p>SharedPreferences 在构造函数里起个工作线程执行文件解析工作，在解析工作完成前，任何的读写操作都会被阻塞；而 MMKV 则是在构造函数里（当前线程）立即执行文件解析任务，任务完成（无论成功 or 失败）退出构造函数才能执行读写操作</p></li><li><p>MMKV 的解析速度要快很多，因为 SharedPreferences 是将 XML 文件全量加载和解析至内存，MMKV 就如上一章节描述的那样并不会立即加载 value data，只加载了 key size、key data 和 value size 三个部分，这三个部分一般情况下要比 value data 小很多</p></li></ol><p>上面介绍过所有的 CURD 操作都是 append 一个键值对到文件末尾，而从文件构建 mapping 词典时，是从文件头扫描到文件尾的，所以旧的键值对会被新 append 的键值对替换/删除，看下具体流程：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> MMKV <span class="hljs-title">mmkvWithID</span><span class="hljs-params">(String mmapID)</span> throws RuntimeException </span>&#123;    <span class="hljs-keyword">if</span> (rootDir == null) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalStateException</span>(<span class="hljs-string">&quot;You should Call MMKV.initialize() first.&quot;</span>);    &#125;    <span class="hljs-type">long</span> handle = <span class="hljs-built_in">getMMKVWithID</span>(mmapID, SINGLE_PROCESS_MODE, null, null);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">checkProcessMode</span>(handle, mmapID, SINGLE_PROCESS_MODE);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> native <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">getMMKVWithID</span><span class="hljs-params">(String mmapID, <span class="hljs-type">int</span> mode, @Nullable String cryptKey, @Nullable String rootPath)</span></span>;<span class="hljs-function">MMKV_EXPORT <span class="hljs-type">void</span> *<span class="hljs-title">getMMKVWithID</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *mmapID, <span class="hljs-type">int32_t</span> mode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cryptKey, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *rootPath)</span> </span>&#123;    MMKV *kv = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">if</span> (!mmapID) &#123;        <span class="hljs-keyword">return</span> kv;    &#125;    string str = mmapID;    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (cryptKey) &#123;        string crypt = cryptKey;        <span class="hljs-keyword">if</span> (crypt.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (rootPath) &#123;                string path = rootPath;                kv = MMKV::<span class="hljs-built_in">mmkvWithID</span>(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, &amp;path);            &#125; <span class="hljs-keyword">else</span> &#123;                kv = MMKV::<span class="hljs-built_in">mmkvWithID</span>(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, <span class="hljs-literal">nullptr</span>);            &#125;            done = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (!done) &#123;        <span class="hljs-keyword">if</span> (rootPath) &#123;            string path = rootPath;            kv = MMKV::<span class="hljs-built_in">mmkvWithID</span>(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, <span class="hljs-literal">nullptr</span>, &amp;path);        &#125; <span class="hljs-keyword">else</span> &#123;            kv = MMKV::<span class="hljs-built_in">mmkvWithID</span>(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 走这条路</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> kv;&#125;<span class="hljs-function">MMKV *<span class="hljs-title">MMKV::mmkvWithID</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;mmapID, <span class="hljs-type">int</span> size, MMKVMode mode, string *cryptKey, string *rootPath)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mmapID.<span class="hljs-built_in">empty</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    &#125;    <span class="hljs-built_in">SCOPED_LOCK</span>(g_instanceLock);    <span class="hljs-keyword">auto</span> mmapKey = <span class="hljs-built_in">mmapedKVKey</span>(mmapID, rootPath);  <span class="hljs-comment">// id 对应的 MMKV 实例如果已创建则直接返回</span>    <span class="hljs-keyword">auto</span> itr = g_instanceDic-&gt;<span class="hljs-built_in">find</span>(mmapKey);    <span class="hljs-keyword">if</span> (itr != g_instanceDic-&gt;<span class="hljs-built_in">end</span>()) &#123;        MMKV *kv = itr-&gt;second;        <span class="hljs-keyword">return</span> kv;    &#125;    <span class="hljs-keyword">if</span> (rootPath) &#123;                                <span class="hljs-comment">// 准备所需的目录</span>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFileExist</span>(*rootPath)) &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">mkPath</span>(*rootPath)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;            &#125;        &#125;        <span class="hljs-built_in">MMKVInfo</span>(<span class="hljs-string">&quot;prepare to load %s (id %s) from rootPath %s&quot;</span>, mmapID.<span class="hljs-built_in">c_str</span>(), mmapKey.<span class="hljs-built_in">c_str</span>(), rootPath-&gt;<span class="hljs-built_in">c_str</span>());    &#125;    <span class="hljs-keyword">auto</span> kv = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MMKV</span>(mmapID, size, mode, cryptKey, rootPath);  <span class="hljs-comment">// 看这里如何创建 MMKV 实例</span>    (*g_instanceDic)[mmapKey] = kv;    <span class="hljs-keyword">return</span> kv;&#125;<span class="hljs-comment">// mmapID 是文件名，size 取默认值则为一个内存页的大小 4K，其余参数为 null</span>MMKV::<span class="hljs-built_in">MMKV</span>(<span class="hljs-type">const</span> string &amp;mmapID, <span class="hljs-type">int</span> size, MMKVMode mode, string *cryptKey, string *rootPath)    : <span class="hljs-built_in">m_mmapID</span>((mode &amp; MMKV_BACKUP) ? mmapID : <span class="hljs-built_in">mmapedKVKey</span>(mmapID, rootPath)) <span class="hljs-comment">// historically Android mistakenly use mmapKey as mmapID</span>    , <span class="hljs-built_in">m_path</span>(<span class="hljs-built_in">mappedKVPathWithID</span>(m_mmapID, mode, rootPath))    <span class="hljs-comment">// mmap 文件路径</span>    , <span class="hljs-built_in">m_crcPath</span>(<span class="hljs-built_in">crcPathWithID</span>(m_mmapID, mode, rootPath))    , <span class="hljs-built_in">m_dic</span>(<span class="hljs-literal">nullptr</span>)                                          <span class="hljs-comment">// 用以实现 Key-Value 映射的词典，后续会初始化</span>    , <span class="hljs-built_in">m_dicCrypt</span>(<span class="hljs-literal">nullptr</span>)    , <span class="hljs-built_in">m_file</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MemoryFile</span>(m_path, size, (mode &amp; MMKV_ASHMEM) ? MMFILE_TYPE_ASHMEM : MMFILE_TYPE_FILE))  <span class="hljs-comment">// mmap 内存区域（MemoryFile 上面介绍过，就是一块内存区域）</span>    , <span class="hljs-built_in">m_metaFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MemoryFile</span>(m_crcPath, DEFAULT_MMAP_SIZE, m_file-&gt;m_fileType))    , <span class="hljs-built_in">m_metaInfo</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MMKVMetaInfo</span>())    , <span class="hljs-built_in">m_crypter</span>(<span class="hljs-literal">nullptr</span>)    , <span class="hljs-built_in">m_lock</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadLock</span>())    , <span class="hljs-built_in">m_fileLock</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileLock</span>(m_metaFile-&gt;<span class="hljs-built_in">getFd</span>(), (mode &amp; MMKV_ASHMEM)))    , <span class="hljs-built_in">m_sharedProcessLock</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InterProcessLock</span>(m_fileLock, SharedLockType))    , <span class="hljs-built_in">m_exclusiveProcessLock</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InterProcessLock</span>(m_fileLock, ExclusiveLockType))    , <span class="hljs-built_in">m_isInterProcess</span>((mode &amp; MMKV_MULTI_PROCESS) != <span class="hljs-number">0</span> || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != <span class="hljs-number">0</span>) &#123;    m_actualSize = <span class="hljs-number">0</span>;    m_output = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// force use fcntl(), otherwise will conflict with MemoryFile::reloadFromFile()</span>    m_fileModeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileLock</span>(m_file-&gt;<span class="hljs-built_in">getFd</span>(), <span class="hljs-literal">true</span>);    m_sharedProcessModeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InterProcessLock</span>(m_fileModeLock, SharedLockType);    m_exclusiveProcessModeLock = <span class="hljs-literal">nullptr</span>;    &#123;        m_dic = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MMKVMap</span>();    &#125;    m_needLoadFromFile = <span class="hljs-literal">true</span>;    m_hasFullWriteback = <span class="hljs-literal">false</span>;    m_crcDigest = <span class="hljs-number">0</span>;    m_sharedProcessLock-&gt;m_enable = m_isInterProcess;    m_exclusiveProcessLock-&gt;m_enable = m_isInterProcess;    <span class="hljs-comment">// sensitive zone</span>    &#123;        <span class="hljs-built_in">SCOPED_LOCK</span>(m_sharedProcessLock);        <span class="hljs-built_in">loadFromFile</span>();    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MMKV::loadFromFile</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!m_file-&gt;<span class="hljs-built_in">isFileValid</span>()) &#123;          m_file-&gt;<span class="hljs-built_in">reloadFromFile</span>();  <span class="hljs-comment">// m_file 是 MemoryFile，上面介绍过，这里主要是进行 open file 和 mmap 映射内存区域</span>    &#125;    <span class="hljs-keyword">if</span> (!m_file-&gt;<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;file [%s] not valid&quot;</span>, m_path.<span class="hljs-built_in">c_str</span>());    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">bool</span> loadFromFile = <span class="hljs-literal">false</span>, needFullWriteback = <span class="hljs-literal">false</span>;        <span class="hljs-built_in">checkDataValid</span>(loadFromFile, needFullWriteback);        <span class="hljs-keyword">auto</span> ptr = (<span class="hljs-type">uint8_t</span> *) m_file-&gt;<span class="hljs-built_in">getMemory</span>();  <span class="hljs-comment">// mmap 映射内存区域地址</span>        <span class="hljs-keyword">if</span> (loadFromFile &amp;&amp; m_actualSize &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-function">MMBuffer <span class="hljs-title">inputBuffer</span><span class="hljs-params">(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy)</span></span>;            <span class="hljs-keyword">if</span> (m_crypter) &#123;                <span class="hljs-built_in">clearDictionary</span>(m_dicCrypt);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">clearDictionary</span>(m_dic);            &#125;            <span class="hljs-keyword">if</span> (needFullWriteback) &#123;                MiniPBCoder::<span class="hljs-built_in">greedyDecodeMap</span>(*m_dic, inputBuffer);            &#125; <span class="hljs-keyword">else</span> &#123;                MiniPBCoder::<span class="hljs-built_in">decodeMap</span>(*m_dic, inputBuffer);    <span class="hljs-comment">// 解析 mmap 文件，构建出词典结构以供后续查找使用</span>            &#125;            m_output = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class="hljs-built_in">getFileSize</span>() - Fixed32Size);            m_output-&gt;<span class="hljs-built_in">seek</span>(m_actualSize);    <span class="hljs-comment">// m_output 指向文件末尾，用以 append 键值对</span>            <span class="hljs-keyword">if</span> (needFullWriteback) &#123;                <span class="hljs-built_in">fullWriteback</span>();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// file not valid or empty, discard everything</span>            <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);            m_output = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CodedOutputData</span>(ptr + Fixed32Size, m_file-&gt;<span class="hljs-built_in">getFileSize</span>() - Fixed32Size);            <span class="hljs-keyword">if</span> (m_actualSize &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">writeActualSize</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, IncreaseSequence);                <span class="hljs-built_in">sync</span>(MMKV_SYNC);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">writeActualSize</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, KeepSequence);            &#125;        &#125;        <span class="hljs-keyword">auto</span> count = m_crypter ? m_dicCrypt-&gt;<span class="hljs-built_in">size</span>() : m_dic-&gt;<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">MMKVInfo</span>(<span class="hljs-string">&quot;loaded [%s] with %zu key-values&quot;</span>, m_mmapID.<span class="hljs-built_in">c_str</span>(), count);    &#125;    m_needLoadFromFile = <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniPBCoder::decodeMap</span><span class="hljs-params">(MMKVMap &amp;dic, <span class="hljs-type">const</span> MMBuffer &amp;oData, <span class="hljs-type">size_t</span> position)</span> </span>&#123;  <span class="hljs-comment">// position 默认为 0</span>    <span class="hljs-function">MiniPBCoder <span class="hljs-title">oCoder</span><span class="hljs-params">(&amp;oData)</span></span>;    oCoder.<span class="hljs-built_in">decodeOneMap</span>(dic, position, <span class="hljs-literal">false</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniPBCoder::decodeOneMap</span><span class="hljs-params">(MMKVMap &amp;dic, <span class="hljs-type">size_t</span> position, <span class="hljs-type">bool</span> greedy)</span> </span>&#123;  <span class="hljs-comment">// position == 0，greedy == false</span>    <span class="hljs-keyword">auto</span> block = [position, <span class="hljs-keyword">this</span>](MMKVMap &amp;dictionary) &#123;        <span class="hljs-keyword">if</span> (position) &#123;            m_inputData-&gt;<span class="hljs-built_in">seek</span>(position);        &#125; <span class="hljs-keyword">else</span> &#123;            m_inputData-&gt;<span class="hljs-built_in">readInt32</span>();    <span class="hljs-comment">// 文件头 32 bits ?</span>        &#125;        <span class="hljs-keyword">while</span> (!m_inputData-&gt;<span class="hljs-built_in">isAtEnd</span>()) &#123;                         <span class="hljs-comment">// 因为是从文件头扫描到文件尾，旧的键值对就会被新 append 的键值对替换 or 删除</span>            KeyValueHolder kvHolder;            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;key = m_inputData-&gt;<span class="hljs-built_in">readString</span>(kvHolder);  <span class="hljs-comment">// 读取 key 的内容为 string</span>            <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;                m_inputData-&gt;<span class="hljs-built_in">readData</span>(kvHolder);                  <span class="hljs-comment">// 读取 value size（没有读取 value data 哦）</span>                <span class="hljs-keyword">if</span> (kvHolder.valueSize &gt; <span class="hljs-number">0</span>) &#123;                     <span class="hljs-comment">// value size &gt; 0 说明是正常的键值对，添加到词典里</span>                    dictionary[key] = <span class="hljs-built_in">move</span>(kvHolder);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">auto</span> itr = dictionary.<span class="hljs-built_in">find</span>(key);              <span class="hljs-comment">// [Remove - 删除操作] 里介绍过删除就是 append 一个 data size 为 0 的键值对</span>                    <span class="hljs-keyword">if</span> (itr != dictionary.<span class="hljs-built_in">end</span>()) &#123;                <span class="hljs-comment">// 所以这里遇到 data size == 0 就表示要从词典里移除这个 key</span>                        dictionary.<span class="hljs-built_in">erase</span>(itr);                    &#125;                &#125;            &#125;        &#125;    &#125;;    <span class="hljs-keyword">if</span> (greedy) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-built_in">block</span>(dic);        &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;exception) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;%s&quot;</span>, exception.<span class="hljs-built_in">what</span>());        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">try</span> &#123;            MMKVMap tmpDic;            <span class="hljs-built_in">block</span>(tmpDic);            dic.<span class="hljs-built_in">swap</span>(tmpDic);        &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;exception) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;%s&quot;</span>, exception.<span class="hljs-built_in">what</span>());        &#125;    &#125;&#125;</code></pre></div><h1 id="内存区域与文件的大小关系"><a href="#内存区域与文件的大小关系" class="headerlink" title="内存区域与文件的大小关系"></a>内存区域与文件的大小关系</h1><p>情形一：一个文件的大小是 5000 字节，mmap 函数从一个文件的起始位置开始映射 5000 字节到虚拟内存中</p><p>分析：因为单位物理页面的大小是 4096 字节，虽然被映射的文件只有 5000 字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此 mmap 函数执行后实际映射到虚拟内存区域 8192 字节，5000~8191 的字节部分用零填充</p><ol><li>读/写前 5000 字节（0~4999）会返回操作文件内容</li><li>读字节 5000-8191 时结果全为 0，写 5000-8191 时进程不会报错，但是所写的内容不会写入原文件中</li><li>读/写 8192 以外的磁盘部分会返回一个 SIGSECV 错误</li></ol><p>情形二：一个文件的大小是 5000 字节，mmap 函数从一个文件的起始位置开始映射 15000 字节到虚拟内存中，即映射大小超过了原始文件的大小</p><p>分析：由于文件的大小是 5000 字节，和情形一一样其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出 5000 的部分不会体现在原文件中。由于程序要求映射 15000 字节而文件只占两个物理页，因此 8192~15000 都不能读写，操作时会返回异常</p><ol><li>进程可以正常读/写被映射的前 5000 字节，写操作的改动会在一定时间后反映在原文件中</li><li>对于 5000~8191 字节，进程可以进行读写过程不会报错。但是内容在写入前均为 0，另外写入后不会反映在文件中</li><li>对于 8192~14999 字节进程不能对其进行读写，会报 SIGBUS 错误</li><li>对于 15000 以外的字节进程不能对其读写，会引发 SIGSEGV 错误</li></ol><p>情形三：一个文件初始大小为 0，使用 mmap 操作映射了 1000*4K 的大小，即 1000 个物理页大约 4M 字节空间，mmap 返回指针 ptr</p><p>分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为 0，并没有合法的物理页对应，如同情形二一样会返回 SIGBUS 错误。但是如果每次操作 ptr 读写前先增加文件的大小，那么 ptr 在文件大小内部的操作就是合法的。</p><p>例如文件扩充 4096 字节，ptr 就能操作 <code>ptr ~ [ (char)ptr + 4095]</code> 的空间，只要文件扩充的范围在 1000 个物理页（映射范围）内 ptr 都可以对应操作相同的大小，这样方便随时扩充文件空间，随时写入文件，不造成空间浪费</p><p>总结：</p><ol><li>mmap 映射的内存地址空间肯定是内存页大小的整数倍</li><li>读写 mmap 映射的区域不能超过映射的大小和磁盘文件的大小</li><li>特殊情况：mmap 映射大小不为页大小的整数倍，系统会开辟一块页大小整数倍且满足映射大小的虚存空间，在这块空间内读写文件大小外的地址会返回 0 且不会同步到文件中</li></ol><h1 id="mmap-扩容"><a href="#mmap-扩容" class="headerlink" title="mmap 扩容"></a>mmap 扩容</h1><ol><li>计算扩容后的大小 newSize：每次将文件大小 double 一倍，直到能够放下新增的内容</li><li>上面说过 mmap 映射的最小单位是页，所以调整 newSize 以满足页大小的整数倍</li><li><code>ftruncate</code> 设置文件大小为 newSize 并将新增的扇区填充为 0（键值对是紧凑地一个个排列在一起，通过头部的 size 判断是否是有效的键值对）</li><li><code>munmap</code> 取消映射后进行重新映射，此时 <code>m_ptr</code> 指向上一次系统开辟的地址空间，mmap 时告诉（建议）系统从 <code>m_ptr</code> 指向的地址开始进行映射</li></ol><blockquote><p>If addr is NULL, then the kernel chooses the (page-aligned) address at which to create the mapping; this is the most portable method of creating a new mapping.<br>If addr is not NULL, then the kernel takes it as a hint about where to place the mapping.<br>on Linux, the kernel will pick a nearby page boundary (but always above or equal to the value specified by /proc/sys/vm/mmap_min_addr) and attempt to create the mapping there.<br>If another mapping already exists there, the kernel picks a new address that may or may not depend on the hint.  The address of the new mapping is returned as the result of the call.</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// since we use append mode, when -[setData: forKey:] many times, space may not be enough</span><span class="hljs-comment">// try a full rewrite to make space</span><span class="hljs-comment">// size 表示 mmap 内存区域需要有至少 size 大小的剩余空间，不是说整个内存区域要调整为 size 大小</span><span class="hljs-comment">// size 一般是新 append 的键值对的大小</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::ensureMemorySize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> newSize)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-built_in">MMKVWarning</span>(<span class="hljs-string">&quot;[%s] file not valid&quot;</span>, m_mmapID.<span class="hljs-built_in">c_str</span>());        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (newSize &gt;= m_output-&gt;<span class="hljs-built_in">spaceLeft</span>() || (m_crypter ? m_dicCrypt-&gt;<span class="hljs-built_in">empty</span>() : m_dic-&gt;<span class="hljs-built_in">empty</span>())) &#123;        <span class="hljs-comment">// try a full rewrite to make space</span>        <span class="hljs-keyword">auto</span> fileSize = m_file-&gt;<span class="hljs-built_in">getFileSize</span>();        <span class="hljs-keyword">auto</span> preparedData = m_crypter ? <span class="hljs-built_in">prepareEncode</span>(*m_dicCrypt) : <span class="hljs-built_in">prepareEncode</span>(*m_dic);        <span class="hljs-keyword">auto</span> sizeOfDic = preparedData.second;        <span class="hljs-type">size_t</span> lenNeeded = sizeOfDic + Fixed32Size + newSize;        <span class="hljs-type">size_t</span> dicCount = m_crypter ? m_dicCrypt-&gt;<span class="hljs-built_in">size</span>() : m_dic-&gt;<span class="hljs-built_in">size</span>();        <span class="hljs-type">size_t</span> avgItemSize = lenNeeded / std::<span class="hljs-built_in">max</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">1</span>, dicCount);        <span class="hljs-type">size_t</span> futureUsage = avgItemSize * std::<span class="hljs-built_in">max</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">8</span>, (dicCount + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        <span class="hljs-comment">// 1. no space for a full rewrite, double it</span>        <span class="hljs-comment">// 2. or space is not large enough for future usage, double it to avoid frequently full rewrite</span>        <span class="hljs-keyword">if</span> (lenNeeded &gt;= fileSize || (lenNeeded + futureUsage) &gt;= fileSize) &#123;            <span class="hljs-type">size_t</span> oldSize = fileSize;            <span class="hljs-keyword">do</span> &#123;                fileSize *= <span class="hljs-number">2</span>;            &#125; <span class="hljs-keyword">while</span> (lenNeeded + futureUsage &gt;= fileSize);    <span class="hljs-comment">// 计算出新的文件大小，每次 double 文件大小直到放得下新 append 的键值对</span>            <span class="hljs-comment">// if we can&#x27;t extend size, rollback to old state</span>            <span class="hljs-keyword">if</span> (!m_file-&gt;<span class="hljs-built_in">truncate</span>(fileSize)) &#123;                <span class="hljs-comment">// 真正的 mmap 扩容操作</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-comment">// check if we fail to make more space</span>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFileValid</span>()) &#123;                <span class="hljs-built_in">MMKVWarning</span>(<span class="hljs-string">&quot;[%s] file not valid&quot;</span>, m_mmapID.<span class="hljs-built_in">c_str</span>());                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">doFullWriteBack</span>(<span class="hljs-built_in">move</span>(preparedData), <span class="hljs-literal">nullptr</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MemoryFile::truncate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;    <span class="hljs-comment">// 将 mmap 扩容至 size 大小</span>    <span class="hljs-keyword">if</span> (!m_diskFile.<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (size == m_size) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">auto</span> oldSize = m_size;    m_size = size;    <span class="hljs-comment">// round up to (n * pagesize)</span>    <span class="hljs-keyword">if</span> (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != <span class="hljs-number">0</span>)) &#123;  <span class="hljs-comment">// 使文件大小刚好是内存页大小的整数倍，这是 mmap 的规定</span>        m_size = ((m_size / DEFAULT_MMAP_SIZE) + <span class="hljs-number">1</span>) * DEFAULT_MMAP_SIZE;    &#125;    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">ftruncate</span>(m_diskFile.m_fd, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">off_t</span>&gt;(m_size)) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 重新设置文件为扩容后的大小</span>        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to truncate [%s] to size %zu, %s&quot;</span>, m_diskFile.m_path.<span class="hljs-built_in">c_str</span>(), m_size, <span class="hljs-built_in">strerror</span>(errno));        m_size = oldSize;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (m_size &gt; oldSize) &#123;                                                 <span class="hljs-comment">// 扩容后的空白区域要填充 0，否则 reloadFromFile 时会加载到错误的键值对</span>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">zeroFillFile</span>(m_diskFile.m_fd, oldSize, m_size - oldSize)) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to zeroFile [%s] to size %zu, %s&quot;</span>, m_diskFile.m_path.<span class="hljs-built_in">c_str</span>(), m_size, <span class="hljs-built_in">strerror</span>(errno));            m_size = oldSize;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (m_ptr) &#123;                                                             <span class="hljs-comment">// 如果已经 mmap 过了则通过系统调用 munmap 取消映射</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">munmap</span>(m_ptr, oldSize) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to munmap [%s], %s&quot;</span>, m_diskFile.m_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">strerror</span>(errno));        &#125;    &#125;    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">mmap</span>();                                                       <span class="hljs-comment">// 重新执行 mmap 映射</span>    <span class="hljs-keyword">if</span> (!ret) &#123;        <span class="hljs-built_in">doCleanMemoryCache</span>(<span class="hljs-literal">true</span>);    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre></div><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h2><p>文件锁 <code>int flock(int fd, int operation);</code> 有以下操作：</p><ol><li><code>LOCK_SH</code> 获取共享锁，也叫读锁，同一文件描述符同一时间可以有多个进程持有此锁；Android 平台为 <code>F_RDLCK</code></li><li><code>LOCK_EX</code> 获取排它锁，也叫写锁，同一文件描述符同一时间只能有一个进程持有此锁；Android 平台为 <code>F_WRLCK</code></li><li>一个进程同一时间只能持有一种类型的锁：共享锁 or 排它锁，后续的 flock 调用会将已持有的锁转换为当前请求的锁类型</li><li><code>LOCK_UN</code> 归还当前进程已获得的锁</li><li><code>LOCK_NB</code> 一般情况下 flock 是阻塞的，此参数设置为非阻塞请求</li></ol><p>MMKV 实现的进程锁底层是基于文件锁 <code>flock</code> 的，并用两个计数器 <code>m_sharedLockCount</code> 和 <code>m_exclusiveLockCount</code> 实现重入和读写锁逻辑：</p><ol><li>如果 m_sharedLockCount == m_exclusiveLockCount == 0 说明进程没有获得锁，通过 <code>flock</code> 请求获得锁</li><li>从 <code>flock</code> 取得锁后将对应的 m_sharedLockCount 或 m_exclusiveLockCount 自增</li><li>由于进程已获得锁，后续的加锁操作只需将计数器自增，解锁操作只需将计数器自减直到归零时通过 LOCK_UN 归还底层的文件锁</li><li><code>flock</code> 实现的读写锁的含义跟我们通常理解的读写锁含义不太一样，所以需要用上面两个计数器来实现所需的读写锁逻辑（比如排它锁/写锁实际上可以包含读锁/读操作）</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterProcessLock</span> &#123;    <span class="hljs-comment">// MMKV 使用的进程锁，底层是文件锁</span>    FileLock *m_fileLock;    LockType m_lockType;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">InterProcessLock</span>(FileLock *fileLock, LockType lockType)        : <span class="hljs-built_in">m_fileLock</span>(fileLock), <span class="hljs-built_in">m_lockType</span>(lockType), <span class="hljs-built_in">m_enable</span>(<span class="hljs-literal">true</span>) &#123;        <span class="hljs-built_in">MMKV_ASSERT</span>(m_fileLock);    &#125;    <span class="hljs-type">bool</span> m_enable;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (m_enable) &#123;            m_fileLock-&gt;<span class="hljs-built_in">lock</span>(m_lockType);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">(<span class="hljs-type">bool</span> *tryAgain = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;        <span class="hljs-keyword">if</span> (m_enable) &#123;            <span class="hljs-keyword">return</span> m_fileLock-&gt;<span class="hljs-built_in">try_lock</span>(m_lockType, tryAgain);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (m_enable) &#123;            m_fileLock-&gt;<span class="hljs-built_in">unlock</span>(m_lockType);        &#125;    &#125;&#125;;<span class="hljs-comment">// FileLock 是对文件锁的包装</span>FileLock::<span class="hljs-built_in">FileLock</span>(MMKVFileHandle_t fd, <span class="hljs-type">bool</span> isAshmem)    <span class="hljs-comment">// using MMKVFileHandle_t = int;</span>    : <span class="hljs-built_in">m_fd</span>(fd), <span class="hljs-built_in">m_sharedLockCount</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_exclusiveLockCount</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_isAshmem</span>(isAshmem) &#123;    m_lockInfo.l_type = F_WRLCK;    m_lockInfo.l_start = <span class="hljs-number">0</span>;    m_lockInfo.l_whence = SEEK_SET;    m_lockInfo.l_len = <span class="hljs-number">0</span>;    m_lockInfo.l_pid = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 上锁逻辑 = flock + 计数器</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileLock::lock</span><span class="hljs-params">(LockType lockType)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">doLock</span>(lockType, <span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileLock::doLock</span><span class="hljs-params">(LockType lockType, <span class="hljs-type">bool</span> wait, <span class="hljs-type">bool</span> *tryAgain)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFileLockValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">bool</span> unLockFirstIfNeeded = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (lockType == SharedLockType) &#123;        <span class="hljs-comment">// don&#x27;t want shared-lock to break any existing locks</span>        <span class="hljs-keyword">if</span> (m_sharedLockCount &gt; <span class="hljs-number">0</span> || m_exclusiveLockCount &gt; <span class="hljs-number">0</span>) &#123;            m_sharedLockCount++;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// don&#x27;t want exclusive-lock to break existing exclusive-locks</span>        <span class="hljs-keyword">if</span> (m_exclusiveLockCount &gt; <span class="hljs-number">0</span>) &#123;            m_exclusiveLockCount++;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">// prevent deadlock</span>        <span class="hljs-keyword">if</span> (m_sharedLockCount &gt; <span class="hljs-number">0</span>) &#123;            unLockFirstIfNeeded = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">platformLock</span>(lockType, wait, unLockFirstIfNeeded, tryAgain);    <span class="hljs-keyword">if</span> (ret) &#123;        <span class="hljs-keyword">if</span> (lockType == SharedLockType) &#123;            m_sharedLockCount++;        &#125; <span class="hljs-keyword">else</span> &#123;            m_exclusiveLockCount++;        &#125;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileLock::platformLock</span><span class="hljs-params">(LockType lockType, <span class="hljs-type">bool</span> wait, <span class="hljs-type">bool</span> unLockFirstIfNeeded, <span class="hljs-type">bool</span> *tryAgain)</span> </span>&#123;<span class="hljs-meta">#    <span class="hljs-keyword">ifdef</span> MMKV_ANDROID</span>    <span class="hljs-keyword">if</span> (m_isAshmem) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ashmemLock</span>(lockType, wait, unLockFirstIfNeeded, tryAgain);    &#125;<span class="hljs-meta">#    <span class="hljs-keyword">endif</span></span>    <span class="hljs-keyword">auto</span> realLockType = <span class="hljs-built_in">LockType2FlockType</span>(lockType);    <span class="hljs-keyword">auto</span> cmd = wait ? realLockType : (realLockType | LOCK_NB);    <span class="hljs-keyword">if</span> (unLockFirstIfNeeded) &#123;        <span class="hljs-comment">// try lock</span>        <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">flock</span>(m_fd, realLockType | LOCK_NB);        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">// let&#x27;s be gentleman: unlock my shared-lock to prevent deadlock</span>        ret = <span class="hljs-built_in">flock</span>(m_fd, LOCK_UN);        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to try unlock first fd=%d, ret=%d, error:%s&quot;</span>, m_fd, ret, <span class="hljs-built_in">strerror</span>(errno));        &#125;    &#125;    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">flock</span>(m_fd, cmd);    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (tryAgain) &#123;            *tryAgain = (errno == EWOULDBLOCK);        &#125;        <span class="hljs-keyword">if</span> (wait) &#123;            <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to lock fd=%d, ret=%d, error:%s&quot;</span>, m_fd, ret, <span class="hljs-built_in">strerror</span>(errno));        &#125;        <span class="hljs-comment">// try recover my shared-lock</span>        <span class="hljs-keyword">if</span> (unLockFirstIfNeeded) &#123;            ret = <span class="hljs-built_in">flock</span>(m_fd, <span class="hljs-built_in">LockType2FlockType</span>(SharedLockType));            <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// let&#x27;s hope this never happen</span>                <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to recover shared-lock fd=%d, ret=%d, error:%s&quot;</span>, m_fd, ret, <span class="hljs-built_in">strerror</span>(errno));            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">short</span> <span class="hljs-title">LockType2FlockType</span><span class="hljs-params">(LockType lockType)</span> </span>&#123;    <span class="hljs-keyword">switch</span> (lockType) &#123;        <span class="hljs-keyword">case</span> SharedLockType:            <span class="hljs-keyword">return</span> F_RDLCK;        <span class="hljs-keyword">case</span> ExclusiveLockType:            <span class="hljs-keyword">return</span> F_WRLCK;    &#125;&#125;<span class="hljs-comment">// 解锁逻辑 = flock + 计数器</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileLock::unlock</span><span class="hljs-params">(LockType lockType)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFileLockValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">bool</span> unlockToSharedLock = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (lockType == SharedLockType) &#123;        <span class="hljs-keyword">if</span> (m_sharedLockCount == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">// don&#x27;t want shared-lock to break any existing locks</span>        <span class="hljs-keyword">if</span> (m_sharedLockCount &gt; <span class="hljs-number">1</span> || m_exclusiveLockCount &gt; <span class="hljs-number">0</span>) &#123;            m_sharedLockCount--;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (m_exclusiveLockCount == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (m_exclusiveLockCount &gt; <span class="hljs-number">1</span>) &#123;            m_exclusiveLockCount--;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">// restore shared-lock when all exclusive-locks are done</span>        <span class="hljs-keyword">if</span> (m_sharedLockCount &gt; <span class="hljs-number">0</span>) &#123;            unlockToSharedLock = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">platformUnLock</span>(unlockToSharedLock);    <span class="hljs-keyword">if</span> (ret) &#123;        <span class="hljs-keyword">if</span> (lockType == SharedLockType) &#123;            m_sharedLockCount--;        &#125; <span class="hljs-keyword">else</span> &#123;            m_exclusiveLockCount--;        &#125;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileLock::platformUnLock</span><span class="hljs-params">(<span class="hljs-type">bool</span> unlockToSharedLock)</span> </span>&#123;<span class="hljs-meta">#    <span class="hljs-keyword">ifdef</span> MMKV_ANDROID</span>    <span class="hljs-keyword">if</span> (m_isAshmem) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ashmemUnLock</span>(unlockToSharedLock);    &#125;<span class="hljs-meta">#    <span class="hljs-keyword">endif</span></span>    <span class="hljs-type">int</span> cmd = unlockToSharedLock ? LOCK_SH : LOCK_UN;    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">flock</span>(m_fd, cmd);    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">MMKVError</span>(<span class="hljs-string">&quot;fail to unlock fd=%d, ret=%d, error:%s&quot;</span>, m_fd, ret, <span class="hljs-built_in">strerror</span>(errno));        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><h2 id="meta-元信息"><a href="#meta-元信息" class="headerlink" title="meta - 元信息"></a>meta - 元信息</h2><p>除了保存键值对的数据文件（二进制的磁盘文件，mmap 映射进内存）和用以索引的词典（存在于进程内存空间内的数据结构 <code>std::unordered_map</code>），还有一些信息需要存储和进程间共享，这些信息以 <code>MMKVMetaInfo</code> 的内存结构排列如下</p><p>MMKVMetaInfo 是一个磁盘文件，与键值对数据文件处于同一目录且同名，但是以 <code>.crc</code> 结尾；元信息文件被 mmap 进内存后进行读写，<a href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B">下个章节</a> 会讲到 mmap 本身支持多进程，所以每个进程对元信息文件的修改都会被其他进程感知到</p><p><code>m_crcDigest</code> 是一个很重要的字段，它代表所有键值对数据的循环校验码，每当有修改操作发生时就会更新 size 和 crc 并将这两个字段的更新写入 mmap 映射区域，这样其他进程就知道数据发生了改变（进程间通讯的一个例子）</p><p>如果修改删除操作是在原来的位置操作，那么每次操作后都需要全量计算 crc，使得修改操作效率低下，好在章节 <a href="#update---%E4%BF%AE%E6%94%B9%E7%9A%84%E6%83%85%E5%86%B5">Update - 修改的情况</a> 说过实际上所有的修改删除操作都是以 append 一个相同 key 的键值对来实现的，这样计算 crc 时就只需做增量计算而不用全量计算</p><p>多个进程同时读写一个 mmap 映射区域，需要用锁进行同步，这里用到了 <a href="#%E8%BF%9B%E7%A8%8B%E9%94%81">进程锁</a> 里介绍的基于文件锁（meta file fd）的进程锁实现，<a href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B">下一章节</a> 有更详细地介绍这个锁的使用</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MMKVMetaInfo</span> &#123;    <span class="hljs-type">uint32_t</span> m_crcDigest = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 所有键值对的循环校验码，如果不一致说明有修改操作</span>    <span class="hljs-type">uint32_t</span> m_version = MMKVVersionSequence;    <span class="hljs-type">uint32_t</span> m_sequence = <span class="hljs-number">0</span>;    <span class="hljs-type">uint8_t</span> m_vector[AES_KEY_LEN] = &#123;&#125;;    <span class="hljs-type">uint32_t</span> m_actualSize = <span class="hljs-number">0</span>;    <span class="hljs-comment">// confirmed info: it&#x27;s been synced to file</span>    <span class="hljs-keyword">struct</span> &#123;        <span class="hljs-type">uint32_t</span> lastActualSize = <span class="hljs-number">0</span>;        <span class="hljs-type">uint32_t</span> lastCRCDigest = <span class="hljs-number">0</span>;        <span class="hljs-type">uint32_t</span> _reserved[<span class="hljs-number">16</span>] = &#123;&#125;;    &#125; m_lastConfirmedMetaInfo;    <span class="hljs-comment">// meta file 被 mmap 进物理内存以供多进程读写</span>    <span class="hljs-comment">// 下面是读写 mmap 映射区域的方法</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-built_in">MMKV_ASSERT</span>(ptr);        <span class="hljs-built_in">memcpy</span>(ptr, <span class="hljs-keyword">this</span>, <span class="hljs-built_in">sizeof</span>(MMKVMetaInfo));    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writeCRCAndActualSizeOnly</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-built_in">MMKV_ASSERT</span>(ptr);        <span class="hljs-keyword">auto</span> other = (MMKVMetaInfo *) ptr;        other-&gt;m_crcDigest = m_crcDigest;        other-&gt;m_actualSize = m_actualSize;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr)</span> </span>&#123;        <span class="hljs-built_in">MMKV_ASSERT</span>(ptr);        <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>, ptr, <span class="hljs-built_in">sizeof</span>(MMKVMetaInfo));    &#125;&#125;;<span class="hljs-comment">// 每当有修改操作时（CURD 都是新增键值对），就会更新循环校验码</span><span class="hljs-function">KVHolderRet_t</span><span class="hljs-function"><span class="hljs-title">MMKV::doAppendDataWithKey</span><span class="hljs-params">(<span class="hljs-type">const</span> MMBuffer &amp;data, <span class="hljs-type">const</span> MMBuffer &amp;keyData, <span class="hljs-type">bool</span> isDataHolder, <span class="hljs-type">uint32_t</span> originKeyLength)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-built_in">SCOPED_LOCK</span>(m_exclusiveProcessLock);    <span class="hljs-comment">// 进程间的排它锁/写锁</span>    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">auto</span> ptr = (<span class="hljs-type">uint8_t</span> *) m_file-&gt;<span class="hljs-built_in">getMemory</span>() + Fixed32Size + m_actualSize;    m_actualSize += size;    <span class="hljs-built_in">updateCRCDigest</span>(ptr, size);    <span class="hljs-comment">// [ptr, ptr + size] 是新增键值对所在的内存地址区间</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">true</span>, <span class="hljs-built_in">KeyValueHolder</span>(originKeyLength, valueLength, offset));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MMKV::updateCRCDigest</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *ptr, <span class="hljs-type">size_t</span> length)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    m_crcDigest = (<span class="hljs-type">uint32_t</span>) <span class="hljs-built_in">CRC32</span>(m_crcDigest, ptr, (<span class="hljs-type">uint32_t</span>) length);    <span class="hljs-comment">// 利用 ZLIB 计算 CRC</span>    <span class="hljs-built_in">writeActualSize</span>(m_actualSize, m_crcDigest, <span class="hljs-literal">nullptr</span>, KeepSequence);      <span class="hljs-comment">// 更新 size 和 crc（m_actualSize 是所有键值对的总大小）</span>&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MMKV::writeActualSize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">uint32_t</span> crcDigest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *iv, <span class="hljs-type">bool</span> increaseSequence)</span> </span>&#123;    <span class="hljs-comment">// backward compatibility</span>    <span class="hljs-built_in">oldStyleWriteActualSize</span>(size);    <span class="hljs-keyword">if</span> (!m_metaFile-&gt;<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">bool</span> needsFullWrite = <span class="hljs-literal">false</span>;    m_actualSize = size;    m_metaInfo-&gt;m_actualSize = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(size);  <span class="hljs-comment">// 更新 size 和 crc</span>    m_crcDigest = crcDigest;    m_metaInfo-&gt;m_crcDigest = crcDigest;    <span class="hljs-keyword">if</span> (m_metaInfo-&gt;m_version &lt; MMKVVersionSequence) &#123;        m_metaInfo-&gt;m_version = MMKVVersionSequence;        needsFullWrite = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(increaseSequence)) &#123;        m_metaInfo-&gt;m_sequence++;        m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastActualSize = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(size);        m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastCRCDigest = crcDigest;        <span class="hljs-keyword">if</span> (m_metaInfo-&gt;m_version &lt; MMKVVersionActualSize) &#123;            m_metaInfo-&gt;m_version = MMKVVersionActualSize;        &#125;        needsFullWrite = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(needsFullWrite)) &#123;        m_metaInfo-&gt;<span class="hljs-built_in">write</span>(m_metaFile-&gt;<span class="hljs-built_in">getMemory</span>());    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 将 size 和 crc 更新至 meta file mmap 映射区域</span>        <span class="hljs-comment">// mmap 本身是支持多进程的，那么其他进程就能感知到 crc 变了</span>        m_metaInfo-&gt;<span class="hljs-built_in">writeCRCAndActualSizeOnly</span>(m_metaFile-&gt;<span class="hljs-built_in">getMemory</span>());    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h2 id="实现多进程"><a href="#实现多进程" class="headerlink" title="实现多进程"></a>实现多进程</h2><p>mmap 自身是支持多进程的，<code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code> 里 <code>flags</code> 有个标志位 <code>MAP_SHARED</code>：</p><ol><li><p>正如 <a href="#mmap">mmap 章节</a> 所说，读写进程虚存里的映射区域 -&gt; 发生缺页，分配并关联一片物理页，从对应的磁盘地址里读取内容至这篇物理页 -&gt; 返回 or 修改物理页的内容</p></li><li><p>所有读写相同映射区间的进程，实际上都关联了相同的物理页，也即它们都在读写相同的物理内存地址，故一个进程对映射区域的修改能够被其他进程的读操作感知到</p></li><li><p>对于以文件作为 backed 的 mmap，所有修改还会同步至文件</p></li></ol><blockquote><p>MAP_SHARED<br>Share this mapping.  Updates to the mapping are visible to other processes mapping the same region, and (in the case of file-backed mappings) are carried through to the underlying file. (To precisely control when updates are carried through to the underlying file requires the use of msync(2).)</p></blockquote><p>也就说如果有进程修改了键值对 mmap 映射区域，的确所有进程都能读到最新的数据，但 MMKV 是通过进程内的数据结构 <code>std::unordered_map</code> 作为索引来搜索键值对的，这个 map 并不会在进程间同步，导致搜索出来的总是旧值</p><p>于是需要 <a href="#meta---%E5%85%83%E4%BF%A1%E6%81%AF">meta - 元信息</a>，它是与键值对数据文件同目录的、以 <code>.crc</code> 结尾的文件，并 mmap 映射进内存；每当 CURD 操作完成时更新它的 crc 字段，每当 CURD 操作前通过 <code>checkLoadData</code> 检查此文件的 crc 是否与进程内的 crc 一致，不一致说明有修改操作发生，需要重新构建索引</p><p>与此同时，在多进程模式下启用读锁 <code>m_sharedProcessLock</code> 和写锁 <code>m_exclusiveProcessLock</code>，所有的 CURD 操作都用 <a href="#%E8%BF%9B%E7%A8%8B%E9%94%81">进程锁</a> 上锁保证读写操作的同步（也可以认为是一种进程间通讯的方式）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> SINGLE_PROCESS_MODE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;  <span class="hljs-comment">// 单进程模式</span><span class="hljs-type">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MULTI_PROCESS_MODE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;   <span class="hljs-comment">// 多进程模式</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> MMKV <span class="hljs-title">mmkvWithID</span><span class="hljs-params">(String mmapID, <span class="hljs-type">int</span> mode, @Nullable String cryptKey, String rootPath)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">private</span> native <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">getMMKVWithID</span><span class="hljs-params">(String mmapID, <span class="hljs-type">int</span> mode, @Nullable String cryptKey, @Nullable String rootPath)</span></span>;<span class="hljs-function">MMKV_JNI jlong <span class="hljs-title">getMMKVWithID</span><span class="hljs-params">(JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring rootPath)</span></span><span class="hljs-function"></span><span class="hljs-function">MMKV *<span class="hljs-title">MMKV::mmkvWithID</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;mmapID, <span class="hljs-type">int</span> size, MMKVMode mode, string *cryptKey, string *rootPath)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">MMKV::MMKV</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;mmapID, <span class="hljs-type">int</span> size, MMKVMode mode, string *cryptKey, string *rootPath)</span></span><span class="hljs-function">    <span class="hljs-comment">// ...</span></span><span class="hljs-function">    , <span class="hljs-title">m_metaFile</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MemoryFile(m_crcPath, DEFAULT_MMAP_SIZE, m_file-&gt;m_fileType))</span></span><span class="hljs-function">    , <span class="hljs-title">m_metaInfo</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MMKVMetaInfo())</span></span><span class="hljs-function">    , <span class="hljs-title">m_crypter</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span><span class="hljs-function">    , <span class="hljs-title">m_lock</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ThreadLock())</span></span><span class="hljs-function">    , <span class="hljs-title">m_fileLock</span><span class="hljs-params">(<span class="hljs-keyword">new</span> FileLock(m_metaFile-&gt;getFd(), (mode &amp; MMKV_ASHMEM)))</span>                               <span class="hljs-comment">// 对 meta file 上文件锁</span></span><span class="hljs-function">    , <span class="hljs-title">m_sharedProcessLock</span><span class="hljs-params">(<span class="hljs-keyword">new</span> InterProcessLock(m_fileLock, SharedLockType))</span>                             <span class="hljs-comment">// 上面介绍过这是基于文件锁的进程锁</span></span><span class="hljs-function">    , <span class="hljs-title">m_exclusiveProcessLock</span><span class="hljs-params">(<span class="hljs-keyword">new</span> InterProcessLock(m_fileLock, ExclusiveLockType))</span>                       <span class="hljs-comment">// 用以在多进程模式下同步 meta file 的读写操作</span></span><span class="hljs-function">    , <span class="hljs-title">m_isInterProcess</span><span class="hljs-params">((mode &amp; MMKV_MULTI_PROCESS) != <span class="hljs-number">0</span> || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != <span class="hljs-number">0</span>)</span> </span>&#123;  <span class="hljs-comment">// 多进程模式下置真</span>    m_actualSize = <span class="hljs-number">0</span>;    m_output = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// force use fcntl(), otherwise will conflict with MemoryFile::reloadFromFile()</span>    m_fileModeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileLock</span>(m_file-&gt;<span class="hljs-built_in">getFd</span>(), <span class="hljs-literal">true</span>);    m_sharedProcessModeLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InterProcessLock</span>(m_fileModeLock, SharedLockType);    m_exclusiveProcessModeLock = <span class="hljs-literal">nullptr</span>;    m_dic = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MMKVMap</span>();    m_needLoadFromFile = <span class="hljs-literal">true</span>;    m_hasFullWriteback = <span class="hljs-literal">false</span>;    m_crcDigest = <span class="hljs-number">0</span>;    m_sharedProcessLock-&gt;m_enable = m_isInterProcess;    <span class="hljs-comment">// 多进程模式下才启用读锁和写锁（meta file）</span>    m_exclusiveProcessLock-&gt;m_enable = m_isInterProcess;    <span class="hljs-comment">// sensitive zone</span>    &#123;        <span class="hljs-built_in">SCOPED_LOCK</span>(m_sharedProcessLock);        <span class="hljs-built_in">loadFromFile</span>();    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MMKV::checkLoadData</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-comment">// 所有 CURD 操作前都会检查 crc 是否有改变（CURD 操作后也会更新 crc）</span>    <span class="hljs-keyword">if</span> (m_needLoadFromFile) &#123;    <span class="hljs-comment">// 一般情况下为 false，特殊情况比如 clearMemoryCache 时才置真</span>        <span class="hljs-built_in">SCOPED_LOCK</span>(m_sharedProcessLock);        m_needLoadFromFile = <span class="hljs-literal">false</span>;        <span class="hljs-built_in">loadFromFile</span>();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (!m_isInterProcess) &#123;    <span class="hljs-comment">// 多进程模式下置真</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (!m_metaFile-&gt;<span class="hljs-built_in">isFileValid</span>()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">SCOPED_LOCK</span>(m_sharedProcessLock);    <span class="hljs-comment">// 获得读锁，读取 meta file</span>    MMKVMetaInfo metaInfo;    metaInfo.<span class="hljs-built_in">read</span>(m_metaFile-&gt;<span class="hljs-built_in">getMemory</span>());    <span class="hljs-keyword">if</span> (m_metaInfo-&gt;m_sequence != metaInfo.m_sequence) &#123;        <span class="hljs-built_in">MMKVInfo</span>(<span class="hljs-string">&quot;[%s] oldSeq %u, newSeq %u&quot;</span>, m_mmapID.<span class="hljs-built_in">c_str</span>(), m_metaInfo-&gt;m_sequence, metaInfo.m_sequence);        <span class="hljs-built_in">SCOPED_LOCK</span>(m_sharedProcessLock);        <span class="hljs-built_in">clearMemoryCache</span>();        <span class="hljs-built_in">loadFromFile</span>();        <span class="hljs-built_in">notifyContentChanged</span>();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m_metaInfo-&gt;m_crcDigest != metaInfo.m_crcDigest) &#123;  <span class="hljs-comment">// CURD 操作导致 crc 不一致</span>        <span class="hljs-built_in">MMKVDebug</span>(<span class="hljs-string">&quot;[%s] oldCrc %u, newCrc %u, new actualSize %u&quot;</span>, m_mmapID.<span class="hljs-built_in">c_str</span>(), m_metaInfo-&gt;m_crcDigest,                  metaInfo.m_crcDigest, metaInfo.m_actualSize);        <span class="hljs-built_in">SCOPED_LOCK</span>(m_sharedProcessLock);        <span class="hljs-type">size_t</span> fileSize = m_file-&gt;<span class="hljs-built_in">getActualFileSize</span>();  <span class="hljs-comment">// 如果文件大小不一致说明有扩容（或者 crc 校验不通过导致文件被清空）</span>        <span class="hljs-keyword">if</span> (m_file-&gt;<span class="hljs-built_in">getFileSize</span>() != fileSize) &#123;        <span class="hljs-comment">// 此时需要重新 mmap 并重新构建索引</span>            <span class="hljs-built_in">MMKVInfo</span>(<span class="hljs-string">&quot;file size has changed [%s] from %zu to %zu&quot;</span>, m_mmapID.<span class="hljs-built_in">c_str</span>(), m_file-&gt;<span class="hljs-built_in">getFileSize</span>(), fileSize);            <span class="hljs-built_in">clearMemoryCache</span>();            <span class="hljs-built_in">loadFromFile</span>();        &#125; <span class="hljs-keyword">else</span> &#123;                                        <span class="hljs-comment">// 大小不变，因为所有修改操作都是通过 append 相同 key 值的键值对实现的</span>            <span class="hljs-built_in">partialLoadFromFile</span>();                      <span class="hljs-comment">// 这里只需要解析新加的键值对即可</span>        &#125;        <span class="hljs-built_in">notifyContentChanged</span>();    &#125;&#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析 mmap：是什么 为什么 怎么用 - Alan Hu - 博客园</a></p></li><li><p><a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Protocol Buffers - Base 128 Varints</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mmap</tag>
      
      <tag>SharedPreferences</tag>
      
      <tag>SP</tag>
      
      <tag>MMKV</tag>
      
      <tag>Jetpack-DataStore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 SharedPreferences：架构、缺点和优化</title>
    <link href="/2022/05/16/sharedpreferences/"/>
    <url>/2022/05/16/sharedpreferences/</url>
    
    <content type="html"><![CDATA[<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><ul><li><code>apply</code> 和 <code>commit</code> 有何区别？</li><li>SharedPreferences 是线程安全的吗？它是如何保证线程安全的？</li><li>SharedPreferences 是进程安全的吗？</li><li>数据丢失时，其最终的屏障 —— 文件备份机制是如何实现的？</li><li>如何实现进程安全的 SharedPreferences</li><li>SharedPreferences 导致 ANR 的原因</li></ul><h1 id="从磁盘加载"><a href="#从磁盘加载" class="headerlink" title="从磁盘加载"></a>从磁盘加载</h1><blockquote><p>以下代码基于 Android 31</p></blockquote><p>SharedPreferences 本质上是：</p><ul><li>在磁盘上是一个 XML 文件：<code>/&#123;app internal data dir&#125;/shared_prefs/&#123;name&#125;.xml</code></li><li>在内存中是一个 <code>Map&lt;String, Object&gt;</code></li></ul><p>构造 SharedPreferences 实例时会立即起一个线程来将磁盘上的 xml 文件加载并解析为内存中的 Map，在加载任务完成前，会通过 <code>mLock</code> 阻塞所有的 get/set 操作</p><p>所以在主线程上操作 SharedPreferences 是有可能阻塞主线程导致 ANR 的</p><div class="code-wrapper"><pre><code class="hljs java">SharedPreferencesImpl(File file, <span class="hljs-type">int</span> mode) &#123;    mFile = file;    mBackupFile = makeBackupFile(file);    mMode = mode;    mLoaded = <span class="hljs-literal">false</span>;    mMap = <span class="hljs-literal">null</span>;    mThrowable = <span class="hljs-literal">null</span>;    startLoadFromDisk();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startLoadFromDisk</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        mLoaded = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;SharedPreferencesImpl-load&quot;</span>) &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            loadFromDisk();        &#125;    &#125;.start();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFromDisk</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        <span class="hljs-keyword">if</span> (mLoaded) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (mBackupFile.exists()) &#123;            mFile.delete();            mBackupFile.renameTo(mFile);        &#125;    &#125;    <span class="hljs-comment">// Debugging</span>    <span class="hljs-keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;        Log.w(TAG, <span class="hljs-string">&quot;Attempt to read preferences file &quot;</span> + mFile + <span class="hljs-string">&quot; without permission&quot;</span>);    &#125;    Map&lt;String, Object&gt; map = <span class="hljs-literal">null</span>;    <span class="hljs-type">StructStat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">try</span> &#123;        stat = Os.stat(mFile.getPath());        <span class="hljs-keyword">if</span> (mFile.canRead()) &#123;            <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">try</span> &#123;                str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(mFile), <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>);                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                Log.w(TAG, <span class="hljs-string">&quot;Cannot read &quot;</span> + mFile.getAbsolutePath(), e);            &#125; <span class="hljs-keyword">finally</span> &#123;                IoUtils.closeQuietly(str);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (ErrnoException e) &#123;        <span class="hljs-comment">// An errno exception means the stat failed. Treat as empty/non-existing by</span>        <span class="hljs-comment">// ignoring.</span>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        thrown = t;    &#125;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        mLoaded = <span class="hljs-literal">true</span>;        mThrowable = thrown;        <span class="hljs-comment">// It&#x27;s important that we always signal waiters, even if we&#x27;ll make</span>        <span class="hljs-comment">// them fail with an exception. The try-finally is pretty wide, but</span>        <span class="hljs-comment">// better safe than sorry.</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (thrown == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;                    mMap = map;                    mStatTimestamp = stat.st_mtim;                    mStatSize = stat.st_size;                &#125; <span class="hljs-keyword">else</span> &#123;                    mMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();                &#125;            &#125;            <span class="hljs-comment">// In case of a thrown exception, we retain the old map. That allows</span>            <span class="hljs-comment">// any open editors to commit and store updates.</span>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            mThrowable = t;        &#125; <span class="hljs-keyword">finally</span> &#123;            mLock.notifyAll();        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getString</span><span class="hljs-params">(String key, <span class="hljs-meta">@Nullable</span> String defValue)</span> &#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        awaitLoadedLocked();        <span class="hljs-type">String</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> (String)mMap.get(key);        <span class="hljs-keyword">return</span> v != <span class="hljs-literal">null</span> ? v : defValue;    &#125;&#125;<span class="hljs-keyword">public</span> Editor <span class="hljs-title function_">edit</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;        awaitLoadedLocked();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EditorImpl</span>();&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitLoadedLocked</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (!mLoaded) &#123;        <span class="hljs-comment">// Raise an explicit StrictMode onReadFromDisk for this</span>        <span class="hljs-comment">// thread, since the real read will be in a different</span>        <span class="hljs-comment">// thread and otherwise ignored by StrictMode.</span>        BlockGuard.getThreadPolicy().onReadFromDisk();    &#125;    <span class="hljs-keyword">while</span> (!mLoaded) &#123;        <span class="hljs-keyword">try</span> &#123;            mLock.wait();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException unused) &#123;        &#125;    &#125;    <span class="hljs-keyword">if</span> (mThrowable != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(mThrowable);    &#125;&#125;</code></pre></div><h1 id="编辑器-Editor"><a href="#编辑器-Editor" class="headerlink" title="编辑器 Editor"></a>编辑器 Editor</h1><ul><li><code>SharedPreferences.Editor</code> 是线程安全的</li><li>编辑的过程其实是在记录编辑操作，在最终 <code>apply/commit</code> 之前都不会影响内存和磁盘里的数据</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Editor <span class="hljs-title function_">putString</span><span class="hljs-params">(String key, <span class="hljs-meta">@Nullable</span> String value)</span> &#123;    <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;        mModified.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;&#125;<span class="hljs-keyword">public</span> Editor <span class="hljs-title function_">putInt</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> value)</span> &#123;    <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;        mModified.put(key, value);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;&#125;<span class="hljs-keyword">public</span> Editor <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> &#123;    <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;        mModified.put(key, <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;&#125;<span class="hljs-keyword">public</span> Editor <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;        mClear = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;&#125;</code></pre></div><p>注意 <code>Editor.clear()</code> 操作是清空 SharedPreferences 里的数据，具体来说是清空已提交的数据，在 Editor 里尚未提交的数据并不会被清空</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MemoryCommitResult <span class="hljs-title function_">commitToMemory</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">changesMade</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (mClear) &#123;            <span class="hljs-keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;                changesMade = <span class="hljs-literal">true</span>;                mapToWriteToDisk.clear();            &#125;            keysCleared = <span class="hljs-literal">true</span>;            mClear = <span class="hljs-literal">false</span>;        &#125;                <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;            <span class="hljs-comment">// ...</span>        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">useAppContext</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> appContext = InstrumentationRegistry.getInstrumentation().targetContext    <span class="hljs-keyword">val</span> sp = appContext.getSharedPreferences(<span class="hljs-string">&quot;test&quot;</span>, Context.MODE_PRIVATE)    sp.edit &#123; clear() &#125;    sp.edit &#123;        putBoolean(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">true</span>)        putFloat(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-number">0.3f</span>)        putString(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>)    &#125;    sp.edit &#123;        putInt(<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-number">99</span>)        putLong(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-number">999L</span>)        clear()    &#125;    Log.d(<span class="hljs-string">&quot;cyrus&quot;</span>, sp.all.map &#123; <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;it.key&#125;</span> - <span class="hljs-subst">$&#123;it.value&#125;</span>&quot;</span> &#125;.joinToString())    <span class="hljs-comment">// l - 999, i - 99</span>    <span class="hljs-comment">// 虽然 clear 操作排在最后面但它并不会清空 i 和 l</span>&#125;</code></pre></div><h1 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h1><p>上面说过 SharedPreferences 本质上是内存中的 <code>Map</code> 对象和磁盘上的 <code>XML 文件</code>，所以提交一个修改就会产生二阶段提交：提交到内存（<code>commitToMemory</code>）和提交到磁盘（<code>writeToFile</code>）</p><h2 id="commitToMemory"><a href="#commitToMemory" class="headerlink" title="commitToMemory"></a>commitToMemory</h2><ul><li>提交到内存也就是把修改操作应用到 <code>mMap</code>，由 <code>mLock</code> 上锁</li><li>对应地内存的版本号（<code>mCurrentMemoryStateGeneration</code>）会自增</li><li>在提交至内存后，尚未提交到磁盘前，<code>mDiskWritesInFlight</code> 会自增，也就说 mDiskWritesInFlight &gt; 0 表示有修改正在等待提交到磁盘</li><li>提交至内存的过程中是直接修改 <code>mMap</code> 的，后续提交至磁盘的过程使用了 <code>MemoryCommitResult</code>，它也是直接引用 <code>mMap</code> 的，但是提交至磁盘的操作只对 <code>mWritingToDiskLock</code> 上锁，这就造成对象的多线程读写问题：一个线程拿到锁 <code>mLock</code> 读写 <code>mMap</code> 同时另一线程拿到 <code>mWritingToDiskLock</code> 读 <code>mMap</code>，所以当 mDiskWritesInFlight &gt; 0 时得将 <code>mMap</code> 复制一份使用，也就是写时复制的思想（<code>copy on write</code>）如 <code>CopyOnWriteArrayList</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MemoryCommitResult <span class="hljs-title function_">commitToMemory</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">long</span> memoryStateGeneration;    List&lt;String&gt; keysModified = <span class="hljs-literal">null</span>;    Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="hljs-literal">null</span>;    Map&lt;String, Object&gt; mapToWriteToDisk;    <span class="hljs-keyword">synchronized</span> (SharedPreferencesImpl.<span class="hljs-built_in">this</span>.mLock) &#123;        <span class="hljs-comment">// We optimistically don&#x27;t make a deep copy until</span>        <span class="hljs-comment">// a memory commit comes in when we&#x27;re already</span>        <span class="hljs-comment">// writing to disk.</span>        <span class="hljs-keyword">if</span> (mDiskWritesInFlight &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// We can&#x27;t modify our mMap as a currently</span>            <span class="hljs-comment">// in-flight write owns it.  Clone it before</span>            <span class="hljs-comment">// modifying it.</span>            <span class="hljs-comment">// noinspection unchecked</span>            mMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;(mMap);        &#125;        mapToWriteToDisk = mMap;        mDiskWritesInFlight++;        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasListeners</span> <span class="hljs-operator">=</span> mListeners.size() &gt; <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (hasListeners) &#123;            keysModified = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();            listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());        &#125;        <span class="hljs-keyword">synchronized</span> (mEditorLock) &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">changesMade</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (mClear) &#123;                <span class="hljs-keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;                    changesMade = <span class="hljs-literal">true</span>;                    mapToWriteToDisk.clear();                &#125;                mClear = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;                <span class="hljs-type">String</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> e.getKey();                <span class="hljs-type">Object</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> e.getValue();                <span class="hljs-comment">// &quot;this&quot; is the magic value for a removal mutation. In addition,</span>                <span class="hljs-comment">// setting a value to &quot;null&quot; for a given key is specified to be</span>                <span class="hljs-comment">// equivalent to calling remove on that key.</span>                <span class="hljs-keyword">if</span> (v == <span class="hljs-built_in">this</span> || v == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    mapToWriteToDisk.remove(k);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;                        <span class="hljs-type">Object</span> <span class="hljs-variable">existingValue</span> <span class="hljs-operator">=</span> mapToWriteToDisk.get(k);                        <span class="hljs-keyword">if</span> (existingValue != <span class="hljs-literal">null</span> &amp;&amp; existingValue.equals(v)) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                    &#125;                    mapToWriteToDisk.put(k, v);                &#125;                changesMade = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span> (hasListeners) &#123;                    keysModified.add(k);                &#125;            &#125;            mModified.clear();            <span class="hljs-keyword">if</span> (changesMade) &#123;                mCurrentMemoryStateGeneration++;            &#125;            memoryStateGeneration = mCurrentMemoryStateGeneration;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryCommitResult</span>(memoryStateGeneration, keysModified, listeners,            mapToWriteToDisk);&#125;</code></pre></div><h2 id="writeToFile"><a href="#writeToFile" class="headerlink" title="writeToFile"></a>writeToFile</h2><ul><li><p><code>isFromSyncCommit</code>，true - 来自 <code>commit</code>，false - 来自 <code>apply</code></p></li><li><p>使用 backup file 策略确保文件写操作的完整性、原子性：</p><ul><li><p>文件写之前将 XML 文件 <code>mFile</code> 剪切到 <code>mBackupFile</code>，写完将 mBackupFile 删除</p></li><li><p>文件写之前发现有 mBackupFile 说明上一次的写操作没有正确结束，mFile 是不正确的，删掉 mFile 即可（当前提交至磁盘的内容是最新的，不用管之前的版本）</p></li><li><p>第一次打开文件 <code>loadFromDisk</code> 时发现 mBackupFile 存在，说明上一次的写操作是不正确的（比如在写的过程中 killed），那么 mFile 即是不正确的（删掉），要以 mBackupFile 为准（将其 rename to mFile）</p></li></ul></li><li><p>使用 <code>mDiskStateGeneration</code> 标识 XML 文件的版本，文件写操作完成后会将其置为 <code>MemoryCommitResult.memoryStateGeneration</code>，也即内存版本号和磁盘版本号最终会保持一致，那么：</p><ul><li><p>因为是先提交至内存再提交至磁盘，磁盘版本号 mDiskStateGeneration 肯定是小于等于内存版本号的 mcr.memoryStateGeneration，否则就是异常状态了</p></li><li><p>如果是 apply，两个阶段的提交逻辑上是异步的，只有当即将提交到磁盘的 snapshot 的版本是当前内存的最新的版本时（<code>mCurrentMemoryStateGeneration == mcr.memoryStateGeneration</code>）才写入到文件，否则等待后续的文件写任务将最新内存版本写入文件即可</p></li><li><p>如果是 commit，两个阶段的提交逻辑上是同步的，每个提交到内存的版本的 snapshot 都需要同步到磁盘</p></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">writeToDiskRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">synchronized</span> (mWritingToDiskLock) &#123;                writeToFile(mcr, isFromSyncCommit);            &#125;            <span class="hljs-keyword">synchronized</span> (mLock) &#123;                mDiskWritesInFlight--;            &#125;            <span class="hljs-keyword">if</span> (postWriteRunnable != <span class="hljs-literal">null</span>) &#123;                postWriteRunnable.run();            &#125;        &#125;    &#125;;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(MemoryCommitResult mcr, <span class="hljs-type">boolean</span> isFromSyncCommit)</span> &#123;    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">existsTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">backupExistsTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">outputStreamCreateTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">writeTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">fsyncTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">setPermTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">fstatTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">deleteTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (DEBUG) &#123;        startTime = System.currentTimeMillis();    &#125;    <span class="hljs-type">boolean</span> <span class="hljs-variable">fileExists</span> <span class="hljs-operator">=</span> mFile.exists();    <span class="hljs-keyword">if</span> (DEBUG) &#123;        existsTime = System.currentTimeMillis();        <span class="hljs-comment">// Might not be set, hence init them to a default value</span>        backupExistsTime = existsTime;    &#125;    <span class="hljs-comment">// Rename the current file so it may be used as a backup during the next read</span>    <span class="hljs-keyword">if</span> (fileExists) &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">needsWrite</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// Only need to write if the disk state is older than this commit</span>        <span class="hljs-keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;            <span class="hljs-keyword">if</span> (isFromSyncCommit) &#123;                needsWrite = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">synchronized</span> (mLock) &#123;                    <span class="hljs-comment">// No need to persist intermediate states. Just wait for the latest state to</span>                    <span class="hljs-comment">// be persisted.</span>                    <span class="hljs-keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;                        needsWrite = <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (!needsWrite) &#123;            mcr.setDiskWriteResult(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">boolean</span> <span class="hljs-variable">backupFileExists</span> <span class="hljs-operator">=</span> mBackupFile.exists();        <span class="hljs-keyword">if</span> (DEBUG) &#123;            backupExistsTime = System.currentTimeMillis();        &#125;        <span class="hljs-keyword">if</span> (!backupFileExists) &#123;            <span class="hljs-keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;                Log.e(TAG, <span class="hljs-string">&quot;Couldn&#x27;t rename file &quot;</span> + mFile                      + <span class="hljs-string">&quot; to backup file &quot;</span> + mBackupFile);                mcr.setDiskWriteResult(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            mFile.delete();        &#125;    &#125;    <span class="hljs-comment">// Attempt to write the file, delete the backup and return true as atomically as</span>    <span class="hljs-comment">// possible.  If any exception occurs, delete the new file; next time we will restore</span>    <span class="hljs-comment">// from the backup.</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> createFileOutputStream(mFile);        <span class="hljs-keyword">if</span> (DEBUG) &#123;            outputStreamCreateTime = System.currentTimeMillis();        &#125;        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;            mcr.setDiskWriteResult(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);            <span class="hljs-keyword">return</span>;        &#125;        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);        writeTime = System.currentTimeMillis();        FileUtils.sync(str);        fsyncTime = System.currentTimeMillis();        str.close();        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (DEBUG) &#123;            setPermTime = System.currentTimeMillis();        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">StructStat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> Os.stat(mFile.getPath());            <span class="hljs-keyword">synchronized</span> (mLock) &#123;                mStatTimestamp = stat.st_mtim;                mStatSize = stat.st_size;            &#125;        &#125; <span class="hljs-keyword">catch</span> (ErrnoException e) &#123;            <span class="hljs-comment">// Do nothing</span>        &#125;        <span class="hljs-keyword">if</span> (DEBUG) &#123;            fstatTime = System.currentTimeMillis();        &#125;        <span class="hljs-comment">// Writing was successful, delete the backup file if there is one.</span>        mBackupFile.delete();        <span class="hljs-keyword">if</span> (DEBUG) &#123;            deleteTime = System.currentTimeMillis();        &#125;        mDiskStateGeneration = mcr.memoryStateGeneration;        mcr.setDiskWriteResult(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (DEBUG) &#123;            Log.d(TAG, <span class="hljs-string">&quot;write: &quot;</span> + (existsTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (backupExistsTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (outputStreamCreateTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (writeTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (fsyncTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (setPermTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (fstatTime - startTime) + <span class="hljs-string">&quot;/&quot;</span>                    + (deleteTime - startTime));        &#125;        <span class="hljs-type">long</span> <span class="hljs-variable">fsyncDuration</span> <span class="hljs-operator">=</span> fsyncTime - writeTime;        mSyncTimes.add((<span class="hljs-type">int</span>) fsyncDuration);        mNumSync++;        <span class="hljs-keyword">if</span> (DEBUG || mNumSync % <span class="hljs-number">1024</span> == <span class="hljs-number">0</span> || fsyncDuration &gt; MAX_FSYNC_DURATION_MILLIS) &#123;            mSyncTimes.log(TAG, <span class="hljs-string">&quot;Time required to fsync &quot;</span> + mFile + <span class="hljs-string">&quot;: &quot;</span>);        &#125;        <span class="hljs-keyword">return</span>;    &#125; <span class="hljs-keyword">catch</span> (XmlPullParserException e) &#123;        Log.w(TAG, <span class="hljs-string">&quot;writeToFile: Got exception:&quot;</span>, e);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        Log.w(TAG, <span class="hljs-string">&quot;writeToFile: Got exception:&quot;</span>, e);    &#125;    <span class="hljs-comment">// Clean up an unsuccessfully written file</span>    <span class="hljs-keyword">if</span> (mFile.exists()) &#123;        <span class="hljs-keyword">if</span> (!mFile.delete()) &#123;            Log.e(TAG, <span class="hljs-string">&quot;Couldn&#x27;t clean up partially-written file &quot;</span> + mFile);        &#125;    &#125;    mcr.setDiskWriteResult(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);&#125;</code></pre></div><h1 id="apply-amp-commit"><a href="#apply-amp-commit" class="headerlink" title="apply &amp; commit"></a>apply &amp; commit</h1><p>了解了二阶段提交后，<code>apply</code> 和 <code>commit</code> 的逻辑与区别也清晰起来</p><ul><li><p>apply 立刻将修改提交至内存，然后将提交至磁盘的任务延迟个 100ms 交由工作队列 <code>QueuedWork</code> 执行，不阻塞当前线程；而且在工作队列里，多个 apply 产生的提交会被优化为只有最后那个（最新的修改，与内存版本一致的修改）才会真正执行文件写操作</p></li><li><p>commit 也是立刻将修改提交至内存，然后提交至磁盘时分两种情况：</p><ul><li>如果此时只有一个提交磁盘的任务（<code>mDiskWritesInFlight == 1</code>），那么由当前线程来执行文件写操作</li><li>否则将提交至磁盘的任务交由工作队列 QueuedWork 执行（无延迟），但当前线程会阻塞直到文件写操作完成</li></ul></li><li><p>但无论哪种情况，commit 都会导致当前线程直到提交至磁盘后才返回，也即 commit 会确保当前修改写入至文件</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    <span class="hljs-keyword">final</span> <span class="hljs-type">MemoryCommitResult</span> <span class="hljs-variable">mcr</span> <span class="hljs-operator">=</span> commitToMemory();    <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">awaitCommit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    mcr.writtenToDiskLatch.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;&#125;                <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;                    Log.d(TAG, mFile.getName() + <span class="hljs-string">&quot;:&quot;</span> + mcr.memoryStateGeneration                            + <span class="hljs-string">&quot; applied after &quot;</span> + (System.currentTimeMillis() - startTime)                            + <span class="hljs-string">&quot; ms&quot;</span>);                &#125;            &#125;        &#125;;    QueuedWork.addFinisher(awaitCommit);    <span class="hljs-type">Runnable</span> <span class="hljs-variable">postWriteRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                awaitCommit.run();                QueuedWork.removeFinisher(awaitCommit);            &#125;        &#125;;    SharedPreferencesImpl.<span class="hljs-built_in">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);    <span class="hljs-comment">// Okay to notify the listeners before it&#x27;s hit disk</span>    <span class="hljs-comment">// because the listeners should always get the same</span>    <span class="hljs-comment">// SharedPreferences instance back, which has the</span>    <span class="hljs-comment">// changes reflected in memory.</span>    notifyListeners(mcr);&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (DEBUG) &#123;        startTime = System.currentTimeMillis();    &#125;    <span class="hljs-type">MemoryCommitResult</span> <span class="hljs-variable">mcr</span> <span class="hljs-operator">=</span> commitToMemory();    SharedPreferencesImpl.<span class="hljs-built_in">this</span>.enqueueDiskWrite(        mcr, <span class="hljs-literal">null</span> <span class="hljs-comment">/* sync write on this thread okay */</span>);    <span class="hljs-keyword">try</span> &#123;        mcr.writtenToDiskLatch.await();    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG) &#123;            Log.d(TAG, mFile.getName() + <span class="hljs-string">&quot;:&quot;</span> + mcr.memoryStateGeneration                    + <span class="hljs-string">&quot; committed after &quot;</span> + (System.currentTimeMillis() - startTime)                    + <span class="hljs-string">&quot; ms&quot;</span>);        &#125;    &#125;    notifyListeners(mcr);    <span class="hljs-keyword">return</span> mcr.writeToDiskResult;&#125;</code></pre></div><h1 id="对于上面提问的回答"><a href="#对于上面提问的回答" class="headerlink" title="对于上面提问的回答"></a>对于上面提问的回答</h1><ol><li><p><code>apply</code> 和 <code>commit</code> 有何区别？</p><ul><li>commit 会被阻塞 or 执行文件写操作直到修改提交至磁盘（确保完成二阶段提交），不适合在主线程执行</li><li>apply 只提交至内存，将提交至磁盘的任务交由其他线程执行，适合在主线程执行</li><li>apply 在频繁修改的情况下性能要比 commit 好，因为只有最新的 snapshot（具有最新的版本号）才会真正写入至文件，旧的 snapshot 会被忽略（即使写入文件后续还是会被更新的 snapshot 覆盖，不如省了一次文件写）</li><li>commit 确保修改能同时被提交至内存和磁盘，频繁的修改就会产生频繁的文件 IO</li><li>由于 apply 只写入最新的 snapshot 至文件，极端情况下可能因为没有及时提交磁盘被 killed 而导致修改丢失</li></ul></li><li><p>SharedPreferences 是线程安全的吗？它是如何保证线程安全的？</p><p> 是线程安全的，Editor 使用 <code>mLock</code> 确保内存层面的线程安全，使用 <code>mWritingToDiskLock</code> 确保磁盘文件的线程安全</p></li><li><p>SharedPreferences 是进程安全的吗？</p><p> 不是：</p><ol><li>它没有使用文件锁等进程间同步工具来确保多进程对 XML 文件的安全读写</li><li>它只在构造时从文件读取内容，后续都是写操作，其他进程对 XML 文件的修改当前进程并不知道</li></ol></li><li><p>数据丢失时，其最终的屏障 —— 文件备份机制是如何实现的？</p><p> 见上面对 <code>mFile</code> 和 <code>mBackupFile</code> 的说明</p></li><li><p>如何实现进程安全的 SharedPreferences</p><ol><li>对于 XML 文件的读写操作需要加上文件锁</li><li>用 <code>epoll</code> 监控 XML 文件内容的改变 </li></ol></li><li><p>SharedPreferences 导致 ANR 的原因</p><ol><li>构造 SharedPreferences 实例时会解析 XML 文件，在解析操作完成前主线程调用 get 方法会阻塞，从而阻塞主线程</li><li>主线程执行 commit 发生文件 IO or 阻塞，从而导致主线程阻塞</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SharedPreferences</tag>
      
      <tag>SP</tag>
      
      <tag>MMKV</tag>
      
      <tag>Jetpack-DataStore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin Flow - 初识</title>
    <link href="/2022/04/09/flow-basic/"/>
    <url>/2022/04/09/flow-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="for-操作符"><a href="#for-操作符" class="headerlink" title="for 操作符"></a>for 操作符</h1><p>具有以下特征的对象可以被 <code>for</code> 操作符遍历：</p><ol><li>具有 <code>operator</code> 函数 <code>iterator()</code></li><li>其返回 <code>Iterator</code> 具有 <code>operator</code> 函数 <code>hasNext()</code> 和 <code>next()</code></li></ol><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sequence</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: Iterator&lt;T&gt;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span>&#125;</code></pre></div><p><code>Sequence</code> 就是可以被 <code>for</code> 操作符遍历的接口</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fruits = sequence &#123;    yield(<span class="hljs-string">&quot;Apple&quot;</span>)    yield(<span class="hljs-string">&quot;Banana&quot;</span>)    yield(<span class="hljs-string">&quot;Guava&quot;</span>)&#125;<span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> fruits) &#123; println(<span class="hljs-string">&quot;we got <span class="hljs-variable">$fruit</span>&quot;</span>) &#125;</code></pre></div><h1 id="热流（hot-stream）和冷流（cold-stream）"><a href="#热流（hot-stream）和冷流（cold-stream）" class="headerlink" title="热流（hot stream）和冷流（cold stream）"></a>热流（hot stream）和冷流（cold stream）</h1><ul><li>已计算出结果的序列叫 <code>热流</code>，平时常用的 <code>Collection</code>、<code>List</code>、<code>Set</code> 和 <code>Map</code> 等容器都属于热流</li><li>尚未计算出结果的序列叫 <code>冷流</code>，<code>sequence</code>、<code>flow</code> 和 <code>RxJava</code> 都可以创建冷流</li><li>冷流的概念类似于 ORM Entity 的懒加载以及其关联关系的懒加载，就是等用到成员时才执行 DB 查询</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> log = &#123; msg: String -&gt;    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(Date())&#125;</span> <span class="hljs-variable">$msg</span>&quot;</span>)&#125;<span class="hljs-keyword">val</span> collect: <span class="hljs-keyword">suspend</span> SequenceScope&lt;String&gt;.(String) -&gt; <span class="hljs-built_in">Unit</span> = &#123;    log(<span class="hljs-string">&quot;collecting <span class="hljs-subst">$&#123;it&#125;</span>...&quot;</span>)    Thread.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000L</span>)    yield(it)&#125;<span class="hljs-comment">// 热流已计算出结果</span><span class="hljs-keyword">var</span> fruits = arrayOf(<span class="hljs-string">&quot;watermelon&quot;</span>, <span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>).asSequence()<span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> fruits) &#123; log(<span class="hljs-string">&quot;we got <span class="hljs-variable">$fruit</span>&quot;</span>) &#125;<span class="hljs-comment">// 16:22:14 we got watermelon</span><span class="hljs-comment">// 16:22:14 we got peach</span><span class="hljs-comment">// 16:22:14 we got orange</span><span class="hljs-comment">// 冷流的每个结果都是实时计算出来的</span>fruits = sequence &#123;    collect(<span class="hljs-string">&quot;Apple&quot;</span>)    collect(<span class="hljs-string">&quot;Banana&quot;</span>)    collect(<span class="hljs-string">&quot;Guava&quot;</span>)&#125;<span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> fruits) &#123; log(<span class="hljs-string">&quot;we got <span class="hljs-variable">$fruit</span>&quot;</span>) &#125;<span class="hljs-comment">// 16:22:14 collecting Apple...</span><span class="hljs-comment">// 16:22:16 we got Apple</span><span class="hljs-comment">// 16:22:16 collecting Banana...</span><span class="hljs-comment">// 16:22:18 we got Banana</span><span class="hljs-comment">// 16:22:18 collecting Guava...</span><span class="hljs-comment">// 16:22:20 we got Guava</span><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> fruits) &#123; log(<span class="hljs-string">&quot;we got <span class="hljs-variable">$fruit</span>&quot;</span>) &#125;<span class="hljs-comment">// 16:22:14 collecting Apple...</span><span class="hljs-comment">// 16:22:16 we got Apple</span><span class="hljs-comment">// 16:22:16 collecting Banana...</span><span class="hljs-comment">// 16:22:18 we got Banana</span><span class="hljs-comment">// 16:22:18 collecting Guava...</span><span class="hljs-comment">// 16:22:20 we got Guava</span><span class="hljs-comment">// 像这些操作符是实时计算的，不会存储计算结果，不会改变热流的本质</span><span class="hljs-comment">// The operation is _intermediate_ and _stateless_.</span>fruits    .filter &#123; it.startsWith(<span class="hljs-string">&quot;B&quot;</span>) &#125;    .map &#123; it.last() &#125;<span class="hljs-comment">// 这些操作符的计算结果将不再是热流</span><span class="hljs-comment">// The operation is _terminal_.</span>fruits.toList()fruits.groupBy &#123; it.first() &#125;</code></pre></div><h1 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h1><p>协程版热流（Asynchronous Flow）：<code>flow</code> = <code>sequence</code> + <code>coroutine</code>，上面 <code>sequence</code> 版热流可以用 <code>flow</code> 改造为协程版本</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> log = &#123; msg: String -&gt;    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(Date())&#125;</span> <span class="hljs-variable">$msg</span>&quot;</span>)&#125;<span class="hljs-keyword">val</span> collect: <span class="hljs-keyword">suspend</span> FlowCollector&lt;String&gt;.(String) -&gt; <span class="hljs-built_in">Unit</span> = &#123;    log(<span class="hljs-string">&quot;collecting <span class="hljs-subst">$&#123;it&#125;</span>...&quot;</span>)    delay(<span class="hljs-number">2</span> * <span class="hljs-number">1000L</span>)    emit(it)&#125;<span class="hljs-keyword">val</span> fruits = flow &#123;    collect(<span class="hljs-string">&quot;Apple&quot;</span>)    collect(<span class="hljs-string">&quot;Banana&quot;</span>)    collect(<span class="hljs-string">&quot;Guava&quot;</span>)&#125;runBlocking &#123; fruits.collect &#123; log(<span class="hljs-string">&quot;we got <span class="hljs-variable">$it</span>&quot;</span>) &#125; &#125;<span class="hljs-comment">// 16:46:25 collecting Apple...</span><span class="hljs-comment">// 16:46:27 we got Apple</span><span class="hljs-comment">// 16:46:27 collecting Banana...</span><span class="hljs-comment">// 16:46:29 we got Banana</span><span class="hljs-comment">// 16:46:29 collecting Guava...</span><span class="hljs-comment">// 16:46:31 we got Guava</span></code></pre></div><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><ul><li><code>collect</code> 在当前 <code>CoroutineContext</code> 上执行</li><li><code>flowOn</code> 使 upstream 在指定的 <code>CoroutineContext</code> 上执行</li><li>下游的 <code>flowOn</code> 不会影响上游的 <code>flowOn</code> 的效果</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;current thread: <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<span class="hljs-comment">// current thread: Test worker @coroutine#1</span><span class="hljs-keyword">val</span> fruits = arrayOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;watermelon&quot;</span>, <span class="hljs-string">&quot;blackcurrant&quot;</span>)<span class="hljs-keyword">val</span> produce: <span class="hljs-keyword">suspend</span> FlowCollector&lt;String&gt;.(String) -&gt; <span class="hljs-built_in">Unit</span> = &#123;    delay(<span class="hljs-number">500L</span>)    println(<span class="hljs-string">&quot;produce <span class="hljs-variable">$it</span> @<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)    emit(it)&#125;<span class="hljs-keyword">val</span> consume: FlowCollector&lt;String&gt; = FlowCollector &#123;    println(<span class="hljs-string">&quot;consume <span class="hljs-variable">$it</span> @<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)&#125;<span class="hljs-keyword">val</span> collectFruits = flow &#123; fruits.forEach &#123; produce(it) &#125; &#125;collectFruits.collect(consume)<span class="hljs-comment">// produce apple        @Test worker @coroutine#1</span><span class="hljs-comment">// consume apple        @Test worker @coroutine#1</span><span class="hljs-comment">// produce banana       @Test worker @coroutine#1</span><span class="hljs-comment">// consume banana       @Test worker @coroutine#1</span><span class="hljs-comment">// produce watermelon   @Test worker @coroutine#1</span><span class="hljs-comment">// consume watermelon   @Test worker @coroutine#1</span><span class="hljs-comment">// produce blackcurrant @Test worker @coroutine#1</span><span class="hljs-comment">// consume blackcurrant @Test worker @coroutine#1</span><span class="hljs-keyword">val</span> worker1 = Executors.newSingleThreadExecutor &#123; Thread(it, <span class="hljs-string">&quot;worker_1&quot;</span>) &#125;.asCoroutineDispatcher()<span class="hljs-keyword">val</span> worker2 = Executors.newSingleThreadExecutor &#123; Thread(it, <span class="hljs-string">&quot;worker_2&quot;</span>) &#125;.asCoroutineDispatcher()collectFruits    .flowOn(worker1)    .map &#123;        println(<span class="hljs-string">&quot;map <span class="hljs-variable">$it</span> @<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)        it    &#125;    .flowOn(worker2)    .collect(consume)<span class="hljs-comment">// produce apple        @worker_1    @coroutine#3</span><span class="hljs-comment">// map apple            @worker_2    @coroutine#2</span><span class="hljs-comment">// consume apple        @Test worker @coroutine#1</span><span class="hljs-comment">// produce banana       @worker_1    @coroutine#3</span><span class="hljs-comment">// map banana           @worker_2    @coroutine#2</span><span class="hljs-comment">// consume banana       @Test worker @coroutine#1</span><span class="hljs-comment">// produce watermelon   @worker_1    @coroutine#3</span><span class="hljs-comment">// map watermelon       @worker_2    @coroutine#2</span><span class="hljs-comment">// consume watermelon   @Test worker @coroutine#1</span><span class="hljs-comment">// produce blackcurrant @worker_1    @coroutine#3</span><span class="hljs-comment">// map blackcurrant     @worker_2    @coroutine#2</span><span class="hljs-comment">// consume blackcurrant @Test worker @coroutine#1    </span></code></pre></div><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>exception 会中断 <code>flow</code></li><li>未被 try-catch 的 exception，无论是在 <code>emitter</code>、<code>operator</code> 还是 <code>collector</code> 都会导致 flow 抛出 exception</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fruits = arrayOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;watermelon&quot;</span>, <span class="hljs-string">&quot;blackcurrant&quot;</span>)<span class="hljs-keyword">try</span> &#123;    flow &#123;        fruits.forEach &#123;            println(<span class="hljs-string">&quot;emit <span class="hljs-variable">$it</span>&quot;</span>)            check(it != <span class="hljs-string">&quot;watermelon&quot;</span>) &#123; <span class="hljs-string">&quot;emitter exception: <span class="hljs-variable">$it</span>&quot;</span> &#125;            emit(it)        &#125;    &#125;.collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    println(<span class="hljs-string">&quot;caught <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emit watermelon</span><span class="hljs-comment">// caught emitter exception: watermelon</span><span class="hljs-keyword">try</span> &#123;    flow &#123;        fruits.forEach &#123;            println(<span class="hljs-string">&quot;emit <span class="hljs-variable">$it</span>&quot;</span>)            emit(it)        &#125;    &#125;.map &#123;        check(it != <span class="hljs-string">&quot;watermelon&quot;</span>) &#123; <span class="hljs-string">&quot;operator exception: <span class="hljs-variable">$it</span>&quot;</span> &#125;        it    &#125;.collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    println(<span class="hljs-string">&quot;caught <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emit watermelon</span><span class="hljs-comment">// caught operator exception: watermelon</span><span class="hljs-keyword">try</span> &#123;    flow &#123;        fruits.forEach &#123;            println(<span class="hljs-string">&quot;emit <span class="hljs-variable">$it</span>&quot;</span>)            emit(it)        &#125;    &#125;.collect &#123;        check(it != <span class="hljs-string">&quot;watermelon&quot;</span>) &#123; <span class="hljs-string">&quot;collector exception: <span class="hljs-variable">$it</span>&quot;</span> &#125;        println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>)    &#125;&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    println(<span class="hljs-string">&quot;caught <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emit watermelon</span><span class="hljs-comment">// caught collector exception: watermelon    </span></code></pre></div><ul><li><code>catch</code> 操作符可以捕获 <code>flow</code> 中抛出的异常</li><li>catch 里可以忽略异常、打印日志、重新抛出异常以及 emit 新数据来替代异常</li><li>catch 不能恢复因异常导致中断的 flow</li><li>catch 不能捕获 downstream 里发生的异常</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fruits = arrayOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;watermelon&quot;</span>, <span class="hljs-string">&quot;blackcurrant&quot;</span>)<span class="hljs-keyword">val</span> flow = flow &#123;    fruits.forEach &#123;        println(<span class="hljs-string">&quot;emit <span class="hljs-variable">$it</span>&quot;</span>)        check(it != <span class="hljs-string">&quot;watermelon&quot;</span>) &#123; <span class="hljs-string">&quot;emitter exception: <span class="hljs-variable">$it</span>&quot;</span> &#125;        emit(it)    &#125;&#125;flow.<span class="hljs-keyword">catch</span> &#123; emit(<span class="hljs-string">&quot;orange&quot;</span>) &#125;.collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;println()<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emit watermelon</span><span class="hljs-comment">// collect orange</span>flow.<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;ignore <span class="hljs-subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;.collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;println()<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emit watermelon</span><span class="hljs-comment">// ignore emitter exception: watermelon</span><span class="hljs-keyword">try</span> &#123;    flow.<span class="hljs-keyword">catch</span> &#123; <span class="hljs-keyword">throw</span> it &#125;.collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    println(<span class="hljs-string">&quot;caught <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emit watermelon</span><span class="hljs-comment">// caught emitter exception: watermelon</span><span class="hljs-keyword">try</span> &#123;    flow.<span class="hljs-keyword">catch</span> &#123; println(<span class="hljs-string">&quot;ignore <span class="hljs-subst">$&#123;it.message&#125;</span>&quot;</span>) &#125;        .map &#123;            check(it != <span class="hljs-string">&quot;banana&quot;</span>) &#123; <span class="hljs-string">&quot;map throw <span class="hljs-variable">$it</span>&quot;</span> &#125;            it        &#125;        .collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    println(<span class="hljs-string">&quot;caught <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// emit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emit banana</span><span class="hljs-comment">// caught map throw banana</span><span class="hljs-keyword">try</span> &#123;    flow &#123;        fruits.forEach &#123;            println(<span class="hljs-string">&quot;emmit <span class="hljs-variable">$it</span>&quot;</span>)            emit(it)        &#125;    &#125;.<span class="hljs-keyword">catch</span> &#123;        println(<span class="hljs-string">&quot;ignore <span class="hljs-subst">$&#123;it.message&#125;</span>&quot;</span>)        &#125;.map &#123;        check(it != <span class="hljs-string">&quot;watermelon&quot;</span>) &#123; <span class="hljs-string">&quot;map throw <span class="hljs-variable">$it</span>&quot;</span> &#125;        it    &#125;.collect &#123; println(<span class="hljs-string">&quot;collect <span class="hljs-variable">$it</span>&quot;</span>) &#125;&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    println(<span class="hljs-string">&quot;caught <span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// emmit apple</span><span class="hljs-comment">// collect apple</span><span class="hljs-comment">// emmit banana</span><span class="hljs-comment">// collect banana</span><span class="hljs-comment">// emmit watermelon</span><span class="hljs-comment">// caught map throw watermelon</span></code></pre></div><h1 id="用-Flow-替代-LiveData"><a href="#用-Flow-替代-LiveData" class="headerlink" title="用 Flow 替代 LiveData"></a>用 Flow 替代 LiveData</h1><p>Android 正在大力推广 coroutine，然而 <code>LiveData</code> 并不能很好地与 coroutine 结合使用，而 <code>StateFlow</code> 正是其继任者</p><p>flow 需要配合着 repeatOnLifecycle 一起使用才不会造成 Activity/Fragment 的泄漏</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LatestNewsViewModel</span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> newsRepository: NewsRepository) : ViewModel() &#123;    <span class="hljs-comment">// Backing property to avoid state updates from other classes</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _uiState = MutableStateFlow(LatestNewsUiState.Success(emptyList()))    <span class="hljs-comment">// The UI collects from this StateFlow to get its state updates</span>    <span class="hljs-keyword">val</span> uiState: StateFlow&lt;LatestNewsUiState&gt; = _uiState    <span class="hljs-keyword">init</span> &#123;        viewModelScope.launch &#123;            newsRepository.favoriteLatestNews                <span class="hljs-comment">// Update View with the latest favorite news</span>                <span class="hljs-comment">// Writes to the value property of MutableStateFlow,</span>                <span class="hljs-comment">// adding a new element to the flow and updating all</span>                <span class="hljs-comment">// of its collectors</span>                .collect &#123; favoriteNews -&gt;                    _uiState.value = LatestNewsUiState.Success(favoriteNews)                &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// Represents different states for the LatestNews screen</span><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LatestNewsUiState</span> &#123;    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span>(news: List&lt;ArticleHeadline&gt;): LatestNewsUiState()    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Error</span>(exception: Throwable): LatestNewsUiState()&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LatestNewsActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> latestNewsViewModel = <span class="hljs-comment">// getViewModel()</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        ...        <span class="hljs-comment">// Start a coroutine in the lifecycle scope</span>        lifecycleScope.launch &#123;            <span class="hljs-comment">// repeatOnLifecycle launches the block in a new coroutine every time the</span>            <span class="hljs-comment">// lifecycle is in the STARTED state (or above) and cancels it when it&#x27;s STOPPED.</span>            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;                <span class="hljs-comment">// Trigger the flow and start listening for values.</span>                <span class="hljs-comment">// Note that this happens when lifecycle is STARTED and stops</span>                <span class="hljs-comment">// collecting when the lifecycle is STOPPED</span>                latestNewsViewModel.uiState.collect &#123; uiState -&gt;                    <span class="hljs-comment">// New value received</span>                    <span class="hljs-keyword">when</span> (uiState) &#123;                        <span class="hljs-keyword">is</span> LatestNewsUiState.Success -&gt; showFavoriteNews(uiState.news)                        <span class="hljs-keyword">is</span> LatestNewsUiState.Error -&gt; showError(uiState.exception)                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h1><ul><li><code>viewModelScope</code> 将任务分发到主线程，而且是 <code>Dispatchers.Main.immediate</code>，也就说在分发任务时如果执行线程是主线程，则立即执行而不是插入到任务队列里</li><li><code>SupervisorJob()</code> 里各个子任务是相互独立的，一个子任务的取消和失败并不会影响其他子任务的执行</li><li><code>ViewModel.onCleared</code> 将会取消整个 viewModelScope，那么里面的子任务也都会被取消掉</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> ViewModel.viewModelScope: CoroutineScope    <span class="hljs-keyword">get</span>() &#123;        <span class="hljs-keyword">val</span> scope: CoroutineScope? = <span class="hljs-keyword">this</span>.getTag(JOB_KEY)        <span class="hljs-keyword">if</span> (scope != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> scope        &#125;        <span class="hljs-keyword">return</span> setTagIfAbsent(            JOB_KEY,            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)        )    &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext = context    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;        coroutineContext.cancel()    &#125;&#125;</code></pre></div><h1 id="lifecycleScope"><a href="#lifecycleScope" class="headerlink" title="lifecycleScope"></a>lifecycleScope</h1><ul><li><code>lifecycleScope</code> 也是将任务分发到主线程</li><li>当状态变为 <code>Lifecycle.State.DESTROYED</code> 时整个 scope 将会被取消</li><li><code>repeatOnLifecycle</code> 当进入指定状态时执行一次 block，当退出这个状态时 Job 将会被取消</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> LifecycleOwner.lifecycleScope: LifecycleCoroutineScope    <span class="hljs-keyword">get</span>() = lifecycle.coroutineScope<span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> Lifecycle.coroutineScope: LifecycleCoroutineScope    <span class="hljs-keyword">get</span>() &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">val</span> existing = mInternalScopeRef.<span class="hljs-keyword">get</span>() <span class="hljs-keyword">as</span> LifecycleCoroutineScopeImpl?            <span class="hljs-keyword">if</span> (existing != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span> existing            &#125;            <span class="hljs-keyword">val</span> newScope = LifecycleCoroutineScopeImpl(                <span class="hljs-keyword">this</span>,                SupervisorJob() + Dispatchers.Main.immediate            )            <span class="hljs-keyword">if</span> (mInternalScopeRef.compareAndSet(<span class="hljs-literal">null</span>, newScope)) &#123;                newScope.register()                <span class="hljs-keyword">return</span> newScope            &#125;        &#125;    &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleCoroutineScopeImpl</span>(    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> lifecycle: Lifecycle,    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext) : LifecycleCoroutineScope(), LifecycleEventObserver &#123;    <span class="hljs-keyword">init</span> &#123;        <span class="hljs-comment">// in case we are initialized on a non-main thread, make a best effort check before</span>        <span class="hljs-comment">// we return the scope. This is not sync but if developer is launching on a non-main</span>        <span class="hljs-comment">// dispatcher, they cannot be 100% sure anyways.</span>        <span class="hljs-keyword">if</span> (lifecycle.currentState == Lifecycle.State.DESTROYED) &#123;            coroutineContext.cancel()        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">register</span><span class="hljs-params">()</span></span> &#123;        launch(Dispatchers.Main.immediate) &#123;            <span class="hljs-keyword">if</span> (lifecycle.currentState &gt;= Lifecycle.State.INITIALIZED) &#123;                lifecycle.addObserver(<span class="hljs-keyword">this</span><span class="hljs-symbol">@LifecycleCoroutineScopeImpl</span>)            &#125; <span class="hljs-keyword">else</span> &#123;                coroutineContext.cancel()            &#125;        &#125;    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(source: <span class="hljs-type">LifecycleOwner</span>, event: <span class="hljs-type">Lifecycle</span>.<span class="hljs-type">Event</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> (lifecycle.currentState &lt;= Lifecycle.State.DESTROYED) &#123;            lifecycle.removeObserver(<span class="hljs-keyword">this</span>)            coroutineContext.cancel()        &#125;    &#125;&#125;</code></pre></div><h1 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h1><p>它们跟上面的 <code>flow</code> 是完全不同的概念，而是与 <code>LiveData</code> 类似，是一个可被观察的对象（<code>Observable</code>）</p><ul><li>使用 <code>collect</code> 观察状态的变化，接收状态变化的通知</li><li>collect 的返回值是 <code>Nothing</code>，表示此函数永远不会返回，后续的代码永远不可能被执行（因为它会抛出异常来结束代码的执行）</li><li>所以每个 collect 都需要在各自的 <code>launch</code> 里执行</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Nothing</span>launch &#123;    state.collect &#123;  &#125;    <span class="hljs-comment">// never reach...</span>&#125;launch &#123; state.collect &#123;  &#125; &#125;launch &#123; state.collect &#123;  &#125; &#125;</code></pre></div><p>LiveData 通过 LifecycleEventObserver 在 Lifecycle.State.DESTROYED 时与 Activity 断开联系，而 StateFlow 则是通过 lifecycleScope 的取消断开与 Activity 的联系，如下面代码所示：</p><ul><li>Activity 被匿名内部类实例 collector 持有引用</li><li>collect 是个 infinite loop，会一直等待 state 的改变直到发生异常中断 loop</li><li><code>suspendCancellableCoroutine</code> 即将返回前，coroutine 进入 suspend 状态，等待 state 的改变，如果此时 coroutine 被 cancel 则 suspendCancellableCoroutine 会抛出 CancellationException，从而结束 collect 里的循环</li><li>一旦 collect 返回，state 将不再持有 collector，也就不再持有 Activity</li><li>当 state 改变时，<code>collectorJob?.ensureActive()</code> 确保 destroyed activity 不会再执行任何逻辑</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateFlowImpl</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Nothing</span> &#123;        <span class="hljs-keyword">val</span> slot = allocateSlot()        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (collector <span class="hljs-keyword">is</span> SubscribedFlowCollector) collector.onSubscription()            <span class="hljs-keyword">val</span> collectorJob = currentCoroutineContext()[Job]            <span class="hljs-keyword">var</span> oldState: Any? = <span class="hljs-literal">null</span> <span class="hljs-comment">// previously emitted T!! | NULL (null -- nothing emitted yet)</span>            <span class="hljs-comment">// The loop is arranged so that it starts delivering current value without waiting first</span>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-comment">// Here the coroutine could have waited for a while to be dispatched,</span>                <span class="hljs-comment">// so we use the most recent state here to ensure the best possible conflation of stale values</span>                <span class="hljs-keyword">val</span> newState = _state.value                <span class="hljs-comment">// always check for cancellation</span>                collectorJob?.ensureActive()                <span class="hljs-comment">// Conflate value emissions using equality</span>                <span class="hljs-keyword">if</span> (oldState == <span class="hljs-literal">null</span> || oldState != newState) &#123;                    collector.emit(NULL.unbox(newState))                    oldState = newState                &#125;                <span class="hljs-comment">// Note: if awaitPending is cancelled, then it bails out of this loop and calls freeSlot</span>                <span class="hljs-keyword">if</span> (!slot.takePending()) &#123; <span class="hljs-comment">// try fast-path without suspending first</span>                    slot.awaitPending() <span class="hljs-comment">// only suspend for new values when needed</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            freeSlot(slot)        &#125;    &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Job.<span class="hljs-title">ensureActive</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;    <span class="hljs-keyword">if</span> (!isActive) <span class="hljs-keyword">throw</span> getCancellationException()&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateFlowSlot</span> &#123;    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitPending</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont -&gt;        assert &#123; _state.value !<span class="hljs-keyword">is</span> CancellableContinuationImpl&lt;*&gt; &#125; <span class="hljs-comment">// can be NONE or PENDING</span>        <span class="hljs-keyword">if</span> (_state.compareAndSet(NONE, cont)) <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-comment">// installed continuation, waiting for pending</span>        <span class="hljs-comment">// CAS failed -- the only possible reason is that it is already in pending state now</span>        assert &#123; _state.value === PENDING &#125;        cont.resume(<span class="hljs-built_in">Unit</span>)    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Suspends the coroutine like [suspendCoroutine], but providing a [CancellableContinuation] to</span><span class="hljs-comment"> * the [block]. This function throws a [CancellationException] if the [Job] of the coroutine is</span><span class="hljs-comment"> * cancelled or completed while it is suspended.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: T</code></pre></div><p>StateFlow.value 是线程安全的</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MutableStateFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">StateFlow</span>&lt;<span class="hljs-type">T</span>&gt;, <span class="hljs-type">MutableSharedFlow</span>&lt;<span class="hljs-type">T</span>&gt; &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The current value of this state flow.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Setting a value that is [equal][Any.equals] to the previous one does nothing.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * This property is **thread-safe** and can be safely updated from concurrent coroutines without</span><span class="hljs-comment">     * external synchronization.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T&#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://kotlinlang.org/docs/flow.html">Kotlin Docs - Asynchronous Flow</a></li><li><a href="https://developer.android.com/kotlin/flow">Android Developers - Kotlin Flow</a></li><li><a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow">StateFlow and SharedFlow</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>coroutine</tag>
      
      <tag>协程</tag>
      
      <tag>flow</tag>
      
      <tag>sequence</tag>
      
      <tag>热流</tag>
      
      <tag>冷流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASM - 字节码操作库</title>
    <link href="/2022/04/07/asm/"/>
    <url>/2022/04/07/asm/</url>
    
    <content type="html"><![CDATA[<p><a href="https://asm.ow2.io/">ASM</a> 是一款广为使用的字节码操作库，很多 Gradle Transform 会用它对编译后的代码进行插桩和修改操作，源码仓库在 <a href="https://gitlab.ow2.org/asm/asm">GitLab</a></p><h1 id="访问者模式（Visitor-pattern）"><a href="#访问者模式（Visitor-pattern）" class="headerlink" title="访问者模式（Visitor pattern）"></a>访问者模式（Visitor pattern）</h1><blockquote><p>Visitor pattern represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">访问者模式</a> 是一种将数据结构与数据操作分离的设计模式，它封装一些作用于某种数据结构中的各元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新的操作，属于行为型模式</p><p>访问者模式被称为最复杂的设计模式，并且使用频率不高，设计模式的作者也评价为：大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了，其基本思想是：</p><ul><li>针对系统中拥有固定类型数的对象结构（元素），在其内提供一个 <code>accept()</code> 方法用来接受访问者对象的访问</li><li>不同的访问者对同一元素的访问内容不同，使得相同的元素集合可以产生不同的数据结果（视图）</li><li><code>accept()</code> 方法可以接收不同的访问者对象，然后在内部将自己（元素）转发到接收到的访问者对象的 <code>visit()</code> 方法内，访问者内部对应类型的 <code>visit()</code> 方法就会得到回调执行</li><li>对元素进行操作也就是通过两次动态分发：第一次是对访问者分发 <code>accept()</code> 方法，第二次是对元素的分发 <code>visit()</code> 方法，才最终将一个具体的元素传递到一个具体的访问者，如此一来就解耦了数据结构与操作，且数据操作不会改变元素状态</li></ul><p>访问者模式的核心是解耦数据结构与数据操作，使得对元素的操作具备优秀的扩展性，可以通过扩展不同的数据操作类型（访问者）实现对相同元素集的不同的操作</p><h1 id="ASM-概览"><a href="#ASM-概览" class="headerlink" title="ASM 概览"></a>ASM 概览</h1><p>整个 ASM 库的核心概念是访问者模式</p><p>字节码（<code>.class</code> 文件）是一种固定格式的文件，它的数据结构如下图，对应的解析逻辑定义在 <code>ClassReader</code>，然后提供了 <code>ClassVisitor</code>、<code>MethodVisitor</code>、<code>FieldVisitor</code> 和 <code>AnnotationVisitor</code> 等各种 Visitor 来访问</p><p><img src="../../../../image/2022-04-07-asm/structure_of_class.png" alt="structure_of_class.png"></p><h1 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h1><p><code>ClassVisitor</code> 提供了以下的 visitor 方法去访问对应的数据结构，下面以 <code>java.lang.String</code> 为例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassVisitor</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-type">int</span> version,           // <span class="hljs-number">52</span></span><span class="hljs-params">      <span class="hljs-type">int</span> access,            // <span class="hljs-number">49</span></span><span class="hljs-params">      String name,           // java/lang/String</span><span class="hljs-params">      String signature,      // Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/lang/CharSequence;</span><span class="hljs-params">      String superName,      // java/lang/Object</span><span class="hljs-params">      String[] interfaces    // java/io/Serializable,java/lang/Comparable,java/lang/CharSequence</span><span class="hljs-params">  )</span>  <span class="hljs-comment">// access:18, name:value, descriptor:[C, signature:null, value:null</span>  <span class="hljs-comment">// access:26, name:serialVersionUID, descriptor:J, signature:null, value:-6849794470754667710</span>  <span class="hljs-comment">// access:25, name:CASE_INSENSITIVE_ORDER, descriptor:Ljava/util/Comparator;, signature:Ljava/util/Comparator&lt;Ljava/lang/String;&gt;;, value:null</span>  <span class="hljs-comment">// ...</span>  <span class="hljs-keyword">public</span> FieldVisitor <span class="hljs-title function_">visitField</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, Object value)</span>  <span class="hljs-comment">// access:1, name:&lt;init&gt;, descriptor:(Ljava/lang/String;)V, signature:null, exceptions:null</span>  <span class="hljs-comment">// access:1, name:&lt;init&gt;, descriptor:([BIILjava/lang/String;)V, signature:null, exceptions:java/io/UnsupportedEncodingException</span>  <span class="hljs-comment">// access:1, name:getBytes, descriptor:(Ljava/lang/String;)[B, signature:null, exceptions:java/io/UnsupportedEncodingException</span>  <span class="hljs-comment">// access:9, name:valueOf, descriptor:(Ljava/lang/Object;)Ljava/lang/String;, signature:null, exceptions:null</span>  <span class="hljs-comment">// ...</span>  <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span>  <span class="hljs-comment">// name:java/lang/String$CaseInsensitiveComparator, outerName:java/lang/String, innerName:CaseInsensitiveComparator, access:10</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitInnerClass</span><span class="hljs-params">(String name, String outerName, String innerName, <span class="hljs-type">int</span> access)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitSource</span><span class="hljs-params">(String source, String debug)</span>  <span class="hljs-keyword">public</span> ModuleVisitor <span class="hljs-title function_">visitModule</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> access, String version)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitNestHost</span><span class="hljs-params">(String nestHost)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitOuterClass</span><span class="hljs-params">(String owner, String name, String descriptor)</span>  <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitAnnotation</span><span class="hljs-params">(String descriptor, <span class="hljs-type">boolean</span> visible)</span>  <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitTypeAnnotation</span><span class="hljs-params">(<span class="hljs-type">int</span> typeRef, TypePath typePath, String descriptor, <span class="hljs-type">boolean</span> visible)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitAttribute</span><span class="hljs-params">(Attribute attribute)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitNestMember</span><span class="hljs-params">(String nestMember)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitPermittedSubclass</span><span class="hljs-params">(String permittedSubclass)</span>  <span class="hljs-keyword">public</span> RecordComponentVisitor <span class="hljs-title function_">visitRecordComponent</span><span class="hljs-params">(String name, String descriptor, String signature)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitEnd</span><span class="hljs-params">()</span>&#125;</code></pre></div><p>描述符（descriptor）的规则和例子如下图：</p><p><img src="../../../../image/2022-04-07-asm/type_descriptors.png" alt="type_descriptors.png"></p><p><img src="../../../../image/2022-04-07-asm/sample_of_method_descriptors.png" alt="sample_of_method_descriptors.png"></p><p><code>version</code> 是 class 文件格式的版本号，有如下版本号的定义：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Opcodes</span> &#123;  <span class="hljs-comment">// Java ClassFile versions (the minor version is stored in the 16 most significant bits, and the</span>  <span class="hljs-comment">// major version in the 16 least significant bits).</span>  <span class="hljs-type">int</span> <span class="hljs-variable">V1_1</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">45</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">46</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">47</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">48</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_5</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">49</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_6</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">50</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_7</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">51</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V1_8</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">52</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V9</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">53</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V10</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">54</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V11</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">55</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V12</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">56</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V13</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">57</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V14</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">58</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V15</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">59</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V16</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">60</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V17</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">61</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V18</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">62</span>;  <span class="hljs-type">int</span> <span class="hljs-variable">V19</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">16</span> | <span class="hljs-number">63</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Version flag indicating that the class is using &#x27;preview&#x27; features.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * &lt;p&gt;&#123;<span class="hljs-doctag">@code</span> version &amp; V_PREVIEW == V_PREVIEW&#125; tests if a version is flagged with &#123;<span class="hljs-doctag">@code</span></span><span class="hljs-comment">   * V_PREVIEW&#125;.</span><span class="hljs-comment">   */</span>  <span class="hljs-type">int</span> <span class="hljs-variable">V_PREVIEW</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xFFFF0000</span>;  &#125;</code></pre></div><p><code>access</code> 是修饰符控制位的组合，有以下控制位：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Opcodes</span> &#123;  <span class="hljs-comment">// Access flags values, defined in</span>  <span class="hljs-comment">// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.1-200-E.1</span>  <span class="hljs-comment">// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.5-200-A.1</span>  <span class="hljs-comment">// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6-200-A.1</span>  <span class="hljs-comment">// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_PUBLIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0001</span>; <span class="hljs-comment">// class, field, method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_PRIVATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0002</span>; <span class="hljs-comment">// class, field, method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_PROTECTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0004</span>; <span class="hljs-comment">// class, field, method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_STATIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0008</span>; <span class="hljs-comment">// field, method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_FINAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0010</span>; <span class="hljs-comment">// class, field, method, parameter</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_SUPER</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0020</span>; <span class="hljs-comment">// class</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_SYNCHRONIZED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0020</span>; <span class="hljs-comment">// method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_OPEN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0020</span>; <span class="hljs-comment">// module</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_TRANSITIVE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0020</span>; <span class="hljs-comment">// module requires</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_VOLATILE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0040</span>; <span class="hljs-comment">// field</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_BRIDGE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0040</span>; <span class="hljs-comment">// method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_STATIC_PHASE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0040</span>; <span class="hljs-comment">// module requires</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_VARARGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0080</span>; <span class="hljs-comment">// method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_TRANSIENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0080</span>; <span class="hljs-comment">// field</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_NATIVE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0100</span>; <span class="hljs-comment">// method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_INTERFACE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0200</span>; <span class="hljs-comment">// class</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_ABSTRACT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0400</span>; <span class="hljs-comment">// class, method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_STRICT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0800</span>; <span class="hljs-comment">// method</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_SYNTHETIC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x1000</span>; <span class="hljs-comment">// class, field, method, parameter, module *</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_ANNOTATION</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x2000</span>; <span class="hljs-comment">// class</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_ENUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x4000</span>; <span class="hljs-comment">// class(?) field inner</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_MANDATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x8000</span>; <span class="hljs-comment">// field, method, parameter, module, module *</span>  <span class="hljs-type">int</span> <span class="hljs-variable">ACC_MODULE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x8000</span>; <span class="hljs-comment">// class  </span>&#125;</code></pre></div><h1 id="MethodVisitor"><a href="#MethodVisitor" class="headerlink" title="MethodVisitor"></a>MethodVisitor</h1><ul><li>修改函数里的代码，建议用 <a href="https://github.com/Konloch/bytecode-viewer">bytecode-viewer</a> 对比源文件和修改文件的字节码，将它们之间的差异翻译为 <code>MethodVisitor.visitXXX</code> 方法调用</li><li>使用 <code>AdviceAdapter</code>、<code>GeneratorAdapter</code> 等辅助类</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodVisitor</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitParameter</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> access)</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitAnnotationDefault</span><span class="hljs-params">()</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitAnnotation</span><span class="hljs-params">(String desc, <span class="hljs-type">boolean</span> visible)</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitTypeAnnotation</span><span class="hljs-params">(<span class="hljs-type">int</span> typeRef, TypePath typePath, String desc, <span class="hljs-type">boolean</span> visible)</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitParameterAnnotation</span><span class="hljs-params">(<span class="hljs-type">int</span> parameter, String desc, <span class="hljs-type">boolean</span> visible)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitAttribute</span><span class="hljs-params">(Attribute attr)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitCode</span><span class="hljs-params">()</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFrame</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">int</span> nLocal, Object[] local, <span class="hljs-type">int</span> nStack, Object[] stack)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitIntInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, <span class="hljs-type">int</span> operand)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitVarInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, <span class="hljs-type">int</span> <span class="hljs-keyword">var</span>)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitTypeInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, String type)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitFieldInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, String owner, String name, String desc)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitMethodInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, String owner, String name, String desc)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitMethodInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, String owner, String name, String desc, <span class="hljs-type">boolean</span> itf)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitInvokeDynamicInsn</span><span class="hljs-params">(String name, String desc, Handle bsm, Object... bsmArgs)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitJumpInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, Label label)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitLabel</span><span class="hljs-params">(Label label)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitLdcInsn</span><span class="hljs-params">(Object cst)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitIincInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">var</span>, <span class="hljs-type">int</span> increment)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitTableSwitchInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, Label dflt, Label... labels)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitLookupSwitchInsn</span><span class="hljs-params">(Label dflt, <span class="hljs-type">int</span>[] keys, Label[] labels)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitMultiANewArrayInsn</span><span class="hljs-params">(String desc, <span class="hljs-type">int</span> dims)</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitInsnAnnotation</span><span class="hljs-params">(<span class="hljs-type">int</span> typeRef, TypePath typePath, String desc, <span class="hljs-type">boolean</span> visible)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitTryCatchBlock</span><span class="hljs-params">(Label start, Label end, Label handler, String type)</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitTryCatchAnnotation</span><span class="hljs-params">(<span class="hljs-type">int</span> typeRef, TypePath typePath, String desc, <span class="hljs-type">boolean</span> visible)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitLocalVariable</span><span class="hljs-params">(String name, String desc, String signature, Label start, Label end, <span class="hljs-type">int</span> index)</span>    <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitLocalVariableAnnotation</span><span class="hljs-params">(<span class="hljs-type">int</span> typeRef, TypePath typePath, Label[] start, Label[] end, <span class="hljs-type">int</span>[] index, String desc, <span class="hljs-type">boolean</span> visible)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitLineNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> line, Label start)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitMaxs</span><span class="hljs-params">(<span class="hljs-type">int</span> maxStack, <span class="hljs-type">int</span> maxLocals)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitEnd</span><span class="hljs-params">()</span>&#125;<span class="hljs-comment">// 可以在方法的前面、后面或者前后织入字节码</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdviceAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GeneratorAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Opcodes</span> &#123;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodEnter</span><span class="hljs-params">()</span> &#123;&#125;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodExit</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> opcode)</span> &#123;&#125;&#125;</code></pre></div><h1 id="FieldVisitor"><a href="#FieldVisitor" class="headerlink" title="FieldVisitor"></a>FieldVisitor</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldVisitor</span> &#123;  <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitAnnotation</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String descriptor, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> visible)</span>  <span class="hljs-keyword">public</span> AnnotationVisitor <span class="hljs-title function_">visitTypeAnnotation</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> typeRef, <span class="hljs-keyword">final</span> TypePath typePath, <span class="hljs-keyword">final</span> String descriptor, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> visible)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitAttribute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Attribute attribute)</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitEnd</span><span class="hljs-params">()</span>&#125;</code></pre></div><h1 id="解析和访问-class"><a href="#解析和访问-class" class="headerlink" title="解析和访问 class"></a>解析和访问 class</h1><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> reader = ClassReader(<span class="hljs-string">&quot;java.lang.String&quot;</span>)    <span class="hljs-keyword">val</span> printer = ClassPrinter()    reader.accept(printer, <span class="hljs-number">0</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPrinter</span>: <span class="hljs-type">ClassVisitor</span>(ASM9) &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visit</span><span class="hljs-params">(version: <span class="hljs-type">Int</span>, access: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>?, signature: <span class="hljs-type">String</span>?, superName: <span class="hljs-type">String</span>?, interfaces: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;?)</span></span> &#123;        println(...)    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h1 id="构造-class"><a href="#构造-class" class="headerlink" title="构造 class"></a>构造 class</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 构造如下一个接口</span><span class="hljs-keyword">package</span> pkg; <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mesurable</span> &#123;   <span class="hljs-type">int</span> <span class="hljs-variable">LESS</span> <span class="hljs-operator">=</span>-<span class="hljs-number">1</span>;   <span class="hljs-type">int</span> <span class="hljs-variable">EQUAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-type">int</span> <span class="hljs-variable">GREATER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span>; &#125;<span class="hljs-comment">// 利用一个特殊的 Visitor：ClassWriter 来动态构造 class</span><span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>); cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class="hljs-string">&quot;pkg/Comparable&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;pkg/Mesurable&quot;</span> &#125;); cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="hljs-string">&quot;LESS&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(-<span class="hljs-number">1</span>)).visitEnd(); cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="hljs-string">&quot;EQUAL&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">0</span>)).visitEnd(); cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="hljs-string">&quot;GREATER&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>)).visitEnd(); cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class="hljs-string">&quot;compareTo&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/Object;)I&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>).visitEnd(); cw.visitEnd(); <span class="hljs-type">byte</span>[] b = cw.toByteArray();<span class="hljs-comment">// 可以将生成的 class 保存在 Comparable.class 文件里待将来加载和使用</span><span class="hljs-comment">// 也可以通过 ClassLoader.defineClass 直接将其加载进来</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;  <span class="hljs-keyword">public</span> Class <span class="hljs-title function_">defineClass</span><span class="hljs-params">(String name, <span class="hljs-type">byte</span>[] b)</span> &#123;          <span class="hljs-comment">// 将 defineClass 暴露出来</span>    <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);   &#125; &#125;<span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> myClassLoader.defineClass(<span class="hljs-string">&quot;pkg.Comparable&quot;</span>, b);    <span class="hljs-comment">// 直接加载进来</span></code></pre></div><h1 id="转换已有的-class（Transforming）"><a href="#转换已有的-class（Transforming）" class="headerlink" title="转换已有的 class（Transforming）"></a>转换已有的 class（Transforming）</h1><p>如下图所示，<code>ClassReader</code> + <code>ClassWriter</code> = 将原有的 class 复制一份</p><p><img src="../../../../image/2022-04-07-asm/transformation.png" alt="transformation.png"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] b1 = ...; <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>); <span class="hljs-type">ClassReader</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(b1); cr.accept(cw, <span class="hljs-number">0</span>); <span class="hljs-type">byte</span>[] b2 = cw.toByteArray();    <span class="hljs-comment">// b2 represents the same class as b1</span></code></pre></div><p>如下图，往中间插入 Visitor 就可以高效地修改原有的 class</p><p><img src="../../../../image/2022-04-07-asm/change_version_transformation.png" alt="change_version_transformation.png"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeVersionAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassVisitor</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChangeVersionAdapter</span><span class="hljs-params">(ClassVisitor cv)</span> &#123;     <span class="hljs-built_in">super</span>(ASM4, cv);   &#125;     <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> version, <span class="hljs-type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;     cv.visit(V1_5, access, name, signature, superName, interfaces);   &#125; &#125;<span class="hljs-type">byte</span>[] b1 = ... <span class="hljs-type">ClassReader</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(b1); <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(cr, <span class="hljs-number">0</span>); <span class="hljs-type">ChangeVersionAdapter</span> <span class="hljs-variable">ca</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangeVersionAdapter</span>(cw); cr.accept(ca, <span class="hljs-number">0</span>); <span class="hljs-type">byte</span>[] b2 = cw.toByteArray();</code></pre></div><h1 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// the following class adapter removes the information about outer and inner classes, as well as the name of the source file from which the class was compiled</span><span class="hljs-comment">// the resulting class remains fully functional, because these elements are only used for debugging purposes</span><span class="hljs-comment">// This is done by not forwarding anything in the appropriate visit methods</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDebugAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassVisitor</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-title function_">RemoveDebugAdapter</span><span class="hljs-params">(ClassVisitor cv)</span> &#123; <span class="hljs-built_in">super</span>(ASM4, cv); &#125;   <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitSource</span><span class="hljs-params">(String source, String debug)</span> &#123;&#125;   <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitOuterClass</span><span class="hljs-params">(String owner, String name, String desc)</span> &#123;&#125;   <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitInnerClass</span><span class="hljs-params">(String name, String outerName, String innerName, <span class="hljs-type">int</span> access)</span> &#123;&#125; &#125;<span class="hljs-comment">// 删除指定的函数</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveMethodAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassVisitor</span> &#123;   <span class="hljs-keyword">private</span> String mName;   <span class="hljs-keyword">private</span> String mDesc;     <span class="hljs-keyword">public</span> <span class="hljs-title function_">RemoveMethodAdapter</span><span class="hljs-params">( ClassVisitor cv, String mName, String mDesc)</span> &#123;     <span class="hljs-built_in">super</span>(ASM4, cv);     <span class="hljs-built_in">this</span>.mName = mName;    <span class="hljs-built_in">this</span>.mDesc = mDesc;   &#125;     <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;    <span class="hljs-keyword">if</span> (name.equals(mName) &amp;&amp; desc.equals(mDesc)) &#123;      <span class="hljs-comment">// do not delegate to next visitor-&gt; this removes the method </span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> cv.visitMethod(access, name, desc, signature, exceptions);   &#125; &#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://asm.ow2.io/asm4-guide.pdf">ASM User Guide</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>asm</tag>
      
      <tag>字节码</tag>
      
      <tag>插桩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排查 Launcher AppStore 静默安装 App 失败的问题</title>
    <link href="/2022/03/14/case-testonly/"/>
    <url>/2022/03/14/case-testonly/</url>
    
    <content type="html"><![CDATA[<p>Launcher 里的 AppStore 模块会根据服务端的配置安装/卸载 APP，当然用户也可以手动安装 AppStore 里的 APP</p><p>某天收到反馈，一个要上线的 APP【食材管理】静默安装总是失败，以往都是正常的</p><blockquote><p>静默安装是指 AppStore 自动在后台安装，无须用户手动点击安装</p><p>静默安装是通过广播 <code>android.intent.action.SILENCE_INSTALL</code> 实现的，由 ROM 鉴权和实现</p></blockquote><p>本地在 <code>YUNMI.21FACE-1.0.UniVer.071320_V8.1 绿联 6810 Android 5.1</code> 还原，我首先通过查询关键字 <code>SILENCE_INSTALL</code> 没找到有用的日志</p><div class="code-wrapper"><pre><code class="hljs bash">D/ActivityThread: BDC-Calling onReceive: intent=Intent &#123; act=android.intent.action.SILENCE_INSTALL flg=0x10 cmp=com.android.settings/.SilenceInstallApkReciver (has extras) &#125;, receiver=com.android.settings.SilenceInstallApkReciver@14f877adD/ActivityThread: BDC-RECEIVER handled : 0 / ReceiverData&#123;intent=Intent &#123; act=android.intent.action.SILENCE_INSTALL flg=0x10 cmp=com.android.settings/.SilenceInstallApkReciver (has extras) &#125; packageName=com.android.settings resultCode=-1 resultData=null resultExtras=null&#125;</code></pre></div><p>然后搜索包名 <code>com.viomi.materialassistant</code> 找到 <code>PackageManager</code> 的日志，看起来它的日志是有用的；但是它的日志里并没有错误出现，只是记录了安装过程中的各个阶段</p><p>况且我也不了解安装的具体流程，PMS 不用想就知道代码量巨大，直接从代码里找日志出现的地方不显示，所以决定跟正常的安装流程日志进行对比</p><div class="code-wrapper"><pre><code class="hljs bash">I/PackageManager: init_copy idx=0: InstallParams&#123;3488adaa file=/storage/emulated/0/viomi/com.viomi.materialassistant-debug-v20001.apk cid=null&#125;I/PackageManager: Trying to <span class="hljs-built_in">bind</span> to DefaultContainerServiceI/PackageManager: onServiceConnectedI/PackageManager: onServiceConnected: <span class="hljs-literal">true</span>, 0I/PackageManager: mcs_boundI/PackageManager: startCopy UserHandle&#123;0&#125;: InstallParams&#123;3488adaa file=/storage/emulated/0/viomi/com.viomi.materialassistant-debug-v20001.apk cid=null&#125;I/PackageManager: Apk copy <span class="hljs-keyword">done</span>I/PackageManager: Checking <span class="hljs-keyword">for</span> more work or unbind...I/PackageManager: Posting delayed MCS_UNBINDD/PackageManager: installPackageLI: path=/data/app/vmdl885444489.tmpI/PackageManager: Start parsing apk: nullI/PackageManager: Parsing <span class="hljs-keyword">done</span> <span class="hljs-keyword">for</span> apk: nullW/PackageManager: installPackageLII/PackageManager: mcs_checkI/PackageManager: mcs_check(<span class="hljs-literal">true</span>, 1)I/PackageManager: mcs_unbindI/PackageManager: calling disconnectService()I/PackageManager: disconnectService: <span class="hljs-literal">false</span></code></pre></div><p>这是一个正常的安装日志，第 10 行就是差异开始的地方，正常的安装会将 APP 复制到 /data/app/packagename 并进行 dexopt 生产本地代码，异常的流程完全没有这些后续操作且也没有异常日志出现</p><p>看来只好 <code>show me the code</code>，关键字是 <code>PackageManagerService</code> 和 <code>installPackageLI</code></p><div class="code-wrapper"><pre><code class="hljs bash">I/PackageManager(  980): init_copy idx=0: InstallParams&#123;23c92659 file=/data/local/tmp/com.viomi.materialassistant-debug-v20001.apk cid=null&#125;I/PackageManager(  980): Trying to <span class="hljs-built_in">bind</span> to DefaultContainerServiceI/PackageManager(  980): onServiceConnectedI/PackageManager(  980): onServiceConnected: <span class="hljs-literal">true</span>, 0I/PackageManager(  980): mcs_boundI/PackageManager(  980): startCopy UserHandle&#123;-1&#125;: InstallParams&#123;23c92659 file=/data/local/tmp/com.viomi.materialassistant-debug-v20001.apk cid=null&#125;I/PackageManager(  980): Apk copy <span class="hljs-keyword">done</span>I/PackageManager(  980): Checking <span class="hljs-keyword">for</span> more work or unbind...I/PackageManager(  980): Posting delayed MCS_UNBINDD/PackageManager(  980): installPackageLI: path=/data/app/vmdl1595486398.tmpI/PackageManager(  980): Start parsing apk: nullI/PackageManager(  980): Parsing <span class="hljs-keyword">done</span> <span class="hljs-keyword">for</span> apk: nullD/PackageManager(  980): manifestDigest was not present, but parser got: ManifestDigest &#123;mDigest=0d,c6,33,12,73,a9,31,fa,52,ea,e1,61,0a,f0,71,10,59,9a,49,67,f9,54,1a,1b,92,7e,cb,f1,b9,6c,c0,c6,&#125;D/PackageManager(  980): Renaming /data/app/vmdl1595486398.tmp to /data/app/com.viomi.materialassistant-1I/PackageManager(  980): Start installation <span class="hljs-keyword">for</span> package: nullD/PackageManager(  980): installNewPackageLI: Package&#123;33bad6f6 com.viomi.materialassistant&#125;I/PackageManager(  980): Linking native library <span class="hljs-built_in">dir</span> <span class="hljs-keyword">for</span> /data/app/com.viomi.materialassistant-1D/installd(  211): do_linklib : com.viomi.materialassistant /data/app/com.viomi.materialassistant-1/lib/arm 0I/PackageManager(  980): Perform pre-dex opt <span class="hljs-keyword">for</span> package: com.viomi.materialassistantI/PackageManager(  980): Running dexopt on: /data/app/com.viomi.materialassistant-1/base.apk pkg=com.viomi.materialassistant isa=arm vmSafeMode=<span class="hljs-literal">false</span>I/PackageManager(  980): Dexopt <span class="hljs-keyword">done</span> on: com.viomi.materialassistantW/PackageManager(  980): Skipping provider name com.viomi.materialassistant.provider (<span class="hljs-keyword">in</span> package com.viomi.materialassistant): name already used by com.viomi.materialassistantD/PackageManager(  980): New package installed <span class="hljs-keyword">in</span> /data/app/com.viomi.materialassistant-1W/PackageManager(  980): Unknown permission com.android.vending.CHECK_LICENSE <span class="hljs-keyword">in</span> package com.viomi.materialassistantW/PackageManager(  980): Unknown permission android.permission.SYSTEM_OVERLAY_WINDOW <span class="hljs-keyword">in</span> package com.viomi.materialassistantW/PackageManager(  980): Unknown permission com.google.android.c2dm.permission.RECEIVE <span class="hljs-keyword">in</span> package com.viomi.materialassistantI/PackageManager(  980): Installation <span class="hljs-keyword">done</span> <span class="hljs-keyword">for</span> package: nullV/PackageManager(  980): + starting restore round-trip 3V/PackageManager(  980): token 3 to BM <span class="hljs-keyword">for</span> possible restoreV/PackageManager(  980): BM finishing package install <span class="hljs-keyword">for</span> 3I/PackageManager(  980): mcs_checkI/PackageManager(  980): mcs_check(<span class="hljs-literal">true</span>, 1)I/PackageManager(  980): mcs_unbindI/PackageManager(  980): disconnectService: <span class="hljs-literal">false</span>I/PackageManager(  980): calling disconnectService()V/PackageManager(  980): Handling post-install <span class="hljs-keyword">for</span> 3I/PackageManager(  980): mcs_unbindI/PackageManager(  980): calling disconnectService()</code></pre></div><p>找到 PackageManagerService.java 文件，切换到 android-5.1.0_r5，搜索 <code>installPackageLI</code> 能找到如下代码片段</p><p>正常流程能走到 <code>manifestDigest was not present</code> 但异常流程在此之前被 <code>return</code> 中断了，那么就从这行代码往前找找看是什么逻辑触发 <code>return</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installPackageLI</span><span class="hljs-params">(InstallArgs args, PackageInstalledInfo res)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">installFlags</span> <span class="hljs-operator">=</span> args.installFlags;        <span class="hljs-type">String</span> <span class="hljs-variable">installerPackageName</span> <span class="hljs-operator">=</span> args.installerPackageName;        <span class="hljs-type">File</span> <span class="hljs-variable">tmpPackageFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(args.getCodePath());        <span class="hljs-type">boolean</span> <span class="hljs-variable">forwardLocked</span> <span class="hljs-operator">=</span> ((installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != <span class="hljs-number">0</span>);        <span class="hljs-type">boolean</span> <span class="hljs-variable">onSd</span> <span class="hljs-operator">=</span> ((installFlags &amp; PackageManager.INSTALL_EXTERNAL) != <span class="hljs-number">0</span>);        <span class="hljs-type">boolean</span> <span class="hljs-variable">replace</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">scanFlags</span> <span class="hljs-operator">=</span> SCAN_NEW_INSTALL | SCAN_FORCE_DEX | SCAN_UPDATE_SIGNATURE;        <span class="hljs-comment">// Result object to be returned</span>        res.returnCode = PackageManager.INSTALL_SUCCEEDED;        <span class="hljs-keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, <span class="hljs-string">&quot;installPackageLI: path=&quot;</span> + tmpPackageFile);        <span class="hljs-comment">// Retrieve PackageSettings and parse package</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parseFlags</span> <span class="hljs-operator">=</span> mDefParseFlags | PackageParser.PARSE_CHATTY                | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : <span class="hljs-number">0</span>)                | (onSd ? PackageParser.PARSE_ON_SDCARD : <span class="hljs-number">0</span>);        <span class="hljs-type">PackageParser</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageParser</span>();        pp.setSeparateProcesses(mSeparateProcesses);        pp.setDisplayMetrics(mMetrics);        <span class="hljs-keyword">final</span> PackageParser.Package pkg;        <span class="hljs-keyword">try</span> &#123;            pkg = pp.parsePackage(tmpPackageFile, parseFlags);        &#125; <span class="hljs-keyword">catch</span> (PackageParserException e) &#123;            res.setError(<span class="hljs-string">&quot;Failed parse during installPackageLI&quot;</span>, e);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// Mark that we have an install time CPU ABI override.</span>        pkg.cpuAbiOverride = args.abiOverride;        <span class="hljs-comment">// 终于找到你！虽然 PackageManager.INSTALL_FAILED_TEST_ONLY 是 -15，但是实际上并没有把 int 输出到 logcat</span>        <span class="hljs-comment">// 所以日志就出现了奇怪的一行 installPackageLI 不带任何错误代码！</span>        <span class="hljs-type">String</span> <span class="hljs-variable">pkgName</span> <span class="hljs-operator">=</span> res.name = pkg.packageName;        <span class="hljs-keyword">if</span> ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == <span class="hljs-number">0</span>) &#123;                res.setError(INSTALL_FAILED_TEST_ONLY, <span class="hljs-string">&quot;installPackageLI&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// setError 干了什么，往下可以看到会把错误输出到 logcat，然而异常流程也没有这行日志，所以不是这里 return 的</span>        <span class="hljs-keyword">try</span> &#123;            pp.collectCertificates(pkg, parseFlags);            pp.collectManifestDigest(pkg);        &#125; <span class="hljs-keyword">catch</span> (PackageParserException e) &#123;            res.setError(<span class="hljs-string">&quot;Failed collect during installPackageLI&quot;</span>, e);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 异常流程并没有出现 Comparing manifests: 这行日志，所以并不是在这里 return 的</span>        <span class="hljs-comment">/* If the installer passed in a manifest digest, compare it now. */</span>        <span class="hljs-keyword">if</span> (args.manifestDigest != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (DEBUG_INSTALL) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">parsedManifest</span> <span class="hljs-operator">=</span> pkg.manifestDigest == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;null&quot;</span>                        : pkg.manifestDigest.toString();                Slog.d(TAG, <span class="hljs-string">&quot;Comparing manifests: &quot;</span> + args.manifestDigest.toString() + <span class="hljs-string">&quot; vs. &quot;</span>                        + parsedManifest);            &#125;            <span class="hljs-keyword">if</span> (!args.manifestDigest.equals(pkg.manifestDigest)) &#123;                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, <span class="hljs-string">&quot;Manifest digest changed&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DEBUG_INSTALL) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">parsedManifest</span> <span class="hljs-operator">=</span> pkg.manifestDigest == <span class="hljs-literal">null</span>                    ? <span class="hljs-string">&quot;null&quot;</span> : pkg.manifestDigest.toString();            Slog.d(TAG, <span class="hljs-string">&quot;manifestDigest was not present, but parser got: &quot;</span> + parsedManifest);        &#125;        ...&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageInstalledInfo</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setError</span><span class="hljs-params">(<span class="hljs-type">int</span> code, String msg)</span> &#123;            returnCode = code;            returnMsg = msg;            Slog.w(TAG, msg);        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setError</span><span class="hljs-params">(String msg, PackageParserException e)</span> &#123;            returnCode = e.error;            returnMsg = ExceptionUtils.getCompleteMessage(msg, e);            Slog.w(TAG, msg, e);        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setError</span><span class="hljs-params">(String msg, PackageManagerException e)</span> &#123;            returnCode = e.error;            returnMsg = ExceptionUtils.getCompleteMessage(msg, e);            Slog.w(TAG, msg, e);        &#125;&#125;</code></pre></div><p>看来安装流程就是在这里被中断了：APK 带有 <code>FLAG_TEST_ONLY</code> 标识，但安装时缺少参数 <code>INSTALL_ALLOW_TEST</code></p><p>原来如此，我记得安装这种 test only 的包时 adb 要带上 -t 选项，也就说 <code>android.intent.action.SILENCE_INSTALL</code> 时没有开启 -t 选项</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == <span class="hljs-number">0</span>) &#123;        res.setError(INSTALL_FAILED_TEST_ONLY, <span class="hljs-string">&quot;installPackageLI&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre></div><p><img src="../../../../image/2022-03-14-case-testonly/01.png" alt="01.png"></p><p>把 AppStore 上的 APK 下载下来看下，果然 <code>testOnly=”true”</code>，看来是不小心上传错安装包了（这里是测试环境，所以不要求放 release 包，debug 包也是可以的）</p>]]></content>
    
    
    
    <tags>
      
      <tag>case</tag>
      
      <tag>案例</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】今日头条 ANR 优化实践系列（5）- 告别 SharedPreference 等待</title>
    <link href="/2022/02/16/toutiao-anr-sharedpreference/"/>
    <url>/2022/02/16/toutiao-anr-sharedpreference/</url>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>前面系列文章（详见文末）中介绍了安卓系统 ANR 设计原理以及我们在实际工作中对 ANR 进行监控得到的方案，基于常规的监控治理方案，ANR 问题得到了有效的抑制，但是有些系统组件的设计初衷与开发人员在实际使用过程中实际使用的背离，导致的冲突问题亟待解决，当前文章针对实际开发过程中滥用 sp 导致的 ANR 问题，如何从系统层面跳过 Google 设计缺陷，规避 ANR 问题。</p><p>Google 在设计之初为了方便开发者，实现了一套轻量级的数据持久化方案——SharedPreference（以下简称 sp），因为其简便的 API，方便的使用方式，得到开发者的青睐，对其依赖越来越重。在应用版本不断迭代的过程中发现 Google 说的轻量级的数据存储是有原因的，越是重量级的应用出现的 ANR 问题越严重。本文从源码层面分析在加载和写入过程中，导致 ANR 问题的原因以及相关的优化解决方案。</p><h1 id="SP-导致-ANR-原因分析"><a href="#SP-导致-ANR-原因分析" class="headerlink" title="SP 导致 ANR 原因分析"></a>SP 导致 ANR 原因分析</h1><p>经常会遇到两类关于 SharedPreference 问题，以下分别介绍导致这两类 ANR 问题的原因和优化方案。</p><p>问题一：sp 文件创建以后，会单独的使用一个线程来加载解析对应的 sp 文件。但是当 UI 线程尝试访问 sp 中内容时，如果 sp 文件还未被完全加载解析到内存，此时 UI 线程会被 block，直到 SP 文件被完全加载到内存中为止。具体 ANR 线程堆栈如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/1.webp" alt="1.webp"></p><p>主要原因是 SP 文件未被加载或解析到内存中，此时无法直接使用 sp 提供的接口。sp 被创建的时候会同时启动一个线程加载对应的 sp 文件，执行 startLoadFromDisk();</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/2.webp" alt="2.webp"></p><p>在 startLoadFromDisk()时，标记 sp 不可使用状态，后期无论是尝试读数据或者写数据，读写线程都会被 block，直到 sp 文件被全部加载解析完毕。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/3.webp" alt="3.webp"></p><p>线程在读或写时，都会走到 awaitLoadedLocked()逻辑，在上图的 mLoaded 为 false 即 sp 文件尚未加载解析到内存，此时读写线程会直接被 block 到 mLock 锁上，直到 loadFromDisk()方法执行完毕。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/4.webp" alt="4.webp"></p><p>sp 文件完全加载解析到内存中，直接唤起所有在等待在当前 sp 的读写线程。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/5.webp" alt="5.webp"></p><p>问题二：Google 系统为了确保数据的跨进程完整性，前期应用可以使用 sp 来做跨进程通信，在组件销毁或其他生命周期的同时为了确保当前这个写入任务必须在当前这个组件的生命周期完成写入，此时主线程会在组件销毁或者组件暂停的生命周期内等待 sp 完全写入到对应的文件中，如下图 UI 线程被 block 在了 QueuedWork.waitToFinish()处，接下来基于源码从 apply 开始到最后写入文件整体流程梳理找出问题根源。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/6.webp" alt="6.webp"></p><p>具体需要等待文件写入的消息在 AcitivtyThread 的 H 中，具体消息类型如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVICE_ARGS</span> <span class="hljs-operator">=</span> <span class="hljs-number">115</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP_SERVICE</span> <span class="hljs-operator">=</span> <span class="hljs-number">116</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAUSE_ACTIVITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">101</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP_ACTIVITY_SHOW</span> <span class="hljs-operator">=</span> <span class="hljs-number">103</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SLEEPING</span>  <span class="hljs-operator">=</span> <span class="hljs-number">137</span>;</code></pre></div><p>由于 Google 官方设计之初是轻量级的数据存储方式，这种等待行为不会有什么问题，但是实际使用过程中由于 sp 过度使用，这个等待的时间被不可控的拉长，直到最后出现 ANR，这种问题越在业务繁重的应用上体现越明显。具体问题堆栈如下，全是系统堆栈，接下来从 waitToFinish 入手分析，剖析这个 ANR 的根源。具体 ANR 堆栈如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/7.webp" alt="7.webp"></p><p>前期 sp 接口只有 commit 接口，接口同步写入文件，这个接口直接影响开发者使用，于是 Google 官方对外提供了异步的 apply 接口，由于开发者认为这个异步是真正意义上的异步，大规模的使用 sp 的 appy 接口，就是这种 apply 的实现方式导致了业务量大的 APP 深受这个 apply 设计缺陷导致的 ANR 问题影响。</p><p>apply 接口整体的详细设计思路如下图（基于 Android8.0 及以下版本分析）：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/8.webp" alt="8.webp"></p><p>整体的思路简单梳理如下：</p><ol><li><code>sp.apply()</code>，写入内存同时得到需要同步写入文件的数据集合 <code>MemoryCommitResult</code>：</li></ol><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/9.webp" alt="9.webp"></p><ol start="2"><li><p>将 <code>MemoryCommitResult</code> 封装成 <code>Runnable</code> 抛到子线程 queued-work-looper 中；</p></li><li><p>在子线程中将 MemoryCommitResult 中的 mapToWriteToDisk 对应的 key-value 写入到文件中去；</p></li><li><p>文件写入完成以后，会执行 MemoryCommitResult 的 setDiskWriteResult 方法，关键的步骤 <code>writtenToDiskLatch.countDown()</code> 出现了；</p></li><li><p>如下当主线中执行到 QueuedWork.waitToFinish()的时候；</p></li></ol><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/10.webp" alt="10.webp"></p><ol start="6"><li>主线程到底在干什么，这个时候得从 QueuedWork.add(Runnable finisher)入手，具体 Runnable 如下图，这个地方就是啥也没干，直接等在了 mcr.writtenToDiskLatch.await()上，这里大家应该有点印象，就是步骤 4 中子线程在写完文件以后直接释放的那个锁</li></ol><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/11.webp" alt="11.webp"></p><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>尽管整体 API 的流程分析异常的复杂，把一个 runnable 封装了一层又一层，从这个线程抛到那个线程，子线程执行完写入文件以后会释放锁，主线程执行到某些地方得等待子线程把写入文件的行为执行完毕，但是整体的思路还是比较简单的。造成这个问题的根源就是太多 pending 的 apply 行为没有写入到文件，主线程在执行到指定消息的时候会有等待行为，等待时间过长就会出现 ANR。</p><p>尽管 Google 官方在 Android 8.0 及以后版本对 sp 写入逻辑进行优化，期望是在上述步骤 6 中 UI 线程不是傻傻的等，而是帮助子线程一起写入，但是由于是保守协助，并没有很好的解决这个问题。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><p>针对加载很慢的问题，一般使用的比较多的是采用预加载的方式来触发到这个 sp 文件的加载和解析，这样在真正使用的时候大概率 sp 已经加载解析完毕了；真正需要处理的是核心场景的 sp 一定不能太大，Google 官方的声明还是有必要遵守一下，轻量级的数据持久化存储方式，不要存太多数据，避免文件过大，导致前期的加载解析耗时过久。</p><h2 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h2><p>至于 Google 为什么要这么设计，提出了自己的几个猜想：</p><ol><li>Google 希望做到数据可能尽可能及时的写入文件，但是这样等待没有任何意义，主线程直接等待并不会提升写入的效率；</li><li>期望 sp 实时写入文件，以方便跨进程的时候可以实时的访问到 sp 内的文件，这种异步写入方式本身就没办法确保实时性；</li><li>可能是在组件发生状态切换的时候，这个时候如果进程内没有啥组件，进程的优先级可能降低，存在进程会在系统资源吃紧的时候被系统干掉，这种概率极低，几乎可以忽略不计；</li><li>感觉最大的可能性就是 Google 官方当时是为了从 commit 无缝的切换到 apply，依然模拟原来的 commit 行为，只是将原来的每次写入文件一次改成多次 commit 行为最后一次性 apply 在主线程等待所有的写入行为一次性全部写入。</li></ol><p>通过以上假设，发现这里的主线程等待子线程写入根本没有什么意义，因此希望可以通过一些必要的手段跳过这种无用的等待行为，在研究了所有的 SharedPreference 相关的逻辑后找到以下入手点。以下是 8.0 以下版本的优化策略，8.0 及以上版本处理方式类似：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/12.webp" alt="12.webp"></p><p>如果需要主线程在 waitToFinish 的时候直接跳过去，让 toTinish.run()执行完毕，显然不可能，如果能让 sPendingWorkFinishers.poll()返回为 null，则这里的等待行为直接就跳过去了，sPendingWorkFinishers 是个 ConcurrentLinkedQueue 集合，可以直接动态代理这个集合，复写 poll 方法，让其永远返回 null，这个时候 UI 永远不会等待子线程写入文件完毕。事实证明这种方式简单有效。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-sharedpreference/13.webp" alt="13.webp"></p><p>针对这种写入等待的 ANR 问题，还有一种就是全局替换写入方式，通过插桩的方式，替换所有的 API 实现，采用其他的存储方式，这种方式修复成本和风险较大，但是后期可以随机的替换存储方式，使用比较灵活。</p><h1 id="方案收益"><a href="#方案收益" class="headerlink" title="方案收益"></a>方案收益</h1><p>通过在字节系多个产品的验证，方案稳定有效，相应堆栈导致的 ANR 问题消灭殆尽，ANR 收益明显，相应的界面跳转等场景流畅性得到了明显的改善。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>Google 新增加了一个新 Jetpack 的成员 DataStore，主要用来替换 SharedPreferences， DataStore 应该是开发者期待已久的库，DataStore 是基于 Flow 实现的，一种新的数据存储方案。详细介绍网上有很多参考资料。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247488558&idx=1&sn=27dda3c3630116d37ab56a8c7bdf1382">今日头条 ANR 优化实践系列 - 告别 SharedPreference 等待</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>bytedance</tag>
      
      <tag>toutiao</tag>
      
      <tag>字节</tag>
      
      <tag>头条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】今日头条 ANR 优化实践系列（4）- Barrier 导致主线程假死</title>
    <link href="/2022/02/16/toutiao-anr-barrier/"/>
    <url>/2022/02/16/toutiao-anr-barrier/</url>
    
    <content type="html"><![CDATA[<h1 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h1><p>前文，我们通过线上案例对影响 ANR 问题的六大场景进行剖析，这几类场景基本覆盖了线上大部分问题，详见 <a href="../../../../2022/02/16/toutiao-anr-samples/">ANR 案例分析集锦</a>。同时我们选取了较多 NativePollOnce 场景的案例，便于大家更好理解，ANR 时看到的 NativePollOnce 场景的问题，并不是导致 ANR 的根本问题。</p><p>下面要介绍的这类问题，Trace 现场依然是 NativePollOnce 信息，但与前几类问题不同的是，这类问题真的发生在 NativePollOnce 场景，接下来就看看到底是什么原因导致的。</p><h1 id="主线程-Trace-堆栈："><a href="#主线程-Trace-堆栈：" class="headerlink" title="主线程 Trace 堆栈："></a>主线程 Trace 堆栈：</h1><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/1.webp" alt="1.webp"></p><h1 id="分析思路："><a href="#分析思路：" class="headerlink" title="分析思路："></a>分析思路：</h1><p>针对该类问题，当看到这个信息时，第一判断依然是主线程历史消息耗时严重，或者系统负载过重导致的问题，因为工作日常分析了太多这类场景的 ANR 问题，而且最后的结论也证明都与此场景无关。但分析这个问题时，进一步拆解大盘指标发现一段时间内 ANR 增加的量级，基本全部落在这个场景，这不太符合我们的预期。但是鉴于 Trace 信息有限，只好把目光转移到系统侧，看看是否有线索。</p><h2 id="分析系统-amp-进程负载："><a href="#分析系统-amp-进程负载：" class="headerlink" title="分析系统&amp;进程负载："></a>分析系统&amp;进程负载：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/2.webp" alt="2.webp"></p><ul><li><p>观察系统负载： 在 ANR Info 中查看 Load 关键字，发现系统在前 1 分钟，前 5 分钟，前 15 分钟各个时段负载并不高。</p></li><li><p>观察进程 CPU 分布： 进一步观察 <code>&quot;CPU usage from 0 ms to 24301 later&quot;</code>，看到 ANR 之后这 24S 多的时间，应用主进程 CPU 占使用率只有 15%，但是 com.meizu.mstore 应用 CPU 使用率达到 92%，user 与 kenel 比例分别为 71%，20%。与此同时 kswapd,mmc-cmdqd 等内核线程 CPU 使用率并不高，说明系统负载总体正常。如果根据我们前面 <a href="../../../../2022/02/16/toutiao-anr-samples/">案例分析</a> 得出的结论来看，这种场景难道是 com.meizu.mstore 进程严重抢占 CPU 导致的？带着这个疑惑，继续观察系统 CPU 分布。</p></li><li><p>观察系统 CPU 分布：</p></li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/3.webp" alt="3.webp"></p><p>进一步分析系统负载，发现整体 CPU 使用率稍微有些高。user 占比 37%，kernel 占比 24%，iowait 占比 6.9%，说明这段时间系统 IO 确实有些繁忙。</p><p>系统侧结论： 通过观察系统负载和各个进程的 CPU 使用情况，发现系统环境比较正常，但是 com.meizu.mstore 进程 CPU 占比偏高，而且 kernel 层 cpu 使用率(20%)较高，与系统 iowait (6.9%)占用较高可能存在一定关联，那么 IO 负载较高对当前应用有多大影响呢？我们回到应用侧进一步分析。</p><h2 id="应用侧分析："><a href="#应用侧分析：" class="headerlink" title="应用侧分析："></a>应用侧分析：</h2><p>根据上面的分析，我们将方向再回到当前进程，通过对比各线程 cpu 耗时(utm+stm)，并没有看到某个线程存在明显异常。<strong>主线程 CPU 执行时长 utm:187，stm:57，基本正常</strong>。</p><p>在分析对比完线程 CPU 耗时之后，将目光再次聚焦到 <a href="(../../../../2022/02/16/toutiao-anr-tools/)">Raster 监控工具</a> 的调度时序图上面。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/4.webp" alt="4.webp"></p><p>通过该时序图，观察以下三类信息特征：<strong>ANR 前的历史消息，正在执行的消息，被 Block 的消息</strong>：</p><ul><li><p>历史消息： 主线程并不存在单次历史消息耗时严重的现象。</p></li><li><p>当正在执行的消息：正在执行的消息 Wall Duration 为 21744ms，CPU Duration 为 100ms。也就是说大量的时间发生在等待的场景，结合该场景，如果期间是因为执行 Idle Task 导致的耗时严重或长时间 Wait，那么 ANR 抓取的堆栈应该有 IdleTask 相关信息才对，因此首先排除了是 Idle Task 耗时严重导致的问题。</p></li><li><p>被 Block 消息：从上图可以看到， 第一个待调度的消息被 block 时长为 22343ms，其 block 时长基本等于当前正在执行消息的 Wall Duration 时长。也就说明了本场景大量消息 blcok 是受到了当前正在执行的消息影响。</p></li></ul><p>分析到这里我们就有些困惑了，ANR 发生时当前正处于 NativePollOnce 场景，但是前面我们多次在案例分析中提到，进入 NativePollOnce 场景的条件是：消息队列没有立刻调度的消息时，会有条件的进入 wait 状态，等到超时或者新消息加入时会唤醒该线程并执行，但是从上图可以看到消息队列中存在大量待调度消息，而且很多消息都被 block 了 20 多 S，既然这么多消息可以被调度，那么系统为何还是一直在 NativePollOnce 环境中呢？难道真的是底层发生了问题，导致无法唤醒当前线程？</p><p>带着这个疑惑，我们陆续分析了同段时间内其他用户上报的问题，发现存在同样的现象：NativePollOnce 场景的 WallDuration 普遍较长，有的甚至超过了 100S，但是 Cpu 时长很短。如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/5.webp" alt="5.webp"></p><p>为此我们第一反应是系统出问题了？但是进一步对比来看，该类现象只在某个版本之后明显增加，而之前的版本并没有这类现象，如果是厂商更新 rom 导致的问题，应该影响全版本，甚至会影响所有应用，但事实并非如此，因此这与我们的推测并不符合，无法自圆其说。</p><p>按照我们的理解，如果直接进入 NativePollOnce 场景并且一直没有唤醒的话，那么 CPU Duration 应该会很少，并不应该是这样表现(CPU Duration 达到或超过 100ms)。</p><h1 id="定向监控："><a href="#定向监控：" class="headerlink" title="定向监控："></a>定向监控：</h1><p>考虑到国内厂商对 Rom 定制化的习惯，为了确认上面监控的 Cpu 耗时是否是厂商在底层定制产生的耗时，我们在 Native 层通过 Hook 代理对 nativePollOnce 接口进行了监测。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/6.webp" alt="6.webp"></p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/7.webp" alt="7.webp"></p><p>在线上小范围验证和复现，通过观察这类 ANR 问题时的线程调度时序图，最终找到一个 NativePollOnce 停留时长高达 100S 的案例，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/8.webp" alt="8.webp"></p><p>通过上图(TYPE=5)可以发现，ANR 发生前，主线程在消息调度结束与下次消息调度开始前，发生多次长时间停留的现象，而且期间都存在一定的 Cpu 耗时，但是远小于 Wall duration。与此同时查看本次进行 epoll_wait 期间，NativePollOnce 是否是一直没有返回，通过监控输出的日志，发现如下现象：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/9.webp" alt="9.webp"></p><p>在对齐监控时序图与上图日志时间戳之后，看到 Java 层调用 looper.next()获取下一个消息过程中，Native 层 NativePollOnce 接口调用了多次，而且每次进入 epollwait 时传入的参数 timeout 为-1。分析到这里有些疑惑了，这并不是我们预期的一直 wait 场景啊，参数-1 代表什么意思呢？继续向下看。</p><h2 id="MessageQueue-代码分析："><a href="#MessageQueue-代码分析：" class="headerlink" title="MessageQueue 代码分析："></a>MessageQueue 代码分析：</h2><p>既然 ANR 这段时间，执行多次 NativePollOnce，就说明其它线程已经多次将主线程多次从 epoll wait 状态唤醒，但是消息队列已经有大量待调度的消息，为何主线程还依然停留在 looper.next()内部呢？分析到这里只好再次回到上层代码继续分析，这个参数-1 是哪里设置的。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/10.webp" alt="10.webp"></p><p>从上图可以看到，每当消息执行结束后，获取下个消息之前会先主动调用一次 NativePollOnce，但是 nextPollTimeoutMillis 默认为 0，并不是底层接口代理时看到的-1，那么这个-1 是哪里传入的呢？继续向下看。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/11.webp" alt="11.webp"></p><p>通过上图可以看到，只有一个地点将 nextPollTimeoutMillis 设置为-1，但是通过注释可以清晰的看到提示”msg=mMessage”，没有消息？这与现实严重不符啊，ANR 发生时，消息队列明显有很多消息待执行，这里却提示”msg=mMessage”。</p><p>通过进一步观察上述逻辑发现，该提示发生在 else 分支，如果进入到该分支，那么则说明 msg 对象获取为空，但是在上面明明看到赋值过程”msg=mMessage”，而且当前这种场景 mMessage 肯定不为 null，毕竟在 ANR 时获取的待调度消息也是通过 mMessage 遍历得到的。</p><p>既然 mMessage 不是 null，那么就说明”msg=mMessage”肯定不是 null，但是到了下面却为 null，说明在此过程肯定被某个逻辑给重新赋值了，继续分析。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/12.webp" alt="12.webp"></p><p>通过上图可以看到只有这个场景可能将 msg 重新赋值，那么这部分逻辑是做什么的呢？</p><h2 id="Barrier-机制介绍："><a href="#Barrier-机制介绍：" class="headerlink" title="Barrier 机制介绍："></a>Barrier 机制介绍：</h2><p>看到上面的注释瞬间明白了，原来是 Barrier 机制，是 Android 系统用来保障部分系统消息高优调度的一种机制，实现原理很简单：会在每次消息返回前，检测该消息是否是 barrier 消息，barrier 消息的典型特征就是 msg.target 对象为 null，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/13.webp" alt="13.webp"></p><p>如果是 Barrier 消息，那么将对消息队列中的消息进行遍历，找到第一个异步消息，然后将其赋值给 msg。但是如果遍历了所有的消息都没有找到异步消息，那么最后一个消息 msg.next 肯定为 null，此时 msg 会被置为 null，并退出循环。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/14.webp" alt="14.webp"></p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/15.webp" alt="15.webp"></p><p>上图为异步消息的设置和判断是否是异步消息的接口实现，我们日常创建的 Message 是不会设置该属性的。只有系统在某些特殊场景，如 UI 刷新，为了保障交互体验，会在请求 vsync 信号前，先发送一个 barrier 消息，然后等到 barrier 消息执行时，遍历 vsync 消息并将其强制调整到头部，以保证该类消息的响应能力：barrier 消息设置和移除，实现逻辑如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/16.webp" alt="16.webp"></p><p>通过上面实现可以看到，barrier 消息是不会主动移除的，需要设置 barrier 消息的业务消息得到响应后主动移除该消息，否则 barrier 消息会一直存在！</p><p>分析到这里就可以很好的解释为何在 MessageQueue.next()接口内部多次调用 NativePollOnce 了，一定是当前的 mMessage 是个 barrier 消息，但是与其关联的业务消息一直没有出现，或者执行之后没有同步移除该消息，导致该 barrier 消息一直处于消息队列头部，每次获取下一个消息时，都被 barrier 拦截和并遍历异步消息，如果有异步消息则响应，没有异步消息则通过 nativePollOnce 进行等待，从而阻塞了正常消息的调度和响应！</p><p>进一步梳理 MessageQueue.next 接口执行逻辑，通过下图就可以清晰的看到我们在 Native 层 Hook 时看到 nextPollTimeMills 传参-1 的场景是怎么设置的。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/17.webp" alt="17.webp"></p><p>那么结合本类 ANR 问题，消息队列第一个待调度的消息是不是 barrier 消息呢？我们再次找到上面分析的案例，通过监控时序图观察第一个被 block 的消息。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/18.webp" alt="18.webp"></p><p>通过上图可以清晰的看到，当前消息 target 对象为 null，正是 barrier 消息！破案了！</p><h2 id="连锁反应："><a href="#连锁反应：" class="headerlink" title="连锁反应："></a>连锁反应：</h2><p>按照上面的分析，<strong>如果 barrier 消息没有及时移除，那么每次通过 MessageQueue.next()查询时，只能过滤并返回带有异步属性的消息，如用户点击消息 input，vsync 消息等等</strong>。 即使用户交互和 UI 刷新消息可以正常执行，但是大量业务消息无法执行，这就导致了 UI 展示可能存在异常或功能异常，并且应用 service，receiver 等消息并没有异步属性，因此也会被 block，最终造成响应超时发生 ANR！</p><p>结合当前问题，我们发现该用户在第一次 ANR 不久之后再次发生 ANR，主线程 Trace：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/19.webp" alt="19.webp"></p><p>第二次 ANR 时，对应的调度时序图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/20.webp" alt="20.webp"></p><p>通过当前用户连续 2 次 ANR 的消息调度监控时序图可以看到，本次 ANR 时，之前的历史消息记录没有发生任何变化，也就是说第一个 ANR 发生后确实没有再调度其他消息，但 2 次 ANR 的 WallTime 间隔超过 40S，也就是说这 40S 时间里，主线程确实一直 Block 在当前场景！</p><p>在消息调度时序图上进一步对比分析，发现两次 ANRCase，<strong>主线程当前正在执行消息的 Cpu Time 时长却发生了变化，即从 100ms 增加 450ms</strong>。那么这个数据是否置信吗？</p><p>结合这两次 ANR，分别分析一下 ANR Trace 主线程 utm+stm 的耗时(见上图 2 次 Trace 堆栈)：</p><p><strong>发生第一次 ANR 时线程状态及 utm,stm 耗时：</strong></p><div class="code-wrapper"><pre><code class="hljs shell">state=S schedstat=( 2442286229 338070603 5221 ) utm=187 stm=57 core=5 HZ=100</code></pre></div><p><strong>发生第二次 ANR 时线程状态及 utm,stm 耗时：</strong></p><div class="code-wrapper"><pre><code class="hljs shell">| state=S schedstat=( 2796231342 442294098 6270 ) utm=202 stm=77 core=5 HZ=100</code></pre></div><p><strong>用第二次发生 ANR 时的 utm+stm 减去第一次 ANR 时的 utm+stm，即 202+77-(187+57)=35ms。这个值对应的是 cpu 时间片，utm,stm 单位换算成时间单位为 1 比 10ms，即 35*10=350ms。这个值恰好等于 Raset 监控工具统计到的两次 Cputime 差值：450ms-100ms=350ms</strong>。</p><p>说明在此期间消息队列增加了多个消息，因为每次增加一个消息，主线程都会从 epollwait 场景唤醒，然后回到 java 环境对消息队列进行遍历，判断是否有异步消息，如果没有找到，则再次进入 epollwait 状态，如此反复，从而导致了上述现象！</p><h2 id="问题初定位："><a href="#问题初定位：" class="headerlink" title="问题初定位："></a>问题初定位：</h2><p>通过上面的层层分析，我们知道了是 barrier 同步机制出现了问题，导致消息调度发生异常，即：在 barrier 消息没有被移除之前，主线程只能处理 asyncronous 属性的消息，这类消息通常是用来刷新的 vsync 消息，以及响应用户交互的 input 消息，但是正常的业务消息及其他系统消息则无法正常调度，如 Serivce，Receiver 具体超时行为的消息，因此导致了 ANR。</p><h1 id="定位及修复："><a href="#定位及修复：" class="headerlink" title="定位及修复："></a>定位及修复：</h1><p>在定位到原因之后，接下来就是找到问题并解决问题，具体什么样的改动会引起这里问题了，通过分析我们知道既然是 Barrier 消息同步的问题，那么我们可以在设置 barrier 和移除 barrier 的过程加入监控，判断哪里设置了 barrier 消息，但是没有同步移除。通过 Java hook 代理了 MessageQueue 的 postSyncBarrier 和 removeSyncBarrier 接口，进行 Barrier 消息同步监测，遗憾的是线下并没有复现。</p><p>因此只能再次回到代码层面，对相关改动进行分析，最终在一笔需求提交中发现了线索。</p><p><strong>逻辑调整前</strong>： 先移除将要强制调度的并设置了异步属性的消息，再强制调度该消息，以保证该消息不受 barrier 消息之前的消息 block，进而提高响应能力。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (hasMsg) &#123;    ......    handler.removeCallbacks(message.getCallback()); <span class="hljs-comment">//先移除</span>    handler.dispatchMessage(cloneMsg); <span class="hljs-comment">//再强制调度该消息</span>    ......&#125;</code></pre></div><p><strong>逻辑调整后</strong>： 先强制调度该消息，然后再将该消息从队列中移除。</p><div class="code-wrapper"><pre><code class="hljs java">......    handler.dispatchMessage(newMessage); <span class="hljs-comment">//先强制调度</span>   handler.removeCallbacks(message.getCallback());  <span class="hljs-comment">//从队列中移除消息</span>......&#125;</code></pre></div><p><strong>但是时序调整后存在一定隐患，即在强制调用 DoFrame 消息期间，业务可能会再次触发 UI 刷新逻辑，产生 barrier 消息并发出 vsync 请求，如果系统及时响应 vsync，并产生 DoFrame 消息，那么调用 removeCallbacks 接口会一次性清除消息队列中所有的 DoFrame 消息，即：移除了消息队列之前的 DoFrame 消息和下次待调度的 DoFrame 消息，但是与下次 DoFrame 消息同步的 barrier 消息并没有被移除</strong>。</p><p>那么为什么会移除多个消息呢？这就要从handler.removeCallbacks 的实现说起了。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/21.webp" alt="21.webp"></p><p>进一步查看 messageQueue.removeMessages 接口实现，发现该接口会遍历消息队列中符合当前 runnable 以及 object 的消息，但是上面传递的 Object 对象是 null，因此就相当于移除了当前 Handler 对象下面所有相同 runnable 对象的消息！</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/22.webp" alt="22.webp"></p><p>因为强制刷新和时序调整的问题，导致了消息队列中同时存在 2 个 UI doFrame 消息，并在强制执行之后被同时移除，<strong>从而导致一个无人认领的 barrier 消息一直停留在消息队列</strong>！</p><p>其它场景：此外，除了上面遇到的场景会导致这类问题之外，还有一种场景也可能会导致这类问题，即:UI 异步刷新，尽管 Android 系统禁止异步刷新，并利用 checkThread 机制对 UI 刷新进行线程检查，但是百密一疏，如果开启硬件加速，<strong>在 Android O 及之后的版本会间接调用 onDescendantInvalidated 触发 UI 刷新，该逻辑躲过了系统 checkThread 检查，将会造成线程并发隐患。如下图，如果并发执行则会导致前一个线程的 mTraversalBarrier 被覆盖，从而导致 vsync 消息与 barrier 出现同步问题</strong>。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/23.webp" alt="23.webp"></p><p>查看 Android Q 源码，看到 <strong>onDescendantInvalidated 内部加上了 checkThread，但被注释掉了！解释如下：修复摄像头后重新启用或者通过 targetSdk 检查？好吧，或许是忘记这个 TODO 了</strong>。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-barrier/24.webp" alt="24.webp"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>至此，我们完成了该类问题的分析和最终定位，综合来看该类问题因 Trace 场景(NativePollOnce)和问题本身的高度隐蔽性，给排查和定位带来了极大挑战，如果单纯依靠系统提供的日志，是很难发现 MessageQueue.next()内部发生了异常。这里我们通过 Raster 监控工具，还原了问题现场，并提供了重要线索。现在总结来看，该类问题其实具有很明显的特征，表现在以下几个方面：</p><ul><li>问题场景 ANR Trace 集中聚合在 NativePollOnce，此过程 Wall duration 持续很长，并且屏蔽了后续所有正常消息调度，看起来像主线被冻结一样。</li><li>通过 Raster 监控工具可以清晰的看到，消息队列中如果第一个待消息 target 为 null，即为 barrier 消息，可以通过后续消息 block 时长评估影响程度。</li><li>出现该类问题时，因为正常消息无法被调度，如 Service，Receiver 消息，将会导致应用连续发生 ANR，直到用户主动 Kill 该进程。</li></ul><h1 id="后续："><a href="#后续：" class="headerlink" title="后续："></a>后续：</h1><p>接下来的文章中，我们将会介绍系统服务与客户端 binder 通信过程中，因为时序颠倒引起的 ANR 问题，因为是系统机制出现了 bug，理论上所有应用都会受到影响，问题表现同样很隐蔽，那么这类问题到底是什么样的表现呢？敬请期待。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247488314&idx=1&sn=559e52288ae2730a580fcd550f22d895&chksm=e9d0d8d8dea751ceecb715d472796f0c678a9358abf91eb279cdb0576329595e87531e221438&token=302589779&lang=zh_CN&scene=21#wechat_redirect">今日头条 ANR 优化实践系列 - Barrier 导致主线程假死</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>bytedance</tag>
      
      <tag>toutiao</tag>
      
      <tag>字节</tag>
      
      <tag>头条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】今日头条 ANR 优化实践系列（3）- 实例剖析集锦</title>
    <link href="/2022/02/16/toutiao-anr-samples/"/>
    <url>/2022/02/16/toutiao-anr-samples/</url>
    
    <content type="html"><![CDATA[<h1 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h1><p>在前文，我们用了较多的篇幅介绍了 <a href="../../../../2022/02/16/toutiao-anr-principle/">ANR 设计原理及影响因素</a>，并根据不同场景进行了分类，如：当前消息严重耗时，历史消息耗时严重，业务异常密集执行，进程内资源抢占，进程间资源抢占等场景。为了应对系统监控能力不足以及应用侧获取信息受限的情况，我们在应用侧实现了一套 <a href="../../../../2022/02/16/toutiao-anr-tools/">消息调度监控工具</a>，重点监控主线程的“过去，现在和将来”，同时结合相关日志对 ANR 问题的分析思路进行了总结。</p><p>为了便于大家更好的理解上述知识，接下来我们将结合工作中遇到的一些比较有代表性的问题，并按照前文归因分类，由浅入深进行实例解剖，下面就来看看这几类问题，我们是如何借助系统日志和监控工具进行分析及定位的。</p><h1 id="案例一：当前业务耗时严重"><a href="#案例一：当前业务耗时严重" class="headerlink" title="案例一：当前业务耗时严重"></a>案例一：当前业务耗时严重</h1><h2 id="主线程-Trace-堆栈："><a href="#主线程-Trace-堆栈：" class="headerlink" title="主线程 Trace 堆栈："></a>主线程 Trace 堆栈：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/1.webp" alt="1.webp"></p><h2 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h2><h3 id="分析堆栈："><a href="#分析堆栈：" class="headerlink" title="分析堆栈："></a>分析堆栈：</h3><p>根据前文讲到的问题分析思路，首先观察 Trace 主线程堆栈，从上面堆栈，可以看到正在业务逻辑，但是当前这个业务逻辑是否耗时呢？如果耗时较长，是不是受到系统调度影响呢？带着这些疑问，我们来看一下系统侧的表现。</p><h3 id="分析系统-amp-进程负载："><a href="#分析系统-amp-进程负载：" class="headerlink" title="分析系统&amp;进程负载："></a>分析系统&amp;进程负载：</h3><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/2.webp" alt="2.webp"></p><ul><li><p>观察不同时段系统负载： 在 ANR Info 中我们搜索 Load 关键字，发现 ANR 前 1，前 5，前 15 分钟(<code>Load:7.45 / 6.92 / 6.84</code>)，系统 CPU 整体负载并不高。</p></li><li><p>观察进程 CPU 使用率： 进一步观察 <code>CPU usage from 0 ms to 8745ms later</code>，看到 ANR 之后 (later：表示发生 ANR 后一段时间各进程 CPU 占比，ago 表示：ANR 之后一段时间，各进程 CPU 占比)的这段时间，<strong>应用主进程 CPU 占比达到 161%，而且在 user，kernel 占比分布上，kernel 比例高达 103%！</strong> 通过前文的介绍，我们知道对应用来说 kernel 空间 CPU 占比较高，说明应用侧应该发生了大量的系统调用，对普通应用来说，发生系统调用的多数场景都是文件 IO 操作。</p></li><li><p>观察线程： 继续观察上图，可以看到应用进程内部的线程 CPU 占用，可以看到 **主线程的 CPU 占比 93%，其中 kernel 占用 69%，明显高于用户空间 23%**，说明 ANR 之后的这 8S 多，主线程依然在进行大量系统调用。</p></li><li><p>系统侧结论： 通过观察系统负载和各个进程的 CPU 使用情况，我们发现系统整体负载比较正常，但是我们的主进程 CPU 占比明显偏高，并且集中在主线程。</p></li></ul><h3 id="业务耗时："><a href="#业务耗时：" class="headerlink" title="业务耗时："></a>业务耗时：</h3><p>根据上面的分析，我们将思路再次回到主线程，进一步观察 Trace 堆栈，发现上面有一个明显的系统调用(read)，难道是本次系统调用导致的 kernel 占比较高吗？那么当前逻辑在 ANR 发生前已经持续了多久呢？分析到这里，如果没有进一步的监控，或者业务不认可当前业务逻辑耗时，那么事情到这里可能就要告一段落，或者需要在业务层添加监控埋点进行复现了，但是如果每次遇到这类问题都要添加埋点，那么将是一个非常糟糕的事情。</p><p>别忘了，在前面介绍 ANR 问题分析思路时，我们还有一个杀手锏(参见：<a href="../../../../2022/02/16/toutiao-anr-tools/">监控工具 Raster</a>)，通过这个监控工具可以看到很清晰的看到：<strong>历史消息耗时，当前消息持续时间以及消息队列未调度消息 Block 耗时</strong>。结合上面这个问题，我们看到了本次主线程消息调度情况，参见下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/3.webp" alt="3.webp"></p><p>通过还原的时序图，可以清晰看到 ANR 之前，主线程消息调度及耗时基本正常，没有发现明显耗时严重的消息，但是观察正在调度的消息，其 Wall duration 超过 9000ms，并且 Cpu duration 长达 4800ms+，说明该消息耗时非常严重。而且上图灰色部分显示第一个消息，被 Block 了 9S 以上，因此可以进一步的说明该消息被 Block 的时长，基本都是当前正在执行的消息导致。</p><h2 id="问题结论："><a href="#问题结论：" class="headerlink" title="问题结论："></a>问题结论：</h2><p>通过上面这些分析信息和实际数据，我们可以得出如下结论：<strong>发生 ANR 问题时，系统负载良好。发生问题前，应用主线程消息调度状态良好，但是当前正在调度的消息耗时严重，导致了后续消息未能及时响应，引起了 ANR</strong>。</p><p>带着这些结论，在和业务对接时便会清晰高效很多。这种场景，属于比较常规和常见的问题，也是大部分同学排查问题的分析思路，过程相对轻松。接下来，我们再看另一种场景的 ANR 问题。</p><h1 id="案例二：历史消息耗时严重"><a href="#案例二：历史消息耗时严重" class="headerlink" title="案例二：历史消息耗时严重"></a>案例二：历史消息耗时严重</h1><p>下面分析的这个案例，是大家经常遇到的，也是引起很多人困惑的一种场景：<code>发生 ANR 时，Trace 堆栈落在了 NativePollOnce</code>。根据我们的理解，这个场景一般表示当前线程处于空闲或 JNI 执行完之后，进行上下文切换的过程，相关逻辑比较清晰。</p><p>可是日常遇到的问题，有很多 Case 都属于这类场景，如果仅仅依靠系统日志让我们很难进一步分析。下面就看看我们是如何应对这类问题的：</p><h2 id="主线程-Trace-堆栈：-1"><a href="#主线程-Trace-堆栈：-1" class="headerlink" title="主线程 Trace 堆栈："></a>主线程 Trace 堆栈：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/4.webp" alt="4.webp"></p><h2 id="分析思路："><a href="#分析思路：" class="headerlink" title="分析思路："></a>分析思路：</h2><h3 id="分析堆栈：-1"><a href="#分析堆栈：-1" class="headerlink" title="分析堆栈："></a>分析堆栈：</h3><p>看到上面的 Trace 堆栈，基本无从下手，线程状态以及线程 utm,stm 时长都没有明显异常，但是线上确实有大量的 ANR 问题落在这个场景，难度在某种极端情况下虚拟机这部分逻辑耗时严重？但是从理论上来说这些假设确实不存在的。既然堆栈没有太多信息，我们就移步到系统层面，看看是否有线索可寻。</p><h3 id="分析系统-amp-进程负载：-1"><a href="#分析系统-amp-进程负载：-1" class="headerlink" title="分析系统&amp;进程负载："></a>分析系统&amp;进程负载：</h3><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/5.webp" alt="5.webp"></p><ul><li><p>观察系统负载： 在 ANR Info 中查看Load关键字，发现系统在前 1 分钟，前 5 分钟，前 15 分钟各个时段负载并不算高，但是最近 1 分钟 CPU 负载为 11.81，比前 5，15 分钟都高，说明负载有加重趋势。</p></li><li><p>观察进程 CPU 分布： 进一步观察 CPU usage from 0 ms to 5599 later 关键字，看到 ANR 之后这 5S 多的时间，我们应用主进程 CPU 占比达到 155%，而且在 user，kernel 层面 CPU 占比分布上，user 占比 124%，明显很高，这时直觉告诉我们，当前进程应该有问题。</p></li><li><p>观察系统 CPU 分布：</p></li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/6.webp" alt="6.webp"></p><p>进一步分析系统负载，发现整体 CPU 使用率并不高。user 占比 17%，kernel 占比 7.5%，iowait 占比 0.7%，说明这段时间系统 IO 并不繁忙，整体也符合预期。</p><ul><li>系统侧结论： 通过观察系统负载和各个进程的 CPU 使用情况，发现系统环境比较正常，但是我们的主进程 CPU 占比明显偏高，但因本次 Anr Info 中未获取到进程内部各线程 CPU 使用率，需要回到应用侧进一步分析。</li></ul><h3 id="应用侧分析："><a href="#应用侧分析：" class="headerlink" title="应用侧分析："></a>应用侧分析：</h3><p>根据上面的分析，我们将方向转回到当前进程，通过对比 Trace 中各线程耗时(utm+stm)，发现除了主线程之外，其它部分子线程耗时(utm+stm)没有明显异常，因此基本排除了进程内部子线程 CPU 竞争导致的问题，因此问题进一步聚焦到主线程。</p><p>接下来再将目光聚焦在主线程消息调度情况，通过监控工具观察主线程的历史消息，当前消息以及待调度消息，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/7.webp" alt="7.webp"></p><p>通过上图可以看到当前消息调度 Wall Duration 为 46ms。**在 ANR 之前存在一个索引为 46 的历史消息耗时严重(wall duration:10747ms)**，同时还有一个索引为 32 的历史消息耗时也比较严重(wall duration:10747ms)。</p><p>进一步观察消息队列第一个待调度消息，发现其实际 block 时长为 9487ms，因此我们排除了索引为 32 的历史消息，<strong>认为索引为 46 的消息耗时是导致后续消息未能及时调度的主要原因</strong>。</p><p>在锁定索引为 46 的历史消息之后，接下来利用监控工具中的<a href="../../../../2022/02/16/toutiao-anr-tools/">消息堆栈采样监控</a>，发现该消息执行过程，多次堆栈采样均命中创建 Webview 逻辑，原来业务在 UI 绘制过程直接实例化 Webview！(涉及到业务代码，采用堆栈详情不在此展示)</p><h2 id="问题结论：-1"><a href="#问题结论：-1" class="headerlink" title="问题结论："></a>问题结论：</h2><p>通过上面的分析并利用监控工具，我们可以很清晰看到发生 ANR 问题时，<strong>NativePollOnce 场景耗时并不长，导致本次 ANR 的主要原因是历史消息在 UI 绘制过程中同步创建 Webview，导致耗时严重。但是期间系统超时监控并没有触发，待主线程继续调度后续消息时，系统监控客户端响应超时，捕获了主线程正在执行的逻辑</strong>。</p><p>这类场景在线上线下都大量存在，但是从 ANR 设计原理和 Trace 采集流程来看，很多并不耗时的消息在调度过程中都成为了“替罪羊”。</p><h1 id="案例三：业务异常密集执行"><a href="#案例三：业务异常密集执行" class="headerlink" title="案例三：业务异常密集执行"></a>案例三：业务异常密集执行</h1><p>接下来分析的这个 Case，在多个产品都有遇到，仅从堆栈上面看，也是经常遇到并困惑我们的，现象和上面分析的案例有些类似，即业务逻辑很简单，实际耗时很少，但是经常出现在各种 ANR Trace 上面，只是依照堆栈信息，就把这个问题草率的分配给相应业务方去解决，业务同学大概率也是一头雾水，不知道从何下手。</p><p>但是如果按照上面两类问题的分析思路，可能也会陷入困惑，这时如果换个思路，可能会是另一番景象，下面就来看看我们是如何分析的。</p><h2 id="ANR-现场堆栈："><a href="#ANR-现场堆栈：" class="headerlink" title="ANR 现场堆栈："></a>ANR 现场堆栈：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/8.webp" alt="8.webp"></p><h2 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h2><h3 id="分析堆栈：-2"><a href="#分析堆栈：-2" class="headerlink" title="分析堆栈："></a>分析堆栈：</h3><p>根据前文分析思路，先观察 Trace 主线程堆栈，从上面堆栈，可以看到业务逻辑，第一反应就是业务耗时？按照经验，我们还是习惯性的再去看看系统日志，进一步缩小或锁定方向。</p><h3 id="分析-CPU-负载："><a href="#分析-CPU-负载：" class="headerlink" title="分析 CPU 负载："></a>分析 CPU 负载：</h3><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/9.webp" alt="9.webp"></p><ul><li><p>观察系统负载： 在 ANR Info 中搜索 Load 关键字，看到系统在各个时段(前 1，5，15 分钟)负载并不高，但是有加重趋势。</p></li><li><p>观察进程 CPU 分布： 进一步观察”CPU usage from 0 ms to 9460ms later”期间各个进程 CPU 占比情况，看到这段时间目标应用的主进程 CPU 占比达到 153%，而且在 user，kernel 占比分布上，<strong>user 占比高达 127%，存在明显异常。Kernel 占比 25%，也有些偏高</strong>。与此同时，我们进一步观察 kswapd，mmc 进程 CPU 使用率，发现占用率不是太高，说明当前系统的整体内存和 IO 并没有太严重问题。</p></li><li><p>观察系统 CPU 分布： 为了进一步验证系统 IO 及内存负载是否正常，接下来再观察一下系统整体 CPU 使用和分布，发现 iowait 占比 7.5%，相对来说有些偏高。</p></li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/10.webp" alt="10.webp"></p><ul><li>进程 CPU 再观察： 与此同时，我们在 ANR Info 里面还发现了一个关键信息，看到了另一个时段问题进程内部主要线程的 CPU 占用情况，通过下图我们可以看到主线程 CPU 占用 95%，属于明显偏高。</li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/11.webp" alt="11.webp"></p><ul><li>系统侧分析结论：通过上面的分析，基本可以得出如下结论：<strong>发生问题时，系统 CPU，Mem 负载比较正常，IO 负载有些偏高，发生 ANR 问题的应用进程 CPU 使用率存在异常，而且集中在主线程</strong>。</li></ul><h2 id="业务耗时：-1"><a href="#业务耗时：-1" class="headerlink" title="业务耗时："></a>业务耗时：</h2><p>根据上面的分析，已经将排查方向锁定在主线程 CPU 使用率较高，接下来观察该线程的 utm+stm，发现累计耗时(1752+128)*10ms=18.8S。对比本次进程启动时长才 22S，说明进程启动后，主线程基本是在满负荷执行！而且主线程的 CPU 响应能力非常不错！</p><p>至此我们再次确认主线程存在严重耗时，难道又是当前消息或某个历史消息耗时严重？于是快速切换到消息调度监控，一探究竟。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/12.webp" alt="12.webp"></p><p>但是看到上面的消息调度监控时序图，发现 <strong>当前消息执行时长才 300ms，并不是我们期待的耗时很严重哪种场景，进一步观察 ANR 之前历史消息调度，也没有看到有单次耗时严重的消息。继续观察上图待调度消息，发现确实被严重 Block。既然主线程没有看到严重耗时，系统负载也比较正常，那么主线程 CPU 使用率为何会这么高呢，这个情况与预期不符，不符合常理啊！</strong></p><p>观察 Block 消息： 之前我们介绍 <a href="../../../../2022/02/16/toutiao-anr-tools/">Raster 工具</a> 时，介绍该工具不仅可以记录历史消息，标记严重耗时，关键消息之外。还有一个作用就是获取消息队列待调度的消息，于是我们继续观察这些被 Block 的消息，发现了一个非常奇怪的现象（由于时序图只能在鼠标停留时展示单个消息详情，因此直接截取原始数据)，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/13.webp" alt="13.webp"></p><p>通过对比，<strong>发现消息队列待调度的消息中，除了第一个消息之外，其余的 200 多个消息(为了便于展示，目前只获取最多前 300 个)，竟然是同一个 Handler 对象(hash:1173da0)的消息</strong>，再进一步对比发现当前正在调度的也是该 Handler 对象的消息。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/14.webp" alt="14.webp"></p><p>这个情况引起了我们的注意，顺着这个思路，继续翻看历史调度信息，发现每条历史记录 (尽管存在多条消息耗时较少被聚合的场景，但是我们会保留最后一个消息的 msg string 信息) 的last msg 也是相同的 handler 对象，如下图。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/15.webp" alt="15.webp"></p><p>这么多消息都来自同一个 Handler，这么密集的在主线程执行，每条记录 cpu 耗时都在 290ms 左右，每条记录监控统计期间调度了 5 条消息。分析到这里，我们基本就有答案了，<strong>很有可能是当前业务发生异常，导致不停的向主线程发送消息，频繁密集的消息依次执行，严重阻塞了后续消息调度</strong>。</p><h2 id="问题结论：-2"><a href="#问题结论：-2" class="headerlink" title="问题结论："></a>问题结论：</h2><p>带着上面这些分析信息和监控数据，我们得出如下结论：<strong>应用在启动之后，业务逻辑发生异常，瞬间产生大量消息，尽管单次消息执行耗时并不严重，但是这些消息在主线程密集执行，严重影响了后续消息调度，进而导致后续消息响应超时</strong>。</p><p>对于这个问题，当我们把相关数据和结论反馈给业务同学时，业务同学进一步分析业务逻辑，发现当前逻辑确实存在隐患，改进之后，该 ANR 问题就此得到解决。</p><p><strong>这种场景属于典型的业务逻辑异常造成的问题，如果没有监控工具由点到面的聚合和展示，单独分析某一次消息耗时，无论如何是找不到问题原因的</strong>。</p><h1 id="案例四：进程内-IO-负载异常"><a href="#案例四：进程内-IO-负载异常" class="headerlink" title="案例四：进程内 IO 负载异常"></a>案例四：进程内 IO 负载异常</h1><p>上面重点介绍了主线程内部环境导致问题的相关案例，介绍当前消息耗时严重，历史消息耗时严重，以及消息密集这几种类型的分析思路，接下来再分析一个进程内 IO 抢占的案例，下面就来看看如何层层拨云揭雾，寻找真相的。</p><h2 id="主线程-Trace-堆栈：-2"><a href="#主线程-Trace-堆栈：-2" class="headerlink" title="主线程 Trace 堆栈："></a>主线程 Trace 堆栈：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/16.webp" alt="16.webp"></p><h2 id="问题分析：-1"><a href="#问题分析：-1" class="headerlink" title="问题分析："></a>问题分析：</h2><h3 id="堆栈分析："><a href="#堆栈分析：" class="headerlink" title="堆栈分析："></a>堆栈分析：</h3><p>上面这个 Trace 信息，也是无从下手，堆栈本身是一个很清晰的系统逻辑，但是现实中确实也有大量 ANR Trace 落在这个场景，难道是系统进入 epoll_wait 之后，没有被及时唤醒？但是从理论上来说这些假设不存在。既然堆栈信息没有太明显，我们就把方向转移到系统侧，看看是否有线索。</p><h3 id="系统-amp-进程负载分析："><a href="#系统-amp-进程负载分析：" class="headerlink" title="系统&amp;进程负载分析："></a>系统&amp;进程负载分析：</h3><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/17.webp" alt="17.webp"></p><ul><li><p>观察系统负载： 在 ANR Info 中我们搜索 Load 关键字，发现 <strong>系统各个时段(前 1，5，15 分钟)负载明显很高，并且最近 1 分钟负载为 71，又明显高于前 5，15 分钟，说明有系统负载进一步加重</strong>！</p></li><li><p>观察进程 CPU 分布： 进一步观察 CPU usage from 0 ms to 21506 later 关键字，看到 <strong>ANR 之后这段时间，内核线程 kworker 的 CPU 占比明显偏高，累计占比超过 45%！其它系统或应用进程 CPU 使用率普遍偏低</strong>。 通过前文介绍我们知道 kworker 属于内核线程，当 IO 负载过重时会在该线程有所体现。进一步观察 kswapd0 线程 cpu 使用率，发现只有 2%，而 kswapd0 主要应用在内存紧张的场景，说明这段时间系统内存负载基本正常。通过上面这些信息解读，可以大致推测最近一段时间系统负载过高，应该是 IO 请求导致，至于系统内存压力尚可接受，接下来我们继续求证。</p></li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/18.webp" alt="18.webp"></p><p>观察进一步分析系统整体负载，发现 user 占比只有 5.4%，kernel 占比 11%，<strong>但是 iowait 占比高达 57%！明显高于 user，kernel 使用率，说明这段时间系统 IO 负载非常严重</strong>。</p><p>而这个 IO 占比较高，也进一步实锤了我们上面的“观察进程 CPU 分布”的结论。那么是哪个应用导致的呢？遗憾的，受限于系统日志获取能力，依靠现有的信息并没有明显看到异常进程，那么 IO 发生在哪里，是否和当前进程有关呢？于是我们将思路再次回到应用内部。</p><h3 id="应用侧分析：-1"><a href="#应用侧分析：-1" class="headerlink" title="应用侧分析："></a>应用侧分析：</h3><p>通过上面的分析，我们基本锁定了是 IO 负载过重导致的问题，接下来便要进一步排查是否是当前进程内部存在异常，于是我们对比了各个线程的耗时(utm+stm)情况：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/19.webp" alt="19.webp"></p><p>通过上图线程耗时对比可以清晰的发现，<strong>DBHelper-AsyncOp-New 线程无论是 utm 时长，还是 stm 时长，都明显超过其它线程，而 stm 高达 2915！</strong> 这个耗时超出了我们的预期，实际场景中我们认为主线程才 CPU 消耗大户，其它线程都是配角。下面我们再看一下线程详情：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/20.webp" alt="20.webp"></p><p>进一步查看该线程堆栈，发现 <strong>存在明显的 IO 操作，而且子线程优先级(nice=0)相对较高，stm(2915)+utm(1259)高达 4000+，换算成时长相当于 CPU 真实执行超过了 40S！</strong></p><p><strong>对比主线程耗时(utm:1035，stm:216)，以及进程启动时长(4 分 18 秒)，可以更好证明了 DBHelper 线程存在异常</strong>，stm 明显过长，说明存在大量系统调用，结合该线程业务，可以很快就猜到是 IO 读写引起的问题了。因为该线程本身就是负责应用内部数据库清理功能的。</p><p>经过上面的分析之后，下面来看一下主线程调度时序图，看看 IO 负载过重对主线程有多大影响。</p><h2 id="消息调度时序图分析"><a href="#消息调度时序图分析" class="headerlink" title="消息调度时序图分析"></a>消息调度时序图分析</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/21.webp" alt="21.webp"></p><p>通过上图，可以清晰看到 ANR 消息之前，有多个历史消息耗时存在明显异常，而且 Wall duration 与 Cpu duration 耗时比例差距较大，部分消息 cpu 时长更是小于 1ms(单位 ms，0 则表示小于 1ms)，说明在此期间主线程整体调度受到很大影响，而且这些消息内部涉及 IO 访问的逻辑将会受到更大影响。</p><p>同时结合我们现场 checkTime 机制，发现 checkTime 调度明显存在严重 delay 情况。</p><h2 id="问题结论：-3"><a href="#问题结论：-3" class="headerlink" title="问题结论："></a>问题结论：</h2><p>带着上面这些分析信息和数据，我们可以得出如下结论：**通过层层分析我们可以发现，发生ANR时的当前消息耗时近2S，但并不是root case，主线程出现多个历史消息耗时，但也不是root case，真正导致本次ANR的原因是DBHelper-AsyncOp线程在过去一段时间进行了长时间的IO操作，严重影响了主线程乃至进程本身的CPU调度，导致后续消息响应不及时，触发系统超时(ANR)**。</p><p>对于该类问题，除了应用本身优化之外，也与一些机型设备差异有关，例如不同机型 IO 性能本身就存在很大差异，因此理论上无法彻底解决。同时无论是进程内部还是其他进程进行 IO 密集操作，都可能引起系统 IO 负载过重，进而导致系统乃至所有进程调度受到影响，对于该类问题只能进一步的优化相关逻辑，降低 IO 访问频率，减少主线程 IO 访问等等。</p><p>这类问题，在线上比较常见，但是在开发同学的线下测试过程，性能普遍符合预期，针对线上用户，应用场景错综复杂，绝非线下能模拟，并且针对不同手机设备，不同芯片平台，甚至磁盘可用空间的差异，其 IO 性能也表现的千差万别而这些小概率的问题，在数亿万用户环境中，会频频出现。</p><h1 id="案例五：其它进程及系统负载异常"><a href="#案例五：其它进程及系统负载异常" class="headerlink" title="案例五：其它进程及系统负载异常"></a>案例五：其它进程及系统负载异常</h1><p>前面我们分析的几类问题，基本都是应用进程内部因素导致的问题，如主线消息耗时，消息密集执行，子线程 IO 资源抢占等等。线上环境中，除了进程或主线线程自身因素导致的问题外，还有一些是外部因素导致的问题，如其它进程或系统负载过重，进而影响当前进程正常调度。下面我们就来看一看这类问题是如何分析的。</p><h2 id="主线程-Trace-堆栈：-3"><a href="#主线程-Trace-堆栈：-3" class="headerlink" title="主线程 Trace 堆栈："></a>主线程 Trace 堆栈：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/22.webp" alt="22.webp"></p><h2 id="问题分析：-2"><a href="#问题分析：-2" class="headerlink" title="问题分析："></a>问题分析：</h2><h3 id="堆栈分析：-1"><a href="#堆栈分析：-1" class="headerlink" title="堆栈分析："></a>堆栈分析：</h3><p>看到上面这个 Trace 信息，同样是熟悉的味道，发生 ANR 时，系统正处于 epoll wait 状态，线程 utm 及 stm 耗时并不算长，累计(376+340)*10=7160ms。观察到这里基本没有看到太多有效信息。接下来继续把方向转移到系统侧，看看是否有线索可循。</p><h3 id="系统-amp-进程负载分析：-1"><a href="#系统-amp-进程负载分析：-1" class="headerlink" title="系统&amp;进程负载分析："></a>系统&amp;进程负载分析：</h3><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/23.webp" alt="23.webp"></p><ul><li><p>观察系统负载： 在 ANR Info 中搜索 Load 关键字，看到系统在各个时段(前 1，5，15 分钟)负载比较高，分别为 37.09，39.37，49.44，呈现加重趋势。</p></li><li><p>观察进程 CPU 分布： 进一步观察”CPU usage from 2401 ms to -22043ms ago”期间，各个进程 CPU 占比情况，看到这段时间目标进程 cpu 使用率很低，只有 17%。看到其它关键进程或线程，如 Kswapd0 线程，cpu 占比 20%，对于该线程来说，其出现则表示系统内存比较紧张了，而且看到了与其相关的 kworker，mmcqd 线程 cpu 占比也比较高。这些线程同时出现，足以说明当前系统环境发生了比较大的问题。而系统资源紧张，一般是因为某个或多个进程出现内存泄漏或大量 IO 读写导致，结合上面 Top 进程的 CPU 占比，com.youku.phone 以及 com.android.contacts 进程可疑性最大。而发生 ANR 问题的 com.ss.android.article.news 进程其 CPU 占比只有 17%。</p></li><li><p>观察系统 CPU 分布：</p></li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/24.webp" alt="24.webp"></p><p>通过上图信息可以看到，系统 CPU 整体使用率达到 54%，kernel 占比 15%，iowait 占比高达 24%，有些偏高。说明系统负载确实存在异常，其结论与我们上面分析的基本一致。</p><p>当然在这里比较遗憾的是，因为是线上问题，我们无法通过拿到系统以及其它进程更多信息，否则可以更加清晰的看到发生异常的是哪个进程， 但是接下来要进一步排除是当前进程导致的系统负载问题，我们将视野再次回到应用侧。</p><h3 id="应用侧分析：-2"><a href="#应用侧分析：-2" class="headerlink" title="应用侧分析："></a>应用侧分析：</h3><p>通过上面的分析，我们基本锁定了是内存负载过重导致的问题，接下来便要进一步排查是否是当前进程内部存在异常，于是我们对比了各线程的耗时(utm+stm)情况：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/25.webp" alt="25.webp"></p><p>通过上图可以看到，排名第一的是主线程，其 utm+stm=700，换算成系统时长，700*10=7000ms，但是 <strong>对比观察进程启动时长，发现进程已经启动 108S，我们知道对应进程来说，启动的前 1~2 分钟，主线程是最为繁忙的，大量的业务和系统消息需要在主线程进行执行。同时我们进一步对比系统负载正常的情况，进程启动 2 分钟时主线程 CPU 执行时长明显大于当前时长</strong>。</p><p>下面我们再来看一下系统负载过重，对主线程消息调度的影响，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/26.webp" alt="26.webp"></p><p>通过上图，可以清晰看到 ANR 消息之前，有多个历史消息耗时存在明显异常，而且 Wall duration 与 Cpu duration 耗时比例差距较大，从侧面也反映了在此期间主线程整体调度受到较大影响。</p><p>超时 Service 消息： 从上图可以清晰看到第一个待调度消息，其 Block 时长超过 18S 之多，接近于前面诸多耗时消息之和。同时从下图可以清晰看到发生 ANR 的这个 service 消息在消息队列排在第 8，消息 block 时长为 18482ms。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/27.webp" alt="27.webp"></p><p><strong>在前文应用四大组件超时归类中提到 Service 超时时长分别为 20S 或 200S，现在该消息在应用侧 block 时长为 18482ms，那就说明剩下 1S 多的时间，耗费在系统 AMS 服务发送到客户端 Binder 线程接收过程，否则没有达到 20S 超时，是不会触发系统超时的。因此也进一步说明了系统调度性能存在问题。</strong></p><h2 id="问题小结"><a href="#问题小结" class="headerlink" title="问题小结"></a>问题小结</h2><p>带着上面这些分析信息和相关数据，我们可以得出如下结论：<strong>在进程启动前，系统负载已经很重，整个系统调度性能受到较大的影响，尽管发生 ANR 时当前堆栈耗时较长，但并不是 root case，多个历史耗时严重的消息也不是 root case，而导致本次 ANR 的应该是 com.youku.phone 或 com.android.contacts 进程，在过去一段时间进行大量系统资源访问，造成系统负载加重，严重影响了其他进程 CPU 调度，导致主线程消息处理不及时，触发系统超时(ANR)</strong></p><p>对于该类问题，因为是其它进程导致系统资源紧张，进而影响了当前进程，因此我们无法从根本上解决，当然能够很好的分析并找出原因，也是对待问题的一种态度吧。</p><h1 id="案例六：跨进程死锁"><a href="#案例六：跨进程死锁" class="headerlink" title="案例六：跨进程死锁"></a>案例六：跨进程死锁</h1><p>在前面更多从应用侧介绍了 ANR 案例的分析思路，接下来看看如何借助更多系统日志分析这类问题。当然，这类问题如果发生在线上，会因为应用侧无法获取跨进程 Trace 的原因，可能会被误归类为 IPC 耗时场景。</p><h2 id="主线程-Trace-堆栈：-4"><a href="#主线程-Trace-堆栈：-4" class="headerlink" title="主线程 Trace 堆栈："></a>主线程 Trace 堆栈：</h2><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/28.webp" alt="28.webp"></p><h2 id="问题分析：-3"><a href="#问题分析：-3" class="headerlink" title="问题分析："></a>问题分析：</h2><h3 id="堆栈分析：-2"><a href="#堆栈分析：-2" class="headerlink" title="堆栈分析："></a>堆栈分析：</h3><p>根据前面讲到的问题分析思路，先观察 Trace 主线程堆栈，从上面堆栈，可以看到业务逻辑发生 Binder 调用被 Block 的情况，但是这次拿到的是完整的 Trace 日志，那么接下来就沿着 Binder 请求逻辑，看一下响应进程的状态。</p><h3 id="服务进程分析："><a href="#服务进程分析：" class="headerlink" title="服务进程分析："></a>服务进程分析：</h3><p>首先查找客户端主线程在和哪个 Binder 线程进行通信，搜索代理接口setAppCallback(Android 命名习惯，代理端和服务端函数命名基本保持一致），发现是 Nfc 的 Binder_3 线程响应了客户端请求：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/29.webp" alt="29.webp"></p><p>但是进一步观察堆栈信息，发现 Binder_3 线程被当前进程的主线程 Block，那么沿着这个线索看看主线程状态：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/30.webp" alt="30.webp"></p><p>观察主线程状态，发现此刻主线程也在执行 Binder 通信，请求 <code>createBeamShareData</code>，同样根据命名习惯，继续搜索关键字 <code>createBeamShareData</code>，看看这次请求是哪个进程在响应，结果发现是 ANR 所在进程的 Binder_6 线程响应此请求。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/31.webp" alt="31.webp"></p><p>通过观察 Binder_6 线程的堆栈和状态，发现该线程处于 await 状态，明显是在等待其它线程通知唤醒！分析到这里，就需要大家结合 Read the Fuck Code 的精神进一步分析业务逻辑了，在研究一番业务逻辑之后，发现唤醒此线程的业务逻辑，已经通过 Handler 发送到主线程，正等待主线程执行呢，但是如果时序处理的不恰当，就会出现主线程还没来得及执行这个消息，就去监听 NFC 状态，进而引起了连锁反应。至此找到了依赖链路：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-samples/32.webp" alt="32.webp"></p><p>通过上图可以清晰的看到本次 ANR 原因：<strong>跨进程死锁</strong>。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>我们按照前文 ANR 影响因素及归类分别选取了一个线上案例，并进行分析总结。回过头来看，第一类问题按照多数人的”解题思路”可能会很快的找到答案。在面对第二类问题时，如果没有监控工具就可能掉入“Trace 陷阱”了。第三类问题并不常见，但是在公司多个产品都有遇到过，因为这类问题更加隐蔽，如果依靠现有系统日志只能锁定方向，之后需要耗费大量的时间去添加埋点分析定位，但是通过我们的监控工具直观展示并暴露了更多细节，为成功定位问题扮演了关键角色。后面两类因为资源抢占的导致线程调度不及时的问题，通过监控工具很好的还原了 ANR 之前消息调度情况，更加清晰的证实了资源竞争对主线程的影响；但「barrier导致主线程假死」，「Service执行时序颠倒」等问题还有待解决。掌握了上述几类问题的分析思路，相信可以帮助大家应对工作中遇到大部分问题，但是所谓“林子大了，什么鸟都有”，下一篇将会介绍主线程假死，Service 执行时序颠倒等更加棘手的案例分析，敬请期待。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247488243&idx=1&sn=1f948e0ef616c6dfe54513a2a94357be&scene=21#wechat_redirect">今日头条 ANR 优化实践系列分享 - 实例剖析集锦</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>bytedance</tag>
      
      <tag>toutiao</tag>
      
      <tag>字节</tag>
      
      <tag>头条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】今日头条 ANR 优化实践系列（2）- 监控工具与分析思路</title>
    <link href="/2022/02/16/toutiao-anr-tools/"/>
    <url>/2022/02/16/toutiao-anr-tools/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>在前文，我们对 <a href="../../../../2022/02/16/toutiao-anr-principle/">ANR 设计原理及影响因素</a> 进行了介绍，并对影响 ANR 的不同场景进行归类。但是依靠现有的系统日志，不足以完成复杂场景的问题归因，而且有些信息从应用侧无法获取，这就导致很多线上问题更加棘手；因此我们在应用侧探索了新的监控能力，以弥补信息获取不足的短板。同时对日常分析过程中用到日志信息和分析思路进行总结，以帮忙大家更好的掌握分析技巧，下面我们就来看看相关实现。</p><h1 id="Raster-监控工具"><a href="#Raster-监控工具" class="headerlink" title="Raster 监控工具"></a>Raster 监控工具</h1><p>俗话说：“工欲善其事，必先利其器”，日常分析 ANR 问题也是如此，一个好的监控工具不仅可以帮助我们在解决常规问题时达到锦上添花的效果，在面对线上复杂隐蔽的问题时，也能为我们打开视野，提供更多线索和思路。</p><h1 id="工具介绍："><a href="#工具介绍：" class="headerlink" title="工具介绍："></a>工具介绍：</h1><p>该工具主要是在主线程消息调度过程进行监控，并按照一定策略聚合，以保证监控工具本身对应用性能和内存抖动影响降至最低。同时对应用四大组件消息执行过程进行监控，便于对这类消息的调度及耗时情况进行跟踪和记录。另外对当前正在调度的消息及消息队列中待调度消息进行统计，从而在发生问题时，可以回放主线程的整体调度情况。此外，我们将系统服务的 CheckTime 机制迁移到应用侧，应用为线程 CheckTime 机制，以便于系统信息不足时，从线程调度及时性推测过去一段时间系统负载和调度情况。 </p><p>因此该工具用一句话来概括就是：由点到面，回放过去，现在和将来。 </p><p>因其实现原理和消息聚合后的效果，直观展示主线程调度过程长短不一的耗时片段，犹如一道道光栅，故将该工具命名为 **Raster[ˈræstər]**。</p><h1 id="监控工具由来"><a href="#监控工具由来" class="headerlink" title="监控工具由来"></a>监控工具由来</h1><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h2><p>例如下图，是线下遇到的 ANR 问题，从手机端获取的 Trace 日志，可以看到从主线程堆栈上基本得不到太多有效信息。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/1.webp" alt="1.webp"></p><p>继续从 Trace 中分析其它信息，包含了各个进程的虚拟机和线程状态信息，以及 ANR 之前或之后一段时间，CPU 使用率比较高的进程乃至系统负载(CPU，IO)的相关信息等等，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/2.webp" alt="2.webp"></p><p>但是从这些信息中，相信很多同学都很难再进一步分析，因为这些信息只是列举了当前各个进程或线程的状态，并没有很好的监控和记录影响这些指标的过程。而现实中这类场景的问题，每天都在线上大量发生。那么针对这种情况该如何更好的解决呢？下面就来介绍一下我们是如何应对的。</p><h2 id="消息调度监控"><a href="#消息调度监控" class="headerlink" title="消息调度监控"></a>消息调度监控</h2><p>在 <a href="../../../../2022/02/16/toutiao-anr-principle/">Android 系统的 ANR 设计原理及影响因素</a> 一文中，我们讲到，ANR 问题很多场景都是历史消息耗时较长并不断累加后导致的，但是在 ANR 发生时我们并不知道之前都调度了哪些消息，如果可以监控每次消息调度的耗时并记录，当发生 ANR 时，获取这些记录信息，并能计算出当前正在执行消息的耗时，是不是就可以清晰的知道 ANR 发生前主线程都发生了什么？按照这个思路，整理出如下示意图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/3.webp" alt="3.webp"></p><p>但是通过上面示意图并结合实际业务场景，我们发现，对于大多数业务消息，单次耗时都很少，如果每个消息都单独记录，要想跟踪记录 ANR 前 10S 甚至更长时间范围内的所有消息，可能需要成千上万条记录，这个显然是不合理的，而且这么多的消息也不方便我们后续查看。</p><h2 id="消息聚合分类"><a href="#消息聚合分类" class="headerlink" title="消息聚合分类"></a>消息聚合分类</h2><p>联想到实际业务场景很多情况都是耗时较少的消息，而在排查这类问题过程耗时较少的消息基本是可以直接忽略的，因此我们是不是可以对这类消息按照一定条件进行聚合，将一段时间以内的消息进行累加计算，如果累计耗时超过我们规定的阈值，那么就将这些消息的数量和累计耗时合并成一条记录，如 16 个消息累计耗时刚好超过 300ms，则生成一条记录。以此类推存储 100 条的话，就能监控到 ANR 发生前 30S 主线程的调度历史了(实际可能是大于 15S，至于为何是这个范围，我们会在后面说明)，如此一来就可以较好的解决大量记录和频繁更新带来的内存抖动问题。</p><p>根据上面的思路，我们对消息监控及记录又进一步的进行聚合优化和关键消息过滤；总结来看，分为以下几种类型：</p><h3 id="多消息聚合："><a href="#多消息聚合：" class="headerlink" title="多消息聚合："></a>多消息聚合：</h3><p><strong>该场景主要用于主线程连续调度多个消息，并且每个消息耗时都很少的情况下，将这些消息耗时累加，直到这些消息累计耗时超过设置的阈值，则汇总并生成一条记录</strong>，并在这条记录中标明本次聚合总共调度了多少个消息。按照消息聚合的思路，发生问题时主线程消息调度示意图如下（Count 表示本条记录包含了多少个消息；Wall 表示本轮消息执行的累计耗时）：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/4.webp" alt="4.webp"></p><h3 id="消息聚合拆分："><a href="#消息聚合拆分：" class="headerlink" title="消息聚合拆分："></a>消息聚合拆分：</h3><p>针对上面多消息聚合策略，会存在一些特殊情况，例如在将多个消息进行累计统计过程中，如果前 N 次消息调度结束后，累计耗时都没有超过阈值，但是调度完下一个消息之后，发现累计耗时超过阈值，并且还明显超出，如设置阈值是 300ms，但是前 N 个消息累计 200ms，加上本次消息累计耗时达到了 900ms，那么这种情况，我们明显知道是最后一次消息耗时严重，因此需要<strong>将本次消息单独记录，并标记其耗时和相关信息，同时将之前 N 次消息调度耗时和消息数聚合在一起并单独记录，这种场景相当于一次生成 2 条记录</strong>。</p><p>为了考虑监控工具对性能的影响，我们只在每轮统计需要保存时，更新线程 cpu 执行时间，如果发生消息聚合拆分的场景，会默认前一条记录的 cpu 时间为-1，因为本条记录并不是我们重点关注的，所以会把本轮统计的 cpu 时间全部归到后一条消息。</p><p>在一些极端场景下，如本轮监控第一个消息执行耗时为 1ms，但是加上本次消息耗时，累计超过 600ms，因此两次消息累计耗时远大于设定的阈值 300ms，那么就需要对本次耗时严重的消息单独记录，而前面那个 1ms 的消息也需要被单独进行记录；类似情形如此反复，就会出现上面说的保存 100 条记录，整体监控可回溯的时长区间存在波动的情况；该场景的示意图如下（Count 表示本条记录包含了多少个消息；Wall 表示本轮消息执行的累计耗时）：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/5.webp" alt="5.webp"></p><h3 id="关键消息聚合："><a href="#关键消息聚合：" class="headerlink" title="关键消息聚合："></a>关键消息聚合：</h3><p>除了上面单次耗时严重的消息需要拆分并单独记录之外，还有一类消息也需要我们单独标记，以达到更好的识别，那就是可能会引起 ANR 的应用组件，如 Activity，Service，Receiver，Provider 等等。为了监控这几种组件的执行过程，我们需要对 ActivityThread.H 的消息调度进行监控，当发现上面这些组件有关的消息在执行时，不管其耗时多少，都对其进行单独记录，并将之前监控的一个或多个消息也保存为一条记录。该场景的示意图如下（Count 表示本条记录包含了多少个消息；Wall 表示本轮消息执行的累计耗时）：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/6.webp" alt="6.webp"></p><h3 id="IDLE-场景聚合："><a href="#IDLE-场景聚合：" class="headerlink" title="IDLE 场景聚合："></a>IDLE 场景聚合：</h3><p>熟悉消息队列的同学都知道，主线程是基于消息队列的方式进行调度，在每次消息调度完成之后都会从消息队列读取下一个待调度的消息，如果消息队列没有消息，或者下一个消息没有到设定的调度时间，并且也没有 IDLE 消息等待调度，那么主线程将会进入 IDLE 状态，如下示意图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/7.webp" alt="7.webp"></p><p>正是因为上面的调度逻辑，使得主线程在消息调度过程中会多次进入 IDLE 状态，而这个过程也涉及到线程上下文切换(如：Java 环境切换到 Native 环境)，会去检测是否有挂起请求，所以对调用频繁的接口来说，会在 ANR 发生时被命中，理论上调用越频繁的接口被命中的概率越大，如下图堆栈：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/8.webp" alt="8.webp"></p><p>但是上面这种场景的 IDLE 停留时长可长可短，如果按照完全上面那几类消息聚合策略，多个消息连续聚合的话，可能会把这类场景也给聚合进来，一定程度造成干扰，这显然不是我们想要的。为此需要进一步优化，在每次消息调度结束后，获取当前时间，在下次消息调度开始前，再次获取当前时间，并统计距离上次消息调度结束的间隔时长。如果间隔较长，那么也需要单独记录，如果间隔时间较短，我们认为可以忽略，并将其合并到之前统计的消息一起跟踪，到这里就完成了各类场景的监控和归类；该场景的示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/9.webp" alt="9.webp"></p><h2 id="耗时消息堆栈采样："><a href="#耗时消息堆栈采样：" class="headerlink" title="耗时消息堆栈采样："></a>耗时消息堆栈采样：</h2><p>在上面重点讲述了主线程消息调度过程的监控和聚合策略，便于发生 ANR，在线下进行回放。但是那些耗时较长的消息，仅仅知道其耗时和消息 tag 是远远不够的，因为每个消息内部的业务逻辑对于我们来说都是黑盒，各个接口耗时也存在很多不确定性，如锁等待、Binder 通信、IO 等系统调用。</p><p>因此需要知道这些耗时消息内部接口的耗时情况，我们选取了 2 种方案进行对比：</p><ul><li><p>第一种方案：是对每个函数进行插桩，在进入和退出过程统计其耗时，并进行聚合和汇总。该方案的优点是可以精确的知道每个函数的真实耗时，缺点是很影响包体积和性能，而且不利于其他产品高效复用。</p></li><li><p>第二种方案，在每个消息开始执行时，触发子线程的超时监控，如果在超时之后本次消息还没执行结束，则抓取主线程堆栈，并继续对该消息设置下一次超时监控，直到该消息执行结束并取消本轮监控。如果在触发超时之前已经执行完毕，则取消本次监控并在下次消息开始执行时，再次设置超时监控，但是因为大部分消息耗时都很少，如果每次都频繁设置和取消，将会带来性能影响，因此我们对此进行优化，采用系统 ANR 超时监控相同的时间对齐方案，具体来说就是： </p></li></ul><p>以消息开始时间加上超时时长为目标超时时间，每次超时时间到了之后，检查当前时间是否大于或等于目标时间，如果满足，则说明目标时间没有更新，也就是说本次消息没结束，则抓取堆栈。如果每次超时之后，检查当前时间小于目标时间，则说明上次消息执行结束，新的消息开始执行并更新了目标超时时间，这时异步监控需对齐目标超时，再次设置超时监控，如此往复。 </p><p>根据上面的思路，整理流程图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/10.webp" alt="10.webp"></p><p>需要注意的是，消息采样堆栈的超时时长不可设置太短，否则频繁抓取堆栈对主线程性能影响较大，同时也不能设置太长，否则会因为采样过低导致数据置信度降低；具体时长根据每个产品复杂度灵活调整即可。</p><h2 id="监控正在调度消息及耗时："><a href="#监控正在调度消息及耗时：" class="headerlink" title="监控正在调度消息及耗时："></a>监控正在调度消息及耗时：</h2><p>除了监控 ANR 发生之前主线程历史消息调度及耗时之外，也需要知道 ANR 发生时正在调度的消息及其耗时，以便于在看到 ANR 的 Trace 堆栈时，可以清晰的知道当前 Trace 逻辑到底执行了多长时间，帮忙我们排除干扰，快速定位；借助这个监控可以很好的回答大家，ANR 发生时当前 Trace 堆栈是否耗时以及耗时多久的问题，避免陷入“Trace 堆栈”误区。</p><h2 id="获取-Pending-消息："><a href="#获取-Pending-消息：" class="headerlink" title="获取 Pending 消息："></a>获取 Pending 消息：</h2><p>同时除了监控主线程历史消息调度及耗时之外，也需要在 ANR 发生时，获取消息队列中待调度的消息，为我们分析问题时提供更多线索，如：</p><ul><li>消息队列中待调度消息是否被 Block 以及被 Block 时长，根据 Block 时长可以推测主线程的繁忙程度；</li><li>可以观察消息队列中是否存在发生 ANR 的应用组件消息，如 Service 消息，以及其在待调度消息队列中的位置和 Block 时长；</li><li>可以观察消息队列中都有哪些消息，这些消息是否有一定规律，如大量重复消息，如果有大量重复消息，则说明很有可能与该消息相关的业务逻辑发生异常，频繁和主线程交互(后面的案例分析中我们也会有介绍)。</li></ul><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/11.webp" alt="11.webp"></p><p>之前我们讲到，对于一次消息调度，它的耗时可以从两个维度进行统计，即 Wall Duration 和 Cpu Duration，通过这两个维度的统计，可以帮助我们更好的推测一次严重耗时，是执行大量业务逻辑还是处于等待或被抢占的情况。如果是后者，那么可以看到这类消息的 Wall Duration 和 Cpu Duration 比例会比较大，当然如何更好更全面的区分一次消息耗时是等待较多还是线程调度被抢占，我们将会在后面结合其他参考信息进行介绍。</p><h1 id="完整示意图"><a href="#完整示意图" class="headerlink" title="完整示意图"></a>完整示意图</h1><p>在这里我们再把 Cpu Duration 耗时也给统计之后，那么整个有关主线程完整的消息调度监控功能就基本完成了。示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/12.webp" alt="12.webp"></p><p>通过这个消息调度监控工具，我们就可以很清晰的看到发生 ANR 时，主线程历史消息调度情况；当前正在调度消息耗时，以及消息队列待调度消息及相关信息；而且利用这个监控工具，一眼便知 ANR 发生时主线程 Trace 实际耗时情况，因此很好解决了部分同学对当前堆栈是否耗时以及耗时多久的疑问。</p><p>从上面介绍可以看出，为了重点标记单次耗时消息和关键消息，我们使用了多种聚合策略，因此监控过程记录的信息可能会代表不同类型的消息，为了便于区分，我们在可视化展示时加上 Type 标识，便于区别。</p><h1 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h1><p>例如下图，从 Trace 日志可以看到，ANR 发生时主线程被 Block 在 Binder 通信过程，可能很多同学第一反应是 WMS 服务没有及时响应 Binder 请求导致的问题。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/13.webp" alt="13.webp"></p><p>但是再结合下面的消息调度监控来核实一下，我们发现当前调度的消息 Wall duration 只有 44ms，而在该消息之前有两次历史消息耗时比较严重，分别为 2166ms，3277ms，也就是说本次 Binder 调用耗时并不严重，真正的问题是前面 2 次消息耗时较长，影响了后续消息调度，只有同时解决这 2 个消息耗时严重问题，该 ANR 问题才可能解决。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/14.webp" alt="14.webp"></p><p>如果没有消息调度监控工具，上去就盲目的分析当前逻辑调用的 IPC 问题，可能就犯了方向性的错误，掉入“Trace 堆栈”陷阱中。 </p><p>接下来再来看一个发生在线上的另外一个实例，从下图可以看到主线程正在调度的消息耗时超过 1S，但是在此之前的另一个历史消息耗时长达 9828ms。继续观察下图消息队列待调度的消息状态(灰色示意)，可以看到第一个待调度的消息被 Block 了 14S 之久。由此我们可以知道 ANR 消息之前的这个历史消息，才是导致 ANR 的罪魁祸首，当然这个正在执行的消息也需要优化一下性能，因为我们在前面说过：“发生 ANR 时，没有一个消息是无辜的。”</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/15.webp" alt="15.webp"></p><p>正是因为有了上面这些监控能力，让我们在日常面对 Trace 日志中的业务逻辑是否耗时以及耗时多久的困惑，瞬间就会变得清晰起来。</p><h1 id="Checktime"><a href="#Checktime" class="headerlink" title="Checktime"></a>Checktime</h1><h2 id="Checktime-背景介绍："><a href="#Checktime-背景介绍：" class="headerlink" title="Checktime 背景介绍："></a>Checktime 背景介绍：</h2><p>Checktime 是 Android 系统针对一些系统服务(AMS，InputService 等)中高频访问的接口，执行时间的监控，当这类接口真实耗时超过预期值将会给出提示信息，此类设计为了在真实环境监测进程被调度和响应能力的一种结果反馈。具体实现是，在每个函数执行前和执行后分析获取当前系统时间，并计算差值，如果该接口耗时超过其设定的阈值，则会触发“slow operation”的信息提醒，部分代码实现如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/16.webp" alt="16.webp"></p><p>Checktime 逻辑很简单，用当前系统时间减去对比时间，如果超过 50ms，则给出 Waring 日志提示。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/17.webp" alt="17.webp"></p><p>我们在分析线下问题，或者在系统层面分析这类问题时，经常会在 logcat 中看到这类消息，但是对于线上的三方应用来说，因为权限问题无法获取系统日志，只能自己实现了。</p><h2 id="线程-Checktime："><a href="#线程-Checktime：" class="headerlink" title="线程 Checktime："></a>线程 Checktime：</h2><p>了解完系统 Checktime 设计思路及实现之后，我们就可以在应用层实现类似的功能了。通过借助其它子线程的周期检测机制，<strong>在每次调度前获取当前系统时间，然后减去我们设置延迟的时间，即可得到本次线程调度前的真实间隔时间，如设置线程每隔 300ms 调度一次，结果发现实际响应时间间隔有时会超过 300ms，如果偏差越大，则说明线程没有被及时调度，进一步反映系统响应能力变差</strong>。</p><p>通过这样的方式，即使在线上环境获取不到系统日志，也可以从侧面反映不同时段系统负载对线程调度影响，如下图示意，当连续发生多次严重 Delay 时，说明线程调度受到了影响。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/18.webp" alt="18.webp"></p><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>通过上述监控能力，我们可以清晰的知道 ANR 发生时主线程历史消息调度以及耗时严重消息的采样堆栈，同时可以知道正在执行消息的耗时，以及消息队列待中调度消息的状态。同时通过线程 CheckTime 机制从侧面反映线程调度响应能力，由此完成了应用侧监控信息从点到面的覆盖。但是在面对 ANR 问题时，只有这个监控，是远远不够的，需要结合其他信息整体分析，以应对更为复杂的系统环境。下面就结合监控工具来介绍一下 ANR 问题的分析思路。</p><h1 id="ANR-分析思路："><a href="#ANR-分析思路：" class="headerlink" title="ANR 分析思路："></a>ANR 分析思路：</h1><p>在介绍分析思路之前，我们先来说一下分析这类问题需要用到哪些日志，当然在不同的环境下，获取信息能力会有很大差别，如线下环境和线上环境，应用侧和系统角度都有差异；这里我们会将我们日常排查问题常用的信息都介绍一下，便于大家更好的理解，主要包括以下几种：</p><ul><li>Trace 日志</li><li>AnrInfo</li><li>Kernel 日志</li><li>Logcat 日志</li><li>Meminfo 日志</li><li>Raster 监控工具</li></ul><p>对于应用侧来说，在线上环境可能只能拿到当前进程内部的线程堆栈(取决于实现原理，参见：<a href="../../../../2022/02/16/toutiao-anr-principle/">Android 系统的 ANR 设计原理及影响因素</a>)以及 ANR Info 信息。在系统侧，几乎能获取到上面的所有信息，对于这类问题获取的信息越多，分析定位成功率就越大，例如可以利用完整的 Trace 日志，分析跨进程 Block 或死锁问题，系统内存或 IO 紧张程度等等，甚至可以知道硬件状态，如低电状态，硬件频率(CPU，IO，GPU)等等。</p><h1 id="关键信息解读："><a href="#关键信息解读：" class="headerlink" title="关键信息解读："></a>关键信息解读：</h1><p>在这里我们把上面列举的日志进行提取并解读，以便于大家在日常开发和面对线上问题，根据当前获取的信息进行参考。</p><h2 id="Trace-信息"><a href="#Trace-信息" class="headerlink" title="Trace 信息"></a>Trace 信息</h2><p>在前文Android 系统的 ANR 设计原理及影响因素中，我们讲到了在发生 ANR 之后，系统会 Dump 当前进程以及关键进程的线程堆栈，状态(红框所示关键信息，稍后详细说明)，示例如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/19.webp" alt="19.webp"></p><p>上面的日志包含很多信息，这里将常用的关键信息进行说明，如下：</p><h3 id="线程堆栈："><a href="#线程堆栈：" class="headerlink" title="线程堆栈："></a>线程堆栈：</h3><p>这个比较好理解，也就是发生 ANR 时，线程正在执行的逻辑，但是很多场景下，获取的堆栈耗时并不长，原因详见 <a href="../../../../2022/02/16/toutiao-anr-principle/">Android 系统的 ANR 设计原理及影响因素</a>。</p><h3 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h3><p>见上图“state=xxx”，表示当前线程工作状态，Running 表示当前线程正在被 CPU 调度，Runnable 表示线程已经 Ready 等待 CPU 调度，如上图 SignalCatcher 线程状态。Native 态则表示线程由 Java 环境进入到 Native 环境，可能在执行 Native 逻辑，也可能是进入等待状态；Waiting 表示处于空闲等待状态。除此之外还有 Sleep，Blocked 状态等等；</p><h3 id="线程耗时："><a href="#线程耗时：" class="headerlink" title="线程耗时："></a>线程耗时：</h3><p>见上图“utmXXX，stmXXX”，表示该线程从创建到现在，被 CPU 调度的真实运行时长，不包括线程等待或者 Sleep 耗时，其中线程 CPU 耗时又可以进一步分为用户空间耗时(utm)和系统空间耗时(stm)，这里的单位是 jiffies，当 HZ=100 时，1utm 等于 10ms。</p><ul><li>utm： Java 层和 Native 层非 Kernel 层系统调用的逻辑，执行时间都会被统计为用户空间耗时；</li><li>stm： 即系统空间耗时，一般调用 Kernel 层 API 过程中会进行空间切换，由用户空间切换到 Kernel 空间，在 Kernel 层执行的逻辑耗时会被统计为 stm，如文件操作，open,write,read 等等；</li><li>core：最后执行这个线程的 cpu 核的序号。</li></ul><h3 id="线程优先级："><a href="#线程优先级：" class="headerlink" title="线程优先级："></a>线程优先级：</h3><p>nice： 该值越低，代表当前线程优先级越高，理论上享受的 CPU 调度能力也越强。对于应用进程(线程)来说，nice 范围基本在 100~139。随着应用所在前后台不同场景，系统会对进程优先级进行调整，厂商可能也会开启 cpu quota 等功能去限制调度能力；</p><h3 id="调度态："><a href="#调度态：" class="headerlink" title="调度态："></a>调度态：</h3><p>schedstat： 参见“schedstat=( 1813617862 14167238 546 )”，分别表示线程 CPU 执行时长(单位 ns)，等待时长，Switch 次数。</p><h2 id="AnrInfo-信息"><a href="#AnrInfo-信息" class="headerlink" title="AnrInfo 信息"></a>AnrInfo 信息</h2><p>除了 Trace 之外，系统会在发生 ANR 时获取一些系统状态，如 ANR 问题发生之前和之后的系统负载以及 Top 进程和关键进程 CPU 使用率。这些信息如果在本地环境可以从 Logcat 日志中拿到，也可以在应用侧通过系统提供的 API 获取(参见：<a href="../../../../2022/02/16/toutiao-anr-principle/">Android 系统的 ANR 设计原理及影响因素</a>)，Anr Info 节选部分信息如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/20.webp" alt="20.webp"></p><p>对于上图信息，主要对以下几部分关键信息进行介绍：</p><h3 id="ANR-类型-longMsg-："><a href="#ANR-类型-longMsg-：" class="headerlink" title="ANR 类型(longMsg)："></a>ANR 类型(longMsg)：</h3><p>表示当前是哪种类型的消息或应用组件导致的 ANR，如 Input，Receiver，Service 等等。</p><h3 id="系统负载-Load-："><a href="#系统负载-Load-：" class="headerlink" title="系统负载(Load)："></a>系统负载(Load)：</h3><p>表示不同时间段的系统整体负载，如：”Load：45.53 / 27.94 / 19.57”，分布代表 ANR 发生前 1 分钟，前 5 分钟，前 15 分钟各个时间段系统 CPU 负载，具体数值代表单位时间等待系统调度的任务数(可以理解为线程)。如果这个数值过高，则表示当前系统中面临 CPU 或 IO 竞争，此时，普通进程或线程调度将会受到影响。如果手机处于温度过高或低电等场景，系统会进行限频，甚至限核，此时系统调度能力也会受到影响。 </p><p>此外，可以将这些时间段的负载和应用进程启动时长进行关联。如果进程刚启动 1 分钟，但是从 Load 数据看到前 5 分钟，甚至前 15 分钟系统负载已经很高，那很大程度说明本次 ANR 在很大程度会受到系统环境影响。</p><h3 id="进程-CPU-使用率："><a href="#进程-CPU-使用率：" class="headerlink" title="进程 CPU 使用率："></a>进程 CPU 使用率：</h3><p>如上图，表示当前 ANR 问题发生之前(CPU usage from XXX to XXX ago)或发生之后(CPU usage from XXX to XXX later)一段时间内，都有哪些进程占用 CPU 较高，并列出这些进程的 user，kernel 的 CPU 占比。当然很多场景会出现 system_server 进程 CPU 占比较高的现象，针对这个进程需要视情况而定，至于 system_server 进程 CPU 占比为何普遍较高，参见：<a href="../../../../2022/02/16/toutiao-anr-principle/">Android 系统的 ANR 设计原理及影响因素</a>。 </p><p>minor 表示次要页错误，文件或其它内存被加载到内存后，但是没有被映射到当前进程，通过内核访问时，会触发一次 Page Fault。如果访问的内容还没有加载到内存，那么会触发 major，所以对比可以看到，major 的系统开销会比 minor 大很多。</p><h3 id="关键进程："><a href="#关键进程：" class="headerlink" title="关键进程："></a>关键进程：</h3><ul><li>kswapd： 是 linux 中用于页面回收的内核线程，主要用来维护可用内存与文件缓存的平衡，以追求性能最大化，当该线程 CPU 占用过高，说明系统可用内存紧张，或者内存碎片化严重，需要进行 file cache 回写或者内存交换(交换到磁盘)，线程 CPU 过高则系统整体性能将会明显下降，进而影响所有应用调度。</li><li>mmcqd： 内核线程，主要作用是把上层的 IO 请求进行统一管理和转发到 Driver 层，当该线程 CPU 占用过高，说明系统存在大量文件读写，当然如果内存紧张也会触发文件回写和内存交换到磁盘，所以 kswapd 和 mmcqd 经常是同步出现的。</li></ul><h3 id="系统-CPU-分布："><a href="#系统-CPU-分布：" class="headerlink" title="系统 CPU 分布："></a>系统 CPU 分布：</h3><p>如下图，反映一段时间内，系统整体 CPU 使用率，以及 user，kernel，iowait 方向的 CPU 占比，如果发生大量文件读写或内存紧张的场景，则 iowait 占比较高，这个时候则要进一步观察上述进程的 kernel 空间 CPU 使用情况，并通过进程 CPU 使用，再进一步对比各个线程的 CPU 使用，找出占比最大的一个或一类线程。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/21.webp" alt="21.webp"></p><h2 id="Logcat-日志："><a href="#Logcat-日志：" class="headerlink" title="Logcat 日志："></a>Logcat 日志：</h2><p>在 log 日志中，我们除了可以观察业务信息之外，还有一些关键字也可以帮我们去推测当前系统性能是否遇到问题，如下图， “Slow operation”，“Slow delivery” 等等。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/22.webp" alt="22.webp"></p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/23.webp" alt="23.webp"></p><h3 id="Slow-operation"><a href="#Slow-operation" class="headerlink" title="Slow operation"></a>Slow operation</h3><p>Android 系统在一些频繁调用的接口中，分别在方法前后利用 checktime 检测，以判断本次函数执行耗时是否超过设定阈值，通常这些值都会设置的较为宽松，如果实际耗时超过设置阈值，则会给出“Slow XXX”提示，表示系统进程调度受到了影响，一般来说系统进程优先级比较高，如果系统进程调度都受到了影响，那么则反映了这段时间内系统性能很有可能发生了问题。</p><h2 id="Kernel-日志："><a href="#Kernel-日志：" class="headerlink" title="Kernel 日志："></a>Kernel 日志：</h2><p>对于应用侧来说，这类日志基本是拿不到的，但是如下是在线下测试或者从事系统开发的同学，可以通过 dmesg 命令进行查看。对于 kernel 日志，我们主要分析的是 lowmemkiller 相关信息，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/24.webp" alt="24.webp"></p><h3 id="Lowmemkiller："><a href="#Lowmemkiller：" class="headerlink" title="Lowmemkiller："></a>Lowmemkiller：</h3><p>从事性能(内存)优化的同学对该模块都比较熟悉，主要是用来监控和管理系统可用内存，当可用内存紧张时，从 kernel 层强制 Kill 一些低优先级的应用，以达到调节系统内存的目的。而选择哪些应用，则主要参考进程优先级(oom_score_adj)，这个优先级是 AMS 服务根据应用当前的状态，如前台还是后台，以及进程存活的应用组件类型而计算出来的。例如：对于用户感知比较明显的前台应用，优先级肯定是最高的，此外还有一些系统服务，和后台服务(播放器场景)优先级也会比较高。当然厂商也对此进行了大量的定制(优化)，以防止三方应用利用系统设计漏洞，将自身进程设置太高优先级进而达到保活目的。</p><h1 id="消息调度时序图："><a href="#消息调度时序图：" class="headerlink" title="消息调度时序图："></a>消息调度时序图：</h1><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/25.webp" alt="25.webp"></p><p>如上图，在我们分析完系统日志之后，会进一步的锁定或缩小范围，但是最终我们还是要回归到主线程进一步的分析 Trace 堆栈的业务逻辑以及耗时情况，以便于我们更加清晰的知道正在调度的消息持续了多长时间。但是很多情况当前 Trace 堆栈并不是我们期待的答案，因此需要进一步的确认 ANR 之前主线程的调度信息，评估历史消息对后续消息调度的影响，便于我们寻找“真凶”。</p><p>当然，有时也需要进一步的参考消息队列中待调度消息，在这些消息里面，除了可以看到 ANR 时对应的应用组件被 Block 的时长之外，还可以了解一下都有哪些消息，这些消息的特征有时对于我们分析问题也会提供有力的证据和方向。</p><h1 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h1><p>在上面我们对各类日志的关键信息进行了基本释义，下面就来介绍一下，当我们日常遇到 ANR 问题时，是如何分析的，总结思路如下：</p><p>分析堆栈，看看是否存在明显业务问题(如死锁，业务严重耗时等等)，如果无上述明显问题，则进一步通过 ANR Info 观察系统负载是否过高，进而导致整体性能较差，如 CPU，Mem，IO。然后再进一步分析是本进程还是其它进程导致，最后再分析进程内部分析对比各个线程 CPU 占比，找出可疑线程。</p><p>综合上述信息，利用监控工具收集的信息，观察和找出 ANR 发生前一段时间内，主线程耗时较长的消息都有哪些，并查看这些耗时较长的消息执行过程中采样堆栈，根据堆栈聚合展示，进一步的对比当前耗时严重的接口或业务逻辑。<br>以上分析思路，进一步细分的话，可以分为以下几个步骤：</p><h2 id="一看-Trace："><a href="#一看-Trace：" class="headerlink" title="一看 Trace："></a>一看 Trace：</h2><h3 id="死锁堆栈"><a href="#死锁堆栈" class="headerlink" title="死锁堆栈"></a>死锁堆栈</h3><p>观察 Trace 堆栈，确认是否有明显问题，如主线程是否与其他线程发生死锁，如果是进程内部发生了死锁，那么恭喜，这类问题就清晰多了，只需找到与当前线程死锁的线程，问题即可解决；</p><h3 id="业务堆栈"><a href="#业务堆栈" class="headerlink" title="业务堆栈"></a>业务堆栈</h3><p>观察通过 Trace 堆栈，发现当前主线程堆栈正在执行业务逻辑，你找到对应的业务同学，他承认该业务逻辑确实存在性能问题，那么恭喜，你很有可能解决了该问题，为什么只是有可能解决该问题呢？因为有些问题取决于技术栈或框架设计，无法在短时间内解决。如果业务同学反馈当前业务很简单，基本不怎么耗时，而这种场景也是日常经常遇到的一类问题，那么就可能需要借助我们的监控工具，追溯历史消息耗时情况了；</p><h3 id="IPC-Block-堆栈"><a href="#IPC-Block-堆栈" class="headerlink" title="IPC Block 堆栈"></a>IPC Block 堆栈</h3><p>观察通过 Trace 堆栈，发现主线程堆栈是在跨进程(Binder)通信，那么这个情况并不能当即下定论就是 IPC block 导致，实际情况也有可能是刚发送 Binder 请求不久，以及想要进一步的分析定位，这时也需要借助我们的自研监控工具了；</p><h3 id="系统堆栈"><a href="#系统堆栈" class="headerlink" title="系统堆栈"></a>系统堆栈</h3><p>通过观察 Trace，发现当前堆栈只是简单的系统堆栈，想要搞清楚是否发生严重耗时，以及进一步的分析定位，如我们常见的 NativePollOnce 场景，那么也需要借助我们的自研监控工具进一步确认了。</p><h2 id="二看关键字：Load，CPU，Slow-Operation，Kswapd，Mmcqd，Kwork，Lowmemkiller-等等"><a href="#二看关键字：Load，CPU，Slow-Operation，Kswapd，Mmcqd，Kwork，Lowmemkiller-等等" class="headerlink" title="二看关键字：Load，CPU，Slow Operation，Kswapd，Mmcqd，Kwork，Lowmemkiller 等等"></a>二看关键字：Load，CPU，Slow Operation，Kswapd，Mmcqd，Kwork，Lowmemkiller 等等</h2><p>刚才我们介绍到，上面这些关键字是反应系统 CPU，Mem，IO 负载的关键信息，在分析完主线程堆栈信息之后，还需要进一步在 ANRInfo，logcat 或 Kernel 日志中搜索这些关键字，并根据这些关键字当前数值，判断当前系统是否存在资源(CPU，Mem，IO)紧张的情况；</p><h2 id="三看系统负载分布：观察系统整体负载：User-Sys-IOWait"><a href="#三看系统负载分布：观察系统整体负载：User-Sys-IOWait" class="headerlink" title="三看系统负载分布：观察系统整体负载：User,Sys,IOWait"></a>三看系统负载分布：观察系统整体负载：User,Sys,IOWait</h2><p>通过观察系统负载，则可以进一步明确是 CPU 资源紧张，还是 IO 资源紧张；如果系统负载过高，一定是有某个进程或多个进程引起的。反之系统负载过高又会影响到所有进程调度性能。通过观察 User，Sys 的 CPU 占比，可以进一步发分析当前负载过高是发生在应用空间，还是系统空间，如大量调用逻辑(如文件读写，内存紧张导致系统不断回收内存等等)，知道这些之后，排查方向又会进一步缩小范围。</p><h2 id="四看进程-CPU：观察-Top-进程的-CPU-占比"><a href="#四看进程-CPU：观察-Top-进程的-CPU-占比" class="headerlink" title="四看进程 CPU：观察 Top 进程的 CPU 占比"></a>四看进程 CPU：观察 Top 进程的 CPU 占比</h2><p>从上面分析，在我们知道当前系统负载过高，是发生在用户空间还是内核空间之后，那么我们就要通过 Anrinfo 的提供的进程 CPU 列表，进一步锁定是哪个(些)进程导致的，这时则要进一步的观察每个进程的 CPU 占比，以及进程内部 user，sys 占比。</p><p>在分析进程 CPU 占比过程，有一个关键的信息，要看统计这些进程 CPU 过高的场景是发生在 ANR 之前的一段时间还是之后一段时间，如下图表示 ANR 之前 4339ms 到 22895ms 时间内进程的 CPU 使用率。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-tools/26.webp" alt="26.webp"></p><h2 id="五看-CPU-占比定线程-：对比各线程-CPU-占比，以及线程内部-user-和-kernel-占比"><a href="#五看-CPU-占比定线程-：对比各线程-CPU-占比，以及线程内部-user-和-kernel-占比" class="headerlink" title="五看 CPU 占比定线程 ：对比各线程 CPU 占比，以及线程内部 user 和 kernel 占比"></a>五看 CPU 占比定线程 ：对比各线程 CPU 占比，以及线程内部 user 和 kernel 占比</h2><p>在通过系统负载(user,sys,iowait)锁定方向之后，又通过进程列表锁定目标进程，那么接下来我们就可以从目标进程内部分析各个线程的(utm,stm)，进一步分析是哪个线程有问题了。</p><p>在 Trace 日志的线程信息里可以清晰的看到每个线程的 utm，stm 耗时。至此我们就完成了从系统到进程，再到进程内部线程方向的负载分析和排查。当然，有时候可能导致系统高负载的不是当前进程，而是其他进程导致，这时同样会影响其他进程，进而导致 ANR。</p><h2 id="六看消息调度锁定细节"><a href="#六看消息调度锁定细节" class="headerlink" title="六看消息调度锁定细节"></a>六看消息调度锁定细节</h2><p>在分析和明确系统负载是否正常，以及负载过高是哪个进程引起的结论之后，接下来便要通过我们的监控工具，进一步排查是当前消息调度耗时导致，历史消息调度耗时导致，还是消息过于频繁导致。同时通过我们的线程 CheckTime 调度情况分析当前进程的 CPU 调度是否及时以及影响程度，在锁定上述场景之后，再进一步分析耗时消息的采样堆栈，才算找到解决问题的终极之钥。当然耗时消息内部可能存在一个或多个耗时较长的函数接口，或者会有多个消息存在耗时较长的函数接口，这就是我们前文中提到的：“发生 ANR 时，没有一个消息是无辜的”</p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>除了上面的一些信息，我们还可以结合 logcat 日志分析 ANR 之前的一些信息，查看是否存在业务侧或系统侧的异常输出，如搜索“Slow operation”，”Slow delivery”等关键字。也可以观察当前进程和系统进程是否存在频繁 GC 等等，以帮忙我们更全面的分析系统状态。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>上面我们重点介绍了基于主线程消息调度的监控工具，实现了“由点到面”的监控能力，以便于发生 ANR 问题时，可以更加清晰直观的整体评估主线程的“过去，现在和将来”。同时结合日常实践，介绍了在应用侧分析 ANR 问题经常用到的日志信息和分析思路。 </p><p>目前，Raster 监控工具因为其很好的提升了问题定位效率和成功率，成为 ANR 问题分析利器，并融合到公司性能稳定性监控平台，为公司众多产品广泛使用。接下来我们将利用该工具并结合上面的分析思路，讲一讲实际工作中遇到不同类型的 ANR 问题时，是如何快速分析和定位问题的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247488182&idx=1&sn=6337f1b51d487057b162064c3e24c439&scene=21#wechat_redirect">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>bytedance</tag>
      
      <tag>toutiao</tag>
      
      <tag>字节</tag>
      
      <tag>头条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】今日头条 ANR 优化实践系列（1）- 设计原理及影响因素</title>
    <link href="/2022/02/16/toutiao-anr-principle/"/>
    <url>/2022/02/16/toutiao-anr-principle/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>ANR 问题，对于从事 Android 开发的同学来说并不陌生，日常开发中，经常会遇到应用乃至系统层面引起的各种问题，很多时候因为不了解其运行原理，在面对该类问题时可能会一头雾水。与此同时，因为现有监控能力不足或获取信息有限，使得这类问题如同镜中花水中月，让我们在追求真理的道路上举步维艰。如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/1.webp" alt="1.webp"></p><p>工作中在帮助大家分析问题时，发现有不少同学问到，在哪里可以更加系统的学习？于是本人抱着“授人以鱼，不如授人以渔”的态度，结合个人理解和工作实践，接下来将从 <strong>设计原理、影响要素、工具建设、分析思路，案例实战、优化探索等几个篇章，对 ANR 方向进行一次全面的总结</strong>，希望帮助大家在今后的工作中更好地理解和应对以下问题：</p><ol><li><strong>什么是 ANR？</strong></li><li><strong>系统是如何设计 ANR 的？</strong></li><li><strong>发生 ANR 时系统都会获取哪些信息以及工作流程？</strong></li><li><strong>导致 ANR 的原因有哪些？</strong></li><li><strong>遇到这类问题该如何分析？</strong></li><li><strong>如何能更加快速准确的定位问题？</strong></li><li><strong>面对这类问题我们能主动做些什么？</strong></li></ol><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在正式分析 ANR 问题之前，先来看看下面这些问题：</p><ul><li>系统是如何设计 ANR 的，都有哪些服务或者组件会发生 ANR？</li><li>发生 ANR 的时候，系统又是如何工作的，都会获取哪些信息？</li><li>影响 ANR 的场景有哪些？我们是如何对其进行归类的？</li><li>了解这些有助于我们在面对各种问题时，做到有的放矢，下面我们就来介绍并回答这些问题。</li></ul><h1 id="ANR-设计原理"><a href="#ANR-设计原理" class="headerlink" title="ANR 设计原理"></a>ANR 设计原理</h1><p>ANR 全称 <code>Applicatipon No Response</code>；Android 设计 ANR 的用意，是系统通过与之交互的组件(Activity，Service，Receiver，Provider)以及用户交互(InputEvent)进行超时监控，以判断应用进程(主线程)是否存在卡死或响应过慢的问题，通俗来说就是很多系统中看门狗(watchdog)的设计思想。</p><h2 id="组件超时分类"><a href="#组件超时分类" class="headerlink" title="组件超时分类"></a>组件超时分类</h2><p>系统在通过 Binder 通信向应用进程发送上述组件消息或 Input 事件时，在 AMS 或 Input 服务端同时设置一个异步超时监控。当然针对不同类型事件，设置的超时时长也存在差别，以下是 Android 系统对不同类型的超时阈值设置(图片仅供参考，国内厂商可能会有调整，每个厂商的标准也存在差异)：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/2.webp" alt="2.webp"></p><h2 id="Broadcast-超时原理举例"><a href="#Broadcast-超时原理举例" class="headerlink" title="Broadcast 超时原理举例"></a>Broadcast 超时原理举例</h2><p>在了解不同类型消息的超时阈值之后，我们再来了解一下超时监控的设计原理。</p><p>以 BroadCastReceiver 广播接收超时为例，<strong>广播分为有序广播和无序广播，同时又有前台广播和后台广播之分；只针对有序广播设置超时监控机制，并根据前台广播和后台广播的广播类型决定了超时时长；例如后台广播超时时长 60S，前台广播超时时长只有 10S；</strong> 下面我们结合代码实现来看一下广播消息的发送过程。</p><h3 id="无序广播："><a href="#无序广播：" class="headerlink" title="无序广播："></a>无序广播：</h3><p><strong>对于无序广播，系统在搜集所有接收者之后一次性全部发送完毕</strong>，如下图；</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/3.webp" alt="3.webp"></p><p>通过上图我们看到无序广播是没有设置超时监听机制的，一次性发送给所有接收者，对于应用侧何时接收和响应完全不关心(相当于 UDP 传输)。</p><h3 id="有序广播："><a href="#有序广播：" class="headerlink" title="有序广播："></a>有序广播：</h3><p>再来看一下有序广播的发送和接收逻辑，同样在系统 AMS 服务中，BoradCastQueue 获取当前正在发送的广播消息，并取出下一个广播接收者，更新发送时间戳，以此时间计算并设置超时时间(但是系统在此进行了一些优化处理，以避免每次广播正常接收后，都需要取消超时监控然后又重新设置，而是采用一种对齐的方式进行复用)。最后将该广播发送给接收者，接收到客户端的完成通知之后，再发送下一个，整个过程如此反复。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/4.webp" alt="4.webp"></p><p>在客户端进程中，Binder 线程接收到 AMS 服务发送过来的广播消息之后，会将此消息进行封装成一个 Message，然后将 Message 发送到主线程消息队列(插入到消息队列当前时间节点的位置，也正是基于此类设计导致较多消息调度及时性的问题，后面我们将详细介绍)，消息接收逻辑如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/5.webp" alt="5.webp"></p><p>正常情况下，很多广播请求都会在客户端及时响应，然后通知到系统 AMS 服务取消本次超时监控。但是在部分业务场景或系统场景异常的情况下，发送的广播未及时调度，没有及时通知到系统服务，便会在系统服务侧触发超时，判定应用进程响应超时。AMS 响应超时代码逻辑如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcastTimeoutLocked</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fromMsg)</span> &#123;        ......        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();        <span class="hljs-type">BroadcastRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> mOrderedBroadcasts.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (fromMsg) &#123;            <span class="hljs-comment">//我们刚才提到的时间对齐方式，避免频繁取消和设置消息超时</span>            <span class="hljs-type">long</span> <span class="hljs-variable">timeoutTime</span> <span class="hljs-operator">=</span> r.receiverTime + mTimeoutPeriod;            <span class="hljs-keyword">if</span> (timeoutTime &gt; now) &#123;                setBroadcastTimeoutLocked(timeoutTime);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        ......        ......        Object curReceiver;        <span class="hljs-keyword">if</span> (r.nextReceiver &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//获取当前超时广播接收者</span>            curReceiver = r.receivers.get(r.nextReceiver-<span class="hljs-number">1</span>);            r.delivery[r.nextReceiver-<span class="hljs-number">1</span>] = BroadcastRecord.DELIVERY_TIMEOUT;        &#125; <span class="hljs-keyword">else</span> &#123;            curReceiver = r.curReceiver;        &#125;        Slog.w(TAG, <span class="hljs-string">&quot;Receiver during timeout of &quot;</span> + r + <span class="hljs-string">&quot; : &quot;</span> + curReceiver);        ......        ......        <span class="hljs-keyword">if</span> (app != <span class="hljs-literal">null</span>) &#123;            anrMessage = <span class="hljs-string">&quot;Broadcast of &quot;</span> + r.intent.toString();        &#125;        ......        <span class="hljs-keyword">if</span> (!debugging &amp;&amp; anrMessage != <span class="hljs-literal">null</span>) &#123;             <span class="hljs-comment">//开始通知AMS服务处理当前超时行为</span>            mHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AppNotResponding</span>(app, anrMessage));        &#125;    &#125;</code></pre></div><p>到这里，广播发送和超时监控逻辑的分析就基本结束了，通过介绍，我们基本知道了广播超时机制是如何设计和工作的，整体流程图示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/6.webp" alt="6.webp"></p><h1 id="ANR-Trace-Dump-流程"><a href="#ANR-Trace-Dump-流程" class="headerlink" title="ANR Trace Dump 流程"></a>ANR Trace Dump 流程</h1><p>上面我们以广播接收为例，介绍了系统监控原理，下面再来介绍一下，发生 ANR 时系统工作流程。</p><h2 id="ANR-信息获取："><a href="#ANR-信息获取：" class="headerlink" title="ANR 信息获取："></a>ANR 信息获取：</h2><p>继续以广播接收为例，在上面介绍到当判定超时后，会调用系统服务 AMS 接口，搜集本次 ANR 相关信息并存档(data/anr/trace，data/system/dropbox)，入口如下。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/7.webp" alt="7.webp"></p><p>进入系统服务 AMS 之后，AppError 先进行场景判断，以过滤当前进程是不是已经发生并正在执行 Dump 流程，或者已经发生 Crash，或者已经被系统 Kill 之类的情况。并且还考虑了系统是否正在关机等场景，如果都不符合上述条件，则认为当前进程真的发生 ANR。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/8.webp" alt="8.webp"></p><p>接下来系统再判断当前 ANR 进程对用户是否可感知，如后台低优先级进程(没有重要服务或者 Activity 界面)。</p><p>然后开始统计与该进程有关联的进程，或系统核心服务进程的信息；例如与应用进程经常交互的 SurfaceFligner，SystemServer 等系统进程，如果这些系统服务进程在响应时被阻塞，那么将导致应用进程 IPC 通信过程被卡死。</p><p>首先把自身进程(系统服务 SystemServer)加进来，逻辑如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/9.webp" alt="9.webp"></p><p>接着获取其它系统核心进程，因为这些服务进程是 Init 进程直接创建的，并不在 SystemServer 或 Zygote 进程管理范围。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/10.webp" alt="10.webp"></p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/11.webp" alt="11.webp"></p><p>在搜集完第一步信息之后，接下来便开始统计各进程本地的更多信息，如虚拟机相关信息、Java 线程状态及堆栈。以便于知道此刻这些进程乃至系统都发生了什么情况。理想很丰满，现实很骨感，后面我们会重点讲述为何有此感受。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/12.webp" alt="12.webp"></p><p>系统为何要收集其它进程信息呢？因为从性能角度来说，任何进程出现高 CPU 或高 IO 情况，都会抢占系统资源，进而影响其它进程调度不及时的现象。下面从代码角度看看系统 dump 流程：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpStackTraces</span><span class="hljs-params">(String tracesFile, ArrayList&lt;Integer&gt; firstPids, ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> useTombstonedForJavaTraces)</span> &#123;        ......        ......        <span class="hljs-comment">//考虑到性能影响，一次dump最多持续20S，否则放弃后续进程直接结束</span>        remainingTime = <span class="hljs-number">20</span> * <span class="hljs-number">1000</span>;        <span class="hljs-keyword">try</span> &#123;                ......                <span class="hljs-comment">//按照优先级依次获取各个进程trace日志</span>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> firstPids.size();                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timeTaken;                    <span class="hljs-keyword">if</span> (useTombstonedForJavaTraces) &#123;                        timeTaken = dumpJavaTracesTombstoned(firstPids.get(i), tracesFile, remainingTime);                    &#125; <span class="hljs-keyword">else</span> &#123;                        timeTaken = observer.dumpWithTimeout(firstPids.get(i), remainingTime);                    &#125;                    remainingTime -= timeTaken;                    <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-comment">//已经超时，则不再进行后续进程的dump操作</span>                        <span class="hljs-keyword">return</span>;                    &#125;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//按照优先级依次获取各个进程trace日志</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pid : nativePids) &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nativeDumpTimeoutMs</span> <span class="hljs-operator">=</span> Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();                    Debug.dumpNativeBacktraceToFileTimeout(                            pid, tracesFile, (<span class="hljs-type">int</span>) (nativeDumpTimeoutMs / <span class="hljs-number">1000</span>));                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime() - start;                    remainingTime -= timeTaken;                    <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-comment">//已经超时，则不再进行后续进程的dump操作</span>                        <span class="hljs-keyword">return</span>;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//按照优先级依次获取各个进程trace日志</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pid : extraPids) &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timeTaken;                    <span class="hljs-keyword">if</span> (useTombstonedForJavaTraces) &#123;                        timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);                    &#125; <span class="hljs-keyword">else</span> &#123;                        timeTaken = observer.dumpWithTimeout(pid, remainingTime);                    &#125;                    remainingTime -= timeTaken;                    <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-comment">//已经超时，则不再进行后续进程的dump操作</span>                        <span class="hljs-keyword">return</span>;                    &#125;                &#125;            &#125;        &#125;        ......    &#125;</code></pre></div><h2 id="Dump-Trace-流程"><a href="#Dump-Trace-流程" class="headerlink" title="Dump Trace 流程"></a>Dump Trace 流程</h2><p>出于安全考虑，进程之间是相互隔离的，即使是系统进程也无法直接获取其它进程相关信息。因此需要借助 IPC 通信的方式，将指令发送到目标进程，目标进程接收到信号后，协助完成自身进程 Dump 信息并发送给系统进程。以 AndroidP 系统为例，大致流程图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/13.webp" alt="13.webp"></p><p>关于应用进程接收信号和响应能力，是在虚拟机内部实现的，在虚拟机启动过程中进行信号注册和监听(SIGQUIT)，初始化逻辑如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/14.webp" alt="14.webp"></p><p>SignalCatcher 线程接收到信号后，首先 Dump 当前虚拟机有关信息，如内存状态，对象，加载 Class，GC 等等，接下来设置各线程标记位(check_point)，以请求线程起态(suspend)。其它线程运行过程进行上下文切换时，会检查该标记，如果发现有挂起请求，会主动将自己挂起。等到所有线程挂起后，SignalCatcher 线程开始遍历 Dump 各线程的堆栈和线程数据，结束之后再唤醒线程。期间如果某些线程一直无法挂起直到超时，那么本次 Dump 流程则失败，并主动抛出超时异常。</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/15.webp" alt="15.webp"></p><p>根据上面梳理的流程，SignalCatcher 获取各线程信息的工作过程，示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/16.webp" alt="16.webp"></p><p>到这里，基本介绍完了系统设计原理，并以广播发送为例说明系统是如何判定 ANR 的，以及发生 ANR 后，系统是如何获取系统信息和进程信息，以及其他进程是如何协助系统进程完成日志收集的。</p><p>整体来看链路比较长，而且涉及到与很多进程交互，同时为了进一步降低对应用乃至系统的影响，系统在很多环节都设置大量超时检测。而且从上面流程可以看到发生 ANR 时，系统进程除了发送信号给其它进程之外，自身也 Dump Trace，并获取系统整体及各进程 CPU 使用情况，且将其它进程 Dump 发送的数据写到文件中。因此这些开销将会导致系统进程在 ANR 过程承担很大的负载，这是为什么我们经常在 ANR Trace 中看到 SystemServer 进程 CPU 占比普遍较高的主要原因。</p><h1 id="应用层如何判定-ANR"><a href="#应用层如何判定-ANR" class="headerlink" title="应用层如何判定 ANR"></a>应用层如何判定 ANR</h1><p>Android M(6.0) 版本之后，应用侧无法直接通过监听 data/anr/trace 文件，监控是否发生 ANR，那么大家又有什么其它手段去判定 ANR 呢？下面我们简单介绍一下</p><p>站在应用侧角度来看，因为系统没有提供太友好的机制，去主动通知应用是否发生 ANR，而且很多信息更是对应用屏蔽了访问权限，但是对于三方 App 来说，也需要关注基本的用户体验，因此很多公司也进行了大量的探索，并给出了不同的解决思路，目前了解到的方案(思路)主要有下面 2 种：</p><h2 id="主线程-watchdog-机制"><a href="#主线程-watchdog-机制" class="headerlink" title="主线程 watchdog 机制"></a>主线程 watchdog 机制</h2><p>核心思想是在应用层定期向主线程设置探测消息，并在异步设置超时监测，如在规定的时间内没有收到发送的探测消息状态更新，则判定可能发生 ANR，为什么是可能发生 ANR？因为还需要进一步从系统服务获取相关数据(下面会讲到如何获取)，进一步判定是否真的发生 ANR。</p><h2 id="监听-SIGNALQUIT-信号"><a href="#监听-SIGNALQUIT-信号" class="headerlink" title="监听 SIGNALQUIT 信号"></a>监听 SIGNALQUIT 信号</h2><p>该方案在很多公司有应用，网上也有相关介绍，这里主要介绍一下思路。我们在上面提到了虚拟机是通过注册和监听 SIGNALQUIT 信号的方式执行请求的，而对于信号机制有了解的同学马上就可以猜到，我们也可以在应用层参考此方式注册相同信号去监听。不过要注意的是注册之后虚拟机之前注册的就会被覆盖，需要在适当的时候进行恢复，否则小心系统(厂商)找上门。</p><p>当接收到该信号时，过滤场景，确定是发生用户可感知的 ANR 之后，从 Java 层获取各线程堆栈，或通过反射方式获取到虚拟机内部 Dump 线程堆栈的接口，在内存映射的函数地址，强制调用该接口，并将数据重定向输出到本地。</p><p><strong>该方案从思路上来说优于第一种方案，并且遵循系统信息获取方式，获取的线程信息及虚拟机信息更加全面，但缺点是对性能影响比较大，对于复杂的 App 来说，统计其耗时，部分场景一次 Dump 耗时可能要超过 10S。</strong></p><h1 id="应用层如何获取-ANR-Info"><a href="#应用层如何获取-ANR-Info" class="headerlink" title="应用层如何获取 ANR Info"></a>应用层如何获取 ANR Info</h1><p>上面提到无论是 Watchdog 还是监听信号的方式，都需要结论进一步过滤，以确保收集我们想要的 ANR 场景，因此需要利用系统提供的接口，进一步判定当前应用是否发生问题(ANR，Crash)；</p><p>与此同时，除了需要获取进程中各线程状态之外，我们也需要知道系统乃至其他进程的一些状态，如系统 CPU，Mem，IO 负载，关键进程的 CPU 使用率等等，便于推测发生问题时系统环境是否正常；</p><p>获取信息相关接口类如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/17.webp" alt="17.webp"></p><p>通过该接口获取的相关信息，示意如下，其中下图红框选中的关键字，我们在后续 ANR 分析思路一章，会对其进行详细释义：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/18.webp" alt="18.webp"></p><h1 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h1><p>上面主要介绍系统针对各种类型的消息是如何设置超时监控，以及监测到超时之后，系统侧和应用侧如何获取各类信息的工作流程。在对这些有所了解之后，接下来再看看 ANR 问题是如何产生的，以及我们对影响 ANR 因素的类型划分。</p><h2 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h2><p>在工作中，有同学问到“我的 Service”逻辑很简单，为何会 ANR 呢？其实通过堆栈和监控工具可以发现，他所说的业务 Service，其实都还没来得及被调度。原来该同学是从我们的内部监控平台上看到是该 Service 发生导致的 ANR，如下图：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/19.webp" alt="19.webp"></p><p>下面我们就来回答一下为何会出现上面的这类现象？</p><h2 id="问题答疑"><a href="#问题答疑" class="headerlink" title="问题答疑"></a>问题答疑</h2><p>通过前面的讲解，我们可以发现，系统服务(AMS，InputService)在将具有超时属性的消息，如创建 Service，Receiver，Input 事件等，通过 Binder 或者其它 IPC 的方式发送到目标进程之后，便启动异步超时监测。而这种性质的监测完全是一种黑盒监测，并不是真的监控发送的消息在真实执行过程中是否超时，也就是说系统不管发送的这个消息有没有被执行，或者真实执行过程耗时有多久，只要在监控超时到来之前，服务端没有接收到通知，那么就判定为超时。</p><p>同时在前面我们讲到，当系统侧将消息发送给目标进程之后，其客户端进程的 Binder 线程接收到该消息后，会按时间顺序插入到消息队列；在后续等待执行过程中，会有下面几种情况发生：</p><ul><li>启动进程启动场景，大量业务或基础库需要初始化，在消息入队之前，已经有很多消息待调度；</li><li>有些场景有可能只是少量消息，但是其中有一个或多个消息耗时很长；</li><li>有些场景其他进程或者系统负载特别高，整个系统都变得有些卡顿。</li></ul><p>上述这些场景都会导致发送的消息还没来得及执行，就可能已经被系统判定成为超时问题，然而此时进程接收信号后，主线程 Dump 的是当前某个消息执行过程的业务堆栈(逻辑)。</p><p>所以总结来说，<strong>发生 ANR 问题时，Trace 堆栈很多情况下都不是 RootCase。而系统 ANR Info 中提示某个 Service 或 Receiver 导致的 ANR 在很大程度上，并不是这些组件自身问题。</strong></p><p>那么影响 ANR 的场景具体可以分为哪几类呢，下面我们就来聊一聊。</p><h1 id="影响因素分类"><a href="#影响因素分类" class="headerlink" title="影响因素分类"></a>影响因素分类</h1><p>结合我们在系统侧和应用侧的工作经历，以及对该类问题的理解，我们将可能导致 ANR 的影响要素分为下面几个方面，影响环境分为 <strong>应用内部环境</strong> 和 <strong>系统环境</strong>；即 <strong>系统负载正常，但是应用内部主线程消息过多或耗时严重</strong>；另外一类则是 <strong>系统或应用内部其它线程或资源负载过高，主线程调度被严重抢占</strong>；系统负载正常，主线程调度问题，总体来说包括以下几种：</p><ul><li>当前 Trace 堆栈所在业务耗时严重；</li><li>当前 Trace 堆栈所在业务耗时并不严重，但是历史调度有一个严重耗时；</li><li>当前 Trace 堆栈所在业务耗时并不严重，但是历史调度有多个消息耗时；</li><li>当前 Trace 堆栈所在业务耗时并不严重，但是历史调度存在巨量重复消息(业务频繁发送消息)；</li><li>当前 Trace 堆栈业务逻辑并不耗时，但是其他线程存在严重资源抢占，如 IO，Mem，CPU；</li><li>当前 Trace 堆栈业务逻辑并不耗时，但是其他进程存在严重资源抢占，如 IO，Mem，CPU；</li></ul><p>下面我们就来分别介绍一下这几种场景以及表现情况：</p><h2 id="当前主线程正在调度的消息耗时严重"><a href="#当前主线程正在调度的消息耗时严重" class="headerlink" title="当前主线程正在调度的消息耗时严重"></a>当前主线程正在调度的消息耗时严重</h2><p>理论上某个消息耗时越严重，那么这个消息造成的卡顿或者 ANR 的概率就越大，这种场景在线上经常发生，相对来说比较容易排查，也是业务开发同学分析该类问题的常规思路。</p><p>发生 ANR 时主线程消息调度示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/20.webp" alt="20.webp"></p><h2 id="已调度的消息发生单点耗时严重"><a href="#已调度的消息发生单点耗时严重" class="headerlink" title="已调度的消息发生单点耗时严重"></a>已调度的消息发生单点耗时严重</h2><p>如果之前某个历史消息严重耗时，但是直到该消息执行完毕，系统服务仍然没有达到触发超时的临界点，后续主线程继续调度其它消息时，系统判定响应超时，那么正在执行的业务场景很不幸被命中，而当前正在执行的业务逻辑可能很简单。</p><p>这种场景在线上大量存在，因为比较隐蔽，所以会给很多同学带来困惑，后面会在 ANR 实例分析中对其进行重点介绍。发生 ANR 时主线程消息调度示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/21.webp" alt="21.webp"></p><h2 id="连续多个消息耗时严重"><a href="#连续多个消息耗时严重" class="headerlink" title="连续多个消息耗时严重"></a>连续多个消息耗时严重</h2><p>除了上述两种场景，还有一种情况就是 <strong>存在多个消息耗时严重的情况，直到后面主线程调度其它消息时，系统判定响应超时，那么正在执行的业务场景很不幸被命中；这种场景在实际环境中也是普遍存在的，这类问题更加隐蔽，并且在分析和问题归因上，也很难清晰的划清界限</strong>，问题治理上需要推动多个业务场景进行优化。(后面会在 ANR 实例分析中对其进行重点介绍)</p><p>发生 ANR 时主线程消息调度示意图如下</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/22.webp" alt="22.webp"></p><h2 id="相同消息高频执行-业务逻辑异常"><a href="#相同消息高频执行-业务逻辑异常" class="headerlink" title="相同消息高频执行(业务逻辑异常)"></a>相同消息高频执行(业务逻辑异常)</h2><p>上面我们讲到的是有一个或多个消息耗时较长，还有另外一种情况就是 <strong>业务逻辑发生异常或者业务线程与主线程频繁交互，大量消息堆积在消息队列，这时对于后续追加到消息队列的消息来说，尽管不存在单个耗时严重的消息，但是消息太密集导致一段时间内同样很难被及时调度，因此这种场景也会造成消息调度不及时，进而导致响应超时问题。</strong>(后面会在 ANR 实例分析中对其进行介绍)</p><p>发生 ANR 时主线程消息调度示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/23.webp" alt="23.webp"></p><h2 id="应用进程或系统-包括其它进程-负载过重"><a href="#应用进程或系统-包括其它进程-负载过重" class="headerlink" title="应用进程或系统(包括其它进程)负载过重"></a>应用进程或系统(包括其它进程)负载过重</h2><p>除了上面列举了一些主线程消息耗时严重或者消息过多，导致的消息调度不及时的可能引起的问题之外，<strong>还有一种我们在线上经常遇到的场景，那就是进程或系统本身负载很重，如高 CPU，高 IO，低内存(应用内内存抖动频繁 GC，系统内存回收)等等。这种情况出现之后，也很导致应用或整体系统性能变差，最终导致一系列超时问题</strong>。</p><p>针对这种情况，具体到主线程消息调度上表现来看，就是<strong>很多消息耗时都比较严重，而且每次消息调度统计的 Wall Duration(绝对时间：包括正常调度和等待，休眠时间)和 CPU Duration(绝对时间：只包括 CPU 执行时间)相差很大</strong>，如果出现这种情况我们则认为系统负载可能发生了异常，需要借助系统信息进一步对比分析。这种情况不仅影响当前应用，也会影响其他应用乃至系统自身。</p><p>发生 ANR 时主线程消息调度示意图如下：</p><p><img src="../../../../image/2022-02-16-toutiao-anr-principle/24.webp" alt="24.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的介绍，我们介绍了 ANR 的设计原理及工作过程，对影响 ANR 的因素和分类也有了进一步认识。从归类上我们可以发现，影响 ANR 的场景会有很多种，甚至很多时候都是层层叠加导致，所以可以借用一句话来形容：<strong>「当 ANR 发生时，没有一个消息是无辜的」</strong>。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>依靠系统现有的监控能力，并不能直观的体现上面列举的众多场景，更无法直观告诉我们 ANR 发生前主线程调度情况。仅仅依靠 ANR 时获取系统及 Top 进程的相关信息和一些 Log 日志，很多数时候只能帮我们完成第一阶段的定位，如系统负载过重，主线程过于繁忙等结论。却无法更进一步深入分析和解决问题，尤其是一些线下难以复现的问题。</p><p>对于我们每个人来说，工作的目标不仅仅是定位方向，更重要的是解决问题。那么怎么才能更好的解决上述系统监控能力不完善以及应用侧信息盲区的问题呢？这就是我们下一期要重点介绍的“监控工具”，一个优秀的工具，不仅可以帮助我们在解决常规问题时达到一锤定音的效果，在面对更加复杂隐蔽的问题时，也能为我们打开视野，提供更多方向，下周的文章我们就去看看它是如何设计及运用的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247488116&idx=1&sn=fdf80fa52c57a3360ad1999da2a9656b&scene=21#wechat_redirect">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>bytedance</tag>
      
      <tag>toutiao</tag>
      
      <tag>字节</tag>
      
      <tag>头条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANR 设计思路：埋雷和除雷</title>
    <link href="/2022/02/14/anr-bigpicture/"/>
    <url>/2022/02/14/anr-bigpicture/</url>
    
    <content type="html"><![CDATA[<p><code>埋雷</code> 和 <code>除雷</code> 是 Android 设计 ANR 时的一个重要思路，ANR 的实质是超时，那么只需要在执行前埋下延迟爆炸的雷，如果在规定时间内执行完毕则把雷移除，否则到点雷爆炸抛出 ANR</p><p>下面以 <code>startService</code> 为例：</p><ol><li><code>startService</code> 时记录下当前时间，并埋下延时任务 <code>sendMessageDelayed</code></li><li><code>bindService</code> 表示启动完毕，移除上面埋下的雷 <code>SERVICE_TIMEOUT_MSG</code></li><li>否则到点雷爆炸 <code>serviceTimeout</code>，根据 Service 的启动时间和超时时间（<code>SERVICE_TIMEOUT</code> / <code>SERVICE_BACKGROUND_TIMEOUT</code>）找到执行超时的 Service</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 埋雷，放入 ANR Message: SERVICE_TIMEOUT_MSG</span><span class="hljs-comment">// How long we wait for a service to finish executing.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVICE_TIMEOUT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span> * <span class="hljs-number">1000</span> * Build.HW_TIMEOUT_MULTIPLIER; <span class="hljs-comment">// 前台 Service 超时时间</span><span class="hljs-comment">// How long we wait for a service to finish executing.</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVICE_BACKGROUND_TIMEOUT</span> <span class="hljs-operator">=</span> SERVICE_TIMEOUT * <span class="hljs-number">10</span>;         <span class="hljs-comment">// 后台 Service 超时时间</span><span class="hljs-comment">// AMS.startService</span><span class="hljs-comment">// ActiveServices.startServiceLocked</span><span class="hljs-comment">// ActiveServices.startServiceInnerLocked(ServiceRecord r, Intent service, ...)</span><span class="hljs-comment">// ActiveServices.startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting)</span><span class="hljs-comment">// ActiveServices.bringUpServiceLocked</span><span class="hljs-comment">// ActiveServices.realStartServiceLocked</span><span class="hljs-comment">// ActiveServices.bumpServiceExecutingLocked</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleServiceTimeoutLocked</span><span class="hljs-params">(ProcessRecord proc)</span> &#123;    <span class="hljs-keyword">if</span> (proc.mServices.numberOfExecutingServices() == <span class="hljs-number">0</span> || proc.getThread() == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mAm.mHandler.obtainMessage(            ActivityManagerService.SERVICE_TIMEOUT_MSG);    msg.obj = proc;    mAm.mHandler.sendMessageDelayed(msg, proc.mServices.shouldExecServicesFg()            ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);&#125;<span class="hljs-comment">// 看看这颗雷爆炸了会发生什么</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;            <span class="hljs-keyword">switch</span> (msg.what) &#123;            <span class="hljs-keyword">case</span> GC_BACKGROUND_PROCESSES_MSG: &#123;                <span class="hljs-keyword">synchronized</span> (ActivityManagerService.<span class="hljs-built_in">this</span>) &#123;                    mAppProfiler.performAppGcsIfAppropriateLocked();                &#125;            &#125; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;                mServices.serviceTimeout((ProcessRecord) msg.obj);            &#125; <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// case ...</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveServices</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceTimeout</span><span class="hljs-params">(ProcessRecord proc)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">anrMessage</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">synchronized</span>(mAm) &#123;            <span class="hljs-keyword">if</span> (proc.isDebugging()) &#123;                <span class="hljs-comment">// The app&#x27;s being debugged, ignore timeout.</span>                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-type">ProcessServiceRecord</span> <span class="hljs-variable">psr</span> <span class="hljs-operator">=</span> proc.mServices;            <span class="hljs-keyword">if</span> (psr.numberOfExecutingServices() == <span class="hljs-number">0</span> || proc.getThread() == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// sr.executingStart 是 startService 的时间</span>            <span class="hljs-comment">// maxTime 是理论上推算出的、如果 Service 没有 timeout 的 startService 时间</span>            <span class="hljs-comment">// 如果 sr.executingStart &lt; maxTime 说明 Service 执行超时了</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxTime</span> <span class="hljs-operator">=</span>  now -                    (psr.shouldExecServicesFg() ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);            <span class="hljs-type">ServiceRecord</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-type">long</span> <span class="hljs-variable">nextTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> psr.numberOfExecutingServices() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                <span class="hljs-type">ServiceRecord</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> psr.getExecutingServiceAt(i);                <span class="hljs-keyword">if</span> (sr.executingStart &lt; maxTime) &#123;                    timeout = sr;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (sr.executingStart &gt; nextTime) &#123;                    nextTime = sr.executingStart;                &#125;            &#125;            <span class="hljs-keyword">if</span> (timeout != <span class="hljs-literal">null</span> &amp;&amp; mAm.mProcessList.isInLruListLOSP(proc)) &#123;                Slog.w(TAG, <span class="hljs-string">&quot;Timeout executing service: &quot;</span> + timeout);                <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastPrintWriter</span>(sw, <span class="hljs-literal">false</span>, <span class="hljs-number">1024</span>);                pw.println(timeout);                timeout.dump(pw, <span class="hljs-string">&quot;    &quot;</span>);                pw.close();                mLastAnrDump = sw.toString();                mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);                mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);                anrMessage = <span class="hljs-string">&quot;executing service &quot;</span> + timeout.shortInstanceName;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mAm.mHandler.obtainMessage(                        ActivityManagerService.SERVICE_TIMEOUT_MSG);                msg.obj = proc;                mAm.mHandler.sendMessageAtTime(msg, psr.shouldExecServicesFg()                        ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));            &#125;        &#125;        <span class="hljs-comment">// 真正的 ANR 处理逻辑，具体可以看这篇 【深入 ANR：产生的根源、处理流程和日志文件】</span>        <span class="hljs-keyword">if</span> (anrMessage != <span class="hljs-literal">null</span>) &#123;            mAm.mAnrHelper.appNotResponding(proc, anrMessage);        &#125;    &#125;    &#125;<span class="hljs-comment">// 除雷，Service 在规定时间内启动完毕，则需要移除 SERVICE_TIMEOUT_MSG 消息</span><span class="hljs-comment">// AMS.bindService</span><span class="hljs-comment">// AMS.bindIsolatedService</span><span class="hljs-comment">// ActiveServices.bindServiceLocked</span><span class="hljs-comment">// ActiveServices.requestServiceBindingLocked</span><span class="hljs-comment">// ActivityThread.scheduleBindService</span><span class="hljs-comment">// ActivityThread.handleBindService</span><span class="hljs-comment">// AMS.publishService</span><span class="hljs-comment">// ActiveServices.publishServiceLocked</span><span class="hljs-comment">// ActiveServices.serviceDoneExecutingLocked</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveServices</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceDoneExecutingLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-type">boolean</span> inDestroying,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> finishing, <span class="hljs-type">boolean</span> enqueueOomAdj)</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="hljs-string">&quot;&lt;&lt;&lt; DONE EXECUTING &quot;</span> + r                + <span class="hljs-string">&quot;: nesting=&quot;</span> + r.executeNesting                + <span class="hljs-string">&quot;, inDestroying=&quot;</span> + inDestroying + <span class="hljs-string">&quot;, app=&quot;</span> + r.app);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,                <span class="hljs-string">&quot;&lt;&lt;&lt; DONE EXECUTING &quot;</span> + r.shortInstanceName);        r.executeNesting--;        <span class="hljs-keyword">if</span> (r.executeNesting &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (r.app != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-type">ProcessServiceRecord</span> <span class="hljs-variable">psr</span> <span class="hljs-operator">=</span> r.app.mServices;                <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,                        <span class="hljs-string">&quot;Nesting at 0 of &quot;</span> + r.shortInstanceName);                psr.setExecServicesFg(<span class="hljs-literal">false</span>);                psr.stopExecutingService(r);                <span class="hljs-keyword">if</span> (psr.numberOfExecutingServices() == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,                            <span class="hljs-string">&quot;No more executingServices of &quot;</span> + r.shortInstanceName);                    <span class="hljs-comment">// Service 成功启动，移除上面埋下的雷 SERVICE_TIMEOUT_MSG</span>                    mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.executeFg) &#123;                    <span class="hljs-comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> psr.numberOfExecutingServices() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                        <span class="hljs-keyword">if</span> (psr.getExecutingServiceAt(i).executeFg) &#123;                            psr.setExecServicesFg(<span class="hljs-literal">true</span>);                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (inDestroying) &#123;                    <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,                            <span class="hljs-string">&quot;doneExecuting remove destroying &quot;</span> + r);                    mDestroyingServices.remove(r);                    r.bindings.clear();                &#125;                <span class="hljs-keyword">if</span> (enqueueOomAdj) &#123;                    mAm.enqueueOomAdjTargetLocked(r.app);                &#125; <span class="hljs-keyword">else</span> &#123;                    mAm.updateOomAdjLocked(r.app, OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);                &#125;            &#125;            r.executeFg = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (r.tracker != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">synchronized</span> (mAm.mProcessStats.mLock) &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">memFactor</span> <span class="hljs-operator">=</span> mAm.mProcessStats.getMemFactorLocked();                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();                    r.tracker.setExecuting(<span class="hljs-literal">false</span>, memFactor, now);                    r.tracker.setForeground(<span class="hljs-literal">false</span>, memFactor, now);                    <span class="hljs-keyword">if</span> (finishing) &#123;                        r.tracker.clearCurrentOwner(r, <span class="hljs-literal">false</span>);                        r.tracker = <span class="hljs-literal">null</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span> (finishing) &#123;                <span class="hljs-keyword">if</span> (r.app != <span class="hljs-literal">null</span> &amp;&amp; !r.app.isPersistent()) &#123;                    stopServiceAndUpdateAllowlistManagerLocked(r);                &#125;                r.setProcess(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);            &#125;        &#125;    &#125;    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识 Fresco</title>
    <link href="/2021/12/22/fresco/"/>
    <url>/2021/12/22/fresco/</url>
    
    <content type="html"><![CDATA[<h1 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h1><p><a href="https://github.com/facebook/fresco">Fresco</a> 最简单和入门级的 API 是 <code>SimpleDraweeView.setImageURI(uri)</code>，那就先从这个方法走下去看看会遇到哪些概念</p><div class="code-wrapper"><pre><code class="hljs java">SimpleDraweeView.setImageURI(uri)SimpleDraweeView.setImageURI(uri, <span class="hljs-literal">null</span>)DraweeView.setControllerDraweeHolder.setControllerDraweeHolder.attachControllerAbstractDraweeController.onAttachAbstractDraweeController.submitRequest<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDraweeController</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submitRequest</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractDraweeController#submitRequest&quot;</span>);    &#125;    <span class="hljs-comment">// 检查缓存，有则直接返回缓存数据，没有则执行抓取操作；现在先不理缓存逻辑</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">T</span> <span class="hljs-variable">closeableImage</span> <span class="hljs-operator">=</span> getCachedImage();        <span class="hljs-keyword">if</span> (closeableImage != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractDraweeController#submitRequest-&gt;cache&quot;</span>);      &#125;      mDataSource = <span class="hljs-literal">null</span>;      mIsRequestSubmitted = <span class="hljs-literal">true</span>;      mHasFetchFailed = <span class="hljs-literal">false</span>;      mEventTracker.recordEvent(Event.ON_SUBMIT_CACHE_HIT);      reportSubmit(mDataSource, getImageInfo(closeableImage));      onImageLoadedFromCacheImmediately(mId, closeableImage);      onNewResultInternal(mId, mDataSource, closeableImage, <span class="hljs-number">1.0f</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;      <span class="hljs-keyword">return</span>;    &#125;    mEventTracker.recordEvent(Event.ON_DATASOURCE_SUBMIT);    mSettableDraweeHierarchy.setProgress(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);    mIsRequestSubmitted = <span class="hljs-literal">true</span>;    mHasFetchFailed = <span class="hljs-literal">false</span>;    mDataSource = getDataSource();    <span class="hljs-comment">// 重要</span>    reportSubmit(mDataSource, <span class="hljs-literal">null</span>);    <span class="hljs-keyword">if</span> (FLog.isLoggable(FLog.VERBOSE)) &#123;      FLog.v(          TAG,          <span class="hljs-string">&quot;controller %x %s: submitRequest: dataSource: %x&quot;</span>,          System.identityHashCode(<span class="hljs-built_in">this</span>),          mId,          System.identityHashCode(mDataSource));    &#125;    <span class="hljs-comment">// 从数据源抓取，callback 模式，有三种情况：成功、失败和更新进度</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> mId;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wasImmediate</span> <span class="hljs-operator">=</span> mDataSource.hasResult();    <span class="hljs-keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber =        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseDataSubscriber</span>&lt;T&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResultImpl</span><span class="hljs-params">(DataSource&lt;T&gt; dataSource)</span> &#123;            <span class="hljs-comment">// isFinished must be obtained before image, otherwise we might set intermediate result</span>            <span class="hljs-comment">// as final image.</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFinished</span> <span class="hljs-operator">=</span> dataSource.isFinished();            <span class="hljs-type">boolean</span> <span class="hljs-variable">hasMultipleResults</span> <span class="hljs-operator">=</span> dataSource.hasMultipleResults();            <span class="hljs-type">float</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> dataSource.getProgress();            <span class="hljs-type">T</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> dataSource.getResult();            <span class="hljs-keyword">if</span> (image != <span class="hljs-literal">null</span>) &#123;              onNewResultInternal(                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFinished) &#123;              onFailureInternal(id, dataSource, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(), <span class="hljs-comment">/* isFinished */</span> <span class="hljs-literal">true</span>);            &#125;          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailureImpl</span><span class="hljs-params">(DataSource&lt;T&gt; dataSource)</span> &#123;            onFailureInternal(id, dataSource, dataSource.getFailureCause(), <span class="hljs-comment">/* isFinished */</span> <span class="hljs-literal">true</span>);          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onProgressUpdate</span><span class="hljs-params">(DataSource&lt;T&gt; dataSource)</span> &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFinished</span> <span class="hljs-operator">=</span> dataSource.isFinished();            <span class="hljs-type">float</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> dataSource.getProgress();            onProgressUpdateInternal(id, dataSource, progress, isFinished);          &#125;        &#125;;    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDataSource</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DataSourceStatus</span> &#123;    <span class="hljs-comment">// data source has not finished yet</span>    IN_PROGRESS,    <span class="hljs-comment">// data source has finished with success</span>    SUCCESS,    <span class="hljs-comment">// data source has finished with failure</span>    FAILURE,  &#125;  <span class="hljs-comment">// 数据源有三种状态：行进中、成功和失败，一般情况下会是还没开始抓取操作也就是【行进中】</span>  <span class="hljs-comment">// callback 也就是订阅者被数据源保存起来以便后续通知</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribe</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber, <span class="hljs-keyword">final</span> Executor executor)</span> &#123;    Preconditions.checkNotNull(dataSubscriber);    Preconditions.checkNotNull(executor);    <span class="hljs-type">boolean</span> shouldNotify;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;      <span class="hljs-keyword">if</span> (mIsClosed) &#123;        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">if</span> (mDataSourceStatus == DataSourceStatus.IN_PROGRESS) &#123;        mSubscribers.add(Pair.create(dataSubscriber, executor));      &#125;      shouldNotify = hasResult() || isFinished() || wasCancelled();    &#125;    <span class="hljs-keyword">if</span> (shouldNotify) &#123;      notifyDataSubscriber(dataSubscriber, executor, hasFailed(), wasCancelled());    &#125;  &#125;    &#125;<span class="hljs-comment">// 到目前为止，只看到了 callback 但没看到是什么时候开始抓取数据（比如网络请求操作）</span><span class="hljs-comment">// 但看到 DataSource 的描述，隐隐感觉到网络请求操作很可能已经发出，而 DataSource 就是代表这个异步操作（类似于 Future）</span><span class="hljs-comment">// 它作为绳子的一端连接着另一端的 fetch task，从这端出发按图索骥即可找到 fetch task</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * An alternative to Java Futures for the image pipeline.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataSource</span>&lt;T&gt;SimpleDraweeView.setImageURI(uri)SimpleDraweeView.setImageURI(uri, <span class="hljs-literal">null</span>)AbstractDraweeControllerBuilder.buildAbstractDraweeControllerBuilder.buildControllerPipelineDraweeControllerBuilder.obtainControllerAbstractDraweeControllerBuilder.obtainDataSourceSupplierAbstractDraweeControllerBuilder.getDataSourceSupplierForRequest(controller, controllerId, imageRequest)AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest(controller, controllerId, imageRequest, CacheLevel.FULL_FETCH)PipelineDraweeControllerBuilder.getDataSourceForRequest<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImagePipeline</span> &#123;  <span class="hljs-keyword">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="hljs-title function_">fetchDecodedImage</span><span class="hljs-params">(</span><span class="hljs-params">      ImageRequest imageRequest,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> Object callerContext,</span><span class="hljs-params">      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestListener requestListener,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> String uiComponentId)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);    <span class="hljs-comment">// Producer 生产者负责从网络抓取图片</span>      <span class="hljs-keyword">return</span> submitFetchRequest(                                                     <span class="hljs-comment">// 在这里将任务提交到任务队列等待执行</span>          producerSequence,          imageRequest,          lowestPermittedRequestLevelOnSubmit,          callerContext,          requestListener,          uiComponentId);    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;      <span class="hljs-keyword">return</span> DataSources.immediateFailedDataSource(exception);    &#125;  &#125;  <span class="hljs-keyword">private</span> &lt;T&gt; DataSource&lt;CloseableReference&lt;T&gt;&gt; <span class="hljs-title function_">submitFetchRequest</span><span class="hljs-params">(</span><span class="hljs-params">      Producer&lt;CloseableReference&lt;T&gt;&gt; producerSequence,</span><span class="hljs-params">      ImageRequest imageRequest,</span><span class="hljs-params">      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> Object callerContext,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestListener requestListener,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> String uiComponentId)</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;ImagePipeline#submitFetchRequest&quot;</span>);    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">RequestListener2</span> <span class="hljs-variable">requestListener2</span> <span class="hljs-operator">=</span>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalRequestListener</span>(            getRequestListenerForRequest(imageRequest, requestListener), mRequestListener2);    <span class="hljs-keyword">if</span> (mCallerContextVerifier != <span class="hljs-literal">null</span>) &#123;      mCallerContextVerifier.verifyCallerContext(callerContext, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-keyword">try</span> &#123;      ImageRequest.<span class="hljs-type">RequestLevel</span> <span class="hljs-variable">lowestPermittedRequestLevel</span> <span class="hljs-operator">=</span>          ImageRequest.RequestLevel.getMax(              imageRequest.getLowestPermittedRequestLevel(), lowestPermittedRequestLevelOnSubmit);      <span class="hljs-type">SettableProducerContext</span> <span class="hljs-variable">settableProducerContext</span> <span class="hljs-operator">=</span>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">SettableProducerContext</span>(              imageRequest,              generateUniqueFutureId(),              uiComponentId,              requestListener2,              callerContext,              lowestPermittedRequestLevel,              <span class="hljs-comment">/* isPrefetch */</span> <span class="hljs-literal">false</span>,              imageRequest.getProgressiveRenderingEnabled()                  || !UriUtil.isNetworkUri(imageRequest.getSourceUri()),              imageRequest.getPriority(),              mConfig);      <span class="hljs-keyword">return</span> CloseableProducerToDataSourceAdapter.create(          producerSequence, settableProducerContext, requestListener2);    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;      <span class="hljs-keyword">return</span> DataSources.immediateFailedDataSource(exception);    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;  &#125;  &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CloseableProducerToDataSourceAdapter</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; DataSource&lt;CloseableReference&lt;T&gt;&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(</span><span class="hljs-params">      Producer&lt;CloseableReference&lt;T&gt;&gt; producer,</span><span class="hljs-params">      SettableProducerContext settableProducerContext,</span><span class="hljs-params">      RequestListener2 listener)</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;CloseableProducerToDataSourceAdapter#create&quot;</span>);    &#125;    CloseableProducerToDataSourceAdapter&lt;T&gt; result =        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CloseableProducerToDataSourceAdapter</span>&lt;T&gt;(producer, settableProducerContext, listener);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">return</span> result;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProducerToDataSourceAdapter</span> &#123;  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractProducerToDataSourceAdapter</span><span class="hljs-params">(</span><span class="hljs-params">      Producer&lt;T&gt; producer,</span><span class="hljs-params">      SettableProducerContext settableProducerContext,</span><span class="hljs-params">      RequestListener2 requestListener)</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractProducerToDataSourceAdapter()&quot;</span>);    &#125;    mSettableProducerContext = settableProducerContext;    mRequestListener = requestListener;    setInitialExtras();    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractProducerToDataSourceAdapter()-&gt;onRequestStart&quot;</span>);    &#125;    mRequestListener.onRequestStart(mSettableProducerContext);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractProducerToDataSourceAdapter()-&gt;produceResult&quot;</span>);    &#125;    producer.produceResults(createConsumer(), settableProducerContext);                     <span class="hljs-comment">// 提交任务到任务队列的操作隐藏在这里</span>    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;  &#125;    &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Fresco 设计了生产者这么一个概念来组合/组装整个图形处理流水线（ImagePipeline），上一个生产者的输出可以作为下一个生产者的输入</span><span class="hljs-comment"> * Building block for image processing in the image pipeline</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Producer</span>&lt;T&gt; &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 此方法用以启动整个图像流水线，结果是通过 callback 模式（Consumer）回传的</span><span class="hljs-comment">   * Start producing results for given context. Provided consumer is notified whenever progress is</span><span class="hljs-comment">   * made (new value is ready or error occurs).</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(Consumer&lt;T&gt; consumer, ProducerContext context)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResult</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> T newResult, <span class="hljs-meta">@Status</span> <span class="hljs-type">int</span> status)</span>;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span>;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellation</span><span class="hljs-params">()</span>;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onProgressUpdate</span><span class="hljs-params">(<span class="hljs-type">float</span> progress)</span>;&#125;<span class="hljs-comment">// 回到 ImagePipeline.fetchDecodedImage 看看整个流水线是怎么组装起来的</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerSequenceFactory</span> &#123;  <span class="hljs-keyword">public</span> Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="hljs-title function_">getDecodedImageProducerSequence</span><span class="hljs-params">(</span><span class="hljs-params">      ImageRequest imageRequest)</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;ProducerSequenceFactory#getDecodedImageProducerSequence&quot;</span>);    &#125;    Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =        getBasicDecodedImageSequence(imageRequest);    <span class="hljs-comment">// 后处理器、预加载为 Bitmap 和延迟加载</span>    <span class="hljs-keyword">if</span> (imageRequest.getPostprocessor() != <span class="hljs-literal">null</span>) &#123;          pipelineSequence = getPostprocessorSequence(pipelineSequence);    &#125;    <span class="hljs-keyword">if</span> (mUseBitmapPrepareToDraw) &#123;      pipelineSequence = getBitmapPrepareSequence(pipelineSequence);    &#125;    <span class="hljs-keyword">if</span> (mAllowDelay &amp;&amp; imageRequest.getDelayMs() &gt; <span class="hljs-number">0</span>) &#123;      pipelineSequence = getDelaySequence(pipelineSequence);    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">return</span> pipelineSequence;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerSequenceFactory</span> &#123;  <span class="hljs-keyword">private</span> Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="hljs-title function_">getBasicDecodedImageSequence</span><span class="hljs-params">(</span><span class="hljs-params">      ImageRequest imageRequest)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;ProducerSequenceFactory#getBasicDecodedImageSequence&quot;</span>);      &#125;      Preconditions.checkNotNull(imageRequest);      <span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> imageRequest.getSourceUri();      Preconditions.checkNotNull(uri, <span class="hljs-string">&quot;Uri is null.&quot;</span>);      <span class="hljs-keyword">switch</span> (imageRequest.getSourceUriType()) &#123;        <span class="hljs-keyword">case</span> SOURCE_TYPE_NETWORK:    <span class="hljs-comment">// 网络数据源</span>          <span class="hljs-keyword">return</span> getNetworkFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_LOCAL_VIDEO_FILE:          <span class="hljs-keyword">return</span> getLocalVideoFileFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_LOCAL_IMAGE_FILE:          <span class="hljs-keyword">return</span> getLocalImageFileFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_LOCAL_CONTENT:          <span class="hljs-keyword">if</span> (imageRequest.getLoadThumbnailOnly()              &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;            <span class="hljs-keyword">return</span> getLocalContentUriThumbnailFetchSequence();          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MediaUtils.isVideo(mContentResolver.getType(uri))) &#123;            <span class="hljs-keyword">return</span> getLocalVideoFileFetchSequence();          &#125;          <span class="hljs-keyword">return</span> getLocalContentUriFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_LOCAL_ASSET:          <span class="hljs-keyword">return</span> getLocalAssetFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_LOCAL_RESOURCE:          <span class="hljs-keyword">return</span> getLocalResourceFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_QUALIFIED_RESOURCE:          <span class="hljs-keyword">return</span> getQualifiedResourceFetchSequence();        <span class="hljs-keyword">case</span> SOURCE_TYPE_DATA:          <span class="hljs-keyword">return</span> getDataFetchSequence();        <span class="hljs-keyword">default</span>:          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(              <span class="hljs-string">&quot;Unsupported uri scheme! Uri is: &quot;</span> + getShortenedUriString(uri));      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;  &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="hljs-title function_">getNetworkFetchSequence</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;ProducerSequenceFactory#getNetworkFetchSequence&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (mNetworkFetchSequence == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;ProducerSequenceFactory#getNetworkFetchSequence:init&quot;</span>);      &#125;      mNetworkFetchSequence =          newBitmapCacheGetToDecodeSequence(getCommonNetworkFetchToEncodedMemorySequence());      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">return</span> mNetworkFetchSequence;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> Producer&lt;EncodedImage&gt; <span class="hljs-title function_">getCommonNetworkFetchToEncodedMemorySequence</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(          <span class="hljs-string">&quot;ProducerSequenceFactory#getCommonNetworkFetchToEncodedMemorySequence&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (mCommonNetworkFetchToEncodedMemorySequence == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(            <span class="hljs-string">&quot;ProducerSequenceFactory#getCommonNetworkFetchToEncodedMemorySequence:init&quot;</span>);      &#125;      Producer&lt;EncodedImage&gt; inputProducer =          Preconditions.checkNotNull(              newEncodedCacheMultiplexToTranscodeSequence(                        <span class="hljs-comment">// decode 和 cache</span>                  mProducerFactory.newNetworkFetchProducer(mNetworkFetcher)));    <span class="hljs-comment">// 从网络获取 byte array</span>      mCommonNetworkFetchToEncodedMemorySequence =          ProducerFactory.newAddImageTransformMetaDataProducer(inputProducer);      mCommonNetworkFetchToEncodedMemorySequence =          mProducerFactory.newResizeAndRotateProducer(                            <span class="hljs-comment">// 缩放和选择</span>              mCommonNetworkFetchToEncodedMemorySequence,              mResizeAndRotateEnabledForNetwork &amp;&amp; !mDownsampleEnabled,              mImageTranscoderFactory);      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">return</span> mCommonNetworkFetchToEncodedMemorySequence;  &#125;      &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerFactory</span> &#123;  <span class="hljs-keyword">public</span> Producer&lt;EncodedImage&gt; <span class="hljs-title function_">newNetworkFetchProducer</span><span class="hljs-params">(NetworkFetcher networkFetcher)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkFetchProducer</span>(mPooledByteBufferFactory, mByteArrayPool, networkFetcher);  &#125;    &#125;<span class="hljs-comment">// NetworkFetchProducer.produceResults 会将网络请求任务提交到任务队列</span><span class="hljs-comment">// 得到的数据（byte array）包装为 EncodedImage（并没有立刻 decode）交给下一个 Producer</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkFetchProducer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Producer</span>&lt;EncodedImage&gt; &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(Consumer&lt;EncodedImage&gt; consumer, ProducerContext context)</span> &#123;    context.getProducerListener().onProducerStart(context, PRODUCER_NAME);    <span class="hljs-keyword">final</span> <span class="hljs-type">FetchState</span> <span class="hljs-variable">fetchState</span> <span class="hljs-operator">=</span> mNetworkFetcher.createFetchState(consumer, context);    mNetworkFetcher.fetch(        fetchState,        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkFetcher</span>.Callback() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(InputStream response, <span class="hljs-type">int</span> responseLength)</span> <span class="hljs-keyword">throws</span> IOException &#123;            <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;              FrescoSystrace.beginSection(<span class="hljs-string">&quot;NetworkFetcher-&gt;onResponse&quot;</span>);            &#125;            NetworkFetchProducer.<span class="hljs-built_in">this</span>.onResponse(fetchState, response, responseLength);            <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;              FrescoSystrace.endSection();            &#125;          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable throwable)</span> &#123;            NetworkFetchProducer.<span class="hljs-built_in">this</span>.onFailure(fetchState, throwable);          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellation</span><span class="hljs-params">()</span> &#123;            NetworkFetchProducer.<span class="hljs-built_in">this</span>.onCancellation(fetchState);          &#125;        &#125;);  &#125;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(</span><span class="hljs-params">      FetchState fetchState, InputStream responseData, <span class="hljs-type">int</span> responseContentLength)</span>      <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">final</span> PooledByteBufferOutputStream pooledOutputStream;    <span class="hljs-keyword">if</span> (responseContentLength &gt; <span class="hljs-number">0</span>) &#123;      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);    &#125; <span class="hljs-keyword">else</span> &#123;      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] ioArray = mByteArrayPool.get(READ_SIZE);    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-type">int</span> length;      <span class="hljs-keyword">while</span> ((length = responseData.read(ioArray)) &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>) &#123;          pooledOutputStream.write(ioArray, <span class="hljs-number">0</span>, length);          maybeHandleIntermediateResult(pooledOutputStream, fetchState);          <span class="hljs-type">float</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> calculateProgress(pooledOutputStream.size(), responseContentLength);          fetchState.getConsumer().onProgressUpdate(progress);        &#125;      &#125;      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());      handleFinalResult(pooledOutputStream, fetchState);    &#125; <span class="hljs-keyword">finally</span> &#123;      mByteArrayPool.release(ioArray);      pooledOutputStream.close();    &#125;  &#125;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleFinalResult</span><span class="hljs-params">(</span><span class="hljs-params">      PooledByteBufferOutputStream pooledOutputStream, FetchState fetchState)</span> &#123;    Map&lt;String, String&gt; extraMap = getExtraMap(fetchState, pooledOutputStream.size());    <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> fetchState.getListener();    listener.onProducerFinishWithSuccess(fetchState.getContext(), PRODUCER_NAME, extraMap);    listener.onUltimateProducerReached(fetchState.getContext(), PRODUCER_NAME, <span class="hljs-literal">true</span>);    fetchState.getContext().putOriginExtra(<span class="hljs-string">&quot;network&quot;</span>);    notifyConsumer(        pooledOutputStream,        Consumer.IS_LAST | fetchState.getOnNewResultStatusFlags(),        fetchState.getResponseBytesRange(),        fetchState.getConsumer(),        fetchState.getContext());  &#125;        &#125;</code></pre></div><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p>Fresco 不能像 Glide 那样直接作用于 <code>ImageView</code>，必须用 <code>SimpleDraweeView</code> 替换掉布局里的 ImageView（感觉侵入性有点强呀？）</p><p>还好 Fresco 内部逻辑并没有写到 UI 控件 <code>SimpleDraweeView</code> 里，而是抽离放在 <code>DraweeHolder</code> 和 <code>DraweeController</code> 里</p><p>图像的加载和处理是一个流水线 <code>ImagePipeline</code>，<code>Producer / Consumer</code> 是流水线上的一个个节点，上一个节点的输出作为下一个节点的输出，各节点是一对一的，生产者和消费者是 callback 模式</p><p>ImagePipeline 的最终输出是一个 <code>DataSource</code>，类似于 <code>Future</code> 的概念，可以用 <code>DataSubscriber</code> 订阅它的各种事件：成功（或者是一个新的结果）、失败、取消和进度更新，数据源和订阅者是一对多的</p><h1 id="ImagePipeline"><a href="#ImagePipeline" class="headerlink" title="ImagePipeline"></a>ImagePipeline</h1><p><code>ImagePipeline</code> 可以想象为一个栈（Stack），不断地往里边添加节点，第一个是头节点，最后一个是尾结点，先添加的节点在后添加节点的前面，后添加节点在先添加节点的后面</p><p>发一个请求时先触达尾结点然后流向头节点，这叫去程，响应从头结点开始流向尾结点，这叫回程</p><p>跟 OkHttp Interceptor Chain 和 Servlet Contianer Filter 一样，ImagePipeline 的一次工作包含去程和回程，以 [A, B, C, D] 为例（A 是头节点）：</p><ul><li>去程从 <code>Producer.produceResults</code> 开始，D.produceResults -&gt; C.produceResults -&gt; B.produceResults -&gt; A.produceResults，A 也许是个 NetworkFetchProducer 执行网络请求，拿到 Response 后执行回程</li><li>回程从 <code>Consumer.onNewResult</code> 开始，A.onNewResult -&gt; B.onNewResult -&gt; C.onNewResult -&gt; D.onNewResult -&gt; my.onNewResult，当然可能会失败 <code>onFailure(throwable)</code>、取消 <code>onCancellation()</code> 等，一样是这个顺序</li></ul><h1 id="NetworkFetchProducer"><a href="#NetworkFetchProducer" class="headerlink" title="NetworkFetchProducer"></a>NetworkFetchProducer</h1><p>顾名思义，执行网络请求（HTTP）的 ImagePipeline 节点，，也是是整个流水线的第一个节点</p><p>它用接口 <code>NetworkFetcher</code> 抹平了底层各网络库的 API 差异，具体的实现有：</p><ul><li>OkHttpNetworkFetcher</li><li>VolleyNetworkFetcher</li><li>HttpUrlConnectionNetworkFetcher</li><li>PriorityNetworkFetcher，它是一个装饰器（Decorator），具体的网络加载功能由上面的那些实现提供，它给请求提供了【优先队列】的特性，后续会说到</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  Interface that specifies network fetcher used by the image pipeline.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NetworkFetcher</span>&lt;FETCH_STATE <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FetchState</span>&gt; &#123;  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(InputStream response, <span class="hljs-type">int</span> responseLength)</span> <span class="hljs-keyword">throws</span> IOException;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable throwable)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellation</span><span class="hljs-params">()</span>;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Creates a new instance of the &#123;<span class="hljs-doctag">@link</span> FetchState&#125;-derived object used to store state.</span><span class="hljs-comment">   */</span>  FETCH_STATE <span class="hljs-title function_">createFetchState</span><span class="hljs-params">(Consumer&lt;EncodedImage&gt; consumer, ProducerContext producerContext)</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Gets a map containing extra parameters to pass to the listeners.</span><span class="hljs-comment">   */</span>  Map&lt;String, String&gt; <span class="hljs-title function_">getExtraMap</span><span class="hljs-params">(FETCH_STATE fetchState, <span class="hljs-type">int</span> byteSize)</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetch</span><span class="hljs-params">(FETCH_STATE fetchState, Callback callback)</span>;  <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldPropagate</span><span class="hljs-params">(FETCH_STATE fetchState)</span>;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFetchCompletion</span><span class="hljs-params">(FETCH_STATE fetchState, <span class="hljs-type">int</span> byteSize)</span>;&#125;</code></pre></div><p><code>NetworkFetchProducer</code> 从 Response 里读取 ByteArray 格式的内容，并包装为 <code>EncodedImage</code> 输出给下一节点；考虑到性能问题，在这一阶段 ByteArray 并没有 decode 为 <code>Bitmap</code>，而是通过解析前 N 个字节长度的数据来获取图片格式、尺寸等一些元信息</p><p>同时加载进度 <code>Consumer.onProgressUpdate</code> 也是由 NetworkFetchProducer 在 Response Reading 时发出</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkFetchProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(Consumer&lt;EncodedImage&gt; consumer, ProducerContext context)</span> &#123;    <span class="hljs-comment">// 网络加载功能交由 NetworkFetcher 实现</span>    context.getProducerListener().onProducerStart(context, PRODUCER_NAME);    <span class="hljs-keyword">final</span> <span class="hljs-type">FetchState</span> <span class="hljs-variable">fetchState</span> <span class="hljs-operator">=</span> mNetworkFetcher.createFetchState(consumer, context);    mNetworkFetcher.fetch(        fetchState,        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkFetcher</span>.Callback() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(InputStream response, <span class="hljs-type">int</span> responseLength)</span> <span class="hljs-keyword">throws</span> IOException &#123;            <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;              FrescoSystrace.beginSection(<span class="hljs-string">&quot;NetworkFetcher-&gt;onResponse&quot;</span>);            &#125;            NetworkFetchProducer.<span class="hljs-built_in">this</span>.onResponse(fetchState, response, responseLength);            <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;              FrescoSystrace.endSection();            &#125;          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable throwable)</span> &#123;            NetworkFetchProducer.<span class="hljs-built_in">this</span>.onFailure(fetchState, throwable);          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellation</span><span class="hljs-params">()</span> &#123;            NetworkFetchProducer.<span class="hljs-built_in">this</span>.onCancellation(fetchState);          &#125;        &#125;);  &#125;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(</span><span class="hljs-params">      FetchState fetchState, InputStream responseData, <span class="hljs-type">int</span> responseContentLength)</span>      <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">final</span> PooledByteBufferOutputStream pooledOutputStream;    <span class="hljs-keyword">if</span> (responseContentLength &gt; <span class="hljs-number">0</span>) &#123;      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);    &#125; <span class="hljs-keyword">else</span> &#123;      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] ioArray = mByteArrayPool.get(READ_SIZE);    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-type">int</span> length;      <span class="hljs-keyword">while</span> ((length = responseData.read(ioArray)) &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>) &#123;          pooledOutputStream.write(ioArray, <span class="hljs-number">0</span>, length);          maybeHandleIntermediateResult(pooledOutputStream, fetchState);          <span class="hljs-type">float</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> calculateProgress(pooledOutputStream.size(), responseContentLength);          fetchState.getConsumer().onProgressUpdate(progress);    <span class="hljs-comment">// 更新加载进度</span>        &#125;      &#125;      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());      handleFinalResult(pooledOutputStream, fetchState);    &#125; <span class="hljs-keyword">finally</span> &#123;      mByteArrayPool.release(ioArray);      pooledOutputStream.close();    &#125;  &#125;      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleFinalResult</span><span class="hljs-params">(</span><span class="hljs-params">      PooledByteBufferOutputStream pooledOutputStream, FetchState fetchState)</span> &#123;    Map&lt;String, String&gt; extraMap = getExtraMap(fetchState, pooledOutputStream.size());    <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> fetchState.getListener();    listener.onProducerFinishWithSuccess(fetchState.getContext(), PRODUCER_NAME, extraMap);    listener.onUltimateProducerReached(fetchState.getContext(), PRODUCER_NAME, <span class="hljs-literal">true</span>);    fetchState.getContext().putOriginExtra(<span class="hljs-string">&quot;network&quot;</span>);    notifyConsumer(        pooledOutputStream,        Consumer.IS_LAST | fetchState.getOnNewResultStatusFlags(),        fetchState.getResponseBytesRange(),        fetchState.getConsumer(),        fetchState.getContext());  &#125;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyConsumer</span><span class="hljs-params">(</span><span class="hljs-params">      PooledByteBufferOutputStream pooledOutputStream,</span><span class="hljs-params">      <span class="hljs-meta">@Consumer</span>.Status <span class="hljs-type">int</span> status,</span><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> BytesRange responseBytesRange,</span><span class="hljs-params">      Consumer&lt;EncodedImage&gt; consumer,</span><span class="hljs-params">      ProducerContext context)</span> &#123;    <span class="hljs-comment">// 将 ByteArray 包装为 EncodedImage 输出给消费者</span>    CloseableReference&lt;PooledByteBuffer&gt; result =        CloseableReference.of(pooledOutputStream.toByteBuffer());    <span class="hljs-type">EncodedImage</span> <span class="hljs-variable">encodedImage</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">try</span> &#123;      encodedImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedImage</span>(result);      encodedImage.setBytesRange(responseBytesRange);      encodedImage.parseMetaData();      context.setEncodedImageOrigin(EncodedImageOrigin.NETWORK);      consumer.onNewResult(encodedImage, status);    &#125; <span class="hljs-keyword">finally</span> &#123;      EncodedImage.closeSafely(encodedImage);      CloseableReference.closeSafely(result);    &#125;  &#125;      &#125;<span class="hljs-comment">// 这里简单地看下 EncodedImage 是如何判断图片格式的，各种图片的格式和 SOI 可以深入代码细节，结合网上资料了解</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncodedImage</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMetaData</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (!sUseCachedMetadata) &#123;      internalParseMetaData();      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (mHasParsedMetadata) &#123;      <span class="hljs-keyword">return</span>;    &#125;    internalParseMetaData();    mHasParsedMetadata = <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">/** Sets the encoded image meta data. */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internalParseMetaData</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">imageFormat</span> <span class="hljs-operator">=</span>        ImageFormatChecker.getImageFormat_WrapIOException(getInputStream());    <span class="hljs-comment">// 解析图片格式</span>    mImageFormat = imageFormat;    <span class="hljs-comment">// BitmapUtil.decodeDimensions has a bug where it will return 100x100 for some WebPs even though</span>    <span class="hljs-comment">// those are not its actual dimensions</span>    <span class="hljs-keyword">final</span> Pair&lt;Integer, Integer&gt; dimensions;    <span class="hljs-comment">// 解析尺寸</span>    <span class="hljs-keyword">if</span> (DefaultImageFormats.isWebpFormat(imageFormat)) &#123;      dimensions = readWebPImageSize();    &#125; <span class="hljs-keyword">else</span> &#123;      dimensions = readImageMetaData().getDimensions();    &#125;    <span class="hljs-keyword">if</span> (imageFormat == DefaultImageFormats.JPEG &amp;&amp; mRotationAngle == UNKNOWN_ROTATION_ANGLE) &#123;      <span class="hljs-comment">// Load the JPEG rotation angle only if we have the dimensions</span>      <span class="hljs-keyword">if</span> (dimensions != <span class="hljs-literal">null</span>) &#123;        mExifOrientation = JfifUtil.getOrientation(getInputStream());        mRotationAngle = JfifUtil.getAutoRotateAngleFromOrientation(mExifOrientation);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imageFormat == DefaultImageFormats.HEIF        &amp;&amp; mRotationAngle == UNKNOWN_ROTATION_ANGLE) &#123;      mExifOrientation = HeifExifUtil.getOrientation(getInputStream());      mRotationAngle = JfifUtil.getAutoRotateAngleFromOrientation(mExifOrientation);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mRotationAngle == UNKNOWN_ROTATION_ANGLE) &#123;      mRotationAngle = <span class="hljs-number">0</span>;    &#125;  &#125;      &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageFormatChecker</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImageFormat <span class="hljs-title function_">getImageFormat_WrapIOException</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InputStream is)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> getImageFormat(is);    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;      <span class="hljs-keyword">throw</span> Throwables.propagate(ioe);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Tries to read up to MAX_HEADER_LENGTH bytes from InputStream is and use read bytes to determine</span><span class="hljs-comment">   * type of the image contained in is. </span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImageFormat <span class="hljs-title function_">getImageFormat</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InputStream is)</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">return</span> getInstance().determineImageFormat(is);  &#125;        <span class="hljs-keyword">public</span> ImageFormat <span class="hljs-title function_">determineImageFormat</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InputStream is)</span> <span class="hljs-keyword">throws</span> IOException &#123;    Preconditions.checkNotNull(is);    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] imageHeaderBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[mMaxHeaderLength];    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">headerSize</span> <span class="hljs-operator">=</span> readHeaderFromStream(mMaxHeaderLength, is, imageHeaderBytes);    <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> mDefaultFormatChecker.determineFormat(imageHeaderBytes, headerSize);    <span class="hljs-keyword">if</span> (format != <span class="hljs-literal">null</span> &amp;&amp; format != ImageFormat.UNKNOWN) &#123;      <span class="hljs-keyword">return</span> format;    &#125;    <span class="hljs-keyword">if</span> (mCustomImageFormatCheckers != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">for</span> (ImageFormat.FormatChecker formatChecker : mCustomImageFormatCheckers) &#123;        format = formatChecker.determineFormat(imageHeaderBytes, headerSize);        <span class="hljs-keyword">if</span> (format != <span class="hljs-literal">null</span> &amp;&amp; format != ImageFormat.UNKNOWN) &#123;          <span class="hljs-keyword">return</span> format;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> ImageFormat.UNKNOWN;  &#125;  &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultImageFormatChecker</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ImageFormat <span class="hljs-title function_">determineFormat</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] headerBytes, <span class="hljs-type">int</span> headerSize)</span> &#123;    Preconditions.checkNotNull(headerBytes);    <span class="hljs-keyword">if</span> (!mUseNewOrder &amp;&amp; WebpSupportStatus.isWebpHeader(headerBytes, <span class="hljs-number">0</span>, headerSize)) &#123;      <span class="hljs-keyword">return</span> getWebpFormat(headerBytes, headerSize);    &#125;    <span class="hljs-keyword">if</span> (isJpegHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.JPEG;    &#125;    <span class="hljs-keyword">if</span> (isPngHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.PNG;    &#125;    <span class="hljs-keyword">if</span> (mUseNewOrder &amp;&amp; WebpSupportStatus.isWebpHeader(headerBytes, <span class="hljs-number">0</span>, headerSize)) &#123;      <span class="hljs-keyword">return</span> getWebpFormat(headerBytes, headerSize);    &#125;    <span class="hljs-keyword">if</span> (isGifHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.GIF;    &#125;    <span class="hljs-keyword">if</span> (isBmpHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.BMP;    &#125;    <span class="hljs-keyword">if</span> (isIcoHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.ICO;    &#125;    <span class="hljs-keyword">if</span> (isHeifHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.HEIF;    &#125;    <span class="hljs-keyword">if</span> (isDngHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.DNG;    &#125;    <span class="hljs-keyword">return</span> ImageFormat.UNKNOWN;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Every JPEG image should start with SOI mark (0xFF, 0xD8) followed by beginning of another</span><span class="hljs-comment">   * segment (0xFF)</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] JPEG_HEADER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[] &#123;(<span class="hljs-type">byte</span>) <span class="hljs-number">0xFF</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">0xD8</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">0xFF</span>&#125;;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Checks if imageHeaderBytes starts with SOI (start of image) marker, followed by 0xFF. If</span><span class="hljs-comment">   * headerSize is lower than 3 false is returned. Description of jpeg format can be found here: &lt;a</span><span class="hljs-comment">   * href=&quot;http://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;</span><span class="hljs-comment">   * http://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt; Annex B deals with compressed data format</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isJpegHeader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] imageHeaderBytes, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> headerSize)</span> &#123;    <span class="hljs-keyword">return</span> headerSize &gt;= JPEG_HEADER.length        &amp;&amp; ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, JPEG_HEADER);  &#125;      &#125;</code></pre></div><h1 id="更多的资源加载器"><a href="#更多的资源加载器" class="headerlink" title="更多的资源加载器"></a>更多的资源加载器</h1><p>通过资源的 URI Scheme 来选择合适的加载器，<code>NetworkFetchProducer</code> 应该是最常用加载器之一了，它从网络获取资源，此外还有 <code>LocalResourceFetchProducer</code>、<code>LocalFileFetchProducer</code> 等</p><table><thead><tr><th>uri</th><th>producer</th><th>core api</th></tr></thead><tbody><tr><td><a href="https://abc.com/avatar.jpg">https://abc.com/avatar.jpg</a></td><td>NetworkFetchProducer</td><td>OkHttp &amp; Volley &amp; HttpUrlConnection</td></tr><tr><td>res://com.example/75281679</td><td>LocalResourceFetchProducer</td><td>Resources.openRawResource(resId) <br /> authority 部分是忽略掉的，直接取 path 作为资源 ID</td></tr><tr><td>asset://com.example/default.jpg</td><td>LocalAssetFetchProducer</td><td>AssetManager.open <br /> authority 部分是忽略掉的，直接取 path 作为 asset path</td></tr><tr><td>file:///sdcard/DCIM/avatar.jpg</td><td>LocalFileFetchProducer</td><td>File API</td></tr><tr><td>content://media/images/2283</td><td>LocalContentUriFetchProducer <br /> LocalThumbnailBitmapProducer</td><td>ContentResolver.openInputStream/loadThumbnail</td></tr><tr><td>data://base64</td><td>DataFetchProducer</td><td>Base64.decode</td></tr><tr><td>android.resource://</td><td>QualifiedResourceFetchProducer</td><td>ContentResolver.openInputStream</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageRequest</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@SourceUriType</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSourceUriType</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Uri uri)</span> &#123;    <span class="hljs-keyword">if</span> (uri == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> SOURCE_TYPE_UNKNOWN;    &#125;    <span class="hljs-keyword">if</span> (UriUtil.isNetworkUri(uri)) &#123;                                      <span class="hljs-comment">// http:// &amp; https://</span>      <span class="hljs-keyword">return</span> SOURCE_TYPE_NETWORK;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UriUtil.isLocalFileUri(uri)) &#123;                             <span class="hljs-comment">// file://</span>      <span class="hljs-keyword">if</span> (MediaUtils.isVideo(MediaUtils.extractMime(uri.getPath()))) &#123;    <span class="hljs-comment">// 通过文件后缀名判断是 image 还是 video</span>        <span class="hljs-keyword">return</span> SOURCE_TYPE_LOCAL_VIDEO_FILE;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> SOURCE_TYPE_LOCAL_IMAGE_FILE;                                    &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UriUtil.isLocalContentUri(uri)) &#123;                          <span class="hljs-comment">// content://</span>      <span class="hljs-keyword">return</span> SOURCE_TYPE_LOCAL_CONTENT;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UriUtil.isLocalAssetUri(uri)) &#123;                            <span class="hljs-comment">// asset://</span>      <span class="hljs-keyword">return</span> SOURCE_TYPE_LOCAL_ASSET;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UriUtil.isLocalResourceUri(uri)) &#123;                         <span class="hljs-comment">// res://</span>      <span class="hljs-keyword">return</span> SOURCE_TYPE_LOCAL_RESOURCE;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UriUtil.isDataUri(uri)) &#123;                                  <span class="hljs-comment">// data://</span>      <span class="hljs-keyword">return</span> SOURCE_TYPE_DATA;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (UriUtil.isQualifiedResourceUri(uri)) &#123;                     <span class="hljs-comment">// android.resource://</span>      <span class="hljs-keyword">return</span> SOURCE_TYPE_QUALIFIED_RESOURCE;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> SOURCE_TYPE_UNKNOWN;    &#125;  &#125;    &#125;</code></pre></div><h1 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h1><p>磁盘缓存这一 feature 由 <code>ImagePipelineConfig.Builder.setDiskCacheEnabled</code> 开启，相关的 <code>ImagePipeline</code> 节点是紧邻着 <code>NetworkFetchProducer</code> 等头节点之后被添加的，包括三个个节点（按添加顺序）：</p><ol><li>PartialDiskCacheProducer</li><li>DiskCacheWriteProducer</li><li>DiskCacheReadProducer</li></ol><p>添加 ImagePipeline 节点的方法栈如下：</p><div class="code-wrapper"><pre><code class="hljs java">SimpleDraweeView.setImageURI(uri)SimpleDraweeView.setImageURI(uri, <span class="hljs-literal">null</span>)AbstractDraweeControllerBuilder.buildAbstractDraweeControllerBuilder.buildControllerPipelineDraweeControllerBuilder.obtainControllerAbstractDraweeControllerBuilder.obtainDataSourceSupplierAbstractDraweeControllerBuilder.getDataSourceSupplierForRequest(controller, controllerId, imageRequest)AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest(controller, controllerId, imageRequest, CacheLevel.FULL_FETCH)PipelineDraweeControllerBuilder.getDataSourceForRequestImagePipeline.fetchDecodedImageProducerSequenceFactory.getDecodedImageProducerSequenceProducerSequenceFactory.getBasicDecodedImageSequenceProducerSequenceFactory.getNetworkFetchSequenceProducerSequenceFactory.getCommonNetworkFetchToEncodedMemorySequenceProducerSequenceFactory.newEncodedCacheMultiplexToTranscodeSequence<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerSequenceFactory</span> &#123;  <span class="hljs-keyword">private</span> Producer&lt;EncodedImage&gt; <span class="hljs-title function_">newDiskCacheSequence</span><span class="hljs-params">(Producer&lt;EncodedImage&gt; inputProducer)</span> &#123;    Producer&lt;EncodedImage&gt; cacheWriteProducer;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;ProducerSequenceFactory#newDiskCacheSequence&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (mPartialImageCachingEnabled) &#123;      Producer&lt;EncodedImage&gt; partialDiskCacheProducer =          mProducerFactory.newPartialDiskCacheProducer(inputProducer);      cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(partialDiskCacheProducer);    &#125; <span class="hljs-keyword">else</span> &#123;      cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(inputProducer);    &#125;    <span class="hljs-type">DiskCacheReadProducer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mProducerFactory.newDiskCacheReadProducer(cacheWriteProducer);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">return</span> result;  &#125;    &#125;</code></pre></div><h2 id="PartialDiskCacheProducer"><a href="#PartialDiskCacheProducer" class="headerlink" title="PartialDiskCacheProducer"></a>PartialDiskCacheProducer</h2><p>由 <code>ImagePipelineConfig.Builder.experiment().setPartialImageCachingEnabled</code> 开启</p><p>继续前先了解下 <a href="../../../../2021/12/16/http-range/">HTTP 分段下载</a> 的概念，可以看到分段下载是可以分多段（按需分段）的，但 <code>PartialDiskCacheProducer</code> 不太一样它只能分两段，看看它代码的逻辑：</p><ol><li>发起 ImagePipeline 请求时（去程）<ol><li>先从 disk cache 里寻找 partial cache</li><li>如果请求的是 partial content 并且 partial cache 包含这一 range，就不需要执行网络请求了，直接返回缓存</li><li>否则 partial cache 作为 <code>IS_PARTIAL_RESULT</code> 返回，且执行网络请求获取剩下的内容</li><li>没有 partial cache 那执行原请求</li></ol></li><li>收到响应时（回程）<ol><li>response header 里包含 <code>Content-Range</code>，说明是 partial content，设置 <code>IS_PARTIAL_RESULT</code> 标志</li><li>存在 partial cache 且是 partial response，合并 cache 和 response 后传递给下一节点，删除 partial cache</li><li>没有 partial cache 且是 partial response，将这部分内容缓存为 partical cache 以便后续合并</li></ol></li></ol><p>那么业务逻辑就是这样的：</p><ol><li>请求一个完整的资源服务器返回部分资源（206，Content-Range），或者请求资源的部分内容（Range 头部），总之就是服务器返回 partial content</li><li>发现 <code>IS_PARTIAL_RESULT</code> 标志，将 response 缓存起来</li><li>下次请求此资源时（Range 头部不是必须的），先返回缓存的部分内容，再请求剩下未获取的内容</li><li>收到响应后（必须包含 <code>Content-Range</code>，否则不认为是 partial content，没有 <code>IS_PARTIAL_RESULT</code> 标志），合并 partial content 和 partial cache 为完整的资源返回，删除 partial cache</li></ol><p>问题就来了，什么场景下会只请求部分内容（Range 头部）、请求一个完整的资源服务器却只返回部分资源（206，Content-Range）？不是很能理解它的使用场景</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PartialDiskCacheProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;EncodedImage&gt; consumer, <span class="hljs-keyword">final</span> ProducerContext producerContext)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> producerContext.getImageRequest();    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDiskCacheEnabledForRead</span> <span class="hljs-operator">=</span>        producerContext            .getImageRequest()            .isCacheEnabled(ImageRequest.CachesLocationsMasks.DISK_READ);    <span class="hljs-keyword">final</span> <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> producerContext.getProducerListener();    listener.onProducerStart(producerContext, PRODUCER_NAME);    <span class="hljs-keyword">final</span> <span class="hljs-type">Uri</span> <span class="hljs-variable">uriForPartialCacheKey</span> <span class="hljs-operator">=</span> createUriForPartialCacheKey(imageRequest);    <span class="hljs-keyword">final</span> <span class="hljs-type">CacheKey</span> <span class="hljs-variable">partialImageCacheKey</span> <span class="hljs-operator">=</span>        mCacheKeyFactory.getEncodedCacheKey(            imageRequest, uriForPartialCacheKey, producerContext.getCallerContext());    <span class="hljs-keyword">if</span> (!isDiskCacheEnabledForRead) &#123;      listener.onProducerFinishWithSuccess(          producerContext, PRODUCER_NAME, getExtraMap(listener, producerContext, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>));      startInputProducer(consumer, producerContext, partialImageCacheKey, <span class="hljs-literal">null</span>);      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 发起请求时，先从 disk cache 里找 partial cache</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">isCancelled</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">final</span> Task&lt;EncodedImage&gt; diskLookupTask =        mDefaultBufferedDiskCache.get(partialImageCacheKey, isCancelled);        <span class="hljs-keyword">final</span> Continuation&lt;EncodedImage, Void&gt; continuation =        onFinishDiskReads(consumer, producerContext, partialImageCacheKey);    diskLookupTask.continueWith(continuation);    subscribeTaskForRequestCancellation(isCancelled, producerContext);  &#125;  <span class="hljs-keyword">private</span> Continuation&lt;EncodedImage, Void&gt; <span class="hljs-title function_">onFinishDiskReads</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;EncodedImage&gt; consumer,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> ProducerContext producerContext,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> CacheKey partialImageCacheKey)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> producerContext.getProducerListener();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Continuation</span>&lt;EncodedImage, Void&gt;() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">then</span><span class="hljs-params">(Task&lt;EncodedImage&gt; task)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (isTaskCancelled(task)) &#123;          listener.onProducerFinishWithCancellation(producerContext, PRODUCER_NAME, <span class="hljs-literal">null</span>);          consumer.onCancellation();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task.isFaulted()) &#123;          listener.onProducerFinishWithFailure(              producerContext, PRODUCER_NAME, task.getError(), <span class="hljs-literal">null</span>);          startInputProducer(consumer, producerContext, partialImageCacheKey, <span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-type">EncodedImage</span> <span class="hljs-variable">cachedReference</span> <span class="hljs-operator">=</span> task.getResult();          <span class="hljs-keyword">if</span> (cachedReference != <span class="hljs-literal">null</span>) &#123;            listener.onProducerFinishWithSuccess(                producerContext,                PRODUCER_NAME,                getExtraMap(listener, producerContext, <span class="hljs-literal">true</span>, cachedReference.getSize()));            <span class="hljs-keyword">final</span> <span class="hljs-type">BytesRange</span> <span class="hljs-variable">cachedRange</span> <span class="hljs-operator">=</span> BytesRange.toMax(cachedReference.getSize() - <span class="hljs-number">1</span>);            cachedReference.setBytesRange(cachedRange);            <span class="hljs-comment">// Create a new ImageRequest for the remaining data</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cachedLength</span> <span class="hljs-operator">=</span> cachedReference.getSize();            <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">originalRequest</span> <span class="hljs-operator">=</span> producerContext.getImageRequest();            <span class="hljs-comment">// 如果请求的是 partial content 并且 partial cache 包含这一 range，就不需要执行网络请求了，直接返回缓存</span>            <span class="hljs-keyword">if</span> (cachedRange.contains(originalRequest.getBytesRange())) &#123;              producerContext.putOriginExtra(<span class="hljs-string">&quot;disk&quot;</span>, <span class="hljs-string">&quot;partial&quot;</span>);              listener.onUltimateProducerReached(producerContext, PRODUCER_NAME, <span class="hljs-literal">true</span>);              consumer.onNewResult(cachedReference, Consumer.IS_LAST | Consumer.IS_PARTIAL_RESULT);            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">// 否则 partial cache 作为 IS_PARTIAL_RESULT 返回，且执行网络请求获取剩下的内容  </span>              consumer.onNewResult(cachedReference, Consumer.IS_PARTIAL_RESULT);              <span class="hljs-comment">// Pass the request on, but only for the remaining bytes</span>              <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">remainingRequest</span> <span class="hljs-operator">=</span>                  ImageRequestBuilder.fromRequest(originalRequest)                      .setBytesRange(BytesRange.from(cachedLength - <span class="hljs-number">1</span>))                      .build();              <span class="hljs-keyword">final</span> <span class="hljs-type">SettableProducerContext</span> <span class="hljs-variable">contextForRemainingRequest</span> <span class="hljs-operator">=</span>                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SettableProducerContext</span>(remainingRequest, producerContext);              startInputProducer(                  consumer, contextForRemainingRequest, partialImageCacheKey, cachedReference);            &#125;          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 没有 partial cache 那执行原请求  </span>            listener.onProducerFinishWithSuccess(                producerContext, PRODUCER_NAME, getExtraMap(listener, producerContext, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>));            startInputProducer(consumer, producerContext, partialImageCacheKey, cachedReference);          &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;      &#125;    &#125;;  &#125;      &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">OkHttpNetworkFetcher</span> &#123;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetchWithRequest</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> OkHttpNetworkFetchState fetchState,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> NetworkFetcher.Callback callback,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Request request)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> mCallFactory.newCall(request);    fetchState        .getContext()        .addCallbacks(            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseProducerContextCallbacks</span>() &#123;              <span class="hljs-meta">@Override</span>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellationRequested</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;                  call.cancel();                &#125; <span class="hljs-keyword">else</span> &#123;                  mCancellationExecutor.execute(                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                          call.cancel();                        &#125;                      &#125;);                &#125;              &#125;            &#125;);    call.enqueue(        <span class="hljs-keyword">new</span> <span class="hljs-title class_">okhttp3</span>.Callback() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;            fetchState.responseTime = SystemClock.elapsedRealtime();            <span class="hljs-keyword">final</span> <span class="hljs-type">ResponseBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> response.body();            <span class="hljs-keyword">if</span> (body == <span class="hljs-literal">null</span>) &#123;              handleException(call, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Response body null: &quot;</span> + response), callback);              <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">try</span> &#123;              <span class="hljs-keyword">if</span> (!response.isSuccessful()) &#123;                handleException(                    call, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unexpected HTTP code &quot;</span> + response), callback);                <span class="hljs-keyword">return</span>;              &#125;              <span class="hljs-comment">// response header 里包含 Content-Range，说明是 partial content，设置 IS_PARTIAL_RESULT 标志</span>              <span class="hljs-type">BytesRange</span> <span class="hljs-variable">responseRange</span> <span class="hljs-operator">=</span>                  BytesRange.fromContentRangeHeader(response.header(<span class="hljs-string">&quot;Content-Range&quot;</span>));              <span class="hljs-keyword">if</span> (responseRange != <span class="hljs-literal">null</span>                  &amp;&amp; !(responseRange.from == <span class="hljs-number">0</span>                      &amp;&amp; responseRange.to == BytesRange.TO_END_OF_CONTENT)) &#123;                <span class="hljs-comment">// Only treat as a partial image if the range is not all of the content</span>                fetchState.setResponseBytesRange(responseRange);                fetchState.setOnNewResultStatusFlags(Consumer.IS_PARTIAL_RESULT);              &#125;              <span class="hljs-type">long</span> <span class="hljs-variable">contentLength</span> <span class="hljs-operator">=</span> body.contentLength();              <span class="hljs-keyword">if</span> (contentLength &lt; <span class="hljs-number">0</span>) &#123;                contentLength = <span class="hljs-number">0</span>;              &#125;              callback.onResponse(body.byteStream(), (<span class="hljs-type">int</span>) contentLength);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;              handleException(call, e, callback);            &#125; <span class="hljs-keyword">finally</span> &#123;              body.close();            &#125;          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;            handleException(call, e, callback);          &#125;        &#125;);  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PartialDiskCacheConsumer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResultImpl</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> EncodedImage newResult, <span class="hljs-meta">@Status</span> <span class="hljs-type">int</span> status)</span> &#123;      <span class="hljs-keyword">if</span> (isNotLast(status)) &#123;        <span class="hljs-comment">// TODO 19247361 Consider merging of non-final results</span>        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// 存在 partial cache 且是 partial response，合并 cache 和 response 后传递给下一节点，删除 partial cache</span>      <span class="hljs-keyword">if</span> (mPartialEncodedImageFromCache != <span class="hljs-literal">null</span>          &amp;&amp; newResult != <span class="hljs-literal">null</span>          &amp;&amp; newResult.getBytesRange() != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">final</span> <span class="hljs-type">PooledByteBufferOutputStream</span> <span class="hljs-variable">pooledOutputStream</span> <span class="hljs-operator">=</span>              merge(mPartialEncodedImageFromCache, newResult);          sendFinalResultToConsumer(pooledOutputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;          <span class="hljs-comment">// TODO 19247425 Delete cached file and request full image</span>          FLog.e(PRODUCER_NAME, <span class="hljs-string">&quot;Error while merging image data&quot;</span>, e);          getConsumer().onFailure(e);        &#125; <span class="hljs-keyword">finally</span> &#123;          newResult.close();          mPartialEncodedImageFromCache.close();        &#125;        mDefaultBufferedDiskCache.remove(mPartialImageCacheKey);        <span class="hljs-comment">// 没有 partial cache 且是 partial response，将这部分内容缓存为 partical cache 以便后续合并</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mIsDiskCacheEnabledForWrite          &amp;&amp; statusHasFlag(status, IS_PARTIAL_RESULT)          &amp;&amp; isLast(status)          &amp;&amp; newResult != <span class="hljs-literal">null</span>          &amp;&amp; newResult.getImageFormat() != ImageFormat.UNKNOWN) &#123;        mDefaultBufferedDiskCache.put(mPartialImageCacheKey, newResult);        getConsumer().onNewResult(newResult, status);      &#125; <span class="hljs-keyword">else</span> &#123;        getConsumer().onNewResult(newResult, status);      &#125;    &#125;    &#125;</code></pre></div><h2 id="read-amp-amp-write"><a href="#read-amp-amp-write" class="headerlink" title="read &amp;&amp; write"></a>read &amp;&amp; write</h2><p>包含两个节点 <code>DiskCacheWriteProducer</code> 和 <code>DiskCacheReadProducer</code>，它们按顺序被添加到 ImagePipeline，那么：</p><ul><li>去程：DiskCacheReadProducer.produceResults -&gt; DiskCacheWriteProducer.produceResults</li><li>回程：DiskCacheWriteProducer.onNewResult -&gt; DiskCacheReadProducer.onNewResult</li></ul><p>发起加载请求是，disk reader 从磁盘缓存里找是否有对应的缓存文件，有的话就无须做网络请求，加载缓存文件至内存后返回；因为是先添加 disk reader 后添加 disk writer 的，请求被 disk reader 截胡后就不经过 disk writer 和 network fetcher 了</p><p>如果没能找到磁盘缓存，请求流转到 network fetcher，拿到 response 后 disk writer 将其保存为磁盘缓存</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskCacheReadProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;EncodedImage&gt; consumer, <span class="hljs-keyword">final</span> ProducerContext producerContext)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> producerContext.getImageRequest();    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDiskCacheEnabledForRead</span> <span class="hljs-operator">=</span>        producerContext            .getImageRequest()            .isCacheEnabled(ImageRequest.CachesLocationsMasks.DISK_READ);    <span class="hljs-keyword">if</span> (!isDiskCacheEnabledForRead) &#123;      maybeStartInputProducer(consumer, producerContext);      <span class="hljs-keyword">return</span>;    &#125;    producerContext.getProducerListener().onProducerStart(producerContext, PRODUCER_NAME);    <span class="hljs-keyword">final</span> <span class="hljs-type">CacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span>        mCacheKeyFactory.getEncodedCacheKey(imageRequest, producerContext.getCallerContext());    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isSmallRequest</span> <span class="hljs-operator">=</span> (imageRequest.getCacheChoice() == CacheChoice.SMALL);    <span class="hljs-keyword">final</span> <span class="hljs-type">BufferedDiskCache</span> <span class="hljs-variable">preferredCache</span> <span class="hljs-operator">=</span>        isSmallRequest ? mSmallImageBufferedDiskCache : mDefaultBufferedDiskCache;    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">isCancelled</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">final</span> Task&lt;EncodedImage&gt; diskLookupTask = preferredCache.get(cacheKey, isCancelled);    <span class="hljs-comment">// 去程，从磁盘缓存里查找</span>    <span class="hljs-keyword">final</span> Continuation&lt;EncodedImage, Void&gt; continuation =        onFinishDiskReads(consumer, producerContext);    diskLookupTask.continueWith(continuation);    subscribeTaskForRequestCancellation(isCancelled, producerContext);  &#125;  <span class="hljs-keyword">private</span> Continuation&lt;EncodedImage, Void&gt; <span class="hljs-title function_">onFinishDiskReads</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;EncodedImage&gt; consumer, <span class="hljs-keyword">final</span> ProducerContext producerContext)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> producerContext.getProducerListener();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Continuation</span>&lt;EncodedImage, Void&gt;() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">then</span><span class="hljs-params">(Task&lt;EncodedImage&gt; task)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (isTaskCancelled(task)) &#123;          listener.onProducerFinishWithCancellation(producerContext, PRODUCER_NAME, <span class="hljs-literal">null</span>);          consumer.onCancellation();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task.isFaulted()) &#123;          listener.onProducerFinishWithFailure(              producerContext, PRODUCER_NAME, task.getError(), <span class="hljs-literal">null</span>);          mInputProducer.produceResults(consumer, producerContext);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-type">EncodedImage</span> <span class="hljs-variable">cachedReference</span> <span class="hljs-operator">=</span> task.getResult();          <span class="hljs-keyword">if</span> (cachedReference != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 找到磁盘缓存直接将去程截了，不继续流向下一节点（网络请求）</span>            listener.onProducerFinishWithSuccess(                producerContext,                PRODUCER_NAME,                getExtraMap(listener, producerContext, <span class="hljs-literal">true</span>, cachedReference.getSize()));            listener.onUltimateProducerReached(producerContext, PRODUCER_NAME, <span class="hljs-literal">true</span>);            producerContext.putOriginExtra(<span class="hljs-string">&quot;disk&quot;</span>);            consumer.onProgressUpdate(<span class="hljs-number">1</span>);            consumer.onNewResult(cachedReference, Consumer.IS_LAST);            cachedReference.close();          &#125; <span class="hljs-keyword">else</span> &#123;                         <span class="hljs-comment">// 否则将请求传递给下一节点</span>            listener.onProducerFinishWithSuccess(                producerContext, PRODUCER_NAME, getExtraMap(listener, producerContext, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>));            mInputProducer.produceResults(consumer, producerContext);          &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;      &#125;    &#125;;  &#125;      &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskCacheWriteConsumer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResultImpl</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> EncodedImage newResult, <span class="hljs-meta">@Status</span> <span class="hljs-type">int</span> status)</span> &#123;      mProducerContext.getProducerListener().onProducerStart(mProducerContext, PRODUCER_NAME);      <span class="hljs-comment">// intermediate, null or uncacheable results are not cached, so we just forward them</span>      <span class="hljs-comment">// as well as the images with unknown format which could be html response from the server</span>      <span class="hljs-keyword">if</span> (isNotLast(status)          || newResult == <span class="hljs-literal">null</span>          || statusHasAnyFlag(status, DO_NOT_CACHE_ENCODED | IS_PARTIAL_RESULT)          || newResult.getImageFormat() == ImageFormat.UNKNOWN) &#123;        mProducerContext            .getProducerListener()            .onProducerFinishWithSuccess(mProducerContext, PRODUCER_NAME, <span class="hljs-literal">null</span>);        getConsumer().onNewResult(newResult, status);        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> mProducerContext.getImageRequest();      <span class="hljs-keyword">final</span> <span class="hljs-type">CacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span>          mCacheKeyFactory.getEncodedCacheKey(imageRequest, mProducerContext.getCallerContext());      <span class="hljs-keyword">if</span> (imageRequest.getCacheChoice() == ImageRequest.CacheChoice.SMALL) &#123;    <span class="hljs-comment">// 将 response 缓存起来</span>        mSmallImageBufferedDiskCache.put(cacheKey, newResult);      &#125; <span class="hljs-keyword">else</span> &#123;        mDefaultBufferedDiskCache.put(cacheKey, newResult);      &#125;      mProducerContext          .getProducerListener()          .onProducerFinishWithSuccess(mProducerContext, PRODUCER_NAME, <span class="hljs-literal">null</span>);      getConsumer().onNewResult(newResult, status);    &#125;    &#125;</code></pre></div><h1 id="内存缓存（encoded）"><a href="#内存缓存（encoded）" class="headerlink" title="内存缓存（encoded）"></a>内存缓存（encoded）</h1><p>添加 <code>EncodedMemoryCacheProducer</code> 节点以实现内存缓存，这里缓存的对象是 <code>encoded</code>，也就是被图像压缩算法编码后的、各种图像格式的原始数据，尚未被 decode 为 Bitmap</p><ul><li><code>去程</code> 时从内存缓存里找，命中直接返回内存数据，未命中则交由下个节点处理</li><li><code>回程</code> 时将原始数据添加到内存缓存中，然后继续往下传递原始数据</li></ul><p>默认开启，由 <code>ImageRequestBuilder.disableMemoryCache</code> 关闭 </p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncodedMemoryCacheProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;EncodedImage&gt; consumer, <span class="hljs-keyword">final</span> ProducerContext producerContext)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;EncodedMemoryCacheProducer#produceResults&quot;</span>);      &#125;      <span class="hljs-keyword">final</span> <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> producerContext.getProducerListener();      listener.onProducerStart(producerContext, PRODUCER_NAME);      <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> producerContext.getImageRequest();      <span class="hljs-keyword">final</span> <span class="hljs-type">CacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span>          mCacheKeyFactory.getEncodedCacheKey(imageRequest, producerContext.getCallerContext());      <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isEncodedCacheEnabledForRead</span> <span class="hljs-operator">=</span>          producerContext              .getImageRequest()              .isCacheEnabled(ImageRequest.CachesLocationsMasks.ENCODED_READ);      CloseableReference&lt;PooledByteBuffer&gt; cachedReference =          isEncodedCacheEnabledForRead ? mMemoryCache.get(cacheKey) : <span class="hljs-literal">null</span>;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (cachedReference != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 命中 encoded 内存缓存，将请求截胡，直接返回内存中的数据</span>          <span class="hljs-type">EncodedImage</span> <span class="hljs-variable">cachedEncodedImage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedImage</span>(cachedReference);          <span class="hljs-keyword">try</span> &#123;            listener.onProducerFinishWithSuccess(                producerContext,                PRODUCER_NAME,                listener.requiresExtraMap(producerContext, PRODUCER_NAME)                    ? ImmutableMap.of(EXTRA_CACHED_VALUE_FOUND, <span class="hljs-string">&quot;true&quot;</span>)                    : <span class="hljs-literal">null</span>);            listener.onUltimateProducerReached(producerContext, PRODUCER_NAME, <span class="hljs-literal">true</span>);            producerContext.putOriginExtra(<span class="hljs-string">&quot;memory_encoded&quot;</span>);            consumer.onProgressUpdate(<span class="hljs-number">1f</span>);            consumer.onNewResult(cachedEncodedImage, Consumer.IS_LAST);            <span class="hljs-keyword">return</span>;          &#125; <span class="hljs-keyword">finally</span> &#123;            EncodedImage.closeSafely(cachedEncodedImage);          &#125;        &#125;        <span class="hljs-keyword">if</span> (producerContext.getLowestPermittedRequestLevel().getValue()            &gt;= ImageRequest.RequestLevel.ENCODED_MEMORY_CACHE.getValue()) &#123;          listener.onProducerFinishWithSuccess(              producerContext,              PRODUCER_NAME,              listener.requiresExtraMap(producerContext, PRODUCER_NAME)                  ? ImmutableMap.of(EXTRA_CACHED_VALUE_FOUND, <span class="hljs-string">&quot;false&quot;</span>)                  : <span class="hljs-literal">null</span>);          listener.onUltimateProducerReached(producerContext, PRODUCER_NAME, <span class="hljs-literal">false</span>);          producerContext.putOriginExtra(<span class="hljs-string">&quot;memory_encoded&quot;</span>, <span class="hljs-string">&quot;nil-result&quot;</span>);          consumer.onNewResult(<span class="hljs-literal">null</span>, Consumer.IS_LAST);          <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumerOfInputProducer</span> <span class="hljs-operator">=</span>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedMemoryCacheConsumer</span>(                consumer,                mMemoryCache,                cacheKey,                producerContext                    .getImageRequest()                    .isCacheEnabled(ImageRequest.CachesLocationsMasks.ENCODED_WRITE),                producerContext.getImagePipelineConfig().getExperiments().isEncodedCacheEnabled());        listener.onProducerFinishWithSuccess(            producerContext,            PRODUCER_NAME,            listener.requiresExtraMap(producerContext, PRODUCER_NAME)                ? ImmutableMap.of(EXTRA_CACHED_VALUE_FOUND, <span class="hljs-string">&quot;false&quot;</span>)                : <span class="hljs-literal">null</span>);        mInputProducer.produceResults(consumerOfInputProducer, producerContext);      &#125; <span class="hljs-keyword">finally</span> &#123;        CloseableReference.closeSafely(cachedReference);      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">EncodedMemoryCacheConsumer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResultImpl</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> EncodedImage newResult, <span class="hljs-meta">@Status</span> <span class="hljs-type">int</span> status)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;EncodedMemoryCacheProducer#onNewResultImpl&quot;</span>);      &#125;      <span class="hljs-comment">// intermediate, null or uncacheable results are not cached, so we just forward them</span>      <span class="hljs-comment">// as well as the images with unknown format which could be html response from the server</span>      <span class="hljs-keyword">if</span> (isNotLast(status)          || newResult == <span class="hljs-literal">null</span>          || statusHasAnyFlag(status, DO_NOT_CACHE_ENCODED | IS_PARTIAL_RESULT)          || newResult.getImageFormat() == ImageFormat.UNKNOWN) &#123;        getConsumer().onNewResult(newResult, status);        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">// cache and forward the last result</span>      CloseableReference&lt;PooledByteBuffer&gt; ref = newResult.getByteBufferRef();      <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;        CloseableReference&lt;PooledByteBuffer&gt; cachedResult = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">if</span> (mEncodedCacheEnabled &amp;&amp; mIsEncodedCacheEnabledForWrite) &#123;    <span class="hljs-comment">// 将原始数据缓存至内存</span>            cachedResult = mMemoryCache.cache(mRequestedCacheKey, ref);          &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;          CloseableReference.closeSafely(ref);        &#125;        <span class="hljs-keyword">if</span> (cachedResult != <span class="hljs-literal">null</span>) &#123;          EncodedImage cachedEncodedImage;          <span class="hljs-keyword">try</span> &#123;            cachedEncodedImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedImage</span>(cachedResult);            cachedEncodedImage.copyMetaDataFrom(newResult);          &#125; <span class="hljs-keyword">finally</span> &#123;            CloseableReference.closeSafely(cachedResult);          &#125;          <span class="hljs-keyword">try</span> &#123;            getConsumer().onProgressUpdate(<span class="hljs-number">1f</span>);            getConsumer().onNewResult(cachedEncodedImage, status);            <span class="hljs-keyword">return</span>;          &#125; <span class="hljs-keyword">finally</span> &#123;            EncodedImage.closeSafely(cachedEncodedImage);          &#125;        &#125;      &#125;      getConsumer().onNewResult(newResult, status);    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;  &#125;    &#125;</code></pre></div><h1 id="内存缓存（decoded-Bitmap）"><a href="#内存缓存（decoded-Bitmap）" class="headerlink" title="内存缓存（decoded, Bitmap）"></a>内存缓存（decoded, Bitmap）</h1><p><code>BitmapMemoryCacheProducer</code> 实现了 Bitmap 的内存缓存，整个逻辑比较简单：</p><ul><li>默认开启，可以通过 <code>ImageRequestBuilder.disableMemoryCache</code> 关闭</li><li>去程时从缓存里读，命中的话截胡，返回缓存在内存中的 Bitmap</li><li>回程时写入缓存</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BitmapMemoryCacheProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> ProducerContext producerContext)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;BitmapMemoryCacheProducer#produceResults&quot;</span>);      &#125;      <span class="hljs-keyword">final</span> <span class="hljs-type">ProducerListener2</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> producerContext.getProducerListener();      listener.onProducerStart(producerContext, getProducerName());      <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> producerContext.getImageRequest();      <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">callerContext</span> <span class="hljs-operator">=</span> producerContext.getCallerContext();      <span class="hljs-keyword">final</span> <span class="hljs-type">CacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> mCacheKeyFactory.getBitmapCacheKey(imageRequest, callerContext);      <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isBitmapCacheEnabledForRead</span> <span class="hljs-operator">=</span>          producerContext              .getImageRequest()              .isCacheEnabled(ImageRequest.CachesLocationsMasks.BITMAP_READ);      CloseableReference&lt;CloseableImage&gt; cachedReference =          isBitmapCacheEnabledForRead ? mMemoryCache.get(cacheKey) : <span class="hljs-literal">null</span>;      <span class="hljs-keyword">if</span> (cachedReference != <span class="hljs-literal">null</span>) &#123;        maybeSetExtrasFromCloseableImage(cachedReference.get(), producerContext);        <span class="hljs-type">boolean</span> <span class="hljs-variable">isFinal</span> <span class="hljs-operator">=</span> cachedReference.get().getQualityInfo().isOfFullQuality();        <span class="hljs-keyword">if</span> (isFinal) &#123;          listener.onProducerFinishWithSuccess(              producerContext,              getProducerName(),              listener.requiresExtraMap(producerContext, getProducerName())                  ? ImmutableMap.of(EXTRA_CACHED_VALUE_FOUND, <span class="hljs-string">&quot;true&quot;</span>)                  : <span class="hljs-literal">null</span>);          listener.onUltimateProducerReached(producerContext, getProducerName(), <span class="hljs-literal">true</span>);          producerContext.putOriginExtra(<span class="hljs-string">&quot;memory_bitmap&quot;</span>, getOriginSubcategory());          consumer.onProgressUpdate(<span class="hljs-number">1f</span>);        &#125;        consumer.onNewResult(cachedReference, BaseConsumer.simpleStatusForIsLast(isFinal));        cachedReference.close();        <span class="hljs-keyword">if</span> (isFinal) &#123;          <span class="hljs-keyword">return</span>;        &#125;      &#125;      <span class="hljs-comment">// ...</span>  &#125;  <span class="hljs-keyword">protected</span> Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="hljs-title function_">wrapConsumer</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> CacheKey cacheKey,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isBitmapCacheEnabledForWrite)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingConsumer</span>&lt;        CloseableReference&lt;CloseableImage&gt;, CloseableReference&lt;CloseableImage&gt;&gt;(consumer) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResultImpl</span><span class="hljs-params">(</span><span class="hljs-params">          <span class="hljs-meta">@Nullable</span> CloseableReference&lt;CloseableImage&gt; newResult, <span class="hljs-meta">@Status</span> <span class="hljs-type">int</span> status)</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">// ...</span>          <span class="hljs-comment">// cache, if needed, and forward the new result</span>          CloseableReference&lt;CloseableImage&gt; newCachedResult = <span class="hljs-literal">null</span>;          <span class="hljs-keyword">if</span> (isBitmapCacheEnabledForWrite) &#123;            newCachedResult = mMemoryCache.cache(cacheKey, newResult);          &#125;          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (isLast) getConsumer().onProgressUpdate(<span class="hljs-number">1f</span>);            getConsumer().onNewResult((newCachedResult != <span class="hljs-literal">null</span>) ? newCachedResult : newResult, status);          &#125; <span class="hljs-keyword">finally</span> &#123; CloseableReference.closeSafely(newCachedResult); &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;          <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) FrescoSystrace.endSection();        &#125;      &#125;    &#125;;  &#125;    &#125;</code></pre></div><h1 id="LruCountingMemoryCache"><a href="#LruCountingMemoryCache" class="headerlink" title="LruCountingMemoryCache"></a>LruCountingMemoryCache</h1><p>内存缓存（包括 encoded 和 decoded）的实现是 <code>LruCountingMemoryCache&lt;CacheKey, CloseableImage&gt;</code>，它有一些参数（可通过 <code>ImagePipelineConfig.Builder.setBitmapMemoryCacheParamsSupplier</code> 配置）：</p><table><thead><tr><th>Name</th><th>Description</th><th>默认值</th></tr></thead><tbody><tr><td>MemoryCacheParams.maxCacheSize</td><td>整个缓存的容量（字节），只包括使用中的</td><td>堆内存 &lt; 32M 则取 4M，&lt; 64M 则取 6M，Android 3.0 HONEYCOMB API 11 以下则取 8M，否则取 1/4 堆内存大小</td></tr><tr><td>MemoryCacheParams.maxCacheEntries</td><td>整个缓存里 Entry 数量的上限，只包括使用中的</td><td>256</td></tr><tr><td>MemoryCacheParams.maxEvictionQueueSize</td><td>eviction queue 的容量上限</td><td>Integer.MAX_VALUE</td></tr><tr><td>MemoryCacheParams.maxEvictionQueueEntries</td><td>eviction queue 里 Entry 数量的上限</td><td>Integer.MAX_VALUE</td></tr><tr><td>MemoryCacheParams.maxCacheEntrySize</td><td>单个 Entry 的大小上限，超过此阈值不缓存</td><td>Integer.MAX_VALUE</td></tr></tbody></table><blockquote><p>eviction queue 指没有被使用、可被安全回收（evict）的缓存对象的集合</p></blockquote><p>核心数据结构、也是实现 <code>LRU</code> 算法和 key-value 映射的是 <a href="../../../../2021/01/19/reviews/#LinkedHashMap">LinkedHashMap</a>，它内部有两个 Map：</p><ul><li><code>mCachedEntries</code>：存放所有的缓存条目</li><li><code>mExclusiveEntries</code>：存放空闲的、未被使用、可被安全回收的缓存条目，它是 mCachedEntries 的一个子集，也是上面所说的 <code>eviction queue</code></li></ul><p>通过 <code>cache(key, valueRef)</code> 放入缓存或者 <code>get(key)</code> 取得缓存对象，会返回一个 <code>CloseableReference</code>，直到 <code>CloseableReference.close</code> 释放/回收缓存对象前，此时缓存条目都只存在于 <code>mCachedEntries</code>；只有当缓存条目不再被任何人持有/引用（<code>CountingMemoryCache.Entry.clientCount == 0</code>），它才会被添加到 <code>mExclusiveEntries</code>，表示它可以被安全释放</p><p>返回 CloseableReference （需要通过 <code>close</code> 释放）这一特性使它跟一般的 LRU 缓存有所不同：</p><ul><li><code>maxCacheSize</code> 容量上限和 <code>maxCacheEntries</code> Entry 数量上限，针对的是使用中的 Entry 集合，也即 mCachedEntries - mExclusiveEntries，这是因为 mExclusiveEntries 是空闲的 Entry 集合，没有人引用意味这可以被 <code>evict</code>，新增缓存条目后可以通过 evict 淘汰空闲的 Entry 以使缓存满足约束</li><li>Entry 是可以被多人持有的（被多人借出，用一个引用计数 <code>Entry.clientCount</code> 表示借出的次数，归还后减一）</li><li>取出的 Entry 用完后执行下 close 就可以了，由缓存决定是继续保留这个 Entry 还是淘汰掉（满足容量等限制条件时会保留在空闲集合中，超过容量限制时如果引用计数为零则释放掉，否则等引用计数归零再释放）</li><li>Entry 有 <code>isOrphan</code> 和 <code>clientCount</code> 两个特征，isOrphan == true 表示 Entry 已经从缓存中移除，但此时如果还有人持有这个 Entry（Entry.clientCount &gt; 0）则暂时还不能释放它，要等到引用计数归零才能释放，有些情况会导致引用计数不为零时强行将 Entry 变为孤儿：<ol><li>放入相同的 key 导致旧 Entry 被强制移除出缓存</li><li>手动执行 <code>MemoryCache.removeAll</code>、<code>CountingMemoryCache.clear</code> 将 Entry 从缓存中移除</li><li>内存不足的情况下执行 <code>MemoryTrimmable.trim(trimType)</code> 强制移除一定比例的 Entry</li></ol></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LruCountingMemoryCache</span> &#123;  <span class="hljs-comment">// Contains the items that are not being used by any client and are hence viable for eviction.</span>  <span class="hljs-keyword">final</span> CountingLruMap&lt;K, Entry&lt;K, V&gt;&gt; mExclusiveEntries;  <span class="hljs-comment">// Contains all the cached items including the exclusively owned ones.</span>  <span class="hljs-keyword">final</span> CountingLruMap&lt;K, Entry&lt;K, V&gt;&gt; mCachedEntries;    <span class="hljs-keyword">public</span> CloseableReference&lt;V&gt; <span class="hljs-title function_">cache</span><span class="hljs-params">(<span class="hljs-keyword">final</span> K key, <span class="hljs-keyword">final</span> CloseableReference&lt;V&gt; valueRef)</span>  <span class="hljs-keyword">public</span> CloseableReference&lt;V&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-keyword">final</span> K key)</span>  &#125;</code></pre></div><p>添加缓存的逻辑：</p><ol><li>key 下有无使用中的旧值，有的话将其标识为孤儿（<code>Entry.isOrphan = true</code>），那么当旧值用完、调用 <code>CloseableReference.close</code> 时（最终会调用 <code>LruCountingMemoryCache.releaseClientReference(entry)</code>）就不会再添加到 <code>mExclusiveEntries</code> 而是释放对象，因为此 key 对应的值已被替换为新值</li><li>当满足以下条件时，value 被添加到 <code>mCachedEntries</code>，新添加的 Entry 的初始值 isOrphan == false &amp;&amp; clientCount == 1，解释下：不是孤儿 Entry 且引用计数为 1</li><li>value size 要小于等于 <code>maxCacheEntrySize</code></li><li>使用中的 Entry 数量要小于 <code>maxCacheEntries</code>，<code>使用中</code> 是指存在于 <code>mCachedEntries</code> 但不在 <code>mExclusiveEntries</code></li><li>使用中的 Entry 的总大小加上 value 大小要小于等于 <code>maxCacheSize</code></li><li>执行 <code>evict</code> 逻辑，淘汰/释放一些 <code>mExclusiveEntries</code> 中的 Entry 以满足约束条件</li><li>返回一个 <code>CloseableReference</code>，当它的 <code>CloseableReference.close</code> 被调用的同时 <code>LruCountingMemoryCache.releaseClientReference(entry)</code> 也被执行</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LruCountingMemoryCache</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> CloseableReference&lt;V&gt; <span class="hljs-title function_">cache</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> K key,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> CloseableReference&lt;V&gt; valueRef,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> EntryStateObserver&lt;K&gt; observer)</span> &#123;    Preconditions.checkNotNull(key);    Preconditions.checkNotNull(valueRef);    maybeUpdateCacheParams();    Entry&lt;K, V&gt; oldExclusive;    CloseableReference&lt;V&gt; oldRefToClose = <span class="hljs-literal">null</span>;    CloseableReference&lt;V&gt; clientRef = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;      <span class="hljs-comment">// remove the old item (if any) as it is stale now</span>      oldExclusive = mExclusiveEntries.remove(key);      Entry&lt;K, V&gt; oldEntry = mCachedEntries.remove(key);      <span class="hljs-keyword">if</span> (oldEntry != <span class="hljs-literal">null</span>) &#123;        makeOrphan(oldEntry);        oldRefToClose = referenceToClose(oldEntry);      &#125;      <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> valueRef.get();      <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mValueDescriptor.getSizeInBytes(value);      <span class="hljs-keyword">if</span> (canCacheNewValueOfSize(size)) &#123;        Entry&lt;K, V&gt; newEntry;        <span class="hljs-keyword">if</span> (mStoreEntrySize) &#123;          newEntry = Entry.of(key, valueRef, size, observer);        &#125; <span class="hljs-keyword">else</span> &#123;          newEntry = Entry.of(key, valueRef, observer);        &#125;        mCachedEntries.put(key, newEntry);        clientRef = newClientReference(newEntry);      &#125;    &#125;    CloseableReference.closeSafely(oldRefToClose);    maybeNotifyExclusiveEntryRemoval(oldExclusive);    maybeEvictEntries();    <span class="hljs-keyword">return</span> clientRef;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeOrphan</span><span class="hljs-params">(Entry&lt;K, V&gt; entry)</span> &#123;    Preconditions.checkNotNull(entry);    Preconditions.checkState(!entry.isOrphan);    entry.isOrphan = <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCacheNewValueOfSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newValueSize)</span> &#123;    <span class="hljs-keyword">return</span> (newValueSize &lt;= mMemoryCacheParams.maxCacheEntrySize)        &amp;&amp; (getInUseCount() &lt;= mMemoryCacheParams.maxCacheEntries - <span class="hljs-number">1</span>)        &amp;&amp; (getInUseSizeInBytes() &lt;= mMemoryCacheParams.maxCacheSize - newValueSize);  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> CloseableReference&lt;V&gt; <span class="hljs-title function_">newClientReference</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Entry&lt;K, V&gt; entry)</span> &#123;    increaseClientCount(entry);    <span class="hljs-keyword">return</span> CloseableReference.of(        entry.valueRef.get(),        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceReleaser</span>&lt;V&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(V unused)</span> &#123;            releaseClientReference(entry);          &#125;        &#125;);  &#125;         &#125;</code></pre></div><p>释放一个 Entry 的逻辑：</p><ol><li>引用数减一（<code>Entry.clientCount--</code>）</li><li>如果没有被引用且不是孤儿（<code>Entry.isOrphan == false</code>），说明此 Entry 没有从 MemoryCache 中被移除（<code>evict</code> 或者被相同 key 的新值覆盖都会导致 Entry 被移除，成为孤儿），添加到空闲集合 <code>mExclusiveEntries</code></li><li>如果没有被引用且是孤儿，则将引用置空释放对象</li><li>往空闲集合添加了元素后可能会不符合 MemoryCache 的约束条件，需要执行一次 <code>evict</code> 逻辑</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseClientReference</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Entry&lt;K, V&gt; entry)</span> &#123;  Preconditions.checkNotNull(entry);  <span class="hljs-type">boolean</span> isExclusiveAdded;  CloseableReference&lt;V&gt; oldRefToClose;  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;    decreaseClientCount(entry);    isExclusiveAdded = maybeAddToExclusives(entry);    oldRefToClose = referenceToClose(entry);  &#125;  CloseableReference.closeSafely(oldRefToClose);  maybeNotifyExclusiveEntryInsertion(isExclusiveAdded ? entry : <span class="hljs-literal">null</span>);  maybeUpdateCacheParams();  maybeEvictEntries();&#125;</code></pre></div><p>淘汰逻辑（<code>evict</code>），针对的是存在于 <code>mExclusiveEntries</code> 中的无人引用的 Entry：</p><ol><li>两个方面的约束：Entry 的数量和 Entry 的总大小，从多个阈值中取最小值：</li><li>maxEvictionQueueEntries/maxEvictionQueueSize，专门针对空闲 Entry 的约束</li><li>maxCacheEntries/maxCacheSize，针对整个 memory cache（包括空闲的 Entry 和使用中的 Entry）的约束，减去使用中的就是针对空闲 Entry 的约束</li><li>从 <code>mExclusiveEntries</code> 逐个剔除 Entry 直到满足上面的容量和大小的约束条件，而剔除的顺序就是 <code>LinkedHashMap</code> 迭代器的顺序，上面说过最终顺序是按访问排序（也就实现了 <code>LRU</code>）</li><li>将剔除的 Entry 集合标识为 <code>孤儿</code> 并删除（<code>CloseableReference.close</code> 最终会调用 <code>LruCountingMemoryCache.releaseClientReference(entry)</code>）</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LruCountingMemoryCache</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maybeEvictEntries</span><span class="hljs-params">()</span> &#123;    ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span>          Math.min(              mMemoryCacheParams.maxEvictionQueueEntries,              mMemoryCacheParams.maxCacheEntries - getInUseCount());      <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span>          Math.min(              mMemoryCacheParams.maxEvictionQueueSize,              mMemoryCacheParams.maxCacheSize - getInUseSizeInBytes());      oldEntries = trimExclusivelyOwnedEntries(maxCount, maxSize);      makeOrphans(oldEntries);    &#125;    maybeClose(oldEntries);    maybeNotifyExclusiveEntryRemoval(oldEntries);  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> ArrayList&lt;Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">trimExclusivelyOwnedEntries</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">int</span> size)</span> &#123;    count = Math.max(count, <span class="hljs-number">0</span>);    size = Math.max(size, <span class="hljs-number">0</span>);    <span class="hljs-comment">// fast path without array allocation if no eviction is necessary</span>    <span class="hljs-keyword">if</span> (mExclusiveEntries.getCount() &lt;= count &amp;&amp; mExclusiveEntries.getSizeInBytes() &lt;= size) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">while</span> (mExclusiveEntries.getCount() &gt; count || mExclusiveEntries.getSizeInBytes() &gt; size) &#123;      <span class="hljs-meta">@Nullable</span> <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> mExclusiveEntries.getFirstKey();      <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (mIgnoreSizeMismatch) &#123;          mExclusiveEntries.resetSize();          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(            String.format(                <span class="hljs-string">&quot;key is null, but exclusiveEntries count: %d, size: %d&quot;</span>,                mExclusiveEntries.getCount(), mExclusiveEntries.getSizeInBytes()));      &#125;      mExclusiveEntries.remove(key);      oldEntries.add(mCachedEntries.remove(key));    &#125;    <span class="hljs-keyword">return</span> oldEntries;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CountingLruMap</span>&lt;K, V&gt; &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedHashMap&lt;K, V&gt; mMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> K <span class="hljs-title function_">getFirstKey</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> mMap.isEmpty() ? <span class="hljs-literal">null</span> : mMap.keySet().iterator().next();  &#125;  &#125;</code></pre></div><p>取缓存时，是直接从 <code>mExclusiveEntries</code> 删除，<code>CloseableReference.close</code> 的时候再重新插入到 <code>mExclusiveEntries</code> 里，所以虽然 <code>mExclusiveEntries</code> 里的 <code>LinkedHashMap</code> 是按插入排序的，但从 MemoryCache 的角度看 <code>mExclusiveEntries</code> 是按访问排序的，<code>evict</code> 时就从最久未访问的 Entry 迭代起</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CloseableReference&lt;V&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-keyword">final</span> K key)</span> &#123;  Preconditions.checkNotNull(key);  Entry&lt;K, V&gt; oldExclusive;  CloseableReference&lt;V&gt; clientRef = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;    oldExclusive = mExclusiveEntries.remove(key);    Entry&lt;K, V&gt; entry = mCachedEntries.get(key);    <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;      clientRef = newClientReference(entry);    &#125;  &#125;  maybeNotifyExclusiveEntryRemoval(oldExclusive);  maybeUpdateCacheParams();  maybeEvictEntries();  <span class="hljs-keyword">return</span> clientRef;&#125;</code></pre></div><p>此外 <code>LruCountingMemoryCache</code> 还提供了以下方法</p><table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody><tr><td>inspect(key)</td><td>返回 key 对应的缓存，但不影响它在 LRU 中的次序</td></tr><tr><td>probe(key)</td><td>碰一下 key 对应的缓存但不获取，这个操作主要是改变它在 LRU 中的次序</td></tr><tr><td>reuse(key)</td><td>从 MemoryCache 里获取并移除 key 对应的缓存，这个缓存必须是空闲的（存在于 <code>mExclusiveEntries</code>）</td></tr><tr><td>maybeEvictEntries</td><td>手动淘汰一些 Entry</td></tr><tr><td>getCount()</td><td>Entry 总数，包括空闲和使用的 Entry</td></tr><tr><td>getSizeInBytes()</td><td>MemoryCache 的总大小，包括空闲和使用的 Entry</td></tr></tbody></table><h1 id="绑定-View-生命周期"><a href="#绑定-View-生命周期" class="headerlink" title="绑定 View 生命周期"></a>绑定 View 生命周期</h1><p>先让我们来看看 Fresco 是如何处理和保存 ImageRequest：</p><ol><li>通过 <code>ProducerSequenceFactory.getEncodedImageProducerSequence</code>，<code>ImageRequest</code> 转变为一个合适的图像流水线（<code>ImagePipeline</code>，实际上是流水线上最后的那个节点）</li><li>将 <code>Producer</code> 适配为 <code>DataSource</code>（就在此时，request 被添加到线程池里开始流水处理）</li><li><code>PipelineDraweeController.mDataSourceSupplier</code> 保存了 <code>Supplier&lt;DataSource&gt;</code>，而 <code>AbstractDraweeController.mDataSource</code> 保存了 <code>DataSource</code></li><li>DataSource 是一个异步的结果（类似于 <code>Future</code>），通过订阅获得异步的结果（成功 or 失败），在 <code>AbstractDraweeController.submitRequest</code> 订阅之，从而拿到 <code>Bitmap</code></li><li>也就说一个图像加载请求是保存在 <code>DraweeView.mDraweeHolder.mController.mDataSource</code></li></ol><div class="code-wrapper"><pre><code class="hljs java">SimpleDraweeView.setImageURI(uri)SimpleDraweeView.setImageURI(uri, <span class="hljs-literal">null</span>)AbstractDraweeControllerBuilder.buildAbstractDraweeControllerBuilder.buildControllerPipelineDraweeControllerBuilder.obtainControllerAbstractDraweeControllerBuilder.obtainDataSourceSupplierAbstractDraweeControllerBuilder.getDataSourceSupplierForRequest(controller, controllerId, imageRequest)AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest(controller, controllerId, imageRequest, cacheLevel)PipelineDraweeControllerBuilder.getDataSourceForRequestImagePipeline.fetchDecodedImageImagePipeline.submitFetchRequestCloseableProducerToDataSourceAdapter.create<span class="hljs-comment">// 最终在这里启动流水线，并把流水线包装为 DataSource</span><span class="hljs-comment">// DataSource 其后被包装为 Supplier&lt;DataSource&gt;，保存在 PipelineDraweeController.mDataSourceSupplier</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProducerToDataSourceAdapter</span> &#123;  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractProducerToDataSourceAdapter</span><span class="hljs-params">(</span><span class="hljs-params">      Producer&lt;T&gt; producer,</span><span class="hljs-params">      SettableProducerContext settableProducerContext,</span><span class="hljs-params">      RequestListener2 requestListener)</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractProducerToDataSourceAdapter()&quot;</span>);    &#125;    mSettableProducerContext = settableProducerContext;    mRequestListener = requestListener;    setInitialExtras();    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractProducerToDataSourceAdapter()-&gt;onRequestStart&quot;</span>);    &#125;    mRequestListener.onRequestStart(mSettableProducerContext);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;AbstractProducerToDataSourceAdapter()-&gt;produceResult&quot;</span>);    &#125;    producer.produceResults(createConsumer(), settableProducerContext);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;  &#125;  &#125;<span class="hljs-comment">// 继续走下去来到 submitRequest</span><span class="hljs-comment">// 从 PipelineDraweeController.mDataSourceSupplier 获得 DataSource 并将其保存在 AbstractDraweeController.mDataSource</span><span class="hljs-comment">// 订阅 DataSource 从而在 callback 里拿到 Bitmap</span>DraweeView.setControllerDraweeHolder.setControllerDraweeHolder.attachControllerAbstractDraweeController.onAttachAbstractDraweeController.submitRequest<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDraweeController</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submitRequest</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// ...</span>    mDataSource = getDataSource();    reportSubmit(mDataSource, <span class="hljs-literal">null</span>);    <span class="hljs-keyword">if</span> (FLog.isLoggable(FLog.VERBOSE)) &#123;      FLog.v(          TAG,          <span class="hljs-string">&quot;controller %x %s: submitRequest: dataSource: %x&quot;</span>,          System.identityHashCode(<span class="hljs-built_in">this</span>),          mId,          System.identityHashCode(mDataSource));    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> mId;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wasImmediate</span> <span class="hljs-operator">=</span> mDataSource.hasResult();    <span class="hljs-keyword">final</span> DataSubscriber&lt;T&gt; dataSubscriber =        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseDataSubscriber</span>&lt;T&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewResultImpl</span><span class="hljs-params">(DataSource&lt;T&gt; dataSource)</span> &#123;            <span class="hljs-comment">// isFinished must be obtained before image, otherwise we might set intermediate result</span>            <span class="hljs-comment">// as final image.</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFinished</span> <span class="hljs-operator">=</span> dataSource.isFinished();            <span class="hljs-type">boolean</span> <span class="hljs-variable">hasMultipleResults</span> <span class="hljs-operator">=</span> dataSource.hasMultipleResults();            <span class="hljs-type">float</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> dataSource.getProgress();            <span class="hljs-type">T</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> dataSource.getResult();            <span class="hljs-keyword">if</span> (image != <span class="hljs-literal">null</span>) &#123;              onNewResultInternal(                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFinished) &#123;              onFailureInternal(id, dataSource, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(), <span class="hljs-comment">/* isFinished */</span> <span class="hljs-literal">true</span>);            &#125;          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailureImpl</span><span class="hljs-params">(DataSource&lt;T&gt; dataSource)</span> &#123;            onFailureInternal(id, dataSource, dataSource.getFailureCause(), <span class="hljs-comment">/* isFinished */</span> <span class="hljs-literal">true</span>);          &#125;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onProgressUpdate</span><span class="hljs-params">(DataSource&lt;T&gt; dataSource)</span> &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">isFinished</span> <span class="hljs-operator">=</span> dataSource.isFinished();            <span class="hljs-type">float</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> dataSource.getProgress();            onProgressUpdateInternal(id, dataSource, progress, isFinished);          &#125;        &#125;;    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PipelineDraweeController</span> &#123;  <span class="hljs-keyword">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.beginSection(<span class="hljs-string">&quot;PipelineDraweeController#getDataSource&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (FLog.isLoggable(FLog.VERBOSE)) &#123;      FLog.v(TAG, <span class="hljs-string">&quot;controller %x: getDataSource&quot;</span>, System.identityHashCode(<span class="hljs-built_in">this</span>));    &#125;    DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get();    <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;      FrescoSystrace.endSection();    &#125;    <span class="hljs-keyword">return</span> result;  &#125;  &#125;</code></pre></div><p>跟 <code>Glide</code> 不同的是，<code>Fresco</code> 并不能直接用在 <code>ImageView</code> 上，而是需要更换 UI 组件为 <code>SimpleDraweeView</code>，然后通过 <code>SimpleDraweeView.setImageURI(uri, callerContext)</code> 发起图像加载请求，整个过程并没有看到有 Activity/Fragment/LifecycleOwner 等组件参加</p><p>通过 <code>DraweeView</code> 可以看出，Fresco image request 绑定的是 UI 层 <code>View</code> 组件的生命周期：<code>onAttachedToWindow</code> 和 <code>onDetachedFromWindow</code></p><p>当 <code>onDetachedFromWindow</code> 触发时，事件会沿着 <code>DraweeView -&gt; DraweeHolder -&gt; DraweeController -&gt; DataSource -&gt; ProducerContext -&gt; ProducerContextCallbacks</code> 的方向传递，凡是注册了 <code>ProducerContextCallbacks</code> 的都能收到 <code>onCancellationRequested</code></p><p>上面介绍过的 ImagePipeline 节点随便拿两个看看（<code>OkHttpNetworkFetcher</code> 和 <code>DiskCacheReadProducer</code>）都能够发现它们是注册了 callback 的，这样无论 request 流转至哪个节点都能及时响应 cancel 事件停止工作，从而实现 image request 与 <code>View</code> 生命周期的绑定</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DraweeView</span> &#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAttachedToWindow</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">super</span>.onAttachedToWindow();    maybeOverrideVisibilityHandling();    onAttach();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDetachedFromWindow</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">super</span>.onDetachedFromWindow();    maybeOverrideVisibilityHandling();    onDetach();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartTemporaryDetach</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">super</span>.onStartTemporaryDetach();    maybeOverrideVisibilityHandling();    onDetach();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFinishTemporaryDetach</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">super</span>.onFinishTemporaryDetach();    maybeOverrideVisibilityHandling();    onAttach();  &#125;&#125;DraweeView.onDetachDraweeView.doDetachDraweeHolder.onDetachDraweeHolder.attachOrDetachControllerDraweeHolder.detachControllerAbstractDraweeController.onDetachAbstractDraweeController.release<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDraweeController</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseFetch</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-variable">wasRequestSubmitted</span> <span class="hljs-operator">=</span> mIsRequestSubmitted;    mIsRequestSubmitted = <span class="hljs-literal">false</span>;    mHasFetchFailed = <span class="hljs-literal">false</span>;    Map&lt;String, Object&gt; datasourceExtras = <span class="hljs-literal">null</span>, imageExtras = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (mDataSource != <span class="hljs-literal">null</span>) &#123;      datasourceExtras = mDataSource.getExtras();      mDataSource.close();    <span class="hljs-comment">// 关闭并置空 mDataSource</span>      mDataSource = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (mDrawable != <span class="hljs-literal">null</span>) &#123;      releaseDrawable(mDrawable);    &#125;    <span class="hljs-keyword">if</span> (mContentDescription != <span class="hljs-literal">null</span>) &#123;      mContentDescription = <span class="hljs-literal">null</span>;    &#125;    mDrawable = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (mFetchedImage != <span class="hljs-literal">null</span>) &#123;      imageExtras = obtainExtrasFromImage(getImageInfo(mFetchedImage));      logMessageAndImage(<span class="hljs-string">&quot;release&quot;</span>, mFetchedImage);      releaseImage(mFetchedImage);      mFetchedImage = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (wasRequestSubmitted) &#123;      reportRelease(datasourceExtras, imageExtras);    &#125;  &#125;      &#125;AbstractProducerToDataSourceAdapter.close           <span class="hljs-comment">// 还记得上面介绍过 DataSource 是适配自 Producer (ImagePipeline 节点)</span>BaseProducerContext.cancelProducerContextCallbacks.onCancellationRequested    <span class="hljs-comment">// 谁会往这里添加 callback 呢？</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OkHttpNetworkFetcher</span> &#123;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetchWithRequest</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> OkHttpNetworkFetchState fetchState,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> NetworkFetcher.Callback callback,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Request request)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> mCallFactory.newCall(request);    fetchState        .getContext()        .addCallbacks(            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseProducerContextCallbacks</span>() &#123;              <span class="hljs-meta">@Override</span>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellationRequested</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 注册一个 callback 接收 cancel request 事件</span>                <span class="hljs-keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;                  call.cancel();                &#125; <span class="hljs-keyword">else</span> &#123;                  mCancellationExecutor.execute(                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                          call.cancel();                        &#125;                      &#125;);                &#125;              &#125;            &#125;);    call.enqueue(...);  &#125;  &#125;<span class="hljs-comment">// 几乎所有的 ImagePipeline 节点都会注册 callback 接收 request cancel 事件</span><span class="hljs-comment">// 这样无论 request 流转至哪个节点，都能及时响应 cancel 事件停止工作</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskCacheReadProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> Consumer&lt;EncodedImage&gt; consumer, <span class="hljs-keyword">final</span> ProducerContext producerContext)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ImageRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> producerContext.getImageRequest();    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDiskCacheEnabledForRead</span> <span class="hljs-operator">=</span>        producerContext            .getImageRequest()            .isCacheEnabled(ImageRequest.CachesLocationsMasks.DISK_READ);    <span class="hljs-keyword">if</span> (!isDiskCacheEnabledForRead) &#123;      maybeStartInputProducer(consumer, producerContext);      <span class="hljs-keyword">return</span>;    &#125;    producerContext.getProducerListener().onProducerStart(producerContext, PRODUCER_NAME);    <span class="hljs-keyword">final</span> <span class="hljs-type">CacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span>        mCacheKeyFactory.getEncodedCacheKey(imageRequest, producerContext.getCallerContext());    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isSmallRequest</span> <span class="hljs-operator">=</span> (imageRequest.getCacheChoice() == CacheChoice.SMALL);    <span class="hljs-keyword">final</span> <span class="hljs-type">BufferedDiskCache</span> <span class="hljs-variable">preferredCache</span> <span class="hljs-operator">=</span>        isSmallRequest ? mSmallImageBufferedDiskCache : mDefaultBufferedDiskCache;    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">isCancelled</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">final</span> Task&lt;EncodedImage&gt; diskLookupTask = preferredCache.get(cacheKey, isCancelled);    <span class="hljs-keyword">final</span> Continuation&lt;EncodedImage, Void&gt; continuation =        onFinishDiskReads(consumer, producerContext);    diskLookupTask.continueWith(continuation);    subscribeTaskForRequestCancellation(isCancelled, producerContext);  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribeTaskForRequestCancellation</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> AtomicBoolean isCancelled, ProducerContext producerContext)</span> &#123;    producerContext.addCallbacks(        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseProducerContextCallbacks</span>() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancellationRequested</span><span class="hljs-params">()</span> &#123;            isCancelled.set(<span class="hljs-literal">true</span>);          &#125;        &#125;);  &#125;    &#125;</code></pre></div><h1 id="请求错乱的问题"><a href="#请求错乱的问题" class="headerlink" title="请求错乱的问题"></a>请求错乱的问题</h1><p>比如在 <code>RecyclerView</code> 里快速地滑动，同一个 <code>DraweeView</code> 会在短时间内多次设置网络图像，但网络加载是需要较长时间的，如何保证旧的 request 不会覆盖掉新的 request？</p><p>如下面所示，通过 <code>setImageURI</code> 设置图片的同时会 <code>close</code> 旧的 <code>DataSource</code></p><div class="code-wrapper"><pre><code class="hljs java">SimpleDraweeView.setImageURI(uri)SimpleDraweeView.setImageURI(uri, <span class="hljs-literal">null</span>)DraweeView.setController<span class="hljs-keyword">class</span> <span class="hljs-title class_">DraweeHolder</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setController</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> DraweeController draweeController)</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-variable">wasAttached</span> <span class="hljs-operator">=</span> mIsControllerAttached;    <span class="hljs-keyword">if</span> (wasAttached) &#123;      detachController();    &#125;    <span class="hljs-comment">// Clear the old controller</span>    <span class="hljs-keyword">if</span> (isControllerValid()) &#123;      mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER);      mController.setHierarchy(<span class="hljs-literal">null</span>);    &#125;    mController = draweeController;    <span class="hljs-keyword">if</span> (mController != <span class="hljs-literal">null</span>) &#123;      mEventTracker.recordEvent(Event.ON_SET_CONTROLLER);      mController.setHierarchy(mHierarchy);    &#125; <span class="hljs-keyword">else</span> &#123;      mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER);    &#125;    <span class="hljs-keyword">if</span> (wasAttached) &#123;      attachController();    &#125;  &#125;  &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDraweeController</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHierarchy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> DraweeHierarchy hierarchy)</span> &#123;    <span class="hljs-keyword">if</span> (FLog.isLoggable(FLog.VERBOSE)) &#123;      FLog.v(          TAG, <span class="hljs-string">&quot;controller %x %s: setHierarchy: %s&quot;</span>, System.identityHashCode(<span class="hljs-built_in">this</span>), mId, hierarchy);    &#125;    mEventTracker.recordEvent(        (hierarchy != <span class="hljs-literal">null</span>) ? Event.ON_SET_HIERARCHY : Event.ON_CLEAR_HIERARCHY);    <span class="hljs-comment">// force release in case request was submitted</span>    <span class="hljs-keyword">if</span> (mIsRequestSubmitted) &#123;      mDeferredReleaser.cancelDeferredRelease(<span class="hljs-built_in">this</span>);      release();    <span class="hljs-comment">// 这里</span>    &#125;    <span class="hljs-comment">// clear the existing hierarchy</span>    <span class="hljs-keyword">if</span> (mSettableDraweeHierarchy != <span class="hljs-literal">null</span>) &#123;      mSettableDraweeHierarchy.setControllerOverlay(<span class="hljs-literal">null</span>);      mSettableDraweeHierarchy = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// set the new hierarchy</span>    <span class="hljs-keyword">if</span> (hierarchy != <span class="hljs-literal">null</span>) &#123;      Preconditions.checkArgument(hierarchy <span class="hljs-keyword">instanceof</span> SettableDraweeHierarchy);      mSettableDraweeHierarchy = (SettableDraweeHierarchy) hierarchy;      mSettableDraweeHierarchy.setControllerOverlay(mControllerOverlay);    &#125;    <span class="hljs-keyword">if</span> (mLoggingListener != <span class="hljs-literal">null</span>) &#123;      setUpLoggingListener();    &#125;  &#125;  &#125;</code></pre></div><h1 id="DecodeProducer-解码"><a href="#DecodeProducer-解码" class="headerlink" title="DecodeProducer - 解码"></a>DecodeProducer - 解码</h1><p>负责将各种压缩图片格式（JPEG、WEBP 等）解码（比如 <code>Bitmap</code>）的 ImagePipeline 节点，它通过 <code>SOI</code> 识别其格式并交由对应的 <code>ImageDecoder</code> 处理，方法栈如下：</p><div class="code-wrapper"><pre><code class="hljs java">DecodeProducer.produceResultsProgressiveDecoder.onNewResultImplNetworkImagesProgressiveDecoder.updateDecodeJobProgressiveDecoder.doDecodeProgressiveDecoder.internalDecode<span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultImageDecoder</span> &#123;  <span class="hljs-keyword">public</span> CloseableImage <span class="hljs-title function_">decode</span><span class="hljs-params">(</span><span class="hljs-params">      <span class="hljs-keyword">final</span> EncodedImage encodedImage,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> length,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> QualityInfo qualityInfo,</span><span class="hljs-params">      <span class="hljs-keyword">final</span> ImageDecodeOptions options)</span> &#123;        <span class="hljs-comment">// 自定义的解码器</span>    <span class="hljs-keyword">if</span> (options.customImageDecoder != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> options.customImageDecoder.decode(encodedImage, length, qualityInfo, options);    &#125;    <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">imageFormat</span> <span class="hljs-operator">=</span> encodedImage.getImageFormat();    <span class="hljs-keyword">if</span> (imageFormat == <span class="hljs-literal">null</span> || imageFormat == ImageFormat.UNKNOWN) &#123;      <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedImage.getInputStream();      <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-literal">null</span>) &#123;        imageFormat = ImageFormatChecker.getImageFormat_WrapIOException(inputStream);        encodedImage.setImageFormat(imageFormat);      &#125;    &#125;    <span class="hljs-keyword">if</span> (mCustomDecoders != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-type">ImageDecoder</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> mCustomDecoders.get(imageFormat);      <span class="hljs-keyword">if</span> (decoder != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> decoder.decode(encodedImage, length, qualityInfo, options);      &#125;    &#125;    <span class="hljs-comment">// Fresco 内置的解码器</span>    <span class="hljs-keyword">return</span> mDefaultDecoder.decode(encodedImage, length, qualityInfo, options);  &#125;  &#125;</code></pre></div><p>Fresco 内置了对常用图片格式如：JPEG、GIF、WEBP 等的支持，这些图片格式定义在 <code>DefaultImageFormats</code>，并在 <code>DefaultImageFormatChecker.determineFormat(headerBytes, headerSize)</code> 实现了高效的、基于 <code>SOI</code> 的图片格式判别逻辑（start of image，也就是图片文件头几个字节的内容，作为特征码进行识别）</p><p>对于 Fresco 不支持的格式，可以通过 <code>ImageDecoderConfig.Builder.addDecodingCapability(imageFormat, imageFormatChecker, decoder)</code> 添加自定义解码器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultImageFormats</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">JPEG</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;JPEG&quot;</span>, <span class="hljs-string">&quot;jpeg&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">PNG</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;PNG&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">GIF</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;GIF&quot;</span>, <span class="hljs-string">&quot;gif&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">BMP</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;BMP&quot;</span>, <span class="hljs-string">&quot;bmp&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">ICO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;ICO&quot;</span>, <span class="hljs-string">&quot;ico&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">WEBP_SIMPLE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;WEBP_SIMPLE&quot;</span>, <span class="hljs-string">&quot;webp&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">WEBP_LOSSLESS</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;WEBP_LOSSLESS&quot;</span>, <span class="hljs-string">&quot;webp&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">WEBP_EXTENDED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;WEBP_EXTENDED&quot;</span>, <span class="hljs-string">&quot;webp&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">WEBP_EXTENDED_WITH_ALPHA</span> <span class="hljs-operator">=</span>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;WEBP_EXTENDED_WITH_ALPHA&quot;</span>, <span class="hljs-string">&quot;webp&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">WEBP_ANIMATED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;WEBP_ANIMATED&quot;</span>, <span class="hljs-string">&quot;webp&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">HEIF</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;HEIF&quot;</span>, <span class="hljs-string">&quot;heif&quot;</span>);  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">DNG</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageFormat</span>(<span class="hljs-string">&quot;DNG&quot;</span>, <span class="hljs-string">&quot;dng&quot;</span>);  &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageFormatChecker</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImageFormat <span class="hljs-title function_">getImageFormat</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InputStream is)</span> <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">return</span> getInstance().determineImageFormat(is);  &#125;  <span class="hljs-keyword">public</span> ImageFormat <span class="hljs-title function_">determineImageFormat</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InputStream is)</span> <span class="hljs-keyword">throws</span> IOException &#123;    Preconditions.checkNotNull(is);    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] imageHeaderBytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[mMaxHeaderLength];    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">headerSize</span> <span class="hljs-operator">=</span> readHeaderFromStream(mMaxHeaderLength, is, imageHeaderBytes);    <span class="hljs-type">ImageFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> mDefaultFormatChecker.determineFormat(imageHeaderBytes, headerSize);    <span class="hljs-keyword">if</span> (format != <span class="hljs-literal">null</span> &amp;&amp; format != ImageFormat.UNKNOWN) &#123;      <span class="hljs-keyword">return</span> format;    &#125;    <span class="hljs-keyword">if</span> (mCustomImageFormatCheckers != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">for</span> (ImageFormat.FormatChecker formatChecker : mCustomImageFormatCheckers) &#123;        format = formatChecker.determineFormat(imageHeaderBytes, headerSize);        <span class="hljs-keyword">if</span> (format != <span class="hljs-literal">null</span> &amp;&amp; format != ImageFormat.UNKNOWN) &#123;          <span class="hljs-keyword">return</span> format;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> ImageFormat.UNKNOWN;  &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultImageFormatChecker</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Every JPEG image should start with SOI mark (0xFF, 0xD8) followed by beginning of another</span><span class="hljs-comment">   * segment (0xFF)</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] JPEG_HEADER = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[] &#123;(<span class="hljs-type">byte</span>) <span class="hljs-number">0xFF</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">0xD8</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">0xFF</span>&#125;;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ImageFormat <span class="hljs-title function_">determineFormat</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] headerBytes, <span class="hljs-type">int</span> headerSize)</span> &#123;    Preconditions.checkNotNull(headerBytes);    <span class="hljs-keyword">if</span> (!mUseNewOrder &amp;&amp; WebpSupportStatus.isWebpHeader(headerBytes, <span class="hljs-number">0</span>, headerSize)) &#123;      <span class="hljs-keyword">return</span> getWebpFormat(headerBytes, headerSize);    &#125;    <span class="hljs-keyword">if</span> (isJpegHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.JPEG;    &#125;    <span class="hljs-keyword">if</span> (isPngHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.PNG;    &#125;    <span class="hljs-keyword">if</span> (mUseNewOrder &amp;&amp; WebpSupportStatus.isWebpHeader(headerBytes, <span class="hljs-number">0</span>, headerSize)) &#123;      <span class="hljs-keyword">return</span> getWebpFormat(headerBytes, headerSize);    &#125;    <span class="hljs-keyword">if</span> (isGifHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.GIF;    &#125;    <span class="hljs-keyword">if</span> (isBmpHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.BMP;    &#125;    <span class="hljs-keyword">if</span> (isIcoHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.ICO;    &#125;    <span class="hljs-keyword">if</span> (isHeifHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.HEIF;    &#125;    <span class="hljs-keyword">if</span> (isDngHeader(headerBytes, headerSize)) &#123;      <span class="hljs-keyword">return</span> DefaultImageFormats.DNG;    &#125;    <span class="hljs-keyword">return</span> ImageFormat.UNKNOWN;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isJpegHeader</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] imageHeaderBytes, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> headerSize)</span> &#123;    <span class="hljs-keyword">return</span> headerSize &gt;= JPEG_HEADER.length        &amp;&amp; ImageFormatCheckerUtils.startsWithPattern(imageHeaderBytes, JPEG_HEADER);  &#125;&#125;</code></pre></div><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><table><thead><tr><th>Condition</th><th>Decoder</th><th>Core API</th></tr></thead><tbody><tr><td>&gt;= Android 8 Oreo API 26</td><td>OreoDecoder: DefaultDecoder</td><td>BitmapFactory.decodeStream <br /> BitmapRegionDecoder.decodeRegion</td></tr><tr><td>&gt;= Android 5 Lolipop API 21</td><td>ArtDecoder: DefaultDecoder</td><td>BitmapFactory.decodeStream <br /> BitmapRegionDecoder.decodeRegion</td></tr><tr><td>&lt;= Android 4.4 KitKat API 19</td><td>KitKatPurgeableDecoder: DalvikPurgeableDecoder</td><td>BitmapFactory.decodeByteArray</td></tr><tr><td>&lt; Android 4.4 KitKat API 19 &amp; <br /> <code>ImagePipelineExperiments.isGingerbreadDecoderEnabled</code></td><td>GingerbreadPurgeableDecoder: DalvikPurgeableDecoder</td><td>MemoryFile <br /> BitmapFactory.decodeStream <br /> native webp decoder</td></tr></tbody></table><h1 id="其他-ImagePipeline-节点"><a href="#其他-ImagePipeline-节点" class="headerlink" title="其他 ImagePipeline 节点"></a>其他 ImagePipeline 节点</h1><h2 id="MultiplexProducer"><a href="#MultiplexProducer" class="headerlink" title="MultiplexProducer"></a>MultiplexProducer</h2><p><code>multiplex</code>：多路复用，<code>multiplexer</code>：多路复用器，顾名思义这个节点的作用是合并相同的 <code>ImageRequest</code> 以节约网络和 IO 资源，因为同一时刻相同的请求只需要执行一次，多个 consumer 可以等待和接收同一个 response，看看是如何实现的：</p><ol><li>多路复用器有两个：<code>EncodedCacheKeyMultiplexProducer</code>（排在 encoded memory cache 后面） 和 <code>BitmapMemoryCacheKeyMultiplexProducer</code>（排在 bitmap memory cache 后面）</li><li>一个请求对应一个 <code>Multiplexer</code>，相同请求（<code>MultiplexProducer.getKey</code>）的 consumer 都挂在同一个 Multiplexer 里</li><li>第一个请求才会通过此节点，流向下一节点（执行真正的请求操作：网络、缓存），后续的相同的请求都被终止，它们的 consumer 被挂在同一 Multiplexer 里</li><li>第一个（也是唯一一个）请求的 response 将被分发给各个 consumer</li><li>涉及到多线程，创建 Multiplexer 和添加 consumer 的操作需要被 <code>synchronized</code> 保护</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplexProducer</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produceResults</span><span class="hljs-params">(Consumer&lt;T&gt; consumer, ProducerContext context)</span> &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.beginSection(<span class="hljs-string">&quot;MultiplexProducer#produceResults&quot;</span>);      &#125;      context.getProducerListener().onProducerStart(context, mProducerName);      <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> getKey(context);      Multiplexer multiplexer;      <span class="hljs-type">boolean</span> createdNewMultiplexer;      <span class="hljs-comment">// We do want to limit scope of this lock to guard only accesses to mMultiplexers map.</span>      <span class="hljs-comment">// However what we would like to do here is to atomically lookup mMultiplexers, add new</span>      <span class="hljs-comment">// consumer to consumers set associated with the map&#x27;s entry and call consumer&#x27;s callback with</span>      <span class="hljs-comment">// last intermediate result. We should not do all of those things under this lock.</span>      <span class="hljs-keyword">do</span> &#123;        createdNewMultiplexer = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;          multiplexer = getExistingMultiplexer(key);          <span class="hljs-keyword">if</span> (multiplexer == <span class="hljs-literal">null</span>) &#123;            multiplexer = createAndPutNewMultiplexer(key);            createdNewMultiplexer = <span class="hljs-literal">true</span>;          &#125;        &#125;        <span class="hljs-comment">// addNewConsumer may call consumer&#x27;s onNewResult method immediately. For this reason</span>        <span class="hljs-comment">// we release &quot;this&quot; lock. If multiplexer is removed from mMultiplexers in the meantime,</span>        <span class="hljs-comment">// which is not very probable, then addNewConsumer will fail and we will be able to retry.</span>      &#125; <span class="hljs-keyword">while</span> (!multiplexer.addNewConsumer(consumer, context));      <span class="hljs-keyword">if</span> (createdNewMultiplexer) &#123;        multiplexer.startInputProducerIfHasAttachedConsumers(            TriState.valueOf(context.isPrefetch()));      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (FrescoSystrace.isTracing()) &#123;        FrescoSystrace.endSection();      &#125;    &#125;  &#125;    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>glide</tag>
      
      <tag>fresco</tag>
      
      <tag>imageloader</tag>
      
      <tag>图片加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP Range - 分段下载</title>
    <link href="/2021/12/16/http-range/"/>
    <url>/2021/12/16/http-range/</url>
    
    <content type="html"><![CDATA[<h1 id="request-header"><a href="#request-header" class="headerlink" title="request header"></a>request header</h1><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">Range</span>: <span class="hljs-operator">&lt;</span>unit<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">-</span><span class="hljs-keyword">Range</span>: <span class="hljs-operator">&lt;</span>unit<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span><span class="hljs-keyword">Range</span>: <span class="hljs-operator">&lt;</span>unit<span class="hljs-operator">&gt;=</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span>, ...</code></pre></div><ul><li><code>&lt;unit&gt;</code>：范围的单位，通常是字节（bytes）</li><li><code>&lt;range-start&gt;</code>：范围的起始值</li><li><code>&lt;range-end&gt;</code>：范围的结束值。这个值是可选的，如果不存在表示此范围一直延伸到文档结束</li></ul><p><code>Range</code> 是一个请求首部，值是一个或多个 <code>范围</code>，告知服务器返回文件的哪一部分</p><ol><li>如果是请求单个范围，服务器返回 <code>206 Partial Content</code></li><li>如果请求多个范围，服务器会以 multipart 文件的形式将其返回</li><li>如果请求的范围不合法，服务器返回 <code>416 Range Not Satisfiable</code></li><li>服务器允许忽略 Range 首部从而返回整个文件（比如服务器不支持分段下载），状态码用 200</li></ol><h1 id="response-header-206"><a href="#response-header-206" class="headerlink" title="response header (206)"></a>response header (206)</h1><p><code>206 Partial Content</code> 表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的</p><ol><li>如果只包含一个数据区间，那么整个响应的 <code>Content-Type</code> 首部的值为所请求的文件的类型，同时包含  <code>Content-Range</code> 首部</li><li>如果包含多个数据区间，那么整个响应的 <code>Content-Type</code> 首部的值为 <code>multipart/byteranges</code>，其中一个片段对应一个数据区间，并提供 <code>Content-Range</code> 和 <code>Content-Type</code> 描述信息</li></ol><div class="code-wrapper"><pre><code class="hljs sql">Content<span class="hljs-operator">-</span><span class="hljs-keyword">Range</span>: <span class="hljs-operator">&lt;</span>unit<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">/</span><span class="hljs-operator">&lt;</span>size<span class="hljs-operator">&gt;</span>Content<span class="hljs-operator">-</span><span class="hljs-keyword">Range</span>: <span class="hljs-operator">&lt;</span>unit<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">start</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">range</span><span class="hljs-operator">-</span><span class="hljs-keyword">end</span><span class="hljs-operator">&gt;</span><span class="hljs-comment">/*</span><span class="hljs-comment">Content-Range: &lt;unit&gt; */</span><span class="hljs-operator">&lt;</span>size<span class="hljs-operator">&gt;</span></code></pre></div><ul><li><code>&lt;size&gt;</code>：整个文件的大小，如果大小未知则用 <code>*</code> 表示</li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>多线程下载、分布式下载</p><ol><li>发送 <code>Head</code> 请求确定服务端是否支持 <code>Range</code> 以及确定文件 <code>Content-Length</code></li><li>划分不同的下载任务<ul><li>任务一： Range: bytes=0-99</li><li>任务二： Range: bytes=100-199</li><li>任务三： Range: bytes=200-330</li><li>…</li></ul></li><li>分发不同的下载任务给不同的节点或线程</li><li>合并下载结果</li></ol><p>断点续传：记录文件长度 <code>Content-Length</code> 和已下载的数据量，中断下载后重新开始时，从上一次下载结束的偏移量开始</p><h1 id="阿里云-OSS-分段下载的例子"><a href="#阿里云-OSS-分段下载的例子" class="headerlink" title="阿里云 OSS 分段下载的例子"></a>阿里云 OSS 分段下载的例子</h1><p>通过 HTTP Range 获取大文件的部分内容示例如下</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Get</span> /ObjectName HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><span class="hljs-attribute">Host</span>:xxxx.oss-cn-hangzhou.aliyuncs.com<span class="hljs-attribute">Date</span>:Tue, <span class="hljs-number">17</span> Nov <span class="hljs-number">2015</span> <span class="hljs-number">17</span>:<span class="hljs-number">27</span>:<span class="hljs-number">45</span> GMT<span class="hljs-attribute">Authorization</span>:SignatureValue<span class="hljs-attribute">Range</span>:bytes=[$ByteRange]</code></pre></div><ul><li><code>[$ByteRange]</code> 指请求资源的范围，单位为字节，有效区间在 0 至 content-length - 1 的范围内</li><li><code>Range: bytes=0-499</code> 表示第 0 ~ 499 字节范围的内容</li><li><code>Range: bytes=500-999</code> 表示第 500 ~ 999 字节范围的内容</li><li><code>Range: bytes=-500</code> 表示最后 500 字节的内容</li><li><code>Range: bytes=500-</code> 表示从第 500 字节开始到文件结束部分的内容</li><li><code>Range: bytes=0-</code> 表示第一个字节到最后一个字节，即完整的文件内容</li><li>OSS 不支持多 <code>Range</code> 参数，即不支持指定多个范围。如果指定多个范围 OSS 只返回第一个 <code>Range</code> 的数据，例如 <code>Range:bytes=0-499,500-999</code> OSS 只返回 0 - 499 字节范围的内容</li></ul><p>如果 HTTP Range 请求合法，响应 <code>206</code> 并在响应头中包含 <code>Content-Range</code>；如果 HTTP Range 请求不合法或者指定范围不在有效区间，会导致 <code>Range</code> 不生效，响应 200 并传送整个 Object 内容</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 请求 Object 资源 0-499 字节范围内的内容</span><span class="hljs-attribute">GET</span> /ObjectName<span class="hljs-attribute">Range</span>: bytes=<span class="hljs-number">0</span>-<span class="hljs-number">499</span><span class="hljs-attribute">Host</span>: bucket.oss-cn-hangzhou.aliyuncs.com<span class="hljs-attribute">Date</span>: Fri, <span class="hljs-number">18</span> Oct <span class="hljs-number">2019</span> <span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">30</span> GMT<span class="hljs-attribute">Authorization</span>: Sigature<span class="hljs-attribute">206</span> (Partial Content)<span class="hljs-attribute">content</span>-length: <span class="hljs-number">500</span><span class="hljs-attribute">content</span>-range: bytes <span class="hljs-number">0</span>-<span class="hljs-number">499</span>/<span class="hljs-number">1000</span><span class="hljs-attribute">connection</span>: keep-alive<span class="hljs-attribute">etag</span>: <span class="hljs-string">&quot;CACF99600561A31D494569C979E6FB81&quot;</span><span class="hljs-attribute">x</span>-oss-request-id: <span class="hljs-number">5</span>DA928B227D52731327DE078<span class="hljs-attribute">date</span>: Fri, <span class="hljs-number">18</span> Oct <span class="hljs-number">2019</span> <span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">30</span> GMT<span class="hljs-meta"></span><span class="hljs-meta">[500 bytes of object data]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 指定范围超出有效区间，导致 Range 不生效，响应 200 并传送整个 Object 内容</span><span class="hljs-attribute">GET</span> /ObjectName<span class="hljs-attribute">Range</span>: bytes=<span class="hljs-number">1000</span>-<span class="hljs-number">2000</span><span class="hljs-attribute">Host</span>: bucket.oss-cn-hangzhou.aliyuncs.com<span class="hljs-attribute">Date</span>: Fri, <span class="hljs-number">18</span> Oct <span class="hljs-number">2019</span> <span class="hljs-number">02</span>:<span class="hljs-number">56</span>:<span class="hljs-number">24</span> GMT<span class="hljs-attribute">Authorization</span>: Sigature<span class="hljs-attribute">200</span> (OK)<span class="hljs-attribute">content</span>-length: <span class="hljs-number">1000</span><span class="hljs-attribute">etag</span>: <span class="hljs-string">&quot;CACF99600561A31D494569C979E6FB81&quot;</span><span class="hljs-attribute">x</span>-oss-request-id: <span class="hljs-number">5</span>DA929D9CCCC823835CBE134<span class="hljs-attribute">date</span>: Fri, <span class="hljs-number">18</span> Oct <span class="hljs-number">2019</span> <span class="hljs-number">02</span>:<span class="hljs-number">56</span>:<span class="hljs-number">25</span> GMT<span class="hljs-meta"></span><span class="hljs-meta">[1000 bytes of object data]</span></code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206">206 Partial Content</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range">Range</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Range">Content-Range</a></li><li><a href="https://zhuanlan.zhihu.com/p/126991550">天天见之HTTP Header Range 和 Content-Range 你真的了解吗？</a></li><li><a href="https://help.aliyun.com/document_detail/39571.html">如何通过HTTP Range请求分段获取OSS资源</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>range</tag>
      
      <tag>content-range</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matrix - ANR 原理解析</title>
    <link href="/2021/12/03/matrix-anr/"/>
    <url>/2021/12/03/matrix-anr/</url>
    
    <content type="html"><![CDATA[<p>上两篇文章 <a href="../../../../2021/06/22/xcrash/">崩溃日志收集库 xCrash 浅析</a> 和 <a href="../../../../2021/11/29/xcrash-anr-compatibility/">xCrash ANR 兼容性测试</a> 介绍了 <a href="https://github.com/iqiyi/xCrash">xCrash</a> 是如何处理 ANR 事件的：</p><ul><li>注册 <code>SIGQUIT</code> 信号处理器捕获 ANR</li><li>查询是否处于 <code>NOT_RESPONDING</code> 状态以判别是否自己发生了 ANR</li><li>寻找符号 <code>Runtime::DumpForSigQuit</code> 并调用以打印 ANR 日志</li></ul><p>过程中提出了几个问题：</p><ol><li><code>NOT_RESPONDING</code> 不够准确，后台 ANR 和主线程从阻塞恢复的情况下会漏掉 ANR</li><li>自己调用 <code>Runtime::DumpForSigQuit</code> 打印了一份 ANR 日志，重新抛出 <code>SIGQUIT</code> 后 <code>Signal Catcher</code> 线程又打印了一份 ANR 日志，重复打印了</li></ol><p>本文主要是分析 <a href="https://github.com/Tencent/matrix">Matrix</a> 处理 ANR 的流程，顺带看看对于上述问题 Matrix 有没提出更好的解决方案</p><h1 id="SIGQUIT-Signal-Handler"><a href="#SIGQUIT-Signal-Handler" class="headerlink" title="SIGQUIT Signal Handler"></a>SIGQUIT Signal Handler</h1><p>Matrix 也是通过注册 SIGQUIT 信号处理器来捕获 ANR 事件的，看来这种方法是比较稳定且被大家认可的，调用栈如下：</p><div class="code-wrapper"><pre><code class="hljs cpp">TracePlugin.startSignalAnrTracer.onStartTraceSignalAnrTracer.onAliveSignalAnrTracer.nativeInitSignalAnrDetective<span class="hljs-type">static</span> std::optional&lt;AnrDumper&gt; sAnrDumper;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">nativeInitSignalAnrDetective</span><span class="hljs-params">(JNIEnv *env, jclass, jstring anrTracePath, jstring printTracePath)</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* anrTracePathChar = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(anrTracePath, <span class="hljs-literal">nullptr</span>);    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* printTracePathChar = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(printTracePath, <span class="hljs-literal">nullptr</span>);    anrTracePathstring = std::<span class="hljs-built_in">string</span>(anrTracePathChar);    printTracePathstring = std::<span class="hljs-built_in">string</span>(printTracePathChar);    sAnrDumper.<span class="hljs-built_in">emplace</span>(anrTracePathChar, printTracePathChar, anrDumpCallback);&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrDumper</span> : <span class="hljs-function"><span class="hljs-keyword">public</span> SignalHandler</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">SignalHandler::SignalHandler</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(sHandlerStackMutex)</span></span>;    <span class="hljs-keyword">if</span> (!sHandlerStack)        sHandlerStack = <span class="hljs-keyword">new</span> std::vector&lt;SignalHandler*&gt;;    <span class="hljs-built_in">installAlternateStackLocked</span>();    <span class="hljs-built_in">installHandlersLocked</span>();    sHandlerStack-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-comment">// 安装 SIGQUIT 信号处理器</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> TARGET_SIG = SIGQUIT;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SignalHandler::installHandlersLocked</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (sHandlerInstalled) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigaction</span>(TARGET_SIG, <span class="hljs-literal">nullptr</span>, &amp;sOldHandlers) == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa&#123;&#125;;    sa.sa_sigaction = signalHandler;    sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigaction</span>(TARGET_SIG, &amp;sa, <span class="hljs-literal">nullptr</span>) == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Signal handler cannot be installed&quot;</span>);    &#125;    sHandlerInstalled = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Signal handler installed.&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// 收到 SIGQUIT 信号后的回调</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SignalHandler::signalHandler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">siginfo_t</span>* info, <span class="hljs-type">void</span>* uc)</span> </span>&#123;    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Entered signal handler.&quot;</span>);    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(sHandlerStackMutex)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = sHandlerStack-&gt;<span class="hljs-built_in">rbegin</span>(); it != sHandlerStack-&gt;<span class="hljs-built_in">rend</span>(); ++it) &#123;        (*it)-&gt;<span class="hljs-built_in">handleSignal</span>(sig, info, uc);    &#125;    lock.<span class="hljs-built_in">unlock</span>();&#125;<span class="hljs-function">SignalHandler::Result <span class="hljs-title">AnrDumper::handleSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">const</span> <span class="hljs-type">siginfo_t</span> *info, <span class="hljs-type">void</span> *uc)</span> </span>&#123;    <span class="hljs-comment">// Only process SIGQUIT, which indicates an ANR.</span>    <span class="hljs-keyword">if</span> (sig != SIGQUIT) <span class="hljs-keyword">return</span> NOT_HANDLED;    <span class="hljs-type">int</span> fromPid1 = info-&gt;_si_pad[<span class="hljs-number">3</span>];    <span class="hljs-type">int</span> fromPid2 = info-&gt;_si_pad[<span class="hljs-number">4</span>]; <span class="hljs-comment">// sender pid</span>    <span class="hljs-type">int</span> myPid = <span class="hljs-built_in">getpid</span>();    <span class="hljs-type">pthread_t</span> thd;    <span class="hljs-keyword">if</span> (fromPid1 != myPid &amp;&amp; fromPid2 != myPid) &#123;        <span class="hljs-built_in">pthread_create</span>(&amp;thd, <span class="hljs-literal">nullptr</span>, anrCallback, <span class="hljs-literal">nullptr</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">pthread_create</span>(&amp;thd, <span class="hljs-literal">nullptr</span>, siUserCallback, <span class="hljs-literal">nullptr</span>);    &#125;    <span class="hljs-built_in">pthread_detach</span>(thd);    <span class="hljs-keyword">return</span> HANDLED_NO_RETRIGGER;&#125;</code></pre></div><h2 id="fromPid1-和-fromPid2"><a href="#fromPid1-和-fromPid2" class="headerlink" title="fromPid1 和 fromPid2"></a>fromPid1 和 fromPid2</h2><p>经测试，如果自己发生 ANR 则 <code>fromPid1:0 fromPid2:1719 myPid:7414</code>，自己给自己发送 SIGQUIT 的话是 <code>fromPid1:0 fromPid2:7414 myPid:7414</code>，也就是说 <code>fromPid2</code> 表示发送信号的进程，正常情况下是走 <code>anrCallback</code>，下面先分析这种情况</p><div class="code-wrapper"><pre><code class="hljs text">system         1719    703 9940960 199048 0                   0 S system_serveru10_a369       7414    703 5513524 135784 0                   0 S sample.tencent.matrix</code></pre></div><h1 id="判别是否自己发生了-ANR"><a href="#判别是否自己发生了-ANR" class="headerlink" title="判别是否自己发生了 ANR"></a>判别是否自己发生了 ANR</h1><p>Matrix 在判别是否发生 ANR 事件时，在 <code>NOT_RESPONDING</code> 的基础上，增加了【主线程是否阻塞】这一条件，增大了 ANR 捕获率：</p><ol><li>首先检查主线程是否阻塞，如果阻塞则一定发生了 ANR</li><li>20s 内每隔 500ms 轮询是否处于 <code>NOT_RESPONDING</code> 状态（<code>SignalAnrTracer.checkErrorState</code>），这跟 xCrash 的逻辑是一致的</li></ol><p><code>SignalAnrTracer.isMainThreadBlocked</code> 判断主线程是否阻塞了，可以先看看 <a href="../../../../2020/09/27/handler-messagequeue-looper/">面试官家常之Handler、MessageQueue 和 Looper</a> 回顾下 <code>MessageQueue</code> 的基础知识：</p><ol><li>MessageQueue 是个单向链表，按 <code>Message.when</code> 自然序排</li><li>表头是 <code>MessageQueue.mMessages</code></li></ol><p>如果主线程阻塞了，那么表头一定是超时的（<code>when - SystemClock.uptimeMillis()</code> 为负），当超时时间大于阈值时（前台 2s，后台 10s，这个阈值是怎么来的呢？）就可以认定是发生阻塞了</p><p>增加了这一条件，后台 ANR 也不会成为漏网之鱼了；而且判断过程发生在 dump anr 之前，不会因为 dump anr 耗时过长、主线程从阻塞及时恢复而导致的漏判</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">anrCallback</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;    <span class="hljs-built_in">anrDumpCallback</span>();    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(mAnrTraceFile) &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">hookAnrTraceWrite</span>(<span class="hljs-literal">false</span>);    &#125;    <span class="hljs-built_in">sendSigToSignalCatcher</span>();    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">anrDumpCallback</span><span class="hljs-params">()</span> </span>&#123;    JNIEnv *env = JniInvocation::<span class="hljs-built_in">getEnv</span>();    <span class="hljs-keyword">if</span> (!env) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    env-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(gJ.AnrDetective, gJ.AnrDetector_onANRDumped);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalAnrTracer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Tracer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CHECK_ANR_STATE_THREAD_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Check-ANR-State-Thread&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHECK_ERROR_STATE_INTERVAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ANR_DUMP_MAX_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHECK_ERROR_STATE_COUNT</span> <span class="hljs-operator">=</span>            ANR_DUMP_MAX_TIME / CHECK_ERROR_STATE_INTERVAL;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">FOREGROUND_MSG_THRESHOLD</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2000</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BACKGROUND_MSG_THRESHOLD</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onANRDumped</span><span class="hljs-params">()</span> &#123;        currentForeground = AppForegroundUtil.isInterestingToUser();        <span class="hljs-type">boolean</span> <span class="hljs-variable">needReport</span> <span class="hljs-operator">=</span> isMainThreadBlocked();        <span class="hljs-keyword">if</span> (needReport) &#123;            report(<span class="hljs-literal">false</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                    checkErrorStateCycle();                &#125;            &#125;, CHECK_ANR_STATE_THREAD_NAME).start();        &#125;    &#125;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkErrorStateCycle</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">checkErrorStateCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (checkErrorStateCount &lt; CHECK_ERROR_STATE_COUNT) &#123;            <span class="hljs-keyword">try</span> &#123;                checkErrorStateCount++;                <span class="hljs-type">boolean</span> <span class="hljs-variable">myAnr</span> <span class="hljs-operator">=</span> checkErrorState();                <span class="hljs-keyword">if</span> (myAnr) &#123;                    report(<span class="hljs-literal">true</span>);                    <span class="hljs-keyword">break</span>;                &#125;                Thread.sleep(CHECK_ERROR_STATE_INTERVAL);            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;                MatrixLog.e(TAG, <span class="hljs-string">&quot;checkErrorStateCycle error, e : &quot;</span> + t.getMessage());                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;        <span class="hljs-comment">// 轮询 NOT_RESPONDING 状态</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkErrorState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Application</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span>                    sApplication == <span class="hljs-literal">null</span> ? Matrix.with().getApplication() : sApplication;            <span class="hljs-type">ActivityManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> (ActivityManager) application                    .getSystemService(Context.ACTIVITY_SERVICE);            List&lt;ActivityManager.ProcessErrorStateInfo&gt; procs = am.getProcessesInErrorState();            <span class="hljs-keyword">if</span> (procs == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (ActivityManager.ProcessErrorStateInfo proc : procs) &#123;                MatrixLog.i(TAG, <span class="hljs-string">&quot;[checkErrorState] found Error State proccessName = %s, proc.condition = %d&quot;</span>, proc.processName, proc.condition);                <span class="hljs-keyword">if</span> (proc.uid != android.os.Process.myUid()                        &amp;&amp; proc.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;                    MatrixLog.i(TAG, <span class="hljs-string">&quot;maybe received other apps ANR signal&quot;</span>);                &#125;                <span class="hljs-keyword">if</span> (proc.pid != android.os.Process.myPid()) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span> (proc.condition != ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            MatrixLog.e(TAG, <span class="hljs-string">&quot;[checkErrorState] error : %s&quot;</span>, t.getMessage());        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;        <span class="hljs-comment">// 判断主线程是否发生了阻塞</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMainThreadBlocked</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">mainQueue</span> <span class="hljs-operator">=</span> Looper.getMainLooper().getQueue();            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> mainQueue.getClass().getDeclaredField(<span class="hljs-string">&quot;mMessages&quot;</span>);            field.setAccessible(<span class="hljs-literal">true</span>);            <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">mMessage</span> <span class="hljs-operator">=</span> (Message) field.get(mainQueue);            <span class="hljs-keyword">if</span> (mMessage != <span class="hljs-literal">null</span>) &#123;                anrMessageString = mMessage.toString();                <span class="hljs-type">long</span> <span class="hljs-variable">when</span> <span class="hljs-operator">=</span> mMessage.getWhen();                <span class="hljs-keyword">if</span> (when == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> when - SystemClock.uptimeMillis();                anrMessageWhen = time;                <span class="hljs-type">long</span> <span class="hljs-variable">timeThreshold</span> <span class="hljs-operator">=</span> BACKGROUND_MSG_THRESHOLD;                <span class="hljs-keyword">if</span> (currentForeground) &#123;                    timeThreshold = FOREGROUND_MSG_THRESHOLD;                &#125;                <span class="hljs-keyword">return</span> time &lt; timeThreshold;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;     &#125;</code></pre></div><h1 id="hook-Signal-Catcher"><a href="#hook-Signal-Catcher" class="headerlink" title="hook Signal Catcher"></a>hook Signal Catcher</h1><p>如何 dump anr 日志，Matrix 也与 xCrash 有着不同的实现方式，Matrix 并没有自己去 dump anr 日志，而是通过 hook 系统调用后重新发送 SIGQUIT 给 Signal Catcher 线程，让它去执行系统的 ANR 处理流程，从而自己也能拿到一份 ANR 日志，避免了重复 dump anr</p><p>hook 用的是 <a href="https://github.com/iqiyi/xHook">xHook</a></p><p><code>Signal Catcher</code> 线程 ID 则是遍历 <code>/proc/[pid]/task/[tid]/comm</code> 对比线程名，以及对比 <code>/proc/[tid]/status</code> 里的 <code>magic code</code> 来确定的</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">anrCallback</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;    <span class="hljs-built_in">anrDumpCallback</span>();    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(mAnrTraceFile) &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">hookAnrTraceWrite</span>(<span class="hljs-literal">false</span>);    &#125;    <span class="hljs-built_in">sendSigToSignalCatcher</span>();    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hookAnrTraceWrite</span><span class="hljs-params">(<span class="hljs-type">bool</span> isSiUser)</span> </span>&#123;    <span class="hljs-type">int</span> apiLevel = <span class="hljs-built_in">getApiLevel</span>();    <span class="hljs-keyword">if</span> (apiLevel &lt; <span class="hljs-number">19</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (!fromMyPrintTrace &amp;&amp; isSiUser) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (isHooking) &#123;        <span class="hljs-keyword">return</span>;    &#125;    isHooking = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (apiLevel &gt;= <span class="hljs-number">27</span>) &#123;        <span class="hljs-type">void</span> *libcutils_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;/system/lib64/libcutils.so&quot;</span>);        <span class="hljs-keyword">if</span>(!libcutils_info) &#123;            libcutils_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;/system/lib/libcutils.so&quot;</span>);        &#125;        <span class="hljs-built_in">xhook_got_hook_symbol</span>(libcutils_info, <span class="hljs-string">&quot;connect&quot;</span>, (<span class="hljs-type">void</span>*) my_connect, (<span class="hljs-type">void</span>**) (&amp;original_connect));    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">void</span>* libart_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;libart.so&quot;</span>);        <span class="hljs-built_in">xhook_got_hook_symbol</span>(libart_info, <span class="hljs-string">&quot;open&quot;</span>, (<span class="hljs-type">void</span>*) my_open, (<span class="hljs-type">void</span>**) (&amp;original_open));    &#125;    <span class="hljs-keyword">if</span> (apiLevel &gt;= <span class="hljs-number">30</span> || apiLevel == <span class="hljs-number">25</span> || apiLevel == <span class="hljs-number">24</span>) &#123;        <span class="hljs-type">void</span>* libc_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;libc.so&quot;</span>);        <span class="hljs-built_in">xhook_got_hook_symbol</span>(libc_info, <span class="hljs-string">&quot;write&quot;</span>, (<span class="hljs-type">void</span>*) my_write, (<span class="hljs-type">void</span>**) (&amp;original_write));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (apiLevel == <span class="hljs-number">29</span>) &#123;        <span class="hljs-type">void</span>* libbase_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;/system/lib64/libbase.so&quot;</span>);        <span class="hljs-keyword">if</span>(!libbase_info) &#123;            libbase_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;/system/lib/libbase.so&quot;</span>);        &#125;        <span class="hljs-built_in">xhook_got_hook_symbol</span>(libbase_info, <span class="hljs-string">&quot;write&quot;</span>, (<span class="hljs-type">void</span>*) my_write, (<span class="hljs-type">void</span>**) (&amp;original_write));        <span class="hljs-built_in">xhook_elf_close</span>(libbase_info);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">void</span>* libart_info = <span class="hljs-built_in">xhook_elf_open</span>(<span class="hljs-string">&quot;libart.so&quot;</span>);        <span class="hljs-built_in">xhook_got_hook_symbol</span>(libart_info, <span class="hljs-string">&quot;write&quot;</span>, (<span class="hljs-type">void</span>*) my_write, (<span class="hljs-type">void</span>**) (&amp;original_write));    &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sendSigToSignalCatcher</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> tid = <span class="hljs-built_in">getSignalCatcherThreadId</span>();    <span class="hljs-built_in">syscall</span>(SYS_tgkill, <span class="hljs-built_in">getpid</span>(), tid, SIGQUIT);&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getSignalCatcherThreadId</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">char</span> taskDirPath[<span class="hljs-number">128</span>];    DIR *taskDir;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sigblk;    <span class="hljs-type">int</span> signalCatcherTid = <span class="hljs-number">-1</span>;    <span class="hljs-type">int</span> firstSignalCatcherTid = <span class="hljs-number">-1</span>;    <span class="hljs-built_in">snprintf</span>(taskDirPath, <span class="hljs-built_in">sizeof</span>(taskDirPath), <span class="hljs-string">&quot;/proc/%d/task&quot;</span>, <span class="hljs-built_in">getpid</span>());    <span class="hljs-keyword">if</span> ((taskDir = <span class="hljs-built_in">opendir</span>(taskDirPath)) == <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *dent;    <span class="hljs-type">pid_t</span> tid;    <span class="hljs-keyword">while</span> ((dent = <span class="hljs-built_in">readdir</span>(taskDir)) != <span class="hljs-literal">nullptr</span>) &#123;        tid = <span class="hljs-built_in">atoi</span>(dent-&gt;d_name);        <span class="hljs-keyword">if</span> (tid &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-type">char</span> threadName[<span class="hljs-number">1024</span>];        <span class="hljs-type">char</span> commFilePath[<span class="hljs-number">1024</span>];        <span class="hljs-built_in">snprintf</span>(commFilePath, <span class="hljs-built_in">sizeof</span>(commFilePath), <span class="hljs-string">&quot;/proc/%d/task/%d/comm&quot;</span>, <span class="hljs-built_in">getpid</span>(), tid);        Support::<span class="hljs-built_in">readFileAsString</span>(commFilePath, threadName, <span class="hljs-built_in">sizeof</span>(threadName));        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(SIGNAL_CATCHER_THREAD_NAME, threadName , <span class="hljs-built_in">sizeof</span>(SIGNAL_CATCHER_THREAD_NAME)<span class="hljs-number">-1</span>) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (firstSignalCatcherTid == <span class="hljs-number">-1</span>) &#123;            firstSignalCatcherTid = tid;        &#125;        sigblk = <span class="hljs-number">0</span>;        <span class="hljs-type">char</span> taskPath[<span class="hljs-number">128</span>];        <span class="hljs-built_in">snprintf</span>(taskPath, <span class="hljs-built_in">sizeof</span>(taskPath), <span class="hljs-string">&quot;/proc/%d/status&quot;</span>, tid);        <span class="hljs-function">ScopedFileDescriptor <span class="hljs-title">fd</span><span class="hljs-params">(open(taskPath, O_RDONLY, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-function">LineReader <span class="hljs-title">lr</span><span class="hljs-params">(fd.get())</span></span>;        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *line;        <span class="hljs-type">size_t</span> len;        <span class="hljs-keyword">while</span> (lr.<span class="hljs-built_in">getNextLine</span>(&amp;line, &amp;len)) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == <span class="hljs-built_in">sscanf</span>(line, <span class="hljs-string">&quot;SigBlk: %&quot;</span> SCNx64, &amp;sigblk)) &#123;                <span class="hljs-keyword">break</span>;            &#125;            lr.<span class="hljs-built_in">popLine</span>(len);        &#125;        <span class="hljs-keyword">if</span> (SIGNAL_CATCHER_THREAD_SIGBLK != sigblk) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        signalCatcherTid = tid;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">closedir</span>(taskDir);    <span class="hljs-keyword">if</span> (signalCatcherTid == <span class="hljs-number">-1</span>) &#123;        signalCatcherTid = firstSignalCatcherTid;    &#125;    <span class="hljs-keyword">return</span> signalCatcherTid;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比 xCrash 的 ANR 方案，Matrix 做了以下优化：</p><ol><li>提前判断是否发生 ANR，并增加【主线程是否阻塞】这一判断条件，提高 ANR 捕获率</li><li>hook 系统调用拿到 <code>Signal Catcher</code> 输出的 ANR 日志，避免了重复 dump anr，属于性能优化</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649288031&idx=1&sn=91c94e16460a4685a9c0c8e1b9c362a6">微信Android客户端的ANR监控方案</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>崩溃</tag>
      
      <tag>xCrash</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xCrash ANR 兼容性测试</title>
    <link href="/2021/11/29/xcrash-anr-compatibility/"/>
    <url>/2021/11/29/xcrash-anr-compatibility/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>Target</th><th>Steps</th></tr></thead><tbody><tr><td>目的</td><td>测试 <code>xCrash</code> 捕获 <code>ANR</code> 的能力在各个 Android 版本上的兼容性</td></tr><tr><td>平台</td><td><a href="https://wetest.qq.com/">WeTest</a> - 兼容性测试 - 选取 Android 5.1 至 Android 12 共 8 个机型</td></tr><tr><td>Apk</td><td>Viomi Fridge Launcher V2.1.2</td></tr><tr><td>xCrash Version</td><td>3.0.0</td></tr><tr><td>ANR 捕获机制</td><td>注册 <code>SIGQUIT</code> 信号处理器，<code>Runtime::DumpForSigQuit</code> 打印调用栈，一段时间内轮询 <code>ActivityManager.getProcessesInErrorState</code> 是否为 <code>ProcessErrorStateInfo.NOT_RESPONDING</code> 来判断当前 APP 是否发生 ANR</td></tr><tr><td>测试流程</td><td>APP 启动后 5s 初始化 xCrash ANR，3s 后启动 <code>AnrService</code>，通过 <code>startService</code> 超时来触发 ANR</td></tr><tr><td>日志分析</td><td>将日志文件逐个下载，放到 <a href="https://cloudvyzor.com/">LogPad</a> 上过滤出 tag 为 <code>xcrash_dumper</code> 的条目</td></tr></tbody></table><h1 id="详细的日志埋点"><a href="#详细的日志埋点" class="headerlink" title="详细的日志埋点"></a>详细的日志埋点</h1><p>tag 为 <code>xcrash_dumper</code> 为插入的日志埋点</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initXCrash</span><span class="hljs-params">()</span></span> &#123;    mainHandler.postDelayed(&#123;        XCrash.<span class="hljs-keyword">init</span>(app, XCrash.InitParameters().apply &#123;            setAnrCallback &#123; logPath, emergency -&gt;                Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;ANR Callback, <span class="hljs-variable">$emergency</span>, <span class="hljs-variable">$logPath</span>&quot;</span>)    <span class="hljs-comment">// 自定义 ANR 回调</span>            &#125;        &#125;)        mainHandler.postDelayed(&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">val</span> nativeHandlerClz = Class.forName(<span class="hljs-string">&quot;xcrash.NativeHandler&quot;</span>)                <span class="hljs-keyword">val</span> instanceField = nativeHandlerClz.getDeclaredField(<span class="hljs-string">&quot;instance&quot;</span>)                instanceField.isAccessible = <span class="hljs-literal">true</span>                <span class="hljs-keyword">val</span> nativeHandler = instanceField.<span class="hljs-keyword">get</span>(nativeHandlerClz)                <span class="hljs-keyword">val</span> anrTimeoutField = nativeHandlerClz.getDeclaredField(<span class="hljs-string">&quot;anrTimeoutMs&quot;</span>)                anrTimeoutField.isAccessible = <span class="hljs-literal">true</span>                anrTimeoutField.<span class="hljs-keyword">set</span>(nativeHandler, <span class="hljs-number">20</span> * <span class="hljs-number">1000L</span>)                <span class="hljs-comment">// 判断 ANR 的阈值校正为 20s，默认 15s 太短有时 ANR 对话框还没弹出，APP 不处于 NOT_RESPONDING 状态</span>                Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;NativeHandler.anrTimeoutMs = 20s&quot;</span>)                &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;                Log.e(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;fail to change NativeHandler.anrTimeoutMs&quot;</span>, e)            &#125;            app.startService(Intent(app, AnrService::<span class="hljs-keyword">class</span>.java))            Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;AnrService was started&quot;</span>)    <span class="hljs-comment">// 启动 Service 超时</span>        &#125;, <span class="hljs-number">3</span> * <span class="hljs-number">1000L</span>)    &#125;, <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>)    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrService</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStartCommand</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?, flags: <span class="hljs-type">Int</span>, startId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;        <span class="hljs-keyword">val</span> tombstones = File(applicationContext.filesDir, <span class="hljs-string">&quot;tombstones&quot;</span>)        <span class="hljs-keyword">var</span> anrs = tombstones.listFiles &#123; _, name -&gt; name.endsWith(<span class="hljs-string">&quot;anr.xcrash&quot;</span>) &#125;        log(<span class="hljs-string">&quot;AnrService, delete <span class="hljs-subst">$&#123;anrs?.size&#125;</span> anr logs before anr&quot;</span>)    <span class="hljs-comment">// 清理 tombstones 目录</span>        anrs.forEach &#123; it.deleteSafely() &#125;        Thread.sleep(<span class="hljs-number">30</span> * <span class="hljs-number">1000L</span>)    <span class="hljs-comment">// 触发 ANR</span>        anrs = tombstones.listFiles &#123; _, name -&gt; name.endsWith(<span class="hljs-string">&quot;anr.xcrash&quot;</span>) &#125;        <span class="hljs-comment">// 看看有没 ANR 日志，没有的话说明没能捕获到 ANR</span>        log(<span class="hljs-string">&quot;AnrService, now <span class="hljs-subst">$&#123;System.currentTimeMillis() / <span class="hljs-number">1000</span>L&#125;</span>, found anr logs, <span class="hljs-subst">$&#123;anrs?.joinToString &#123; it.name &#125;</span>&#125;&quot;</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStartCommand(intent, flags, startId)    &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XCrash</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Context ctx, InitParameters params)</span> &#123;        <span class="hljs-keyword">if</span> (XCrash.initialized) &#123;            <span class="hljs-keyword">return</span> Errno.OK;        &#125;        XCrash.initialized = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> Errno.CONTEXT_IS_NULL;        &#125;        Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;xcrash start&quot;</span>);    <span class="hljs-comment">// xCrash 初始化</span>        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">//init native crash handler / ANR handler (API level &gt;= 21)</span>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Errno.OK;        <span class="hljs-keyword">if</span> (params.enableNativeCrashHandler || (params.enableAnrHandler &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>)) &#123;            r = NativeHandler.getInstance().initialize(                ctx,                params.libLoader,                appId,                params.appVersion,                params.logDir,                params.enableNativeCrashHandler,                params.nativeRethrow,                params.nativeLogcatSystemLines,                params.nativeLogcatEventsLines,                params.nativeLogcatMainLines,                params.nativeDumpElfHash,                params.nativeDumpMap,                params.nativeDumpFds,                params.nativeDumpNetworkInfo,                params.nativeDumpAllThreads,                params.nativeDumpAllThreadsCountMax,                params.nativeDumpAllThreadsWhiteList,                params.nativeCallback,                params.enableAnrHandler &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>,                params.anrRethrow,                params.anrCheckProcessState,                params.anrLogcatSystemLines,                params.anrLogcatEventsLines,                params.anrLogcatMainLines,                params.anrDumpFds,                params.anrDumpNetworkInfo,                params.anrCallback);        &#125;        <span class="hljs-comment">//maintain tombstone and placeholder files in a background thread with some delay</span>        FileManager.getInstance().maintain();        <span class="hljs-keyword">return</span> r;    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(...)</span> &#123;        <span class="hljs-comment">//load lib</span>        <span class="hljs-keyword">if</span> (libLoader == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                System.loadLibrary(<span class="hljs-string">&quot;xcrash&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;                XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;NativeHandler System.loadLibrary failed&quot;</span>, e);                <span class="hljs-keyword">return</span> Errno.LOAD_LIBRARY_FAILED;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">try</span> &#123;                libLoader.loadLibrary(<span class="hljs-string">&quot;xcrash&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;                XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;NativeHandler ILibLoader.loadLibrary failed&quot;</span>, e);                <span class="hljs-keyword">return</span> Errno.LOAD_LIBRARY_FAILED;            &#125;        &#125;        <span class="hljs-built_in">this</span>.ctx = ctx;        <span class="hljs-built_in">this</span>.crashRethrow = crashRethrow;        <span class="hljs-built_in">this</span>.crashCallback = crashCallback;        <span class="hljs-built_in">this</span>.anrEnable = anrEnable;        <span class="hljs-built_in">this</span>.anrCheckProcessState = anrCheckProcessState;        <span class="hljs-built_in">this</span>.anrCallback = anrCallback;        <span class="hljs-built_in">this</span>.anrTimeoutMs = anrRethrow ? <span class="hljs-number">15</span> * <span class="hljs-number">1000</span> : <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">//setting rethrow to &quot;false&quot; is NOT recommended</span>        Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;xcrash native start&quot;</span>);    <span class="hljs-comment">// xCrash native 初始化 </span>        <span class="hljs-comment">//init native lib</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nativeInit(                Build.VERSION.SDK_INT,                Build.VERSION.RELEASE,                Util.getAbiList(),                Build.MANUFACTURER,                Build.BRAND,                Util.getMobileModel(),                Build.FINGERPRINT,                appId,                appVersion,                ctx.getApplicationInfo().nativeLibraryDir,                logDir,                crashEnable,                crashRethrow,                crashLogcatSystemLines,                crashLogcatEventsLines,                crashLogcatMainLines,                crashDumpElfHash,                crashDumpMap,                crashDumpFds,                crashDumpNetworkInfo,                crashDumpAllThreads,                crashDumpAllThreadsCountMax,                crashDumpAllThreadsWhiteList,                anrEnable,                anrRethrow,                anrLogcatSystemLines,                anrLogcatEventsLines,                anrLogcatMainLines,                anrDumpFds,                anrDumpNetworkInfo);            <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;                XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;NativeHandler init failed&quot;</span>);                <span class="hljs-keyword">return</span> Errno.INIT_LIBRARY_FAILED;            &#125;            initNativeLibOk = <span class="hljs-literal">true</span>;            Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, <span class="hljs-string">&quot;xcrash native end&quot;</span>);    <span class="hljs-comment">// xCrash native 初始化结束</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//OK</span>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;NativeHandler init failed&quot;</span>, e);            <span class="hljs-keyword">return</span> Errno.INIT_LIBRARY_FAILED;        &#125;    &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">xc_jni_init</span><span class="hljs-params">(...)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">if</span>(trace_enable)    &#123;        <span class="hljs-comment">//trace init</span>        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;ANR native start&quot;</span>);    <span class="hljs-comment">// xcrash anr 初始化</span>        r_trace = <span class="hljs-built_in">xc_trace_init</span>(env,                            trace_rethrow ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,                            (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)trace_logcat_system_lines,                            (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)trace_logcat_events_lines,                            (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)trace_logcat_main_lines,                            trace_dump_fds ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,                            trace_dump_network_info ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//...</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xc_trace_init</span><span class="hljs-params">(JNIEnv *env,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> rethrow,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> logcat_system_lines,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> logcat_events_lines,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> logcat_main_lines,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> dump_fds,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> dump_network_info)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> r;    <span class="hljs-type">pthread_t</span> thd;    <span class="hljs-comment">//capture SIGQUIT only for ART</span>    <span class="hljs-keyword">if</span>(xc_common_api_level &lt; <span class="hljs-number">21</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//is Android Lollipop (5.x)?</span>    xc_trace_is_lollipop = ((<span class="hljs-number">21</span> == xc_common_api_level || <span class="hljs-number">22</span> == xc_common_api_level) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);    xc_trace_dump_status = XC_TRACE_DUMP_NOT_START;    xc_trace_rethrow = rethrow;    xc_trace_logcat_system_lines = logcat_system_lines;    xc_trace_logcat_events_lines = logcat_events_lines;    xc_trace_logcat_main_lines = logcat_main_lines;    xc_trace_dump_fds = dump_fds;    xc_trace_dump_network_info = dump_network_info;    <span class="hljs-comment">//init for JNI callback</span>    <span class="hljs-built_in">xc_trace_init_callback</span>(env);    <span class="hljs-comment">//create event FD</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &gt; (xc_trace_notifier = <span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_CLOEXEC))) <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;    <span class="hljs-comment">//register signal handler</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_signal_trace_register</span>(xc_trace_handler))) <span class="hljs-keyword">goto</span> err2;    <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;ANR native register SIGQUIT&quot;</span>);    <span class="hljs-comment">// 为捕获 ANR 注册 SIGQUIT 信号处理器并启动 xc_trace_dumper 线程</span>    <span class="hljs-comment">//create thread for dump trace</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">pthread_create</span>(&amp;thd, <span class="hljs-literal">NULL</span>, xc_trace_dumper, <span class="hljs-literal">NULL</span>))) <span class="hljs-keyword">goto</span> err1;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; err1:    <span class="hljs-built_in">xcc_signal_trace_unregister</span>(); err2:    <span class="hljs-built_in">close</span>(xc_trace_notifier);    xc_trace_notifier = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">xc_trace_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">siginfo_t</span> *si, <span class="hljs-type">void</span> *uc)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 信号处理程序收到 SIGQUIT(3)，唤醒 xc_trace_dumper 线程</span>    <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;SIGQUIT handler get %d, %d&quot;</span>, sig, xc_trace_notifier);        <span class="hljs-type">uint64_t</span> data;        (<span class="hljs-type">void</span>)sig;    (<span class="hljs-type">void</span>)si;    (<span class="hljs-type">void</span>)uc;    <span class="hljs-keyword">if</span>(xc_trace_notifier &gt;= <span class="hljs-number">0</span>)    &#123;        data = <span class="hljs-number">1</span>;        <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">write</span>(xc_trace_notifier, &amp;data, <span class="hljs-built_in">sizeof</span>(data)));    &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">xc_trace_dumper</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><span class="hljs-function"></span>&#123;    JNIEnv         *env = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">uint64_t</span>        data;    <span class="hljs-type">uint64_t</span>        trace_time;    <span class="hljs-type">int</span>             fd;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span>  tv;    <span class="hljs-type">char</span>            pathname[<span class="hljs-number">1024</span>];    jstring         j_pathname;        (<span class="hljs-type">void</span>)arg;        <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());    JavaVMAttachArgs attach_args = &#123;        .version = XC_JNI_VERSION,        .name    = <span class="hljs-string">&quot;xcrash_trace_dp&quot;</span>,        .group   = <span class="hljs-literal">NULL</span>    &#125;;    <span class="hljs-keyword">if</span>(JNI_OK != (*xc_common_vm)-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(xc_common_vm, &amp;env, &amp;attach_args)) <span class="hljs-keyword">goto</span> exit;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        <span class="hljs-comment">//block here, waiting for sigquit</span>        <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(xc_trace_notifier, &amp;data, <span class="hljs-built_in">sizeof</span>(data)));        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;ANR native dumper awaken&quot;</span>);    <span class="hljs-comment">// xc_trace_dumper 线程被唤醒，说明收到了 SIGQUIT</span>        <span class="hljs-comment">//check if process already crashed</span>        <span class="hljs-keyword">if</span>(xc_common_native_crashed || xc_common_java_crashed) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//trace time</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">gettimeofday</span>(&amp;tv, <span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">break</span>;        trace_time = (<span class="hljs-type">uint64_t</span>)(tv.tv_sec) * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> + (<span class="hljs-type">uint64_t</span>)tv.tv_usec;        <span class="hljs-comment">//Keep only one current trace.</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_logs_clean</span>()) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//create and open log file</span>        <span class="hljs-keyword">if</span>((fd = <span class="hljs-built_in">xc_common_open_trace_log</span>(pathname, <span class="hljs-built_in">sizeof</span>(pathname), trace_time)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//write header info</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_write_header</span>(fd, trace_time)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-comment">//write trace info from ART runtime</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_format</span>(fd, XCC_UTIL_THREAD_SEP<span class="hljs-string">&quot;Cmd line: %s\n&quot;</span>, xc_common_process_name)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Mode: ART DumpForSigQuit\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_load_symbols</span>())        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to load symbols.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;            <span class="hljs-keyword">goto</span> skip;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_check_address_valid</span>())        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to check runtime address.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;            <span class="hljs-keyword">goto</span> skip;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dup2</span>(fd, STDERR_FILENO) &lt; <span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to duplicate FD.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;            <span class="hljs-keyword">goto</span> skip;        &#125;        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;read header from %s&quot;</span>, pathname);    <span class="hljs-comment">// 首先写入 header，这里从日志文件里打印出来</span>        <span class="hljs-built_in">print_file</span>(pathname);        xc_trace_dump_status = XC_TRACE_DUMP_ON_GOING;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sigsetjmp</span>(jmpenv, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)         &#123;            <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)                <span class="hljs-built_in">xc_trace_libart_dbg_suspend</span>();            <span class="hljs-comment">// 利用 Runtime::DumpForSigQuit 打印调用栈</span>            <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;before dump&quot;</span>);            <span class="hljs-built_in">xc_trace_libart_runtime_dump</span>(*xc_trace_libart_runtime_instance, xc_trace_libcpp_cerr);                <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;after dump, print log file&quot;</span>);            <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)                <span class="hljs-built_in">xc_trace_libart_dbg_resume</span>();        &#125;         <span class="hljs-keyword">else</span>         &#123;            <span class="hljs-built_in">fflush</span>(<span class="hljs-literal">NULL</span>);            <span class="hljs-built_in">XCD_LOG_WARN</span>(<span class="hljs-string">&quot;longjmp to skip dumping trace\n&quot;</span>);        &#125;        <span class="hljs-built_in">dup2</span>(xc_common_fd_null, STDERR_FILENO);                                skip:        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;\n&quot;</span>XCC_UTIL_THREAD_END<span class="hljs-string">&quot;\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-comment">//write other info</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_logcat</span>(fd, xc_common_process_id, xc_common_api_level, xc_trace_logcat_system_lines, xc_trace_logcat_events_lines, xc_trace_logcat_main_lines)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;logcat added&quot;</span>);    <span class="hljs-comment">// 收集 logcat 日志</span>        <span class="hljs-keyword">if</span>(xc_trace_dump_fds)            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_fds</span>(fd, xc_common_process_id)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(xc_trace_dump_network_info)            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_network_info</span>(fd, xc_common_process_id, xc_common_api_level)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_meminfo_record</span>(fd, xc_common_process_id)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;meminfo added&quot;</span>);    <span class="hljs-comment">// 收集内存相关信息</span>    end:        <span class="hljs-comment">//close log file</span>        <span class="hljs-built_in">xc_common_close_trace_log</span>(fd);        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;close log fd&quot;</span>);    <span class="hljs-comment">// 日志文件写入完毕</span>        <span class="hljs-comment">//rethrow SIGQUIT to ART Signal Catcher</span>        <span class="hljs-keyword">if</span>(xc_trace_rethrow &amp;&amp; (XC_TRACE_DUMP_ART_CRASH != xc_trace_dump_status)) <span class="hljs-built_in">xc_trace_send_sigquit</span>();        xc_trace_dump_status = XC_TRACE_DUMP_END;        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;rethrow SIGQUIT&quot;</span>);    <span class="hljs-comment">// 重新抛出 SIGQUIT，不中断系统的 ANR 流程</span>        <span class="hljs-comment">//JNI callback</span>        <span class="hljs-comment">//Do we need to implement an emergency buffer for disk exhausted?</span>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == xc_trace_cb_method) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (j_pathname = (*env)-&gt;<span class="hljs-built_in">NewStringUTF</span>(env, pathname))) <span class="hljs-keyword">continue</span>;        (*env)-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(env, xc_common_cb_class, xc_trace_cb_method, j_pathname, <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;JNI callback %s&quot;</span>, pathname);    <span class="hljs-comment">// 执行 NativeHandler.traceCallback</span>        <span class="hljs-built_in">XC_JNI_IGNORE_PENDING_EXCEPTION</span>();        (*env)-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(env, j_pathname);    &#125;        (*xc_common_vm)-&gt;<span class="hljs-built_in">DetachCurrentThread</span>(xc_common_vm); exit:    xc_trace_notifier = <span class="hljs-number">-1</span>;    <span class="hljs-built_in">close</span>(xc_trace_notifier);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceCallback</span><span class="hljs-params">(String logPath, String emergency)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xcrash_dumper&quot;</span>;        Log.d(tag, String.format(<span class="hljs-string">&quot;traceCallback %s %s&quot;</span>, emergency, logPath));    <span class="hljs-comment">// 记录 callback 调用</span>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(logPath)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//append memory info</span>        TombstoneManager.appendSection(logPath, <span class="hljs-string">&quot;memory info&quot;</span>, Util.getProcessMemoryInfo());        Log.d(tag, <span class="hljs-string">&quot;memory info appended&quot;</span>);    <span class="hljs-comment">// 添加额外信息</span>        <span class="hljs-comment">//append background / foreground</span>        TombstoneManager.appendSection(logPath, <span class="hljs-string">&quot;foreground&quot;</span>, ActivityMonitor.getInstance().isApplicationForeground() ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>);        Log.d(tag, <span class="hljs-string">&quot;background / foreground appended&quot;</span>);    <span class="hljs-comment">// 添加额外信息</span>        <span class="hljs-comment">//check process ANR state</span>        <span class="hljs-comment">// 一段时间内轮询 ActivityManager.getProcessesInErrorState 是否为 ProcessErrorStateInfo#NOT_RESPONDING 来判断当前 APP 是否发生 ANR</span>        <span class="hljs-keyword">if</span> (NativeHandler.getInstance().anrCheckProcessState) &#123;            <span class="hljs-keyword">if</span> (!Util.checkProcessAnrState(NativeHandler.getInstance().ctx, NativeHandler.getInstance().anrTimeoutMs)) &#123;                FileManager.getInstance().recycleLogFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logPath));                Log.d(tag, <span class="hljs-string">&quot;not an ANR&quot;</span>);                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">//not an ANR</span>            &#125;        &#125;        <span class="hljs-comment">//delete extra ANR log files</span>        <span class="hljs-keyword">if</span> (!FileManager.getInstance().maintainAnr()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//rename trace log file to ANR log file</span>        <span class="hljs-type">String</span> <span class="hljs-variable">anrLogPath</span> <span class="hljs-operator">=</span> logPath.substring(<span class="hljs-number">0</span>, logPath.length() - Util.traceLogSuffix.length()) + Util.anrLogSuffix;        <span class="hljs-type">File</span> <span class="hljs-variable">traceFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logPath);        <span class="hljs-type">File</span> <span class="hljs-variable">anrFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(anrLogPath);        <span class="hljs-keyword">if</span> (!traceFile.renameTo(anrFile)) &#123;            FileManager.getInstance().recycleLogFile(traceFile);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// trace.xcrash 和 anr.xcrash 的流程是一样的，通过上面的检查逻辑判断是否为 anr，是的话将后缀改为 anr.xcrash</span>        Log.d(tag, String.format(<span class="hljs-string">&quot;%s rename to %s&quot;</span>, logPath, anrLogPath));            <span class="hljs-type">ICrashCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> NativeHandler.getInstance().anrCallback;        <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                callback.onCrash(anrLogPath, emergency);                Log.d(tag, <span class="hljs-string">&quot;anr callback invoked&quot;</span>);    <span class="hljs-comment">// 执行用户自定义的回调</span>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                Log.e(tag, e.getMessage(), e);                XCrash.getLogger().w(Util.TAG, <span class="hljs-string">&quot;NativeHandler ANR callback.onCrash failed&quot;</span>, e);            &#125;        &#125;    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkProcessAnrState</span><span class="hljs-params">(Context ctx, <span class="hljs-type">long</span> timeoutMs)</span> &#123;        <span class="hljs-type">ActivityManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE);        <span class="hljs-keyword">if</span> (am == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> android.os.Process.myPid();        <span class="hljs-type">long</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> timeoutMs / <span class="hljs-number">500</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poll; i++) &#123;            List&lt;ActivityManager.ProcessErrorStateInfo&gt; processErrorList = am.getProcessesInErrorState();            <span class="hljs-keyword">if</span> (processErrorList != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">for</span> (ActivityManager.ProcessErrorStateInfo errorStateInfo : processErrorList) &#123;                    <span class="hljs-keyword">if</span> (errorStateInfo.pid == pid) &#123;                        <span class="hljs-comment">// 轮询检查当前进程是否处于 NOT_RESPONDING 状态，这个轮询时间很关键</span>                        Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, String.format(<span class="hljs-string">&quot;process state: %s&quot;</span>, errorStateInfo.condition));                        &#125;                    <span class="hljs-keyword">if</span> (errorStateInfo.pid == pid &amp;&amp; errorStateInfo.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    &#125;</code></pre></div><h1 id="PIXEL-4-Android-12"><a href="#PIXEL-4-Android-12" class="headerlink" title="PIXEL 4 - Android 12"></a>PIXEL 4 - Android 12</h1><p>主线程阻塞 20s 后进入 ANR 处理流程，收到 SIGQUIT，0.5s 后完成 ANR 日志重启抛出 SIGQUIT，4s 后 APP 进入 NOT_RESPONDING 状态</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 11:27:26.760  3215  3215 D xcrash_dumper: xcrash start11-25 11:27:26.770  3215  3215 D xcrash_dumper: xcrash native start11-25 11:27:26.771  3215  3215 D xcrash_dumper: ANR native start11-25 11:27:26.771  3215  3215 D xcrash_dumper: ANR native register SIGQUIT11-25 11:27:26.772  3215  3215 D xcrash_dumper: xcrash native end11-25 11:27:29.775  3215  3215 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-25 11:27:29.779  3215  3215 D xcrash_dumper: AnrService was started11-25 11:27:29.781  3215  3215 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 11:27:50.178  3215  3215 D xcrash_dumper: SIGQUIT handler get 3, 23511-25 11:27:50.178  3215  4153 D xcrash_dumper: ANR native dumper awaken11-25 11:27:50.205  3215  4153 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:27:50.205  3215  4153 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 11:27:50.205  3215  4153 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Start time: &#x27;2021-11-25T11:27:26.770+0800&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Crash time: &#x27;2021-11-25T11:27:50.178+0800&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: API level: &#x27;30&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: OS version: &#x27;11&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Kernel version: &#x27;Linux version 4.14.204-g074de30eab1a-ab7083077 #1 SMP PREEMPT Thu Jan 14 21:14:19 UTC 2021 (armv8l)&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Manufacturer: &#x27;Google&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Brand: &#x27;google&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Model: &#x27;Pixel 4&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: Build fingerprint: &#x27;google/flame/flame:S/SPP1.210122.020.A3/7145137:user/release-keys&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 11:27:50.205  3215  4153 D xcrash_dumper: pid: 3215  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 11:27:50.205  3215  4153 D xcrash_dumper:11-25 11:27:50.205  3215  4153 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 11:27:50.205  3215  4153 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 11:27:50.205  3215  4153 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 11:27:50.205  3215  4153 D xcrash_dumper: before dump11-25 11:27:50.563  3215  4153 D xcrash_dumper: after dump, print log file11-25 11:27:50.630  3215  4153 D xcrash_dumper: logcat added11-25 11:27:50.683  3215  4153 D xcrash_dumper: meminfo added11-25 11:27:50.683  3215  4153 D xcrash_dumper: close log fd11-25 11:27:50.684  3215  4153 D xcrash_dumper: rethrow SIGQUIT11-25 11:27:50.684  3215  4153 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:27:50.849  3215  4153 D xcrash_dumper: memory info appended11-25 11:27:50.849  3215  4153 D xcrash_dumper: background / foreground appended11-25 11:27:54.360  3215  4153 D xcrash_dumper: process state: 211-25 11:27:54.361  3215  4153 D xcrash_dumper: delete anr log file until 1011-25 11:27:54.362  3215  4153 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:27:54.362  3215  4153 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:27:54.362  3215  4153 D xcrash_dumper: anr callback invoked11-25 11:27:54.362  3215  4153 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:27:59.784  3215  3215 D xcrash_dumper: AnrService, now 1637810879, found anr logs, tombstone_00001637810870178747_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash</code></pre></div><h1 id="PIXEL-5-Android-11"><a href="#PIXEL-5-Android-11" class="headerlink" title="PIXEL 5 - Android 11"></a>PIXEL 5 - Android 11</h1><p>主线程阻塞 12s 后进入 ANR 处理流程，收到 SIGQUIT，0.5s 后完成 ANR 日志重启抛出 SIGQUIT，6s 后 APP 进入 NOT_RESPONDING 状态</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 15:43:01.820  2668  2668 D xcrash_dumper: xcrash start11-25 15:43:01.844  2668  2668 D xcrash_dumper: xcrash native start11-25 15:43:01.845  2668  2668 D xcrash_dumper: ANR native start11-25 15:43:01.845  2668  2668 D xcrash_dumper: ANR native register SIGQUIT11-25 15:43:01.846  2668  2668 D xcrash_dumper: xcrash native end11-25 15:43:04.849  2668  2668 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-25 15:43:04.852  2668  2668 D xcrash_dumper: AnrService was started11-25 15:43:04.857  2668  2668 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 15:43:16.061  2668  2668 D xcrash_dumper: SIGQUIT handler get 3, 16811-25 15:43:16.061  2668  3318 D xcrash_dumper: ANR native dumper awaken11-25 15:43:16.079  2668  3318 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 15:43:16.079  2668  3318 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 15:43:16.079  2668  3318 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Start time: &#x27;2021-11-25T15:43:01.844+0800&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Crash time: &#x27;2021-11-25T15:43:16.061+0800&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: API level: &#x27;30&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: OS version: &#x27;11&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Kernel version: &#x27;Linux version 4.19.110-g9ceb3bf92e0a-ab6790968 #2 SMP PREEMPT Wed Aug 26 04:14:37 UTC 2020 (armv8l)&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Manufacturer: &#x27;Google&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Brand: &#x27;google&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Model: &#x27;Pixel 5&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: Build fingerprint: &#x27;google/redfin/redfin:11/RD1A.200810.022.A4/6835977:user/release-keys&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 15:43:16.079  2668  3318 D xcrash_dumper: pid: 2668  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 15:43:16.079  2668  3318 D xcrash_dumper:11-25 15:43:16.079  2668  3318 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 15:43:16.079  2668  3318 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 15:43:16.079  2668  3318 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 15:43:16.079  2668  3318 D xcrash_dumper: before dump11-25 15:43:16.372  2668  3318 D xcrash_dumper: after dump, print log file11-25 15:43:16.470  2668  3318 D xcrash_dumper: logcat added11-25 15:43:16.519  2668  3318 D xcrash_dumper: meminfo added11-25 15:43:16.519  2668  3318 D xcrash_dumper: close log fd11-25 15:43:16.519  2668  3318 D xcrash_dumper: rethrow SIGQUIT11-25 15:43:16.519  2668  3318 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 15:43:16.687  2668  3318 D xcrash_dumper: memory info appended11-25 15:43:16.688  2668  3318 D xcrash_dumper: background / foreground appended11-25 15:43:22.715  2668  3318 D xcrash_dumper: process state: 211-25 15:43:22.716  2668  3318 D xcrash_dumper: delete anr log file until 1011-25 15:43:22.716  2668  3318 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 15:43:22.716  2668  3318 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 15:43:22.717  2668  3318 D xcrash_dumper: anr callback invoked11-25 15:43:22.717  2668  3318 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 15:43:34.860  2668  2668 D xcrash_dumper: AnrService, now 1637826214, found anr logs, tombstone_00001637826196061961_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash</code></pre></div><h1 id="MI-10-Android-10"><a href="#MI-10-Android-10" class="headerlink" title="MI 10 - Android 10"></a>MI 10 - Android 10</h1><p>主线程阻塞 20s 后进入 ANR 处理流程，收到 SIGQUIT，0.5s 后完成 ANR 日志重启抛出 SIGQUIT，5s 后 APP 进入 NOT_RESPONDING 状态</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 11:30:52.898  8554  8554 D xcrash_dumper: xcrash start11-25 11:30:52.906  8554  8554 D xcrash_dumper: xcrash native start11-25 11:30:52.907  8554  8554 D xcrash_dumper: ANR native start11-25 11:30:52.907  8554  8554 D xcrash_dumper: ANR native register SIGQUIT11-25 11:30:52.907  8554  8554 D xcrash_dumper: xcrash native end11-25 11:30:55.910  8554  8554 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-25 11:30:55.915  8554  8554 D xcrash_dumper: AnrService was started11-25 11:30:55.918  8554  8554 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 11:31:16.430  8554  8554 D xcrash_dumper: SIGQUIT handler get 3, 15111-25 11:31:16.430  8554  8867 D xcrash_dumper: ANR native dumper awaken11-25 11:31:16.449  8554  8867 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:31:16.449  8554  8867 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 11:31:16.449  8554  8867 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Start time: &#x27;2021-11-25T11:30:52.906+0800&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Crash time: &#x27;2021-11-25T11:31:16.430+0800&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: API level: &#x27;29&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: OS version: &#x27;10&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Kernel version: &#x27;Linux version 4.19.81-perf-g453ac5d #1 SMP PREEMPT Tue May 19 03:00:27 CST 2020 (armv8l)&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Manufacturer: &#x27;Xiaomi&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Brand: &#x27;Xiaomi&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Model: &#x27;Mi 10&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: Build fingerprint: &#x27;Xiaomi/umi/umi:10/QKQ1.191117.002/V11.0.25.0.QJBCNXM:user/release-keys&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 11:31:16.449  8554  8867 D xcrash_dumper: pid: 8554  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 11:31:16.449  8554  8867 D xcrash_dumper:11-25 11:31:16.449  8554  8867 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 11:31:16.449  8554  8867 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 11:31:16.449  8554  8867 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 11:31:16.449  8554  8867 D xcrash_dumper: before dump11-25 11:31:16.624  8554  8867 D xcrash_dumper: after dump, print log file11-25 11:31:16.758  8554  8867 D xcrash_dumper: logcat added11-25 11:31:16.804  8554  8867 D xcrash_dumper: meminfo added11-25 11:31:16.804  8554  8867 D xcrash_dumper: close log fd11-25 11:31:16.804  8554  8867 D xcrash_dumper: rethrow SIGQUIT11-25 11:31:16.804  8554  8867 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:31:16.923  8554  8867 D xcrash_dumper: memory info appended11-25 11:31:16.923  8554  8867 D xcrash_dumper: background / foreground appended11-25 11:31:21.932  8554  8867 D xcrash_dumper: process state: 211-25 11:31:21.932  8554  8867 D xcrash_dumper: delete anr log file until 1011-25 11:31:21.933  8554  8867 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:31:21.933  8554  8867 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:31:21.933  8554  8867 D xcrash_dumper: anr callback invoked11-25 11:31:21.933  8554  8867 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:31:25.920  8554  8554 D xcrash_dumper: AnrService, now 1637811085, found anr logs, tombstone_00001637811076430808_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash</code></pre></div><h1 id="HUAWEI-Mate-30-Android-10"><a href="#HUAWEI-Mate-30-Android-10" class="headerlink" title="HUAWEI Mate 30 - Android 10"></a>HUAWEI Mate 30 - Android 10</h1><p>主线程阻塞 20s 后进入 ANR 处理流程，收到 SIGQUIT，0.7s 后完成 ANR 日志重启抛出 SIGQUIT，0.8s 后 APP 进入 NOT_RESPONDING 状态</p><div class="code-wrapper"><pre><code class="hljs logcat">11-29 16:01:45.634 22368 22368 D xcrash_dumper: xcrash start11-29 16:01:45.657 22368 22368 D xcrash_dumper: xcrash native start11-29 16:01:45.658 22368 22368 D xcrash_dumper: ANR native start11-29 16:01:45.658 22368 22368 D xcrash_dumper: ANR native register SIGQUIT11-29 16:01:45.658 22368 22368 D xcrash_dumper: xcrash native end11-29 16:01:48.660 22368 22368 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-29 16:01:48.667 22368 22368 D xcrash_dumper: AnrService was started11-29 16:01:48.674 22368 22368 D xcrash_dumper: AnrService, delete 1 anr logs before anr11-29 16:02:09.330 22368 22368 D xcrash_dumper: SIGQUIT handler get 3, 25911-29 16:02:09.330 22368 22783 D xcrash_dumper: ANR native dumper awaken11-29 16:02:09.404 22368 22783 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-29 16:02:09.404 22368 22783 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-29 16:02:09.404 22368 22783 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Start time: &#x27;2021-11-29T16:01:45.658+0800&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Crash time: &#x27;2021-11-29T16:02:09.330+0800&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Rooted: &#x27;No&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: API level: &#x27;29&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: OS version: &#x27;10&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Kernel version: &#x27;Linux version 4.14.116 #1 SMP PREEMPT Mon Sep 27 15:35:43 CST 2021 (armv8l)&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Manufacturer: &#x27;HUAWEI&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Brand: &#x27;HUAWEI&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Model: &#x27;TAS-AL00&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: Build fingerprint: &#x27;HUAWEI/TAS-AL00/HWTAS:10/HUAWEITAS-AL00/102.0.0.209C00:user/release-keys&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: ABI: &#x27;arm&#x27;11-29 16:02:09.404 22368 22783 D xcrash_dumper: pid: 22368  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-29 16:02:09.404 22368 22783 D xcrash_dumper:11-29 16:02:09.404 22368 22783 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-29 16:02:09.404 22368 22783 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-29 16:02:09.404 22368 22783 D xcrash_dumper: Mode: ART DumpForSigQuit11-29 16:02:09.404 22368 22783 D xcrash_dumper: before dump11-29 16:02:09.766 22368 22783 D xcrash_dumper: after dump, print log file11-29 16:02:09.882 22368 22783 D xcrash_dumper: logcat added11-29 16:02:10.002 22368 22783 D xcrash_dumper: meminfo added11-29 16:02:10.002 22368 22783 D xcrash_dumper: close log fd11-29 16:02:10.002 22368 22783 D xcrash_dumper: rethrow SIGQUIT11-29 16:02:10.003 22368 22783 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-29 16:02:10.232 22368 22783 D xcrash_dumper: memory info appended11-29 16:02:10.232 22368 22783 D xcrash_dumper: background / foreground appended11-29 16:02:10.735 22368 22783 D xcrash_dumper: process state: 211-29 16:02:10.735 22368 22783 D xcrash_dumper: delete anr log file until 1011-29 16:02:10.736 22368 22783 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-29 16:02:10.736 22368 22783 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-29 16:02:10.736 22368 22783 D xcrash_dumper: anr callback invoked11-29 16:02:10.736 22368 22783 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-29 16:02:18.678 22368 22368 D xcrash_dumper: AnrService, now 1638172938, found anr logs, tombstone_00001638172929330558_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash</code></pre></div><h1 id="Redmi-K20-Android-9"><a href="#Redmi-K20-Android-9" class="headerlink" title="Redmi K20 - Android 9"></a>Redmi K20 - Android 9</h1><p>主线程阻塞 20s 后进入 ANR 处理流程，收到 SIGQUIT，0.5s 后完成 ANR 日志重启抛出 SIGQUIT，4s 后 APP 进入 NOT_RESPONDING 状态</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 11:30:24.925 10449 10449 D xcrash_dumper: xcrash start11-25 11:30:24.936 10449 10449 D xcrash_dumper: xcrash native start11-25 11:30:24.938 10449 10449 D xcrash_dumper: ANR native start11-25 11:30:24.939 10449 10449 D xcrash_dumper: ANR native register SIGQUIT11-25 11:30:24.939 10449 10449 D xcrash_dumper: xcrash native end11-25 11:30:27.942 10449 10449 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-25 11:30:27.946 10449 10449 D xcrash_dumper: AnrService was started11-25 11:30:27.949 10449 10449 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 11:30:48.467 10449 10449 D xcrash_dumper: SIGQUIT handler get 3, 15911-25 11:30:48.467 10449 10750 D xcrash_dumper: ANR native dumper awaken11-25 11:30:48.500 10449 10750 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:30:48.500 10449 10750 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 11:30:48.500 10449 10750 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Start time: &#x27;2021-11-25T11:30:24.937+0800&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Crash time: &#x27;2021-11-25T11:30:48.467+0800&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: API level: &#x27;28&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: OS version: &#x27;9&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Kernel version: &#x27;Linux version 4.14.83-perf+ #1 SMP PREEMPT Thu Sep 26 12:23:20 CST 2019 (armv8l)&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Manufacturer: &#x27;Xiaomi&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Brand: &#x27;Xiaomi&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Model: &#x27;Redmi K20&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: Build fingerprint: &#x27;Xiaomi/davinci/davinci:9/PKQ1.190302.001/V11.0.3.0.PFJCNXM:user/release-keys&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 11:30:48.500 10449 10750 D xcrash_dumper: pid: 10449  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 11:30:48.500 10449 10750 D xcrash_dumper:11-25 11:30:48.500 10449 10750 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 11:30:48.500 10449 10750 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 11:30:48.500 10449 10750 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 11:30:48.500 10449 10750 D xcrash_dumper: before dump11-25 11:30:48.658 10449 10750 D xcrash_dumper: after dump, print log file11-25 11:30:48.975 10449 10750 D xcrash_dumper: logcat added11-25 11:30:49.063 10449 10750 D xcrash_dumper: meminfo added11-25 11:30:49.063 10449 10750 D xcrash_dumper: close log fd11-25 11:30:49.065 10449 10750 D xcrash_dumper: rethrow SIGQUIT11-25 11:30:49.066 10449 10750 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:30:49.179 10449 10750 D xcrash_dumper: memory info appended11-25 11:30:49.184 10449 10750 D xcrash_dumper: background / foreground appended11-25 11:30:52.699 10449 10750 D xcrash_dumper: process state: 211-25 11:30:52.700 10449 10750 D xcrash_dumper: delete anr log file until 1011-25 11:30:52.701 10449 10750 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:30:52.701 10449 10750 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:30:52.701 10449 10750 D xcrash_dumper: anr callback invoked11-25 11:30:52.701 10449 10750 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:30:57.953 10449 10449 D xcrash_dumper: AnrService, now 1637811057, found anr logs, tombstone_00001637811048467666_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash</code></pre></div><h1 id="HUAWEI-P20-Pro-Android-8-1-0"><a href="#HUAWEI-P20-Pro-Android-8-1-0" class="headerlink" title="HUAWEI P20 Pro - Android 8.1.0"></a>HUAWEI P20 Pro - Android 8.1.0</h1><p>主线程阻塞 10s 后进入 ANR 处理流程，收到 SIGQUIT，0.5s 后完成 ANR 日志重启抛出 SIGQUIT，2s 后 APP 进入 NOT_RESPONDING 状态</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 11:32:17.213 23690 23690 D xcrash_dumper: xcrash start11-25 11:32:17.222 23690 23690 D xcrash_dumper: xcrash native start11-25 11:32:17.223 23690 23690 D xcrash_dumper: ANR native start11-25 11:32:17.223 23690 23690 D xcrash_dumper: ANR native register SIGQUIT11-25 11:32:17.223 23690 23690 D xcrash_dumper: xcrash native end11-25 11:32:20.226 23690 23690 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-25 11:32:20.233 23690 23690 D xcrash_dumper: AnrService was started11-25 11:32:20.238 23690 23690 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 11:32:30.826 23690 23690 D xcrash_dumper: SIGQUIT handler get 3, 16511-25 11:32:30.826 23690 23972 D xcrash_dumper: ANR native dumper awaken11-25 11:32:30.856 23690 23972 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811150826614_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:32:30.856 23690 23972 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 11:32:30.856 23690 23972 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Start time: &#x27;2021-11-25T11:32:17.222+0800&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Crash time: &#x27;2021-11-25T11:32:30.826+0800&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: API level: &#x27;27&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: OS version: &#x27;8.1.0&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Kernel version: &#x27;Linux version 4.4.103+ #1 SMP PREEMPT Sun Jul 8 16:11:30 CST 2018 (armv7l)&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Manufacturer: &#x27;HUAWEI&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Brand: &#x27;HUAWEI&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Model: &#x27;CLT-L29&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: Build fingerprint: &#x27;HUAWEI/CLT-L29/HWCLT:8.1.0/HUAWEICLT-L29/152(C432):user/release-keys&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 11:32:30.856 23690 23972 D xcrash_dumper: pid: 23690  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 11:32:30.856 23690 23972 D xcrash_dumper:11-25 11:32:30.856 23690 23972 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 11:32:30.856 23690 23972 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 11:32:30.856 23690 23972 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 11:32:30.856 23690 23972 D xcrash_dumper: before dump11-25 11:32:31.013 23690 23972 D xcrash_dumper: after dump, print log file11-25 11:32:31.187 23690 23972 D xcrash_dumper: logcat added11-25 11:32:31.311 23690 23972 D xcrash_dumper: meminfo added11-25 11:32:31.311 23690 23972 D xcrash_dumper: close log fd11-25 11:32:31.311 23690 23972 D xcrash_dumper: rethrow SIGQUIT11-25 11:32:31.316 23690 23972 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811150826614_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:32:31.474 23690 23972 D xcrash_dumper: memory info appended11-25 11:32:31.475 23690 23972 D xcrash_dumper: background / foreground appended11-25 11:32:33.487 23690 23972 D xcrash_dumper: process state: 211-25 11:32:33.488 23690 23972 D xcrash_dumper: delete anr log file until 1011-25 11:32:33.491 23690 23972 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811150826614_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811150826614_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:32:33.491 23690 23972 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811150826614_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 11:32:33.491 23690 23972 D xcrash_dumper: anr callback invoked11-25 11:32:33.491 23690 23972 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811150826614_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash</code></pre></div><h1 id="vivo-X9-Plus-Android-7-1-2"><a href="#vivo-X9-Plus-Android-7-1-2" class="headerlink" title="vivo X9 Plus - Android 7.1.2"></a>vivo X9 Plus - Android 7.1.2</h1><p>AnrService 运行 30s 未返回并没有触发 ANR，而后通过手动点击阻塞主线程 60s 才触发 ANR</p><p>没有继续深入测试触发 ANR 的阈值，总之 SIGQUIT 处理器还是能捕获到 ANR 的，从收到 SIGQUIT 到写入调用栈重新抛出 SIGQUIT 用时 0.8s，0.3s 后进入 ANR 状态</p><p>系统的 ANR 处理流程还会将日志写入到 /data/anr/traces.txt</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 16:38:01.561 12462 12462 D xcrash_dumper: xcrash start11-25 16:38:01.574 12462 12462 D xcrash_dumper: xcrash native start11-25 16:38:01.576 12462 12462 D xcrash_dumper: ANR native start11-25 16:38:01.576 12462 12462 D xcrash_dumper: ANR native register SIGQUIT11-25 16:38:01.576 12462 12462 D xcrash_dumper: xcrash native end11-25 16:38:04.584 12462 12462 D xcrash_dumper: NativeHandler.anrTimeoutMs = 20s11-25 16:38:04.598 12462 12462 D xcrash_dumper: AnrService was started11-25 16:38:04.608 12462 12462 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 16:38:34.620 12462 12462 D xcrash_dumper: AnrService, now 1637829514, found anr logs, 11-25 16:41:10.125 12462 12462 D xcrash_dumper: SIGQUIT handler get 3, 14311-25 16:41:10.125 12462 12741 D xcrash_dumper: ANR native dumper awaken11-25 16:41:10.296 12462 12741 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637829670125799_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 16:41:10.296 12462 12741 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 16:41:10.296 12462 12741 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Start time: &#x27;2021-11-25T16:38:01.575+0800&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Crash time: &#x27;2021-11-25T16:41:10.125+0800&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: API level: &#x27;25&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: OS version: &#x27;7.1.2&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Kernel version: &#x27;Linux version 3.10.84-perf-g955b276c #1 SMP PREEMPT Thu Dec 10 17:42:47 CST 2020 (armv8l)&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Manufacturer: &#x27;vivo&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Brand: &#x27;vivo&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Model: &#x27;vivo X9Plus&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: Build fingerprint: &#x27;vivo/PD1619/PD1619:7.1.2/N2G47H/compil12101707:user/release-keys&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 16:41:10.296 12462 12741 D xcrash_dumper: pid: 12462  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 16:41:10.296 12462 12741 D xcrash_dumper: 11-25 16:41:10.296 12462 12741 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 16:41:10.296 12462 12741 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 16:41:10.296 12462 12741 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 16:41:10.296 12462 12741 D xcrash_dumper: before dump11-25 16:41:10.581 12462 12741 D xcrash_dumper: after dump, print log file11-25 16:41:10.700 12462 12741 D xcrash_dumper: logcat added11-25 16:41:10.851 12462 12741 D xcrash_dumper: meminfo added11-25 16:41:10.851 12462 12741 D xcrash_dumper: close log fd11-25 16:41:10.851 12462 12741 D xcrash_dumper: rethrow SIGQUIT11-25 16:41:10.851 12462 12468 I art     : Thread[3,tid=12468,WaitingInMainSignalCatcherLoop,Thread*=0xdcd2b000,peer=0x12c13d30,&quot;Signal Catcher&quot;]: reacting to signal 311-25 16:41:10.851 12462 12468 I art     : 11-25 16:41:11.132 12462 12468 I art     : Wrote stack traces to &#x27;/data/anr/traces.txt&#x27;11-25 16:41:11.133  3743  3778 E ActivityManager: ANR in com.viomi.fridge.vertical11-25 16:41:11.133  3743  3778 E ActivityManager: PID: 1246211-25 16:41:11.133  3743  3778 E ActivityManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x58000014 (has extras) &#125;11-25 16:41:11.137 12462 12741 D xcrash_dumper: memory info appended11-25 16:41:11.143 12462 12741 D xcrash_dumper: background / foreground appended11-25 16:41:11.145 12462 12741 D xcrash_dumper: process state: 211-25 16:41:11.146 12462 12741 D xcrash_dumper: delete anr log file until 1011-25 16:41:11.147 12462 12741 D xcrash_dumper: /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637829670125799_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash rename to /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637829670125799_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 16:41:11.147 12462 12741 D xcrash_dumper: ANR Callback, null, /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637829670125799_2.1.2.11.17__com.viomi.fridge.vertical.anr.xcrash11-25 16:41:11.147 12462 12741 D xcrash_dumper: anr callback invoked11-25 16:41:11.147 12462 12741 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637829670125799_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash</code></pre></div><h1 id="Galaxy-S7-edge-Android-6-0-1"><a href="#Galaxy-S7-edge-Android-6-0-1" class="headerlink" title="Galaxy S7 edge - Android 6.0.1"></a>Galaxy S7 edge - Android 6.0.1</h1><p>从下面的日志可以看到 AnrService 运行 30s 未返回的确触发了 ANR 并收到了 SIGQUIT（具体是用时 22s 触发 ANR），但是输出日志文件用时 14s 太长了（Runtime::DumpForSigQuit 用了 14s），当重新抛出 SIGQUIT 时 AnrService 已返回，主线程随即恢复运行，我猜测此时 APP 就不再处于 NOT_RESPONDING 状态，也就无法判别 APP 发生了 ANR</p><p>HUAWEI Mate 30 时也出现过不能判别 ANR 的情况，当时是弹出通知权限的设置页，导致 APP 进入到后台（后台 ANR）</p><p>系统 ANR 流程会输出 /data/anr/traces.txt，从 Signal Catcher 线程收到 SIGQUIT 到输出日志文件耗时 6s</p><div class="code-wrapper"><pre><code class="hljs logcat">11-25 11:31:44.883 17149 17149 D xcrash_dumper: xcrash start11-25 11:31:44.913 17149 17149 D xcrash_dumper: xcrash native start11-25 11:31:44.913 17149 17149 D xcrash_dumper: ANR native start11-25 11:31:44.913 17149 17149 D xcrash_dumper: ANR native register SIGQUIT11-25 11:31:44.923 17149 17149 D xcrash_dumper: xcrash native end11-25 11:31:47.923 17149 17149 D xcrash_dumper: NativeHandler.anrTimeoutMs = 60s11-25 11:31:47.933 17149 17149 D xcrash_dumper: AnrService was started11-25 11:31:47.933 17149 17149 D xcrash_dumper: AnrService, delete 0 anr logs before anr11-25 11:32:10.173 17149 17149 D xcrash_dumper: SIGQUIT handler get 3, 15011-25 11:32:10.173 17149 17447 D xcrash_dumper: ANR native dumper awaken11-25 11:32:10.543 17149 17447 D xcrash_dumper: read header from /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811130176482_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:32:10.543 17149 17447 D xcrash_dumper: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***11-25 11:32:10.543 17149 17447 D xcrash_dumper: Tombstone maker: &#x27;xCrash 3.0.0&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Crash type: &#x27;anr&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Start time: &#x27;2021-11-25T11:31:44.917+0800&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Crash time: &#x27;2021-11-25T11:32:10.176+0800&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: App ID: &#x27;com.viomi.fridge.vertical&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: App version: &#x27;2.1.2.11.17&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Rooted: &#x27;No&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: API level: &#x27;23&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: OS version: &#x27;6.0.1&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Kernel version: &#x27;Linux version 3.18.20-9032921 #1 SMP PREEMPT Fri Dec 23 15:24:17 KST 2016 (armv8l)&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Manufacturer: &#x27;samsung&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Brand: &#x27;samsung&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Model: &#x27;SM-G9350&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: Build fingerprint: &#x27;samsung/hero2qltezc/hero2qltechn:6.0.1/MMB29M/G9350ZCU2APL3:user/release-keys&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: ABI: &#x27;arm&#x27;11-25 11:32:10.543 17149 17447 D xcrash_dumper: pid: 17149  &gt;&gt;&gt; com.viomi.fridge.vertical &lt;&lt;&lt;11-25 11:32:10.543 17149 17447 D xcrash_dumper:11-25 11:32:10.543 17149 17447 D xcrash_dumper: --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---11-25 11:32:10.543 17149 17447 D xcrash_dumper: Cmd line: com.viomi.fridge.vertical11-25 11:32:10.543 17149 17447 D xcrash_dumper: Mode: ART DumpForSigQuit11-25 11:32:10.543 17149 17447 D xcrash_dumper: before dump11-25 11:32:17.933 17149 17149 D xcrash_dumper: AnrService, now 1637811137, found anr logs,11-25 11:32:24.053 17149 17447 D xcrash_dumper: after dump, print log file11-25 11:32:24.383 17149 17447 D xcrash_dumper: logcat added11-25 11:32:24.863 17149 17447 D xcrash_dumper: meminfo added11-25 11:32:24.863 17149 17447 D xcrash_dumper: close log fd11-25 11:32:24.863 17149 17447 D xcrash_dumper: rethrow SIGQUIT11-25 11:32:24.863 17149 17153 I art     : Thread[2,tid=17153,WaitingInMainSignalCatcherLoop,Thread*=0xee096000,peer=0x12c160a0,&quot;Signal Catcher&quot;]: reacting to signal 311-25 11:32:24.863 17149 17447 D xcrash_dumper: traceCallback null /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811130176482_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:32:25.163 17149 17447 D xcrash_dumper: memory info appended11-25 11:32:25.183 17149 17447 D xcrash_dumper: background / foreground appended11-25 11:32:50.103 17149 17447 D xcrash_dumper: not an ANR11-25 11:32:50.103 17149 17447 D xcrash_dumper: JNI callback /data/user/0/com.viomi.fridge.vertical/files/tombstones/tombstone_00001637811130176482_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash11-25 11:32:30.233 17149 17153 I art     : Wrote stack traces to &#x27;/data/anr/traces.txt&#x27;</code></pre></div><h1 id="绿联-6810-Android-5-1"><a href="#绿联-6810-Android-5-1" class="headerlink" title="绿联 6810 - Android 5.1"></a>绿联 6810 - Android 5.1</h1><p>捕获到 <code>SIGQUIT</code> 后，会卡在 <code>Runtime::DumpForSigQuit</code> 然后不断收到 <code>SIGQUIT</code>，APP 会一直卡顿一直弹出 ANR 对话框（即使一直点击等待），APP 重启后可以发现上一次的 ANR dump 被输出到日志文件里了，但文件名还没改过来 <code>tombstone_00001637663901079557_2.1.2.11.17__com.viomi.fridge.vertical.trace.xcrash</code>，从日志来看应该是后续代码没有执行，卡在 <code>Runtime::DumpForSigQuit</code> 里了</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// is Android Lollipop (5.x)?</span>xc_trace_is_lollipop = ((<span class="hljs-number">21</span> == xc_common_api_level || <span class="hljs-number">22</span> == xc_common_api_level) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<span class="hljs-comment">// ...</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">sigsetjmp</span>(jmpenv, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)        <span class="hljs-built_in">xc_trace_libart_dbg_suspend</span>();    <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;before dump&quot;</span>);    <span class="hljs-built_in">xc_trace_libart_runtime_dump</span>(*xc_trace_libart_runtime_instance, xc_trace_libcpp_cerr);    <span class="hljs-built_in">XCD_LOG_DEBUG</span>(<span class="hljs-string">&quot;after dump, print log file&quot;</span>);    <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)        <span class="hljs-built_in">xc_trace_libart_dbg_resume</span>();&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs logcat">2021-11-23 18:20:10.580 4176-4477/com.viomi.fridge.vertical D/xcrash_dumper: before dump2021-11-23 18:20:36.784 4176-4176/com.viomi.fridge.vertical D/xcrash_dumper: SIGQUIT handler get 3, 2552021-11-23 18:21:10.108 4176-4176/com.viomi.fridge.vertical D/xcrash_dumper: SIGQUIT handler get 3, 2552021-11-23 18:21:26.920 4176-4176/com.viomi.fridge.vertical D/xcrash_dumper: SIGQUIT handler get 3, 2552021-11-23 18:22:10.100 4176-4176/com.viomi.fridge.vertical D/xcrash_dumper: SIGQUIT handler get 3, 2552021-11-23 18:22:26.634 4176-4176/com.viomi.fridge.vertical D/xcrash_dumper: SIGQUIT handler get 3, 2552021-11-23 18:23:10.109 4176-4176/com.viomi.fridge.vertical D/xcrash_dumper: SIGQUIT handler get 3, 255</code></pre></div><h1 id="NOT-RESPONDING-轮询时长的缺陷"><a href="#NOT-RESPONDING-轮询时长的缺陷" class="headerlink" title="NOT_RESPONDING 轮询时长的缺陷"></a>NOT_RESPONDING 轮询时长的缺陷</h1><p>在 <code>NativeHandler.traceCallback</code> 里会检查当前进程的状态是否为 ANR，默认是在 15s 内轮询检查进程是否处于 <code>ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceCallback</span><span class="hljs-params">(String logPath, String emergency)</span> &#123;        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(logPath)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//append memory info</span>        TombstoneManager.appendSection(logPath, <span class="hljs-string">&quot;memory info&quot;</span>, Util.getProcessMemoryInfo());        <span class="hljs-comment">//append background / foreground</span>        TombstoneManager.appendSection(logPath, <span class="hljs-string">&quot;foreground&quot;</span>, ActivityMonitor.getInstance().isApplicationForeground() ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>);        <span class="hljs-comment">//check process ANR state</span>        <span class="hljs-keyword">if</span> (NativeHandler.getInstance().anrCheckProcessState) &#123;            <span class="hljs-keyword">if</span> (!Util.checkProcessAnrState(NativeHandler.getInstance().ctx, NativeHandler.getInstance().anrTimeoutMs)) &#123;                FileManager.getInstance().recycleLogFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logPath));                <span class="hljs-keyword">return</span>; <span class="hljs-comment">//not an ANR</span>            &#125;        &#125;        <span class="hljs-comment">//delete extra ANR log files</span>        <span class="hljs-keyword">if</span> (!FileManager.getInstance().maintainAnr()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//rename trace log file to ANR log file</span>        <span class="hljs-type">String</span> <span class="hljs-variable">anrLogPath</span> <span class="hljs-operator">=</span> logPath.substring(<span class="hljs-number">0</span>, logPath.length() - Util.traceLogSuffix.length()) + Util.anrLogSuffix;        <span class="hljs-type">File</span> <span class="hljs-variable">traceFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logPath);        <span class="hljs-type">File</span> <span class="hljs-variable">anrFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(anrLogPath);        <span class="hljs-keyword">if</span> (!traceFile.renameTo(anrFile)) &#123;            FileManager.getInstance().recycleLogFile(traceFile);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">ICrashCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> NativeHandler.getInstance().anrCallback;        <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                callback.onCrash(anrLogPath, emergency);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                XCrash.getLogger().w(Util.TAG, <span class="hljs-string">&quot;NativeHandler ANR callback.onCrash failed&quot;</span>, e);            &#125;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkProcessAnrState</span><span class="hljs-params">(Context ctx, <span class="hljs-type">long</span> timeoutMs)</span> &#123;        <span class="hljs-type">ActivityManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE);        <span class="hljs-keyword">if</span> (am == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> android.os.Process.myPid();        <span class="hljs-type">long</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> timeoutMs / <span class="hljs-number">500</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poll; i++) &#123;            List&lt;ActivityManager.ProcessErrorStateInfo&gt; processErrorList = am.getProcessesInErrorState();            <span class="hljs-keyword">if</span> (processErrorList != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">for</span> (ActivityManager.ProcessErrorStateInfo errorStateInfo : processErrorList) &#123;                    <span class="hljs-keyword">if</span> (errorStateInfo.pid == pid) &#123;                        Log.d(<span class="hljs-string">&quot;xcrash_dumper&quot;</span>, String.format(<span class="hljs-string">&quot;process state: %s&quot;</span>, errorStateInfo.condition));                    &#125;                    <span class="hljs-keyword">if</span> (errorStateInfo.pid == pid &amp;&amp; errorStateInfo.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    &#125;</code></pre></div><p>但是这个轮询时长很有问题，默认 15s 在 MI 9 - Android 11 上不够长，ANR 对话框还没弹出来，此时进程并不处于 <code>ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING</code>，导致 xCrash 判定不是 ANR，然后把日志删了，我把这个时长增加到 60s 是能判定 ANR 的</p><p>还有上面的 Galaxy S7 edge - Android 6.0.1，dump 耗时太长了以至于重新抛出 <code>SIGQUIT</code> 时主线程已经从阻塞中恢复过来，这样 APP 就不会进入 <code>NOT_RESPONDING</code> 状态</p><p>可以想到有这么几个解决方案：</p><ol><li><p>增大 <code>NOT_RESPONDING</code> 轮询时长到一个足够大的值，但此时 ANR 对话框已经弹出，用户可能直接 kill app，于是以下逻辑可能会无法执行（<code>NativeHandler.traceCallback</code> <code>check process ANR state</code> 以下的代码）：</p><ol><li>清理 ANR 目录（维持最多 <code>XCrash.InitParameters.anrLogCountMax</code>）</li><li>日志文件后缀是 <code>.trace.xcrash</code> 而不是 <code>.anr.xcrash</code>，因为 anr 和 trace 的逻辑是一样的，最后通过上面的 ANR 判定逻辑来判断是不是 ANR，是的话把 <code>.trace.xcrash</code> 改名为 <code>.anr.xcrash</code></li><li>anr callback 无法执行（<code>XCrash.InitParameters.setAnrCallback</code>）</li></ol></li><li><p>关闭 ANR 检查（<code>XCrash.InitParameters.setAnrCheckProcessState</code>）    </p></li></ol><p>这个看似最简单但是不行的，因为 <code>SIGQUIT</code> 对于 APP 来说是 <code>Runtime::DumpForSigQuit</code>，那么当其他 APP 发生 ANR 时系统是通过向所有其他进程发送 <code>SIGQUIT</code> 来收集 ANR 日志的（参考 <a href="../../../../2021/07/10/deep-drive-into-anr/#SignalCatcher-amp-SIGQUIT"></a>），当然我们的 APP 也会收到，但此时并不是我们的 APP 发生了 ANR</p><p>所以检查是否当前 APP 发生了 ANR 这个校验是一定要做得，那么怎么优化第一个解决方案呢？</p><ol><li>清理操作可以放到其他地方，比如初始化后</li><li>日志默认是 <code>.anr.xcrash</code>，轮询后发现 app 并没有处于 <code>NOT_RESPONDING</code> 则把日志删掉，如果是 ANR 则足够长的轮询时长能够保证在弹出 ANR 对话框（处于 <code>NOT_RESPONDING</code>）后判定为 ANR，即使用户即刻 kill app，ANR 日志还是保留下来，判定为 ANR</li><li>anr callback 不要在 catch anr 后回调，因为此刻很有可能被 kill 而不能稳定调用，可以将 ANR 日志标为 unread，初始化后检查日志将 unread 的回调并置为 read</li></ol><h1 id="NOT-RESPONDING-机制的缺陷"><a href="#NOT-RESPONDING-机制的缺陷" class="headerlink" title="NOT_RESPONDING 机制的缺陷"></a>NOT_RESPONDING 机制的缺陷</h1><p>HUAWEI Mate 30 出现过不能判别 ANR 的情况，当时是弹出通知权限的设置页，导致 APP 进入到后台（后台 ANR）</p><p>后台 ANR 的情况下除非在【开发者选项】里打开了【显示所有“应用程序无响应”】否则 APP 是不会进入 <code>NOT_RESPONDING</code> 状态的</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://github.com/iqiyi/xCrash">xCrash ANR</a> 在 Android 7 API 24 及之后的版本上都是比较稳定的，Android 6 API 23 及之前的版本就效果比较差，可能是 ROM 的原因，也可能是机器性能太差了</p><p>利用 <code>SIGQUIT</code> 来捕获 ANR 的发生这一机制是稳定有效的</p><p>轮询 APP 是否处于 <code>NOT_RESPONDING</code> 来判别是不是当前 APP 发生了 ANR，这一手段不太可靠</p>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
      <tag>崩溃</tag>
      
      <tag>xCrash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析 Kotlin Coroutines 是如何实现的（二）</title>
    <link href="/2021/07/20/kotlin-coroutine-2/"/>
    <url>/2021/07/20/kotlin-coroutine-2/</url>
    
    <content type="html"><![CDATA[<h1 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h1><p><code>async</code> 和 <code>await</code> 是一对较为现代的 API 用以实现 **结构化并发编程 (Structured Concurrency)**，如下面代码所示，虽然 <code>runBlocking</code> 底层是单个线程，但是 <code>delay</code> 操作是非阻塞的，这两个操作的结合模拟了多线程环境下的阻塞 IO</p><p><code>job1</code>、<code>job2</code> 和 <code>job3</code> 三个任务并发执行，不需要编写任何线程同步代码如 <code>Condition.await</code> 、<code>Condition.signal</code>、<code>CountDownLatch</code> 等即可获得任务结果并计算它们之和，从输出 <code>measureTimeMillis: 961</code> 可以确认三个任务是并发执行的，<code>result: 2453</code> 正确地输出了任务结果之和说明求和这一行代码是在三个任务都执行完毕并返回计算结果后执行的</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;    <span class="hljs-keyword">val</span> values = (<span class="hljs-number">500L</span>..<span class="hljs-number">1000L</span>)    <span class="hljs-keyword">val</span> cost = measureTimeMillis &#123;        <span class="hljs-keyword">val</span> job1 = async &#123;            <span class="hljs-keyword">val</span> value = values.random()            println(<span class="hljs-string">&quot;job1 delay: <span class="hljs-variable">$value</span>&quot;</span>)            delay(value)            value        &#125;        <span class="hljs-keyword">val</span> job2 = async &#123;            <span class="hljs-keyword">val</span> value = values.random()            println(<span class="hljs-string">&quot;job2 delay: <span class="hljs-variable">$value</span>&quot;</span>)            delay(value)            value        &#125;        <span class="hljs-keyword">val</span> job3 = async &#123;            <span class="hljs-keyword">val</span> value = values.random()            println(<span class="hljs-string">&quot;job3 delay: <span class="hljs-variable">$value</span>&quot;</span>)            delay(value)            value        &#125;        println(<span class="hljs-string">&quot;result: <span class="hljs-subst">$&#123;job3.await() + job2.await() + job1.await()&#125;</span>&quot;</span>)    &#125;    println(<span class="hljs-string">&quot;measureTimeMillis: <span class="hljs-variable">$cost</span>&quot;</span>)&#125;<span class="hljs-comment">// output:</span><span class="hljs-comment">// job1 delay: 758</span><span class="hljs-comment">// job2 delay: 822</span><span class="hljs-comment">// job3 delay: 873</span><span class="hljs-comment">// result: 2453</span><span class="hljs-comment">// measureTimeMillis: 961</span></code></pre></div><p>从 <code>async</code> 的实现可以看到它跟 <a href="../../../../2021/07/15/kotlin-coroutine/">上篇文章</a> 介绍到的 <code>launch</code> 基本相同，那也就说 <code>async</code> 同样是创建协程/任务 -&gt; 放入任务队列 -&gt; 等待调度</p><p>跟踪 <code>await</code> 调用栈：<code>DeferredCoroutine.await</code> -&gt; <code>JobSupport.awaitInternal</code> -&gt; <code>JobSupport.awaitSuspend</code> -&gt; <code>CancellableContinuationImpl.getResult</code>，在这里分为两条路：</p><ol><li>如果协程已经执行完毕得到计算结果（比如在多线程环境下），计算结果存储在 <code>CancellableContinuationImpl.state</code>，<code>trySuspend</code> 返回 false，<code>getResult</code> 返回计算所得的结果</li><li>协程尚未完成，比如上面的例子，被 <code>delay</code> 中断执行而放入任务队列重新调度，<code>trySuspend</code> 返回 true，<code>getResult</code> 返回 <code>COROUTINE_SUSPENDED</code></li></ol><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> CoroutineScope.<span class="hljs-title">async</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: Deferred&lt;T&gt; &#123;    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)        LazyDeferredCoroutine(newContext, block) <span class="hljs-keyword">else</span>        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="hljs-literal">true</span>)    coroutine.start(start, coroutine, block)    <span class="hljs-keyword">return</span> coroutine&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeferredCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;(    parentContext: CoroutineContext,    active: <span class="hljs-built_in">Boolean</span>) : AbstractCoroutine&lt;T&gt;(parentContext, <span class="hljs-literal">true</span>, active = active), Deferred&lt;T&gt;, SelectClause1&lt;T&gt; &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T = awaitInternal() <span class="hljs-keyword">as</span> T&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JobSupport</span> <span class="hljs-keyword">constructor</span>(active: <span class="hljs-built_in">Boolean</span>) : Job, ChildJob, ParentJob, SelectClause0 &#123;    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitInternal</span><span class="hljs-params">()</span></span>: Any? &#123;        <span class="hljs-comment">// fast-path -- check state (avoid extra object creation)</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// lock-free loop on state</span>            <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state            <span class="hljs-keyword">if</span> (state !<span class="hljs-keyword">is</span> Incomplete) &#123;                <span class="hljs-comment">// already complete -- just return result</span>                <span class="hljs-keyword">if</span> (state <span class="hljs-keyword">is</span> CompletedExceptionally) &#123; <span class="hljs-comment">// Slow path to recover stacktrace</span>                    recoverAndThrow(state.cause)                &#125;                <span class="hljs-keyword">return</span> state.unboxState()            &#125;            <span class="hljs-keyword">if</span> (startInternal(state) &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> <span class="hljs-comment">// break unless needs to retry</span>        &#125;        <span class="hljs-keyword">return</span> awaitSuspend() <span class="hljs-comment">// slow-path</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span>: Any? = suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Custom code here, so that parent coroutine that is using await</span><span class="hljs-comment">         * on its child deferred (async) coroutine would throw the exception that this child had</span><span class="hljs-comment">         * thrown and not a JobCancellationException.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">val</span> cont = AwaitContinuation(uCont.intercepted(), <span class="hljs-keyword">this</span>)        <span class="hljs-comment">// we are mimicking suspendCancellableCoroutine here and call initCancellability, too.</span>        cont.initCancellability()        cont.disposeOnCancellation(invokeOnCompletion(ResumeAwaitOnCompletion(cont).asHandler))        cont.getResult()    &#125;    &#125;    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CancellableContinuationImpl</span>&lt;<span class="hljs-type">in T</span>&gt;(    <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> delegate: Continuation&lt;T&gt;,    resumeMode: <span class="hljs-built_in">Int</span>) : DispatchedTask&lt;T&gt;(resumeMode), CancellableContinuation&lt;T&gt;, CoroutineStackFrame &#123;    <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;        <span class="hljs-keyword">val</span> isReusable = isReusable()        <span class="hljs-comment">// trySuspend may fail either if &#x27;block&#x27; has resumed/cancelled a continuation</span>        <span class="hljs-comment">// or we got async cancellation from parent.</span>        <span class="hljs-keyword">if</span> (trySuspend()) &#123;            <span class="hljs-comment">/*</span><span class="hljs-comment">             * Invariant: parentHandle is `null` *only* for reusable continuations.</span><span class="hljs-comment">             * We were neither resumed nor cancelled, time to suspend.</span><span class="hljs-comment">             * But first we have to install parent cancellation handle (if we didn&#x27;t yet),</span><span class="hljs-comment">             * so CC could be properly resumed on parent cancellation.</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * This read has benign data-race with write of &#x27;NonDisposableHandle&#x27;</span><span class="hljs-comment">             * in &#x27;detachChildIfNotReusable&#x27;.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span> (parentHandle == <span class="hljs-literal">null</span>) &#123;                installParentHandle()            &#125;            <span class="hljs-comment">/*</span><span class="hljs-comment">             * Release the continuation after installing the handle (if needed).</span><span class="hljs-comment">             * If we were successful, then do nothing, it&#x27;s ok to reuse the instance now.</span><span class="hljs-comment">             * Otherwise, dispose the handle by ourselves.</span><span class="hljs-comment">            */</span>            <span class="hljs-keyword">if</span> (isReusable) &#123;                releaseClaimedReusableContinuation()            &#125;            <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED        &#125;        <span class="hljs-comment">// otherwise, onCompletionInternal was already invoked &amp; invoked tryResume, and the result is in the state</span>        <span class="hljs-keyword">if</span> (isReusable) &#123;            <span class="hljs-comment">// release claimed reusable continuation for the future reuse</span>            releaseClaimedReusableContinuation()        &#125;        <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state        <span class="hljs-keyword">if</span> (state <span class="hljs-keyword">is</span> CompletedExceptionally) <span class="hljs-keyword">throw</span> recoverStackTrace(state.cause, <span class="hljs-keyword">this</span>)        <span class="hljs-comment">// if the parent job was already cancelled, then throw the corresponding cancellation exception</span>        <span class="hljs-comment">// otherwise, there is a race if suspendCancellableCoroutine &#123; cont -&gt; ... &#125; does cont.resume(...)</span>        <span class="hljs-comment">// before the block returns. This getResult would return a result as opposed to cancellation</span>        <span class="hljs-comment">// exception that should have happened if the continuation is dispatched for execution later.</span>        <span class="hljs-keyword">if</span> (resumeMode.isCancellableMode) &#123;            <span class="hljs-keyword">val</span> job = context[Job]            <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) &#123;                <span class="hljs-keyword">val</span> cause = job.getCancellationException()                cancelCompletedResult(state, cause)                <span class="hljs-keyword">throw</span> recoverStackTrace(cause, <span class="hljs-keyword">this</span>)            &#125;        &#125;        <span class="hljs-keyword">return</span> getSuccessfulResult(state)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">getSuccessfulResult</span><span class="hljs-params">(state: <span class="hljs-type">Any</span>?)</span></span>: T =        <span class="hljs-keyword">when</span> (state) &#123;            <span class="hljs-keyword">is</span> CompletedContinuation -&gt; state.result <span class="hljs-keyword">as</span> T            <span class="hljs-keyword">else</span> -&gt; state <span class="hljs-keyword">as</span> T        &#125;    &#125;</code></pre></div><p><code>await</code> 的返回值会直接影响代码的执行流程，为了使反编译后的代码清晰点，我将上面的例子删除掉多余的代码如下：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;    <span class="hljs-keyword">val</span> values = (<span class="hljs-number">500L</span>..<span class="hljs-number">1000L</span>)    <span class="hljs-keyword">val</span> job1 = async &#123;        <span class="hljs-keyword">val</span> value = values.random()        println(<span class="hljs-string">&quot;job1 delay: <span class="hljs-variable">$value</span>&quot;</span>)        delay(value)        value    &#125;    <span class="hljs-keyword">val</span> job2 = async &#123;        <span class="hljs-keyword">val</span> value = values.random()        println(<span class="hljs-string">&quot;job2 delay: <span class="hljs-variable">$value</span>&quot;</span>)        delay(value)        value    &#125;    <span class="hljs-keyword">val</span> job3 = async &#123;        <span class="hljs-keyword">val</span> value = values.random()        println(<span class="hljs-string">&quot;job3 delay: <span class="hljs-variable">$value</span>&quot;</span>)        delay(value)        value    &#125;    println(<span class="hljs-string">&quot;result: <span class="hljs-subst">$&#123;job3.await() + job2.await() + job1.await()&#125;</span>&quot;</span>)&#125;</code></pre></div><p>将其反编译（decompile by <a href="https://github.com/Konloch/bytecode-viewer">bytecode-viewer</a> using CFR）可以看到：</p><ul><li>初始代码段 <code>case 0</code> 创建了三个异步协程然后执行其中一个 <code>await</code></li><li><code>case 1</code> 和 <code>case 2</code> 分别对应其余的两个 <code>await</code>，<code>case 3</code> 对应求和操作</li><li>从 <code>label</code> 的赋值操作看，四个 case 必须从 0 执行到 3，不能跳级</li><li>如果 <code>await</code> 返回计算结果则继续执行代码，进入下一个 case</li><li>如果 <code>await</code> 返回 <code>COROUTINE_SUSPENDED</code> 则中断代码执行直接返回（case 不变）</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example_basic_01Kt</span>.main<span class="hljs-number">.1</span><span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuspendLambda</span><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function2</span>&lt;CoroutineScope, Continuation&lt;? <span class="hljs-built_in">super</span> Unit&gt;, Object&gt; &#123;    Object L$<span class="hljs-number">1</span>;    Object L$<span class="hljs-number">2</span>;    <span class="hljs-type">long</span> J$<span class="hljs-number">0</span>;    <span class="hljs-type">int</span> label;    <span class="hljs-keyword">private</span> <span class="hljs-comment">/* synthetic */</span> Object L$<span class="hljs-number">0</span>;    Example_basic_01Kt.main<span class="hljs-number">.1</span>(Continuation&lt;? <span class="hljs-built_in">super</span> Example_basic_01Kt.main<span class="hljs-number">.1</span>&gt; $completion) &#123;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Unable to fully structure code</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object var1_1)</span> &#123;        var13_2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();        <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.label) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;                ResultKt.throwOnFailure((Object)var1_1);                $<span class="hljs-built_in">this</span>$runBlocking = (CoroutineScope)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span>;                values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongRange</span>(<span class="hljs-number">500L</span>, <span class="hljs-number">1000L</span>);                job1 = BuildersKt.async$<span class="hljs-keyword">default</span>((CoroutineScope)$<span class="hljs-built_in">this</span>$runBlocking, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, (Function2)((Function2)<span class="hljs-keyword">new</span> <span class="hljs-comment">/* Unavailable Anonymous Inner Class!! */</span>), (<span class="hljs-type">int</span>)<span class="hljs-number">3</span>, <span class="hljs-literal">null</span>);                job2 = BuildersKt.async$<span class="hljs-keyword">default</span>((CoroutineScope)$<span class="hljs-built_in">this</span>$runBlocking, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, (Function2)((Function2)<span class="hljs-keyword">new</span> <span class="hljs-comment">/* Unavailable Anonymous Inner Class!! */</span>), (<span class="hljs-type">int</span>)<span class="hljs-number">3</span>, <span class="hljs-literal">null</span>);                job3 = BuildersKt.async$<span class="hljs-keyword">default</span>((CoroutineScope)$<span class="hljs-built_in">this</span>$runBlocking, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, (Function2)((Function2)<span class="hljs-keyword">new</span> <span class="hljs-comment">/* Unavailable Anonymous Inner Class!! */</span>), (<span class="hljs-type">int</span>)<span class="hljs-number">3</span>, <span class="hljs-literal">null</span>);                var9_8 = <span class="hljs-string">&quot;result: &quot;</span>;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span> = job1;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">1</span> = job2;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">2</span> = var9_8;                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">1</span>;                v0 = job3.await((Continuation)<span class="hljs-built_in">this</span>);                <span class="hljs-keyword">if</span> (v0 == var13_2) &#123;                    <span class="hljs-keyword">return</span> var13_2;                &#125;                ** GOTO lbl25            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;                var9_8 = (String)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">2</span>;                job2 = (Deferred)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">1</span>;                job1 = (Deferred)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span>;                ResultKt.throwOnFailure((Object)$result);                v0 = $result;lbl25:                <span class="hljs-comment">// 2 sources</span>                var10_9 = v0;                var10_10 = ((Number)var10_9).longValue();                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span> = job1;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">1</span> = var9_8;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">2</span> = <span class="hljs-literal">null</span>;                <span class="hljs-built_in">this</span>.J$<span class="hljs-number">0</span> = var10_10;                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">2</span>;                v1 = job2.await((Continuation)<span class="hljs-built_in">this</span>);                <span class="hljs-keyword">if</span> (v1 == var13_2) &#123;                    <span class="hljs-keyword">return</span> var13_2;                &#125;                ** GOTO lbl42            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;                var10_10 = <span class="hljs-built_in">this</span>.J$<span class="hljs-number">0</span>;                var9_8 = (String)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">1</span>;                job1 = (Deferred)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span>;                ResultKt.throwOnFailure((Object)$result);                v1 = $result;lbl42:                <span class="hljs-comment">// 2 sources</span>                var12_11 = v1;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span> = var9_8;                <span class="hljs-built_in">this</span>.L$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;                <span class="hljs-built_in">this</span>.J$<span class="hljs-number">0</span> = var10_10 += ((Number)var12_11).longValue();                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">3</span>;                v2 = job1.await((Continuation)<span class="hljs-built_in">this</span>);                <span class="hljs-keyword">if</span> (v2 == var13_2) &#123;                    <span class="hljs-keyword">return</span> var13_2;                &#125;                ** GOTO lbl56            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;                var10_10 = <span class="hljs-built_in">this</span>.J$<span class="hljs-number">0</span>;                var9_8 = (String)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span>;                ResultKt.throwOnFailure((Object)$result);                v2 = $result;lbl56:                <span class="hljs-comment">// 2 sources</span>                var12_11 = v2;                var7_12 = Intrinsics.stringPlus((String)var9_8, (Object)Boxing.boxLong((<span class="hljs-type">long</span>)(var10_10 + ((Number)var12_11).longValue())));                var8_13 = <span class="hljs-literal">false</span>;                System.out.println((Object)var7_12);                <span class="hljs-keyword">return</span> Unit.INSTANCE;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);    &#125;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation&lt;Unit&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation&lt;?&gt; $completion)</span> &#123;        Function2&lt;CoroutineScope, Continuation&lt;? <span class="hljs-built_in">super</span> Unit&gt;, Object&gt; function2 = <span class="hljs-keyword">new</span> <span class="hljs-comment">/* invalid duplicate definition of identical inner class */</span>;        function2.L$<span class="hljs-number">0</span> = value;        <span class="hljs-keyword">return</span> (Continuation)function2;    &#125;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineScope p1, <span class="hljs-meta">@Nullable</span> Continuation&lt;? <span class="hljs-built_in">super</span> Unit&gt; p2)</span> &#123;        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.create(p1, p2)).invokeSuspend(Unit.INSTANCE);    &#125;&#125;</code></pre></div><p>结合上面的内容，将 <code>async</code> / <code>await</code> 这对 API 的执行流程解释下：</p><ol><li>三个 <code>async</code> 将会创建三个协程：<code>job1</code>、<code>job2</code> 和 <code>job3</code> 并放入任务队列进行调度，假设当前的 Dispatcher 是线程池那么三个协程将创建三个线程并发执行</li><li>假设在求和前 <code>job1</code> 和 <code>job3</code> 执行完毕（计算结果作为 <code>CompletedContinuation</code> 存储在 <code>CancellableContinuationImpl.state</code>）</li><li><code>case 0</code> 从 <code>job3.await</code> 取得计算结果并进入 <code>case 1</code>，<code>job2.await</code> 返回 <code>COROUTINE_SUSPENDED</code> 导致代码执行中断并返回，此时 <code>label = 2</code></li><li>为啥不是 <code>case 1</code> 呢？不是得从 <code>job2.await</code> 获取计算结果吗？并不需要，下次 <code>Example_basic_01Kt.main.1</code> 被调度时 <code>job2</code> 的计算结果将会作为参数从 <code>invokeSuspend</code> 传入</li><li>进入 <code>case 2</code>，<code>job3.await</code> 返回计算结果</li><li>进入 <code>case 3</code>，执行求和并打印出来</li></ol><p>现在只剩下一个问题：<code>await</code> 返回 <code>COROUTINE_SUSPENDED</code> 导致流程中断后 <code>Example_basic_01Kt.main.1</code> 啥时候被再次调度？如下代码所示</p><ul><li><code>uCont</code> 实际上是 <code>CoroutineStart.DEFAULT.invoke(block, receiver, completion)</code> 参数里的 <code>completion</code>，也就是 <code>Example_basic_01Kt.main.1</code> 这个 <code>Continuation</code></li><li><code>invokeOnCompletion</code> 给 <code>async</code> 创建的任务添加了一个回调，当任务执行完毕时调用（返回非 <code>COROUTINE_SUSPENDED</code> 值）</li><li><code>ResumeAwaitOnCompletion</code> 顾名思义就是恢复任务，重新调度被 <code>await</code> 中断的 <code>Continuation</code></li><li>在这里就是 <code>Example_basic_01Kt.main.1</code> 由于 <code>job2</code> 没有完成而被中断，当 <code>job2</code> 完成后重新将 <code>Example_basic_01Kt.main.1</code> 放入任务队列进行调度，并且将 <code>job2</code> 的计算结果作为参数</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// DeferredCoroutine.await</span><span class="hljs-comment">// JobSupport.awaitInternal</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">awaitSuspend</span><span class="hljs-params">()</span></span>: Any? = suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Custom code here, so that parent coroutine that is using await</span><span class="hljs-comment">     * on its child deferred (async) coroutine would throw the exception that this child had</span><span class="hljs-comment">     * thrown and not a JobCancellationException.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">val</span> cont = AwaitContinuation(uCont.intercepted(), <span class="hljs-keyword">this</span>)    <span class="hljs-comment">// we are mimicking suspendCancellableCoroutine here and call initCancellability, too.</span>    cont.initCancellability()    cont.disposeOnCancellation(invokeOnCompletion(ResumeAwaitOnCompletion(cont).asHandler))    cont.getResult()&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResumeAwaitOnCompletion</span>&lt;<span class="hljs-type">T</span>&gt;(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: CancellableContinuationImpl&lt;T&gt;) : JobNode() &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>?)</span></span> &#123;        <span class="hljs-keyword">val</span> state = job.state        assert &#123; state !<span class="hljs-keyword">is</span> Incomplete &#125;        <span class="hljs-keyword">if</span> (state <span class="hljs-keyword">is</span> CompletedExceptionally) &#123;            <span class="hljs-comment">// Resume with with the corresponding exception to preserve it</span>            continuation.resumeWithException(state.cause)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Resuming with value in a cancellable way (AwaitContinuation is configured for this mode).</span>            <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span>            continuation.resume(state.unboxState() <span class="hljs-keyword">as</span> T)        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineStart</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">invoke</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>, receiver: <span class="hljs-type">R</span>, completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Unit</span> =        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)            ATOMIC -&gt; block.startCoroutine(receiver, completion)            UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)            LAZY -&gt; <span class="hljs-built_in">Unit</span> <span class="hljs-comment">// will start lazily</span>        &#125;&#125;</code></pre></div><h1 id="withContext-线程切换"><a href="#withContext-线程切换" class="headerlink" title="withContext - 线程切换"></a>withContext - 线程切换</h1><p>如下代码所示，使用 <code>withContext</code> 将执行线程从 main 切换至 worker，但不影响代码的执行顺序</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;    withContext(Dispatchers.IO) &#123;        delay(<span class="hljs-number">1000</span>)        println(<span class="hljs-string">&quot;jumping to Dispatchers.IO, <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)    &#125;    println(<span class="hljs-string">&quot;finish main func, <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)&#125;<span class="hljs-comment">// output:</span><span class="hljs-comment">// jumping to Dispatchers.IO, DefaultDispatcher-worker-1</span><span class="hljs-comment">// finish main func, main</span></code></pre></div><p>在了解了协程的本质是任务调度/线程调度，以及 <code>delay</code>、<code>async</code>、<code>await</code> 等操作的实现逻辑后，我们很容易能猜测出 <code>withContext</code> 的逻辑：</p><ol><li>添加成员属性 <code>label</code> 用以将代码分段：<code>withContext</code> 前的代码为片段 0，之后的代码为片段 1</li><li><code>withContext</code> 将 <code>runBlocking</code> 添加为 block 的 completion handler，并将 block 放入 <code>Dispatchers.IO</code> 的任务队列，返回 <code>COROUTINE_SUSPENDED</code> 中断 <code>runBlocking</code> 的执行</li><li><code>withContext</code> 得到调度，执行完毕后恢复 <code>runBlocking</code> 的执行</li></ol><p>show me the code 看看是不是如上面说的那样，用 Bytecode Viewer 反编译得到如下代码，正如上面说的 main 代码块从线程切换为边界，切分为两个代码块，<code>case 0</code> 将被 <code>withContext</code> 的返回值中断，重新调度时进入 <code>case 1</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example_basic_01Kt</span>.main<span class="hljs-number">.1</span><span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuspendLambda</span><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function2</span>&lt;CoroutineScope, Continuation&lt;? <span class="hljs-built_in">super</span> Unit&gt;, Object&gt; &#123;    <span class="hljs-type">int</span> label;    Example_basic_01Kt.main<span class="hljs-number">.1</span>(Continuation&lt;? <span class="hljs-built_in">super</span> Example_basic_01Kt.main<span class="hljs-number">.1</span>&gt; $completion) &#123;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Unable to fully structure code</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object var1_1)</span> &#123;        var4_2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();        <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.label) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;                ResultKt.throwOnFailure((Object)var1_1);                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">1</span>;                v0 = BuildersKt.withContext((CoroutineContext)((CoroutineContext)Dispatchers.getIO()), (Function2)((Function2)<span class="hljs-keyword">new</span> <span class="hljs-comment">/* Unavailable Anonymous Inner Class!! */</span>), (Continuation)((Continuation)<span class="hljs-built_in">this</span>));                <span class="hljs-keyword">if</span> (v0 == var4_2) &#123;                    <span class="hljs-keyword">return</span> var4_2;                &#125;                ** GOTO lbl13            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;                ResultKt.throwOnFailure((Object)$result);                v0 = $result;lbl13:                <span class="hljs-comment">// 2 sources</span>                var2_3 = Intrinsics.stringPlus((String)<span class="hljs-string">&quot;finish main func, &quot;</span>, (Object)Thread.currentThread().getName());                var3_4 = <span class="hljs-literal">false</span>;                System.out.println((Object)var2_3);                <span class="hljs-keyword">return</span> Unit.INSTANCE;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);    &#125;    <span class="hljs-meta">@NotNull</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation&lt;Unit&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation&lt;?&gt; $completion)</span> &#123;        <span class="hljs-keyword">return</span> (Continuation)<span class="hljs-keyword">new</span> <span class="hljs-comment">/* invalid duplicate definition of identical inner class */</span>;    &#125;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineScope p1, <span class="hljs-meta">@Nullable</span> Continuation&lt;? <span class="hljs-built_in">super</span> Unit&gt; p2)</span> &#123;        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.create(p1, p2)).invokeSuspend(Unit.INSTANCE);    &#125;&#125;</code></pre></div><p><code>withContext</code> 跟 <code>launch</code> 和 <code>async</code> 差不多，将当前环境的和参数提供的 <code>CoroutineContext</code> 合并并用它作为 block context，当前 <code>Continuation</code>(也就是 runBlocking block) 作为 block 的 completion handler</p><p><code>withContext</code> 将 block 包装为 <code>DispatchedCoroutine</code>，它没有执行过（<code>Continuation.resumeWith</code>）所以 <code>DispatchedCoroutine.trySuspend</code> 返回 true，导致 <code>withContext</code> 返回 <code>COROUTINE_SUSPENDED</code> 从而中断 main block 的执行，跟上面的猜想一致</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">withContext</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span>,</span></span><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    <span class="hljs-keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;        <span class="hljs-comment">// compute new context</span>        <span class="hljs-keyword">val</span> oldContext = uCont.context        <span class="hljs-keyword">val</span> newContext = oldContext + context        <span class="hljs-comment">// always check for cancellation of new context</span>        newContext.ensureActive()        <span class="hljs-comment">// FAST PATH #1 -- new context is the same as the old one</span>        <span class="hljs-keyword">if</span> (newContext === oldContext) &#123;            <span class="hljs-keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont)            <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)        &#125;        <span class="hljs-comment">// FAST PATH #2 -- the new dispatcher is the same as the old one (something else changed)</span>        <span class="hljs-comment">// `equals` is used by design (see equals implementation is wrapper context like ExecutorCoroutineDispatcher)</span>        <span class="hljs-keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;            <span class="hljs-keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont)            <span class="hljs-comment">// There are changes in the context, so this thread needs to be updated</span>            withCoroutineContext(newContext, <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)            &#125;        &#125;        <span class="hljs-comment">// SLOW PATH -- use new dispatcher</span>        <span class="hljs-keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont)        block.startCoroutineCancellable(coroutine, coroutine)        coroutine.getResult()    &#125;&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchedCoroutine</span>&lt;<span class="hljs-type">in T</span>&gt;(    context: CoroutineContext,    uCont: Continuation&lt;T&gt;) : ScopeCoroutine&lt;T&gt;(context, uCont) &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;        <span class="hljs-keyword">if</span> (trySuspend()) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED        <span class="hljs-comment">// otherwise, onCompletionInternal was already invoked &amp; invoked tryResume, and the result is in the state</span>        <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state.unboxState()        <span class="hljs-keyword">if</span> (state <span class="hljs-keyword">is</span> CompletedExceptionally) <span class="hljs-keyword">throw</span> state.cause        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span>        <span class="hljs-keyword">return</span> state <span class="hljs-keyword">as</span> T    &#125;&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchedCoroutine</span>&lt;<span class="hljs-type">in T</span>&gt;(    context: CoroutineContext,    uCont: Continuation&lt;T&gt;) : ScopeCoroutine&lt;T&gt;(context, uCont) &#123;    <span class="hljs-comment">// this is copy-and-paste of a decision state machine inside AbstractionContinuation</span>    <span class="hljs-comment">// todo: we may some-how abstract it via inline class</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _decision = atomic(UNDECIDED)    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trySuspend</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        _decision.loop &#123; decision -&gt;            <span class="hljs-keyword">when</span> (decision) &#123;                UNDECIDED -&gt; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._decision.compareAndSet(UNDECIDED, SUSPENDED)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                RESUMED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;Already suspended&quot;</span>)            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>coroutine</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析 Kotlin Coroutines 是如何实现的</title>
    <link href="/2021/07/15/kotlin-coroutine/"/>
    <url>/2021/07/15/kotlin-coroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="launch-启动协程"><a href="#launch-启动协程" class="headerlink" title="launch - 启动协程"></a>launch - 启动协程</h1><p>从 kotlin coroutines 的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt">Hello World!</a> 看起</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123; <span class="hljs-comment">// this: CoroutineScope</span>    launch &#123; <span class="hljs-comment">// launch a new coroutine and continue</span>        delay(<span class="hljs-number">1000L</span>) <span class="hljs-comment">// non-blocking delay for 1 second (default time unit is ms)</span>        println(<span class="hljs-string">&quot;World!&quot;</span>) <span class="hljs-comment">// print after delay</span>    &#125;    println(<span class="hljs-string">&quot;Hello&quot;</span>) <span class="hljs-comment">// main coroutine continues while a previous one is delayed</span>&#125;</code></pre></div><p>需要先了解的是 <code>launch</code> 的参数 <code>block: suspend CoroutineScope.() -&gt; Unit</code> 被编译为继承自 <code>SuspendLamda</code> 和 <code>Function2&lt;CoroutineScope, Continuation&gt;</code>，如下面的代码所示（decompile by <a href="https://github.com/Konloch/bytecode-viewer">bytecode-viewer</a>）</p><p><code>SuspendLambda</code> 的继承关系如下：<code>SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl -&gt; Continuation</code>，所以 <code>block</code> 在库代码里一般称为 <code>continuation</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example_basic_01Kt$main$1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuspendLambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function2</span> &#123;   <span class="hljs-type">int</span> label;   <span class="hljs-comment">// $FF: synthetic field</span>   <span class="hljs-keyword">private</span> Object L$<span class="hljs-number">0</span>;   Example_basic_01Kt$main$<span class="hljs-number">1</span>(Continuation $completion) &#123;      <span class="hljs-built_in">super</span>(<span class="hljs-number">2</span>, $completion);   &#125;   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object var1)</span> &#123;      <span class="hljs-type">Object</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.label) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:         ResultKt.throwOnFailure(var1);         <span class="hljs-type">CoroutineScope</span> <span class="hljs-variable">$this$runBlocking</span> <span class="hljs-operator">=</span> (CoroutineScope)<span class="hljs-built_in">this</span>.L$<span class="hljs-number">0</span>;         BuildersKt.launch$<span class="hljs-keyword">default</span>($<span class="hljs-built_in">this</span>$runBlocking, (CoroutineContext)<span class="hljs-literal">null</span>, (CoroutineStart)<span class="hljs-literal">null</span>, (Function2)(<span class="hljs-keyword">new</span> <span class="hljs-number">1</span>((Continuation)<span class="hljs-literal">null</span>)), <span class="hljs-number">3</span>, (Object)<span class="hljs-literal">null</span>);         <span class="hljs-type">String</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;         <span class="hljs-type">boolean</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;         System.out.println(var3);         <span class="hljs-keyword">return</span> Unit.INSTANCE;      <span class="hljs-keyword">default</span>:         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);      &#125;   &#125;   <span class="hljs-meta">@NotNull</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> &#123;      <span class="hljs-type">Example_basic_01Kt$main$1</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example_basic_01Kt$main$1</span>($completion);      var3.L$<span class="hljs-number">0</span> = value;      <span class="hljs-keyword">return</span> (Continuation)var3;   &#125;   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineScope p1, <span class="hljs-meta">@Nullable</span> Continuation p2)</span> &#123;      <span class="hljs-keyword">return</span> ((Example_basic_01Kt$main$<span class="hljs-number">1</span>)<span class="hljs-built_in">this</span>.create(p1, p2)).invokeSuspend(Unit.INSTANCE);   &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example_basic_01Kt$main$1$1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuspendLambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function2</span> &#123;   <span class="hljs-type">int</span> label;   Example_basic_01Kt$main$<span class="hljs-number">1</span>$<span class="hljs-number">1</span>(Continuation $completion) &#123;      <span class="hljs-built_in">super</span>(<span class="hljs-number">2</span>, $completion);   &#125;   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> &#123;      <span class="hljs-type">Object</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.label) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:         ResultKt.throwOnFailure($result);         <span class="hljs-type">Continuation</span> <span class="hljs-variable">var10001</span> <span class="hljs-operator">=</span> (Continuation)<span class="hljs-built_in">this</span>;         <span class="hljs-built_in">this</span>.label = <span class="hljs-number">1</span>;         <span class="hljs-keyword">if</span> (DelayKt.delay(<span class="hljs-number">1000L</span>, var10001) == var4) &#123;            <span class="hljs-keyword">return</span> var4;         &#125;         <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:         ResultKt.throwOnFailure($result);         <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>:         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);      &#125;      <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World!&quot;</span>;      <span class="hljs-type">boolean</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;      System.out.println(var2);      <span class="hljs-keyword">return</span> Unit.INSTANCE;   &#125;   <span class="hljs-meta">@NotNull</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Continuation <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> &#123;      <span class="hljs-keyword">return</span> (Continuation)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Example_basic_01Kt$main$1$1</span>($completion));   &#125;   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineScope p1, <span class="hljs-meta">@Nullable</span> Continuation p2)</span> &#123;      <span class="hljs-keyword">return</span> ((Example_basic_01Kt$main$<span class="hljs-number">1</span>$<span class="hljs-number">1</span>)<span class="hljs-built_in">this</span>.create(p1, p2)).invokeSuspend(Unit.INSTANCE);   &#125;&#125;</code></pre></div><p>然后一路跟踪下去看看 <code>launch</code> 做了什么</p><div class="code-wrapper"><pre><code class="hljs kotlin">CoroutineScope.launch                              <span class="hljs-comment">// return Job (实际上是 StandaloneCoroutine/LazyStandaloneCoroutine)</span>AbstractCoroutine.start                            <span class="hljs-comment">// 创建 StandaloneCoroutine/LazyStandaloneCoroutine</span>CoroutineStart.invoke(block, receiver, completion) <span class="hljs-comment">// CoroutineStart.DEFAULT</span>startCoroutineCancellable(receiver, completion, onCancellation)    createCoroutineUnintercepted       <span class="hljs-comment">// 此方法定义在 kotlin-stdlib 包的 /kotlin/coroutines/intrinsics/IntrinsicsJvm.kt 文件里</span>        block.create(value = <span class="hljs-literal">null</span>, completion = coroutine) <span class="hljs-comment">// 如上面反编译出来的代码所示，重新创建一个 block 的实例</span>    ContinuationImpl.intercepted       <span class="hljs-comment">// 包装为 DispatchedContinuation（dispatcher 是 BlockingEventLoop）</span>        BlockingEventLoop.interceptContinuation    Continuation.resumeCancellableWith <span class="hljs-comment">// 将 block 放入任务队列</span>        DispatchedContinuation.resumeCancellableWith        BlockingEventLoop.dispatch            BlockingEventLoop.enqueue<span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopImplBase</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> (enqueueImpl(task)) &#123;            unpark()        &#125; <span class="hljs-keyword">else</span> &#123;            DefaultExecutor.enqueue(task)        &#125;    &#125;    <span class="hljs-comment">// _queue 是 Atomic&lt;Any?&gt;，当任务队列里只有一个任务时 _queue 持有此任务的引用，当任务队列里有多个任务时，_queue 是 Queue&lt;Runnable&gt;</span>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueueImpl</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        _queue.loop &#123; queue -&gt;            <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// fail fast if already completed, may still add, but queues will close</span>            <span class="hljs-keyword">when</span> (queue) &#123;                <span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">if</span> (_queue.compareAndSet(<span class="hljs-literal">null</span>, task)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                <span class="hljs-keyword">is</span> Queue&lt;*&gt; -&gt; &#123;                    <span class="hljs-keyword">when</span> ((queue <span class="hljs-keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;                        Queue.ADD_SUCCESS -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                        Queue.ADD_CLOSED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                        Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next())                    &#125;                &#125;                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">when</span> &#123;                    queue === CLOSED_EMPTY -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    <span class="hljs-keyword">else</span> -&gt; &#123;                        <span class="hljs-comment">// update to full-blown queue to add one more</span>                        <span class="hljs-keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="hljs-literal">true</span>)                        newQueue.addLast(queue <span class="hljs-keyword">as</span> Runnable)                        newQueue.addLast(task)                        <span class="hljs-keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;    <span class="hljs-comment">// Infinite loop that reads this atomic variable and performs the specified action on its value.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> AtomicRef<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">loop</span><span class="hljs-params">(action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: <span class="hljs-built_in">Nothing</span> &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        action(value)    &#125;&#125;</code></pre></div><p>至此知道了 <code>block</code> 是被放到了任务队列里，那是谁在执行任务队列里的任务呢？这就不得不说起 <code>runBlocking</code></p><p><code>runBlocking</code> 通过 <code>BlockingCoroutine.joinBlocking</code> 不断地执行任务队列里的任务（<code>EventLoopBase.processNextEvent</code>）直到队列为空，因此它是 <code>blocking method</code>；第一个加入到任务队列的是 runBlocking block，所以 <code>Hello World!</code> 示例里会先输出 <code>Hello</code> 然后执行第二个 coroutine 输出 <code>World!</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">runBlocking</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    <span class="hljs-keyword">val</span> currentThread = Thread.currentThread()    <span class="hljs-keyword">val</span> contextInterceptor = context[ContinuationInterceptor]    <span class="hljs-keyword">val</span> eventLoop: EventLoop?    <span class="hljs-keyword">val</span> newContext: CoroutineContext    <span class="hljs-keyword">if</span> (contextInterceptor == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// create or use private event loop if no dispatcher is specified</span>        eventLoop = ThreadLocalEventLoop.eventLoop        newContext = GlobalScope.newCoroutineContext(context + eventLoop)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span>        <span class="hljs-comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span>        eventLoop = (contextInterceptor <span class="hljs-keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;            ?: ThreadLocalEventLoop.currentOrNull()        newContext = GlobalScope.newCoroutineContext(context)    &#125;    <span class="hljs-keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)    <span class="hljs-keyword">return</span> coroutine.joinBlocking()&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingCoroutine</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">joinBlocking</span><span class="hljs-params">()</span></span>: T &#123;        registerTimeLoopThread()        <span class="hljs-keyword">try</span> &#123;            eventLoop?.incrementUseCount()            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                    <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;DEPRECATION&quot;</span>)</span>                    <span class="hljs-keyword">if</span> (Thread.interrupted()) <span class="hljs-keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125;                    <span class="hljs-keyword">val</span> parkNanos = eventLoop?.processNextEvent() ?: <span class="hljs-built_in">Long</span>.MAX_VALUE                    <span class="hljs-comment">// note: process next even may loose unpark flag, so check if completed before parking</span>                    <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">break</span>                    parkNanos(<span class="hljs-keyword">this</span>, parkNanos)                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// paranoia</span>                eventLoop?.decrementUseCount()            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// paranoia</span>            unregisterTimeLoopThread()        &#125;        <span class="hljs-comment">// now return result</span>        <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state.unboxState()        (state <span class="hljs-keyword">as</span>? CompletedExceptionally)?.let &#123; <span class="hljs-keyword">throw</span> it.cause &#125;        <span class="hljs-keyword">return</span> state <span class="hljs-keyword">as</span> T    &#125;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>launch</code> 把 block 放入任务队列等待执行，类似于 <code>ExecutorService.submit</code> 和 <code>Handler.post</code>，同时说明 <code>协程</code> 本质上就是对任务的调度，底层是线程/线程池 + 任务队列</p><h1 id="Dispatcher-任务调度"><a href="#Dispatcher-任务调度" class="headerlink" title="Dispatcher - 任务调度"></a>Dispatcher - 任务调度</h1><p>首先要了解下 <code>CoroutineContext</code> 这个概念，跟 Android 上 <code>Context</code> 的意义是一样的，就是代表了一系列 coroutine API 的 <code>上下文</code>，本质上是一个 <code>Map</code>，通过 <code>CoroutineContext[key] = value</code> 存取</p><p>其中有一个非常重要的组件：<code>CoroutineContext[ContinuationInterceptor]</code>，负责分发/调度 coroutine，有 <code>BlockingEventLoop</code>, <code>Dispatchers.Default</code>, <code>Dispatchers.IO</code> 等等</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineContext</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the element with the given [key] from this context or `null`.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E?&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ContinuationInterceptor</span> : <span class="hljs-type">CoroutineContext.Element</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The key that defines *the* context interceptor.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;&#125;</code></pre></div><p>通过 <code>CoroutineScope.launch</code> 启动 coroutine 时，新创建的 coroutine 会继承 scpoe context（<code>launch</code> 的参数 <code>context</code> 会覆盖相同 key 的 scope context element），而且当 context 不含 interceptor 时主动添加 <code>Dispatchers.Default</code> 作为 <code>Dispatcher</code>，也就是说 <code>Dispatcher</code>/<code>CoroutineContext[ContinuationInterceptor]</code> 作为任务调度器是一个 <strong>必不可少</strong> 的 coroutine 组件</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: Job &#123;    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)    coroutine.start(start, coroutine, block)    <span class="hljs-keyword">return</span> coroutine&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">newCoroutineContext</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;    <span class="hljs-keyword">val</span> combined = coroutineContext + context    <span class="hljs-keyword">val</span> debug = <span class="hljs-keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="hljs-keyword">else</span> combined    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="hljs-literal">null</span>)        debug + Dispatchers.Default <span class="hljs-keyword">else</span> debug&#125;</code></pre></div><p>现在回顾下 <code>launch</code></p><ul><li><code>createCoroutineUnintercepted</code> - 创建 block 实例 <code>Continuation</code>，并使其获得 context</li><li><code>ContinuationImpl.intercepted</code> - 从 context 里取出 Dispatcher，由它负责把 <code>Continuation</code> 包装成 <code>DispatchedContinuation</code>（Dispatcher + Continuation），这样 <code>任务</code> 和 <code>调度器</code> 就齐活了</li><li><code>Continuation.resumeCancellableWith</code> - 让 Dispatcher 负责调度 Continuation</li></ul><p>上一章节分析了 coroutine 本质上就是任务队列里的任务，并简单提了下 <code>BlockingEventLoop</code> 这个调度器，这一章节分析各种各样的调度器</p><div class="code-wrapper"><pre><code class="hljs kotlin">CoroutineScope.launchAbstractCoroutine.startCoroutineStart.invoke(block, receiver, completion)startCoroutineCancellable(receiver, completion, onCancellation)    createCoroutineUnintercepted        block.create(value = <span class="hljs-literal">null</span>, completion = coroutine)    ContinuationImpl.intercepted        ContinuationInterceptor.interceptContinuation    Continuation.resumeCancellableWith        DispatchedContinuation.resumeCancellableWith        CoroutineDispatcher.dispatch<span class="hljs-comment">// kotlin-stdlib - kotlin/coroutines/intrinsics/IntrinsicsJvm.kt</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutineUnintercepted(    receiver: R,    completion: Continuation&lt;T&gt;): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;    <span class="hljs-keyword">val</span> probeCompletion = probeCoroutineCreated(completion)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> BaseContinuationImpl) <span class="hljs-comment">// block -&gt; SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl</span>        create(receiver, probeCompletion)    <span class="hljs-keyword">else</span> &#123;        createCoroutineFromSuspendFunction(probeCompletion) &#123;            (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)        &#125;    &#125;&#125;            <span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContinuationImpl</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =        intercepted            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)                .also &#123; intercepted = it &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineDispatcher</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =        DispatchedContinuation(<span class="hljs-keyword">this</span>, continuation)   &#125;</code></pre></div><h2 id="BlockingEventLoop-runBlocking"><a href="#BlockingEventLoop-runBlocking" class="headerlink" title="BlockingEventLoop / runBlocking"></a>BlockingEventLoop / runBlocking</h2><p><code>runBlocking</code> 会往 context 添加 <code>BlockingEventLoop</code></p><ul><li>上一章节介绍过，它是基于 <code>Queue</code> 的任务队列；只有一个任务时 <code>_queue</code> 直接引用这个任务节省空间，多个任务时 <code>_queue</code> 才引用 <code>Queue</code></li><li>它是 <code>ThreadLocal</code> 的，跟 <code>Looper</code> 一样每个线程单独绑定一个 <code>BlockingEventLoop</code></li><li><code>dispatch</code> 只是简单地将任务入队，然后唤醒对应的线程</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">runBlocking</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext, block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    <span class="hljs-keyword">val</span> currentThread = Thread.currentThread()    <span class="hljs-keyword">val</span> contextInterceptor = context[ContinuationInterceptor]    <span class="hljs-keyword">val</span> eventLoop: EventLoop?    <span class="hljs-keyword">val</span> newContext: CoroutineContext    <span class="hljs-keyword">if</span> (contextInterceptor == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// create or use private event loop if no dispatcher is specified</span>        eventLoop = ThreadLocalEventLoop.eventLoop        newContext = GlobalScope.newCoroutineContext(context + eventLoop)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span>        <span class="hljs-comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span>        eventLoop = (contextInterceptor <span class="hljs-keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;            ?: ThreadLocalEventLoop.currentOrNull()        newContext = GlobalScope.newCoroutineContext(context)    &#125;    <span class="hljs-keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)    <span class="hljs-keyword">return</span> coroutine.joinBlocking()&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> ThreadLocalEventLoop &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ref = CommonThreadLocal&lt;EventLoop?&gt;()    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> eventLoop: EventLoop        <span class="hljs-keyword">get</span>() = ref.<span class="hljs-keyword">get</span>() ?: createEventLoop().also &#123; ref.<span class="hljs-keyword">set</span>(it) &#125;&#125;<span class="hljs-comment">// https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/EventLoop.kt</span><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingEventLoop</span>(    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> thread: Thread) : EventLoopImplBase()<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createEventLoop</span><span class="hljs-params">()</span></span>: EventLoop = BlockingEventLoop(Thread.currentThread())<span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopImplBase</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _queue = atomic&lt;Any?&gt;(<span class="hljs-literal">null</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> = enqueue(block)    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> (enqueueImpl(task)) &#123;            <span class="hljs-comment">// todo: we should unpark only when this delayed task became first in the queue</span>            unpark()        &#125; <span class="hljs-keyword">else</span> &#123;            DefaultExecutor.enqueue(task)        &#125;    &#125;       <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueueImpl</span><span class="hljs-params">(task: <span class="hljs-type">Runnable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        _queue.loop &#123; queue -&gt;            <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// fail fast if already completed, may still add, but queues will close</span>            <span class="hljs-keyword">when</span> (queue) &#123;                <span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">if</span> (_queue.compareAndSet(<span class="hljs-literal">null</span>, task)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                <span class="hljs-keyword">is</span> Queue&lt;*&gt; -&gt; &#123;                    <span class="hljs-keyword">when</span> ((queue <span class="hljs-keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;                        Queue.ADD_SUCCESS -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                        Queue.ADD_CLOSED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                        Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next())                    &#125;                &#125;                <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">when</span> &#123;                    queue === CLOSED_EMPTY -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    <span class="hljs-keyword">else</span> -&gt; &#123;                        <span class="hljs-comment">// update to full-blown queue to add one more</span>                        <span class="hljs-keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="hljs-literal">true</span>)                        newQueue.addLast(queue <span class="hljs-keyword">as</span> Runnable)                        newQueue.addLast(task)                        <span class="hljs-keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                    &#125;                &#125;            &#125;        &#125;    &#125;    &#125;</code></pre></div><h2 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h2><p>上一章节说过 <code>Coroutine.launch</code> 开启协程时，如果 context 不包含 dispatcher，会自动添加默认的 dispatcher: <code>Dispatchers.Default</code>，如下示例代码</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = runBlocking &#123;    <span class="hljs-keyword">val</span> scope = CoroutineScope(EmptyCoroutineContext)    <span class="hljs-keyword">val</span> job = scope.launch &#123;        println(<span class="hljs-string">&quot;Thread name: <span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)    &#125;    job.join()&#125;</code></pre></div><p>从下面的代码可以看到 <code>Dispatchers.Default</code> 最终是通过 <code>CoroutineScheduler</code> 进行任务调度的，<code>CoroutineScheduler</code> 的代码量比较大这里就不深入分析了，但从它的构造函数参数 <code>corePoolSize</code>、<code>maxPoolSize</code> 和 <code>idleWorkerKeepAliveNs</code> 这些熟悉的概念可以看出它是个 <a href="../../../../2021/02/19/threadpool/">线程池</a></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The default [CoroutineDispatcher] that is used by all standard builders like</span><span class="hljs-comment">     * [launch][CoroutineScope.launch], [async][CoroutineScope.async], etc</span><span class="hljs-comment">     * if no dispatcher nor any other [ContinuationInterceptor] is specified in their context.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * It is backed by a shared pool of threads on JVM. By default, the maximal level of parallelism used</span><span class="hljs-comment">     * by this dispatcher is equal to the number of CPU cores, but is at least two.</span><span class="hljs-comment">     * Level of parallelism X guarantees that no more than X tasks can be executed in this dispatcher in parallel.</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@JvmStatic</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> Default: CoroutineDispatcher = createDefaultDispatcher()&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDefaultDispatcher</span><span class="hljs-params">()</span></span>: CoroutineDispatcher =    <span class="hljs-keyword">if</span> (useCoroutinesScheduler) DefaultScheduler <span class="hljs-keyword">else</span> CommonPool<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher()<span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExperimentalCoroutineDispatcher</span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span>,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> schedulerName: String = <span class="hljs-string">&quot;CoroutineScheduler&quot;</span>) : ExecutorCoroutineDispatcher() &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(        corePoolSize: <span class="hljs-built_in">Int</span> = CORE_POOL_SIZE,        maxPoolSize: <span class="hljs-built_in">Int</span> = MAX_POOL_SIZE,        schedulerName: String = DEFAULT_SCHEDULER_NAME    ) : <span class="hljs-keyword">this</span>(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS, schedulerName)    <span class="hljs-meta">@Deprecated(message = <span class="hljs-string">&quot;Binary compatibility for Ktor 1.0-beta&quot;</span>, level = DeprecationLevel.HIDDEN)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(        corePoolSize: <span class="hljs-built_in">Int</span> = CORE_POOL_SIZE,        maxPoolSize: <span class="hljs-built_in">Int</span> = MAX_POOL_SIZE    ) : <span class="hljs-keyword">this</span>(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS)    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> executor: Executor        <span class="hljs-keyword">get</span>() = coroutineScheduler    <span class="hljs-comment">// This is variable for test purposes, so that we can reinitialize from clean state</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> coroutineScheduler = createScheduler()    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span>: <span class="hljs-built_in">Unit</span> =        <span class="hljs-keyword">try</span> &#123;            coroutineScheduler.dispatch(block)        &#125; <span class="hljs-keyword">catch</span> (e: RejectedExecutionException) &#123;            <span class="hljs-comment">// CoroutineScheduler only rejects execution when it is being closed and this behavior is reserved</span>            <span class="hljs-comment">// for testing purposes, so we don&#x27;t have to worry about cancelling the affected Job here.</span>            DefaultExecutor.dispatch(context, block)        &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createScheduler</span><span class="hljs-params">()</span></span> = CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)        &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineScheduler</span>(    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME) : Executor, Closeable</code></pre></div><h2 id="Dispatchers-IO"><a href="#Dispatchers-IO" class="headerlink" title="Dispatchers.IO"></a>Dispatchers.IO</h2><p><code>Dispatchers.IO</code> 如注释所说的，是一个用以承载阻塞型 IO 操作的线程池，线程池是由上面说的 <code>CoroutineScheduler</code> 实现的，而它本身之所以叫做 <code>LimitingDispatcher</code> 是因为它限制了并发任务数为 64：</p><ul><li><code>inFlightTasks</code> 记录了并发任务数，如果小于阈值 <code>parallelism</code>（默认 64）则提交到线程池</li><li>否则将任务放到任务队列 <code>queue: ConcurrentLinkedQueue</code> 里，等提交到线程池的任务执行完自身逻辑，空出一个并发任务的位置后，再从 <code>queue</code> 里取一个等待中的任务提交到线程池</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The [CoroutineDispatcher] that is designed for offloading blocking IO tasks to a shared pool of threads.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Additional threads in this pool are created and are shutdown on demand.</span><span class="hljs-comment">     * The number of threads used by tasks in this dispatcher is limited by the value of</span><span class="hljs-comment">     * `kotlinx.coroutines.io.parallelism`&quot; ([IO_PARALLELISM_PROPERTY_NAME]) system property.</span><span class="hljs-comment">     * It defaults to the limit of 64 threads or the number of cores (whichever is larger).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Moreover, the maximum configurable number of threads is capped by the</span><span class="hljs-comment">     * `kotlinx.coroutines.scheduler.max.pool.size` system property.</span><span class="hljs-comment">     * If you need a higher number of parallel threads,</span><span class="hljs-comment">     * you should use a custom dispatcher backed by your own thread pool.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * ### Implementation note</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * This dispatcher shares threads with the [Default][Dispatchers.Default] dispatcher, so using</span><span class="hljs-comment">     * `withContext(Dispatchers.IO) &#123; ... &#125;` when already running on the [Default][Dispatchers.Default]</span><span class="hljs-comment">     * dispatcher does not lead to an actual switching to another thread &amp;mdash; typically execution</span><span class="hljs-comment">     * continues in the same thread.</span><span class="hljs-comment">     * As a result of thread sharing, more than 64 (default parallelism) threads can be created (but not used)</span><span class="hljs-comment">     * during operations over IO dispatcher.</span><span class="hljs-comment">     */</span>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = DefaultScheduler.IO&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher() &#123;    <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = LimitingDispatcher(        <span class="hljs-keyword">this</span>,        systemProp(IO_PARALLELISM_PROPERTY_NAME, <span class="hljs-number">64.</span>coerceAtLeast(AVAILABLE_PROCESSORS)), <span class="hljs-comment">// 64</span>        <span class="hljs-string">&quot;Dispatchers.IO&quot;</span>,        TASK_PROBABLY_BLOCKING <span class="hljs-comment">// 1</span>    )&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitingDispatcher</span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: ExperimentalCoroutineDispatcher,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parallelism: <span class="hljs-built_in">Int</span>,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> taskMode: <span class="hljs-built_in">Int</span>) : ExecutorCoroutineDispatcher(), TaskContext, Executor &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ConcurrentLinkedQueue&lt;Runnable&gt;()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> inFlightTasks = atomic(<span class="hljs-number">0</span>)    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> executor: Executor        <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">(command: <span class="hljs-type">Runnable</span>)</span></span> = dispatch(command, <span class="hljs-literal">false</span>)    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> = dispatch(block, <span class="hljs-literal">false</span>)    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: <span class="hljs-type">Runnable</span>, tailDispatch: <span class="hljs-type">Boolean</span>)</span></span> &#123;        <span class="hljs-keyword">var</span> taskToSchedule = block        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-comment">// Commit in-flight tasks slot</span>            <span class="hljs-keyword">val</span> inFlight = inFlightTasks.incrementAndGet()            <span class="hljs-comment">// Fast path, if parallelism limit is not reached, dispatch task and return</span>            <span class="hljs-keyword">if</span> (inFlight &lt;= parallelism) &#123;                dispatcher.dispatchWithContext(taskToSchedule, <span class="hljs-keyword">this</span>, tailDispatch)                <span class="hljs-keyword">return</span>            &#125;            <span class="hljs-comment">// Parallelism limit is reached, add task to the queue</span>            queue.add(taskToSchedule)            <span class="hljs-comment">/*</span><span class="hljs-comment">             * We&#x27;re not actually scheduled anything, so rollback committed in-flight task slot:</span><span class="hljs-comment">             * If the amount of in-flight tasks is still above the limit, do nothing</span><span class="hljs-comment">             * If the amount of in-flight tasks is lesser than parallelism, then</span><span class="hljs-comment">             * it&#x27;s a race with a thread which finished the task from the current context, we should resubmit the first task from the queue</span><span class="hljs-comment">             * to avoid starvation.</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * Race example #1 (TN is N-th thread, R is current in-flight tasks number), execution is sequential:</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * T1: submit task, start execution, R == 1</span><span class="hljs-comment">             * T2: commit slot for next task, R == 2</span><span class="hljs-comment">             * T1: finish T1, R == 1</span><span class="hljs-comment">             * T2: submit next task to local queue, decrement R, R == 0</span><span class="hljs-comment">             * Without retries, task from T2 will be stuck in the local queue</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span> (inFlightTasks.decrementAndGet() &gt;= parallelism) &#123;                <span class="hljs-keyword">return</span>            &#125;            taskToSchedule = queue.poll() ?: <span class="hljs-keyword">return</span>        &#125;    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchYield</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;        dispatch(block, tailDispatch = <span class="hljs-literal">true</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> name ?: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;super.toString()&#125;</span>[dispatcher = <span class="hljs-variable">$dispatcher</span>]&quot;</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Tries to dispatch tasks which were blocked due to reaching parallelism limit if there is any.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Implementation note: blocking tasks are scheduled in a fair manner (to local queue tail) to avoid</span><span class="hljs-comment">     * non-blocking continuations starvation.</span><span class="hljs-comment">     * E.g. for</span><span class="hljs-comment">     * ```</span><span class="hljs-comment">     * foo()</span><span class="hljs-comment">     * blocking()</span><span class="hljs-comment">     * bar()</span><span class="hljs-comment">     * ```</span><span class="hljs-comment">     * it&#x27;s more profitable to execute bar at the end of `blocking` rather than pending blocking task</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterTask</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">var</span> next = queue.poll()        <span class="hljs-comment">// If we have pending tasks in current blocking context, dispatch first</span>        <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;            dispatcher.dispatchWithContext(next, <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)            <span class="hljs-keyword">return</span>        &#125;        inFlightTasks.decrementAndGet()        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Re-poll again and try to submit task if it&#x27;s required otherwise tasks may be stuck in the local queue.</span><span class="hljs-comment">         * Race example #2 (TN is N-th thread, R is current in-flight tasks number), execution is sequential:</span><span class="hljs-comment">         * T1: submit task, start execution, R == 1</span><span class="hljs-comment">         * T2: commit slot for next task, R == 2</span><span class="hljs-comment">         * T1: finish T1, poll queue (it&#x27;s still empty), R == 2</span><span class="hljs-comment">         * T2: submit next task to the local queue, decrement R, R == 1</span><span class="hljs-comment">         * T1: decrement R, finish. R == 0</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * The task from T2 is stuck is the local queue</span><span class="hljs-comment">         */</span>        next = queue.poll() ?: <span class="hljs-keyword">return</span>        dispatch(next, <span class="hljs-literal">true</span>)    &#125;&#125;</code></pre></div><h2 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h2><p><code>Dispatchers.Main</code> 在 Android 代表主线程，也就说这个调度器会把任务放到主线程执行：<code>Handler.post</code></p><p>值得注意的是这里创建的是 <code>Async Handler</code>，<code>Async Handler</code> 创建的 <code>Message</code> 都是异步的：<code>Message.isAsynchronous() == true</code>，也就是说通过 <code>Dispatchers.Main</code> 调度的任务不会受到 <a href="../../../../2020/09/27/handler-messagequeue-looper/">同步栅栏</a> 的影响</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * A coroutine dispatcher that is confined to the Main thread operating with UI objects.</span><span class="hljs-comment">     * This dispatcher can be used either directly or via [MainScope] factory.</span><span class="hljs-comment">     * Usually such dispatcher is single-threaded.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Access to this property may throw [IllegalStateException] if no main thread dispatchers are present in the classpath.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Depending on platform and classpath it can be mapped to different dispatchers:</span><span class="hljs-comment">     * - On JS and Native it is equivalent of [Default] dispatcher.</span><span class="hljs-comment">     * - On JVM it is either Android main thread dispatcher, JavaFx or Swing EDT dispatcher. It is chosen by</span><span class="hljs-comment">     *   [`ServiceLoader`](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html).</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * In order to work with `Main` dispatcher, the following artifacts should be added to project runtime dependencies:</span><span class="hljs-comment">     *  - `kotlinx-coroutines-android` for Android Main thread dispatcher</span><span class="hljs-comment">     *  - `kotlinx-coroutines-javafx` for JavaFx Application thread dispatcher</span><span class="hljs-comment">     *  - `kotlinx-coroutines-swing` for Swing EDT dispatcher</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * In order to set a custom `Main` dispatcher for testing purposes, add the `kotlinx-coroutines-test` artifact to </span><span class="hljs-comment">     * project test dependencies.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * Implementation note: [MainCoroutineDispatcher.immediate] is not supported on Native and JS platforms.</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@JvmStatic</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> Main: MainCoroutineDispatcher <span class="hljs-keyword">get</span>() = MainDispatcherLoader.dispatcher&#125;<span class="hljs-comment">// Lazy loader for the main dispatcher</span><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> MainDispatcherLoader &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> FAST_SERVICE_LOADER_ENABLED = systemProp(FAST_SERVICE_LOADER_PROPERTY_NAME, <span class="hljs-literal">true</span>)    <span class="hljs-meta">@JvmField</span>    <span class="hljs-keyword">val</span> dispatcher: MainCoroutineDispatcher = loadMainDispatcher()    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcher</span><span class="hljs-params">()</span></span>: MainCoroutineDispatcher &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;                FastServiceLoader.loadMainDispatcherFactory()            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// We are explicitly using the</span>                <span class="hljs-comment">// `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`</span>                <span class="hljs-comment">// form of the ServiceLoader call to enable R8 optimization when compiled on Android.</span>                ServiceLoader.load(                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java,                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java.classLoader                ).iterator().asSequence().toList()            &#125;            <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;ConstantConditionIf&quot;</span>)</span>            factories.maxByOrNull &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)                ?: createMissingDispatcher()        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;            <span class="hljs-comment">// Service loader can throw an exception as well</span>            createMissingDispatcher(e)        &#125;    &#125;&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidDispatcherFactory</span> : <span class="hljs-type">MainDispatcherFactory</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(allFactories: <span class="hljs-type">List</span>&lt;<span class="hljs-type">MainDispatcherFactory</span>&gt;)</span></span> =        HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>))&#125;<span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Looper.<span class="hljs-title">asHandler</span><span class="hljs-params">(async: <span class="hljs-type">Boolean</span>)</span></span>: Handler &#123;    <span class="hljs-comment">// Async support was added in API 16.</span>    <span class="hljs-keyword">if</span> (!async || Build.VERSION.SDK_INT &lt; <span class="hljs-number">16</span>) &#123;        <span class="hljs-keyword">return</span> Handler(<span class="hljs-keyword">this</span>)    &#125;    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">28</span>) &#123;        <span class="hljs-comment">// TODO compile against API 28 so this can be invoked without reflection.</span>        <span class="hljs-keyword">val</span> factoryMethod = Handler::<span class="hljs-keyword">class</span>.java.getDeclaredMethod(<span class="hljs-string">&quot;createAsync&quot;</span>, Looper::<span class="hljs-keyword">class</span>.java)        <span class="hljs-keyword">return</span> factoryMethod.invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>) <span class="hljs-keyword">as</span> Handler    &#125;    <span class="hljs-keyword">val</span> <span class="hljs-keyword">constructor</span>: Constructor&lt;Handler&gt;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">constructor</span> = Handler::<span class="hljs-keyword">class</span>.java.getDeclaredConstructor(Looper::<span class="hljs-keyword">class</span>.java,            Handler.Callback::<span class="hljs-keyword">class</span>.java, <span class="hljs-built_in">Boolean</span>::<span class="hljs-keyword">class</span>.javaPrimitiveType)    &#125; <span class="hljs-keyword">catch</span> (ignored: NoSuchMethodException) &#123;        <span class="hljs-comment">// Hidden constructor absent. Fall back to non-async constructor.</span>        <span class="hljs-keyword">return</span> Handler(<span class="hljs-keyword">this</span>)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">constructor</span>.newInstance(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>)&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span>) : HandlerDispatcher(), Delay &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> (!handler.post(block)) &#123;            cancelOnRejection(context, block)        &#125;    &#125;&#125;</code></pre></div><h1 id="delay-非阻塞"><a href="#delay-非阻塞" class="headerlink" title="delay - 非阻塞"></a>delay - 非阻塞</h1><blockquote><p>Delays coroutine for a given time without blocking a thread and resumes it after a specified time.</p></blockquote><p>正如 <code>delay</code> 的函数文档所说，它是 <code>non-blocking</code> 的，那什么是非阻塞呢？如下代码所示，上面说过 <code>launch coroutine</code> 其实就是任务调度，下面的两个 <code>launch</code> 一共往任务队列放进两个任务，而 <code>runBlocking</code> 底层是单个线程，故两个任务是串行的：先执行 <code>delay(1000)</code> 再执行 <code>delay(500)</code>；然而 <code>500</code> 却先于 <code>1000</code> 输出，说明 <code>delay(1000)</code> 确实没有阻塞线程</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = runBlocking &#123;    launch &#123;        delay(<span class="hljs-number">1000</span>)        println(<span class="hljs-string">&quot;1000&quot;</span>)    &#125;    launch &#123;        delay(<span class="hljs-number">500</span>)        println(<span class="hljs-string">&quot;500&quot;</span>)    &#125;&#125;<span class="hljs-comment">// output:</span><span class="hljs-comment">// 500</span><span class="hljs-comment">// 1000</span></code></pre></div><p>跟踪 <code>delay</code> 看看它是怎么实现的，但到 <code>suspendCoroutineUninterceptedOrReturn</code> 就走不下去了因为这个函数并没有什么实质的 body，那就直接看编译后的字节码吧</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// don&#x27;t delay</span>    <span class="hljs-keyword">return</span> suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;        <span class="hljs-comment">// if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don&#x27;t schedule.</span>        <span class="hljs-keyword">if</span> (timeMillis &lt; <span class="hljs-built_in">Long</span>.MAX_VALUE) &#123;            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: T =    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)        <span class="hljs-comment">/*</span><span class="hljs-comment">         * For non-atomic cancellation we setup parent-child relationship immediately</span><span class="hljs-comment">         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but</span><span class="hljs-comment">         * properly supports cancellation.</span><span class="hljs-comment">         */</span>        cancellable.initCancellability()        block(cancellable)        cancellable.getResult()    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCoroutineUninterceptedOrReturn</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Any</span>?)</span></span>: T &#123;    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;    <span class="hljs-keyword">throw</span> NotImplementedError(<span class="hljs-string">&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;</span>)&#125;</code></pre></div><p>用 <code>bytecode-viewer</code> 打开如下，关键代码是这一行：<code>getDelay(cont.getContext()).scheduleResumeAfterDelay(timeMillis, cont)</code></p><ul><li>从 context 里取 <code>Delay</code>，key 是 <code>ContinuationInterceptor.Key</code>，咦这不就是上一章节讨论的 <code>Dispatcher</code> 的 key 嘛！也就是说 <code>delay</code> 有可能是由 Dispatcher 实现的</li><li>如果 Dispatcher 没有实现 <code>Delay</code> 接口则由 <code>DefaultDelay</code> 负责</li></ul><p>那么就一个个 Dispatcher 地看吧</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example_basic_01Kt$main$1$1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuspendLambda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function2</span> &#123;   <span class="hljs-meta">@Nullable</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> &#123;      <span class="hljs-type">Object</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.label) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:         ResultKt.throwOnFailure($result);         <span class="hljs-type">Continuation</span> <span class="hljs-variable">var10001</span> <span class="hljs-operator">=</span> (Continuation)<span class="hljs-built_in">this</span>;         <span class="hljs-built_in">this</span>.label = <span class="hljs-number">1</span>;         <span class="hljs-keyword">if</span> (DelayKt.delay(<span class="hljs-number">1000L</span>, var10001) == var4) &#123;            <span class="hljs-keyword">return</span> var4;         &#125;         <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:         ResultKt.throwOnFailure($result);         <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>:         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);      &#125;      <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1000&quot;</span>;      <span class="hljs-type">boolean</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;      System.out.println(var2);      <span class="hljs-keyword">return</span> Unit.INSTANCE;   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayKt</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">delay</span><span class="hljs-params">(<span class="hljs-type">long</span> timeMillis, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> &#123;      <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0L</span>) &#123;         <span class="hljs-keyword">return</span> Unit.INSTANCE;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$suspendCancellableCoroutine</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;         <span class="hljs-type">int</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;         <span class="hljs-type">CancellableContinuationImpl</span> <span class="hljs-variable">cancellable$iv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellableContinuationImpl</span>(IntrinsicsKt.intercepted($completion), <span class="hljs-number">1</span>);         cancellable$iv.initCancellability();         <span class="hljs-type">CancellableContinuation</span> <span class="hljs-variable">cont</span> <span class="hljs-operator">=</span> (CancellableContinuation)cancellable$iv;         <span class="hljs-type">int</span> <span class="hljs-variable">var8</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;         <span class="hljs-keyword">if</span> (timeMillis &lt; Long.MAX_VALUE) &#123;            getDelay(cont.getContext()).scheduleResumeAfterDelay(timeMillis, cont);         &#125;         <span class="hljs-type">Object</span> <span class="hljs-variable">var10000</span> <span class="hljs-operator">=</span> cancellable$iv.getResult();         <span class="hljs-keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;            DebugProbesKt.probeCoroutineSuspended($completion);         &#125;         <span class="hljs-keyword">return</span> var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED() ? var10000 : Unit.INSTANCE;      &#125;   &#125;   <span class="hljs-meta">@NotNull</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Delay <span class="hljs-title function_">getDelay</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> CoroutineContext $<span class="hljs-built_in">this</span>$delay)</span> &#123;      <span class="hljs-type">Element</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> $<span class="hljs-built_in">this</span>$delay.get((Key)ContinuationInterceptor.Key);      <span class="hljs-type">Delay</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> var2 <span class="hljs-keyword">instanceof</span> Delay ? (Delay)var2 : <span class="hljs-literal">null</span>;      <span class="hljs-keyword">return</span> var1 == <span class="hljs-literal">null</span> ? DefaultExecutorKt.getDefaultDelay() : var1;   &#125;   &#125;</code></pre></div><h2 id="BlockingEventLoop"><a href="#BlockingEventLoop" class="headerlink" title="BlockingEventLoop"></a>BlockingEventLoop</h2><p>block 被层层包装为 <code>DelayedResumeTask</code> 并被放入 <code>_delayed: atomic&lt;DelayedTaskQueue?&gt;</code>，等待在 <code>delay</code> 毫秒后重新调度，类似于 <code>Handler.postDelayed(r, delayMillis)</code>，可重新调度任务后 block 不就重新被执行了一遍吗？</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingEventLoop</span>(    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> thread: Thread) : EventLoopImplBase()<span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopImplBase</span>: <span class="hljs-type">EventLoopImplPlatform</span>(), Delay &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;            <span class="hljs-keyword">val</span> now = nanoTime()            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt;                continuation.disposeOnCancellation(task)                schedule(now, task)            &#125;        &#125;    &#125;         <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayedTask: <span class="hljs-type">DelayedTask</span>)</span></span> &#123;        <span class="hljs-keyword">when</span> (scheduleImpl(now, delayedTask)) &#123;            SCHEDULE_OK -&gt; <span class="hljs-keyword">if</span> (shouldUnpark(delayedTask)) unpark()            SCHEDULE_COMPLETED -&gt; reschedule(now, delayedTask)            SCHEDULE_DISPOSED -&gt; &#123;&#125; <span class="hljs-comment">// do nothing -- task was already disposed</span>            <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;unexpected result&quot;</span>)        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleImpl</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayedTask: <span class="hljs-type">DelayedTask</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;        <span class="hljs-keyword">if</span> (isCompleted) <span class="hljs-keyword">return</span> SCHEDULE_COMPLETED        <span class="hljs-keyword">val</span> delayedQueue = _delayed.value ?: run &#123;            _delayed.compareAndSet(<span class="hljs-literal">null</span>, DelayedTaskQueue(now))            _delayed.value!!        &#125;        <span class="hljs-keyword">return</span> delayedTask.scheduleTask(now, delayedQueue, <span class="hljs-keyword">this</span>)    &#125;        &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedTask</span> &#123;    <span class="hljs-meta">@Synchronized</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleTask</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayed: <span class="hljs-type">DelayedTaskQueue</span>, eventLoop: <span class="hljs-type">EventLoopImplBase</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;        <span class="hljs-keyword">if</span> (_heap === DISPOSED_TASK) <span class="hljs-keyword">return</span> SCHEDULE_DISPOSED <span class="hljs-comment">// don&#x27;t add -- was already disposed</span>        delayed.addLastIf(<span class="hljs-keyword">this</span>) &#123; firstTask -&gt;            <span class="hljs-keyword">if</span> (eventLoop.isCompleted) <span class="hljs-keyword">return</span> SCHEDULE_COMPLETED <span class="hljs-comment">// non-local return from scheduleTask</span>            <span class="hljs-comment">/**</span><span class="hljs-comment">             * We are about to add new task and we have to make sure that [DelayedTaskQueue]</span><span class="hljs-comment">             * invariant is maintained. The code in this lambda is additionally executed under</span><span class="hljs-comment">             * the lock of [DelayedTaskQueue] and working with [DelayedTaskQueue.timeNow] here is thread-safe.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span> (firstTask == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * When adding the first delayed task we simply update queue&#x27;s [DelayedTaskQueue.timeNow] to</span><span class="hljs-comment">                 * the current now time even if that means &quot;going backwards in time&quot;. This makes the structure</span><span class="hljs-comment">                 * self-correcting in spite of wild jumps in `nanoTime()` measurements once all delayed tasks</span><span class="hljs-comment">                 * are removed from the delayed queue for execution.</span><span class="hljs-comment">                 */</span>                delayed.timeNow = now            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * Carefully update [DelayedTaskQueue.timeNow] so that it does not sweep past first&#x27;s tasks time</span><span class="hljs-comment">                 * and only goes forward in time. We cannot let it go backwards in time or invariant can be</span><span class="hljs-comment">                 * violated for tasks that were already scheduled.</span><span class="hljs-comment">                 */</span>                <span class="hljs-keyword">val</span> firstTime = firstTask.nanoTime                <span class="hljs-comment">// compute min(now, firstTime) using a wrap-safe check</span>                <span class="hljs-keyword">val</span> minTime = <span class="hljs-keyword">if</span> (firstTime - now &gt;= <span class="hljs-number">0</span>) now <span class="hljs-keyword">else</span> firstTime                <span class="hljs-comment">// update timeNow only when going forward in time</span>                <span class="hljs-keyword">if</span> (minTime - delayed.timeNow &gt; <span class="hljs-number">0</span>) delayed.timeNow = minTime            &#125;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * Here [DelayedTaskQueue.timeNow] was already modified and we have to double-check that newly added</span><span class="hljs-comment">             * task does not violate [DelayedTaskQueue] invariant because of that. Note also that this scheduleTask</span><span class="hljs-comment">             * function can be called to reschedule from one queue to another and this might be another reason</span><span class="hljs-comment">             * where new task&#x27;s time might now violate invariant.</span><span class="hljs-comment">             * We correct invariant violation (if any) by simply changing this task&#x27;s time to now.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span> (nanoTime - delayed.timeNow &lt; <span class="hljs-number">0</span>) nanoTime = delayed.timeNow            <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">return</span> SCHEDULE_OK    &#125;    &#125;</code></pre></div><p>上面的例子一个 block 里只有一个 <code>delay</code>，规律不明显，添加多个 <code>delay</code> 就能看出端倪了：</p><ul><li><code>delay</code> 前的代码段被逐个编号：1, 2, 3…</li><li>引入成员属性 <code>label</code>，执行 block 时根据 <code>label</code> 的指示通过 <code>switch</code> 跳转执行各个代码段</li><li>重新调度时执行完的代码段就不会被再次执行了</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// kotlin</span>fun <span class="hljs-title function_">main</span><span class="hljs-params">()</span>: Unit = runBlocking &#123;    println(<span class="hljs-number">0</span>)    delay(<span class="hljs-number">100</span>)    println(<span class="hljs-number">100</span>)    delay(<span class="hljs-number">200</span>)    println(<span class="hljs-number">200</span>)    delay(<span class="hljs-number">300</span>)    println(<span class="hljs-number">300</span>)    delay(<span class="hljs-number">400</span>)    println(<span class="hljs-number">400</span>)&#125;<span class="hljs-comment">// decompile by CFR</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example_basic_01Kt</span>.main<span class="hljs-number">.1</span><span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuspendLambda</span><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function2</span>&lt;CoroutineScope, Continuation&lt;? <span class="hljs-built_in">super</span> Unit&gt;, Object&gt; &#123;        <span class="hljs-type">int</span> label;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Unable to fully structure code</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object var1_1)</span> &#123;        var4_2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();        <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.label) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: &#123;                ResultKt.throwOnFailure((Object)var1_1);                var2_3 = <span class="hljs-number">0</span>;                var3_4 = <span class="hljs-literal">false</span>;                System.out.println(var2_3);                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">1</span>;                v0 = DelayKt.delay((<span class="hljs-type">long</span>)<span class="hljs-number">100L</span>, (Continuation)((Continuation)<span class="hljs-built_in">this</span>));                <span class="hljs-keyword">if</span> (v0 == var4_2) &#123;                    <span class="hljs-keyword">return</span> var4_2;                &#125;                ** GOTO lbl16            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;                ResultKt.throwOnFailure((Object)$result);                v0 = $result;lbl16:                <span class="hljs-comment">// 2 sources</span>                var2_3 = <span class="hljs-number">100</span>;                var3_4 = <span class="hljs-literal">false</span>;                System.out.println(var2_3);                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">2</span>;                v1 = DelayKt.delay((<span class="hljs-type">long</span>)<span class="hljs-number">200L</span>, (Continuation)((Continuation)<span class="hljs-built_in">this</span>));                <span class="hljs-keyword">if</span> (v1 == var4_2) &#123;                    <span class="hljs-keyword">return</span> var4_2;                &#125;                ** GOTO lbl27            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;                ResultKt.throwOnFailure((Object)$result);                v1 = $result;lbl27:                <span class="hljs-comment">// 2 sources</span>                var2_3 = <span class="hljs-number">200</span>;                var3_4 = <span class="hljs-literal">false</span>;                System.out.println(var2_3);                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">3</span>;                v2 = DelayKt.delay((<span class="hljs-type">long</span>)<span class="hljs-number">300L</span>, (Continuation)((Continuation)<span class="hljs-built_in">this</span>));                <span class="hljs-keyword">if</span> (v2 == var4_2) &#123;                    <span class="hljs-keyword">return</span> var4_2;                &#125;                ** GOTO lbl38            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;                ResultKt.throwOnFailure((Object)$result);                v2 = $result;lbl38:                <span class="hljs-comment">// 2 sources</span>                var2_3 = <span class="hljs-number">300</span>;                var3_4 = <span class="hljs-literal">false</span>;                System.out.println(var2_3);                <span class="hljs-built_in">this</span>.label = <span class="hljs-number">4</span>;                v3 = DelayKt.delay((<span class="hljs-type">long</span>)<span class="hljs-number">400L</span>, (Continuation)((Continuation)<span class="hljs-built_in">this</span>));                <span class="hljs-keyword">if</span> (v3 == var4_2) &#123;                    <span class="hljs-keyword">return</span> var4_2;                &#125;                ** GOTO lbl49            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: &#123;                ResultKt.throwOnFailure((Object)$result);                v3 = $result;lbl49:                <span class="hljs-comment">// 2 sources</span>                var2_3 = <span class="hljs-number">400</span>;                var3_4 = <span class="hljs-literal">false</span>;                System.out.println(var2_3);                <span class="hljs-keyword">return</span> Unit.INSTANCE;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);    &#125;&#125;</code></pre></div><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>coroutine 本质是任务队列，而 <code>delay</code> 本质是重新调度（重新入队至 <code>EventLoopImplBase._delay</code>），通过引入成员属性 <code>label</code>，以及将各个代码段用 <code>switch</code> 分段，即可实现在重新调度时跳转到指定 <code>代码行</code> 而不重复执行前面的代码</p><h2 id="HandlerContext"><a href="#HandlerContext" class="headerlink" title="HandlerContext"></a>HandlerContext</h2><p><code>Dispatchers.Main</code> 在 Android 上是底层为单线程/主线程的 <code>HandlerContext(Looper.getMainLooper().asHandler(async = true))</code>，它实现了 <code>Delay</code>，通过 <code>Handler.postDelayed</code> 实现重新调度</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span>) : HandlerDispatcher(), Delay &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;        <span class="hljs-keyword">val</span> block = Runnable &#123;            with(continuation) &#123; resumeUndispatched(<span class="hljs-built_in">Unit</span>) &#125;        &#125;        <span class="hljs-keyword">if</span> (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) &#123;            continuation.invokeOnCancellation &#123; handler.removeCallbacks(block) &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            cancelOnRejection(continuation.context, block)        &#125;    &#125;    &#125;</code></pre></div><h2 id="DefaultDelay"><a href="#DefaultDelay" class="headerlink" title="DefaultDelay"></a>DefaultDelay</h2><p><code>Dispatchers.Default</code> 和 <code>Dispatcher.IO</code> 并没有实现 <code>Delay</code> 接口，如上面反编译后的 <code>getDelay</code> 所示，是由 <code>DefaultDelay</code> 来实现的</p><p><code>EventLoopImplBase</code> 在上一章节介绍过，它实现了 <code>Delay</code> 接口，<code>EventLoopImplBase.scheduleResumeAfterDelay</code> 会将任务放入 <code>EventLoopImplBase._delay</code> 任务队列，也就是说这两个调度器上的 delay task 实际上是被放入别人的（<code>DefaultDelay</code>） delay queue 里</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> DefaultDelay: Delay = DefaultExecutor<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> DefaultExecutor : EventLoopImplBase(), Runnable</code></pre></div><p>那这些 delay task 不就被改变了 Dispatcher，跑到 <code>DefaultDelay/DefaultExecutor</code> 里执行了吗？我们从 <code>Delay.scheduleResumeAfterDelay</code> 看下去：</p><ul><li>task 被加入到 <code>_delay</code> 任务队列，然后唤醒对应的线程 <code>DefaultExecutor.run</code></li><li><code>DefaultExecutor</code> 将 <code>_delay</code> 里第一个到执行时间点的 task 转移到任务队列 <code>_queue</code> 并执行</li></ul><p>而任务队列里的 <code>Runnable</code> 实际上是 <code>DispatchedContinuation</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopImplBase</span>: <span class="hljs-type">EventLoopImplPlatform</span>(), Delay &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;            <span class="hljs-keyword">val</span> now = nanoTime()            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt;                continuation.disposeOnCancellation(task)                schedule(now, task)            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">schedule</span><span class="hljs-params">(now: <span class="hljs-type">Long</span>, delayedTask: <span class="hljs-type">DelayedTask</span>)</span></span> &#123;        <span class="hljs-keyword">when</span> (scheduleImpl(now, delayedTask)) &#123;            SCHEDULE_OK -&gt; <span class="hljs-keyword">if</span> (shouldUnpark(delayedTask)) unpark()            SCHEDULE_COMPLETED -&gt; reschedule(now, delayedTask)            SCHEDULE_DISPOSED -&gt; &#123;&#125; <span class="hljs-comment">// do nothing -- task was already disposed</span>            <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;unexpected result&quot;</span>)        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldUnpark</span><span class="hljs-params">(task: <span class="hljs-type">DelayedTask</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = _delayed.value?.peek() === task    &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopImplPlatform</span>: <span class="hljs-type">EventLoop</span>() &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> thread: Thread    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">val</span> thread = thread <span class="hljs-comment">// atomic read</span>        <span class="hljs-keyword">if</span> (Thread.currentThread() !== thread)            unpark(thread)    &#125;&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> DefaultExecutor: EventLoopImplBase(), Delay &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;        ThreadLocalEventLoop.setEventLoop(<span class="hljs-keyword">this</span>)        registerTimeLoopThread()        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">var</span> shutdownNanos = <span class="hljs-built_in">Long</span>.MAX_VALUE            <span class="hljs-keyword">if</span> (!notifyStartup()) <span class="hljs-keyword">return</span>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                Thread.interrupted() <span class="hljs-comment">// just reset interruption flag</span>                <span class="hljs-keyword">var</span> parkNanos = processNextEvent()                <span class="hljs-keyword">if</span> (parkNanos == <span class="hljs-built_in">Long</span>.MAX_VALUE) &#123;                    <span class="hljs-comment">// nothing to do, initialize shutdown timeout</span>                    <span class="hljs-keyword">val</span> now = nanoTime()                    <span class="hljs-keyword">if</span> (shutdownNanos == <span class="hljs-built_in">Long</span>.MAX_VALUE) shutdownNanos = now + KEEP_ALIVE_NANOS                    <span class="hljs-keyword">val</span> tillShutdown = shutdownNanos - now                    <span class="hljs-keyword">if</span> (tillShutdown &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// shut thread down</span>                    parkNanos = parkNanos.coerceAtMost(tillShutdown)                &#125; <span class="hljs-keyword">else</span>                    shutdownNanos = <span class="hljs-built_in">Long</span>.MAX_VALUE                <span class="hljs-keyword">if</span> (parkNanos &gt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// check if shutdown was requested and bail out in this case</span>                    <span class="hljs-keyword">if</span> (isShutdownRequested) <span class="hljs-keyword">return</span>                    parkNanos(<span class="hljs-keyword">this</span>, parkNanos)                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            _thread = <span class="hljs-literal">null</span> <span class="hljs-comment">// this thread is dead</span>            acknowledgeShutdownIfNeeded()            unregisterTimeLoopThread()            <span class="hljs-comment">// recheck if queues are empty after _thread reference was set to null (!!!)</span>            <span class="hljs-keyword">if</span> (!isEmpty) thread <span class="hljs-comment">// recreate thread if it is needed</span>        &#125;    &#125;    &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopImplBase</span>: <span class="hljs-type">EventLoopImplPlatform</span>(), Delay &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processNextEvent</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Long</span> &#123;        <span class="hljs-comment">// unconfined events take priority</span>        <span class="hljs-keyword">if</span> (processUnconfinedEvent()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-comment">// queue all delayed tasks that are due to be executed</span>        <span class="hljs-keyword">val</span> delayed = _delayed.value        <span class="hljs-keyword">if</span> (delayed != <span class="hljs-literal">null</span> &amp;&amp; !delayed.isEmpty) &#123;            <span class="hljs-keyword">val</span> now = nanoTime()            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-comment">// make sure that moving from delayed to queue removes from delayed only after it is added to queue</span>                <span class="hljs-comment">// to make sure that &#x27;isEmpty&#x27; and `nextTime` that check both of them</span>                <span class="hljs-comment">// do not transiently report that both delayed and queue are empty during move</span>                delayed.removeFirstIf &#123;                    <span class="hljs-keyword">if</span> (it.timeToExecute(now)) &#123;                        enqueueImpl(it)                    &#125; <span class="hljs-keyword">else</span>                        <span class="hljs-literal">false</span>                &#125; ?: <span class="hljs-keyword">break</span> <span class="hljs-comment">// quit loop when nothing more to remove or enqueueImpl returns false on &quot;isComplete&quot;</span>            &#125;        &#125;        <span class="hljs-comment">// then process one event from queue</span>        <span class="hljs-keyword">val</span> task = dequeue()        <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;            task.run()            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        <span class="hljs-keyword">return</span> nextTime    &#125;     &#125;</code></pre></div><p>上面曾经说过 block 会经过重重包装，其中一层就是 <code>DispatchedContinuation</code>，它也是一个 <code>Runnable</code>（被 <code>DefaultExecutor</code> 执行）：<code>SchedulerTask.run</code> -&gt;  <code>DispatchedContinuation.resumeWith</code> -&gt; <code>CoroutineDispatcher.dispatch</code></p><p>也就说 <code>DispatchedContinuation</code> = <code>CoroutineDispatcher</code> + <code>Continuation</code>，它被执行时是将任务交由对应的 Dispatcher 执行而不是由当前的线程执行（正如它的名字描述的那样），同时也实现了一个很重要的概念：<code>线程切换</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchedContinuation</span>&lt;<span class="hljs-type">in T</span>&gt;(    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> dispatcher: CoroutineDispatcher,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation<span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchedTask</span>&lt;<span class="hljs-type">in T</span>&gt;(    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> resumeMode: <span class="hljs-built_in">Int</span>) : SchedulerTask() &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;        assert &#123; resumeMode != MODE_UNINITIALIZED &#125; <span class="hljs-comment">// should have been set before dispatching</span>        <span class="hljs-keyword">val</span> taskContext = <span class="hljs-keyword">this</span>.taskContext        <span class="hljs-keyword">var</span> fatalException: Throwable? = <span class="hljs-literal">null</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">val</span> delegate = delegate <span class="hljs-keyword">as</span> DispatchedContinuation&lt;T&gt;            <span class="hljs-keyword">val</span> continuation = delegate.continuation            withContinuationContext(continuation, delegate.countOrElement) &#123;                <span class="hljs-keyword">val</span> context = continuation.context                <span class="hljs-keyword">val</span> state = takeState() <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Must take state in any case, even if cancelled</span>                <span class="hljs-keyword">val</span> exception = getExceptionalResult(state)                <span class="hljs-comment">/*</span><span class="hljs-comment">                 * Check whether continuation was originally resumed with an exception.</span><span class="hljs-comment">                 * If so, it dominates cancellation, otherwise the original exception</span><span class="hljs-comment">                 * will be silently lost.</span><span class="hljs-comment">                 */</span>                <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>                <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) &#123;                    <span class="hljs-keyword">val</span> cause = job.getCancellationException()                    cancelCompletedResult(state, cause)                    continuation.resumeWithStackTrace(cause)                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;                        continuation.resumeWithException(exception)                    &#125; <span class="hljs-keyword">else</span> &#123;                        continuation.resume(getSuccessfulResult(state))                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;            <span class="hljs-comment">// This instead of runCatching to have nicer stacktrace and debug experience</span>            fatalException = e        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;            handleFatalException(fatalException, result.exceptionOrNull())        &#125;    &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> =    resumeWith(Result.success(value))<span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchedContinuation</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;        <span class="hljs-keyword">val</span> context = continuation.context        <span class="hljs-keyword">val</span> state = result.toState()        <span class="hljs-keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;            _state = state            resumeMode = MODE_ATOMIC            dispatcher.dispatch(context, <span class="hljs-keyword">this</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            executeUnconfined(state, MODE_ATOMIC) &#123;                withCoroutineContext(<span class="hljs-keyword">this</span>.context, countOrElement) &#123;                    continuation.resumeWith(result)                &#125;            &#125;        &#125;    &#125;    &#125;</code></pre></div><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>coroutine API 很多都需要上下文 context，但作为参数传来穿去总是麻烦，于是有了 <code>CoroutineScope</code> 用以承载上下文：</p><ul><li><code>runBlocking</code> - 用当前线程作为调度器，会阻塞代码的执行直到所有协程都执行完毕</li><li><code>CoroutineScope(EmptyCoroutineContext|Dispatchers.Main|Dispatchers.IO|...)</code> - 构造 scope，使用指定的上下文/调度器，如果上下文里不包含调度器则使用默认的 <code>Dispatchers.Default</code></li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineScope</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The context of this scope.</span><span class="hljs-comment">     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.</span><span class="hljs-comment">     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>coroutine</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 ANR：产生的根源、处理流程和日志文件</title>
    <link href="/2021/07/10/deep-drive-into-anr/"/>
    <url>/2021/07/10/deep-drive-into-anr/</url>
    
    <content type="html"><![CDATA[<h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>在 <a href="../../../../2020/10/20/anr/">阅读源码系列：ANR 是怎么产生的</a> 聊过不及时消费 input event 会产生 <code>ANR</code>：</p><ol><li><code>InputReaderThread</code> 不断地从 <code>/dev/input</code> 读取 input event 并放入 <code>InputDispatcher.mInboundQueue</code> 等待分发</li><li><code>InputDispatcher</code> 寻找 input event 对应的 window 并分发到它的待发送队列里（<code>outboundQueue</code>）</li><li>input event 通过 socket 发送给 app process 后转移到待消费队列（<code>waitQueue</code>）</li><li>app main thread 在 <code>Choreographer.doFrame</code> 渲染一帧时首先会响应 input event 并通过 socket 告诉 <code>InputDispatcher</code> 从待消费队列里移除</li><li>在执行第二步的过程中，如果发现 window 存在有未消费的 input event 则产生 ANR</li></ol><p><code>产生 ANR - 输出 ANR 日志 - 弹出 ANR 对话框</code> 整个流程的方法栈如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">InputDispatcher::start</span><span class="hljs-function">InputDispatcher::dispatchOnce</span><span class="hljs-function">InputDispatcher::processAnrsLocked</span><span class="hljs-function"><span class="hljs-title">InputDispatcher::onAnrLocked</span><span class="hljs-params">(<span class="hljs-type">const</span> Connection&amp; connection)</span></span><span class="hljs-function">InputDispatcher::doNotifyAnrLockedInterruptible</span><span class="hljs-function">NativeInputManager::notifyAnr</span><span class="hljs-function">InputManagerService.<span class="hljs-title">notifyANR</span><span class="hljs-params">(InputApplicationHandle inputApplicationHandle, IBinder token, String reason)</span></span><span class="hljs-function">InputManagerCallback.notifyANR</span><span class="hljs-function">InputManagerCallback.notifyANRInner</span><span class="hljs-function">ActivityManagerService.inputDispatchingTimedOut</span><span class="hljs-function">AnrHelper.appNotResponding</span><span class="hljs-function">AnrRecord.appNotResponding</span><span class="hljs-function">ProcessErrorStateRecord.appNotResponding</span><span class="hljs-function">ActivityManagerService.UiHandler.<span class="hljs-title">handleMessage</span><span class="hljs-params">(SHOW_NOT_RESPONDING_UI_MSG)</span></span><span class="hljs-function">AppErrors.handleShowAnrUi</span><span class="hljs-function">ProcessRecord.ErrorDialogController.showAnrDialogs</span></code></pre></div><h1 id="logcat-system"><a href="#logcat-system" class="headerlink" title="logcat system"></a>logcat system</h1><blockquote><p><code>adb logcat -v threadtime &gt; logcat</code></p><p><code>-b</code> 指定 ring buffer，默认是 <code>main</code>, <code>system</code> 和 <code>crash</code></p></blockquote><p>从上面的代码可以看到 logcat system 里会输出一段 ANR 日志如下，包含以下几部分的信息（它们的次序可能会有所变化）：</p><ol><li><code>ANR</code> 关键字</li><li>发生 ANR 的 app process name 及 android component name</li><li>app process id</li><li>原因/描述（看得出来这是由于没有及时消费 input event 而产生的 ANR）</li><li>parent component (?)</li><li><code>Load: 0.17 / 0.44 / 0.71</code> 读取自 <code>/proc/loadavg</code>，表示 1, 5 和 15 分钟内的系统平均负载</li><li>内存压力统计信息（Pressure Stall Information），读取自 <code>/proc/pressure/memory</code>，表示任务阻塞在内存资源上的总时长</li><li>最近几个采集点之间的 CPU 使用率（CPU Usage）</li></ol><div class="code-wrapper"><pre><code class="hljs log"># from mi 909-29 16:03:03.457  1763 29602 E ActivityManager: ANR in com.example.myapplication (com.example.myapplication/.MainActivity)09-29 16:03:03.457  1763 29602 E ActivityManager: PID: 2775009-29 16:03:03.457  1763 29602 E ActivityManager: Reason: Input dispatching timed out (com.example.myapplication/com.example.myapplication.MainActivity, 23ec514 com.example.myapplication/com.example.myapplication.MainActivity (server) is not responding. Waited 8008ms for MotionEvent(action=DOWN))09-29 16:03:03.457  1763 29602 E ActivityManager: Parent: com.example.myapplication/.MainActivity09-29 16:03:03.457  1763 29602 E ActivityManager: Load: 0.17 / 0.44 / 0.7109-29 16:03:03.457  1763 29602 E ActivityManager: ----- Output from /proc/pressure/memory -----09-29 16:03:03.457  1763 29602 E ActivityManager: some avg10=0.00 avg60=0.00 avg300=0.02 total=3299562509-29 16:03:03.457  1763 29602 E ActivityManager: full avg10=0.00 avg60=0.00 avg300=0.00 total=1159118309-29 16:03:03.457  1763 29602 E ActivityManager: ----- End output from /proc/pressure/memory -----09-29 16:03:03.457  1763 29602 E ActivityManager:09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 0ms to 14680ms later (2021-09-29 16:02:48.726 to 2021-09-29 16:03:03.406):09-29 16:03:03.457  1763 29602 E ActivityManager:   32% 8356/com.taobao.taobao: 17% user + 15% kernel / faults: 9334 minor 85 major09-29 16:03:03.457  1763 29602 E ActivityManager:   27% 19687/com.tencent.mm: 12% user + 15% kernel / faults: 14028 minor 129 major09-29 16:03:03.457  1763 29602 E ActivityManager:   13% 1763/system_server: 5.8% user + 7.5% kernel / faults: 7732 minor 29 major09-29 16:03:03.457  1763 29602 E ActivityManager:   12% 1464/media.codec: 8.5% user + 4.2% kernel / faults: 39180 minor 6 major09-29 16:03:03.457  1763 29602 E ActivityManager:   5.1% 969/surfaceflinger: 1.1% user + 3.9% kernel / faults: 582 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   4% 26354/com.xiaomi.mi_connect_service: 2.8% user + 1.1% kernel / faults: 2438 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1569/media.swcodec: 0% user + 0% kernel / faults: 21304 minor 8 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 876/media.hwcodec: 0% user + 0% kernel / faults: 6726 minor 20 major09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 23059/kworker/u16:10: 0% user + 2.3% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 5410/com.sohu.inputmethod.sogou: 1.3% user + 0.9% kernel / faults: 2961 minor 53 major09-29 16:03:03.457  1763 29602 E ActivityManager:   2% 2847/com.android.phone: 1.2% user + 0.7% kernel / faults: 2180 minor 12 major09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 1283/adbd: 0.5% user + 1.1% kernel / faults: 3 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 1362/cnss_diag: 1.3% user + 0.3% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 22809/kworker/u16:2: 0% user + 1.7% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.2% 22965/kworker/u16:7: 0% user + 1.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1410/media.extractor: 0% user + 0% kernel / faults: 4053 minor 8 major09-29 16:03:03.457  1763 29602 E ActivityManager:   1% 2239/cds_ol_rx_threa: 0% user + 1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1% 21236/kworker/u16:3: 0% user + 1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.9% 22805/kworker/u16:1: 0% user + 0.9% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 150/kswapd0: 0% user + 0.8% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 582/logd: 0.4% user + 0.3% kernel / faults: 1 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 596/android.hardware.keymaster@4.0-service-qti: 0% user + 0.8% kernel / faults: 15 minor 4 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 795/android.hardware.camera.provider@2.4-service_64: 0% user + 0.8% kernel / faults: 74 minor 29 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 835/android.hardware.sensors@1.0-service: 0.4% user + 0.3% kernel / faults: 298 minor 15 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 4647/com.android.nfc: 0.4% user + 0.3% kernel / faults: 1060 minor 4 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.7% 26974/com.miui.player: 0.2% user + 0.5% kernel / faults: 6 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 530/irq/303-fts: 0% user + 0.6% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 5337/com.miui.analytics: 0.2% user + 0.4% kernel / faults: 363 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 23277/com.smile.gifmaker: 0.4% user + 0.2% kernel / faults: 119 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.5% 492/crtc_commit:131: 0% user + 0.5% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.5% 693/netd: 0.1% user + 0.4% kernel / faults: 208 minor 10 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 8387/com.taobao.taobao:channel: 0.3% user + 0.1% kernel / faults: 53 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 27750/com.example.myapplication: 0.4% user + 0% kernel / faults: 1733 minor 17 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 861/vendor.qti.hardware.perf@2.2-service: 0.1% user + 0.2% kernel / faults: 54 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 27850/com.android.browser: 0.1% user + 0.2% kernel / faults: 117 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 9/rcu_preempt: 0% user + 0.3% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 21238/kworker/u16:13: 0% user + 0.3% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 26155/mdnsd: 0.2% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 10/rcu_sched: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 842/android.hardware.wifi@1.0-service: 0.1% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 2457/com.android.systemui: 0.2% user + 0% kernel / faults: 80 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 25386/com.tencent.mm:appbrand0: 0.2% user + 0% kernel / faults: 20 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 26203/com.smile.gifmaker:messagesdk: 0.2% user + 0% kernel / faults: 11 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 26730/logcat: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 1/init: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 12/rcuop/0: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 13/rcuos/0: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 584/servicemanager: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 664/jbd2/sda31-8: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 685/tombstoned: 0% user + 0% kernel / faults: 26 minor 52 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 958/audioserver: 0% user + 0.1% kernel / faults: 89 minor 3 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 3509/irq/33-90cd000.: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 18880/kworker/u16:4: 0% user + 0.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 22/rcuop/1: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 30/rcuop/2: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 46/rcuop/4: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 652/ipacm: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 653/android.system.suspend@1.0-service: 0.1% user + 0% kernel / faults: 70 minor 7 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 692/statsd: 0% user + 0.1% kernel / faults: 73 minor 2 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 794/android.hardware.bluetooth@1.0-service-qti: 0% user + 0% kernel / faults: 15 minor 13 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 815/android.hardware.gnss@2.1-service-qti: 0% user + 0% kernel / faults: 97 minor 17 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 821/android.hardware.health@2.1-service: 0% user + 0.1% kernel / faults: 33 minor 4 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 833/android.hardware.neuralnetworks@1.3-service-qti: 0% user + 0% kernel / faults: 108 minor 34 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 862/qrtr_rx: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1093/mi_thermald: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1371/cameraserver: 0% user + 0% kernel / faults: 46 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1388/keystore: 0% user + 0.1% kernel / faults: 252 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1436/mediaserver: 0% user + 0% kernel / faults: 42 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1651/msm_irqbalance: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 3449/com.google.android.gms.persistent: 0.1% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 3507/irq/32-90b6400.: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 4583/tcpdump: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 4834/com.xiaomi.mircs: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 5105/com.tencent.wework: 0% user + 0% kernel / faults: 5 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 25408/com.tencent.mm:appbrand1: 0.1% user + 0% kernel / faults: 15 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 29363/kworker/0:2: 0% user + 0.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8/ksoftirqd/0: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 15/migration/0: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 31/rcuos/2: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 38/rcuop/3: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 39/rcuos/3: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 54/rcuop/5: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 70/rcuop/7: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 278/qseecom-unload-: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 370/irq/573-dma-gra: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 542/kworker/2:1H: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 556/ueventd: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 585/hwservicemanager: 0% user + 0% kernel / faults: 56 minor 8 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 626/vold: 0% user + 0% kernel / faults: 54 minor 1 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 740/kworker/3:1H: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 783/android.hardware.audio.service: 0% user + 0% kernel / faults: 65 minor 8 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 818/android.hardware.graphics.composer@2.4-service: 0% user + 0% kernel / faults: 215 minor 1 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1095/batteryd: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1272/wlan_logging_th: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1433/media.metrics: 0% user + 0% kernel / faults: 35 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1457/wificond: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1480/ipacm-diag: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1574/cnss-daemon: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1617/android.hardware.biometrics.fingerprint@2.1-service: 0% user + 0% kernel / faults: 24 minor 3 major09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1632/qcrild: 0% user + 0% kernel / faults: 3 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1644/hvdcp_opti: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1665/qcrild: 0% user + 0% kernel / faults: 3 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1853/psimon: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 5514/com.miui.securitycenter.remote: 0% user + 0% kernel / faults: 21 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8782/com.miui.powerkeeper: 0% user + 0% kernel / faults: 23 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8829/com.taobao.taobao:sandboxed_privilege_process0: 0% user + 0% kernel / faults: 3 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8985/com.taobao.taobao:remote: 0% user + 0% kernel / faults: 1 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 9034/cn.ticktick.task: 0% user + 0% kernel / faults: 1 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 13678/com.tencent.mm:toolsmp: 0% user + 0% kernel / faults: 17 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 13906/tv.danmaku.bili:download: 0% user + 0% kernel / faults: 2 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 14396/iptables-restore: 0% user + 0% kernel / faults: 10 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 14408/ip6tables-restore: 0% user + 0% kernel / faults: 1 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 26888/com.miui.player:remote: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 28950/kworker/1:0: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29260/com.miui.aod:settings: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29378/kworker/3:3: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29558/logcat: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29564/kworker/2:0: 0% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager: 19% TOTAL: 8% user + 9.2% kernel + 0.6% iowait + 0.9% irq + 0.4% softirq09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 57ms to 615ms later (2021-09-29 16:02:48.783 to 2021-09-29 16:02:49.341):09-29 16:03:03.457  1763 29602 E ActivityManager:   75% 1763/system_server: 27% user + 47% kernel / faults: 1442 minor09-29 16:03:03.457  1763 29602 E ActivityManager:     54% 29602/AnrConsumer: 15% user + 38% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:     15% 1772/HeapTaskDaemon: 13% user + 2.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:     2.2% 1781/android.ui: 0% user + 2.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:     2.2% 3385/Binder:1763_F: 0% user + 2.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   4% 835/android.hardware.sensors@1.0-service: 2% user + 2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   4.2% 969/surfaceflinger: 0% user + 4.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:     2.1% 1040/Binder:969_1: 0% user + 2.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:     2.1% 1214/app: 0% user + 2.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   4.2% 1362/cnss_diag: 4.2% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   5.7% 8356/com.taobao.taobao: 2.8% user + 2.8% kernel / faults: 7 minor09-29 16:03:03.457  1763 29602 E ActivityManager:     2.8% 8356/m.taobao.taobao: 0% user + 2.8% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.8% 46/rcuop/4: 0% user + 1.8% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.8% 70/rcuop/7: 0% user + 1.8% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 492/crtc_commit:131: 0% user + 1.9% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 542/kworker/2:1H: 0% user + 1.9% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 584/servicemanager: 0% user + 1.9% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   2.1% 1093/mi_thermald: 0% user + 2.1% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   2.2% 1665/qcrild: 0% user + 2.2% kernel / faults: 1 minor09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 2239/cds_ol_rx_threa: 0% user + 2.3% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 2847/com.android.phone: 2.3% user + 0% kernel / faults: 19 minor09-29 16:03:03.457  1763 29602 E ActivityManager:     2.3% 2847/m.android.phone: 2.3% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:     2.3% 3437/Binder:2847_A: 2.3% user + 0% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   2.4% 3509/irq/33-90cd000.: 0% user + 2.4% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   3.2% 19687/com.tencent.mm: 0% user + 3.2% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   3.3% 22965/kworker/u16:7: 0% user + 3.3% kernel09-29 16:03:03.457  1763 29602 E ActivityManager:   3.5% 26155/mdnsd: 0% user + 3.5% kernel09-29 16:03:03.457  1763 29602 E ActivityManager: 15% TOTAL: 6.1% user + 7.5% kernel + 0.9% irq + 0.4% softirq</code></pre></div><p>上面的日志是在 <code>ProcessErrorStateRecord.appNotResponding</code> 输出的，<code>info</code> 是输出至 logcat system 的日志</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span><span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">// Log the ANR to the main log.</span>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        info.setLength(<span class="hljs-number">0</span>);        info.append(<span class="hljs-string">&quot;ANR in &quot;</span>).append(mApp.processName);        <span class="hljs-keyword">if</span> (activityShortComponentName != <span class="hljs-literal">null</span>) &#123;            info.append(<span class="hljs-string">&quot; (&quot;</span>).append(activityShortComponentName).append(<span class="hljs-string">&quot;)&quot;</span>);        &#125;        info.append(<span class="hljs-string">&quot;\n&quot;</span>);        info.append(<span class="hljs-string">&quot;PID: &quot;</span>).append(pid).append(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">if</span> (annotation != <span class="hljs-literal">null</span>) &#123;            info.append(<span class="hljs-string">&quot;Reason: &quot;</span>).append(annotation).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (parentShortComponentName != <span class="hljs-literal">null</span>                &amp;&amp; parentShortComponentName.equals(activityShortComponentName)) &#123;            info.append(<span class="hljs-string">&quot;Parent: &quot;</span>).append(parentShortComponentName).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (errorId != <span class="hljs-literal">null</span>) &#123;            info.append(<span class="hljs-string">&quot;ErrorId: &quot;</span>).append(errorId.toString()).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        info.append(<span class="hljs-string">&quot;Frozen: &quot;</span>).append(mApp.mOptRecord.isFrozen()).append(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-comment">// ...</span>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        report.append(MemoryPressureUtil.currentPsiState());        <span class="hljs-type">ProcessCpuTracker</span> <span class="hljs-variable">processCpuTracker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessCpuTracker</span>(<span class="hljs-literal">true</span>);        <span class="hljs-comment">// don&#x27;t dump native PIDs for background ANRs unless it is the process of interest</span>        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">// For background ANRs, don&#x27;t pass the ProcessCpuTracker to</span>        <span class="hljs-comment">// avoid spending 1/2 second collecting stats to rank lastPids.</span>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">tracesFileException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();        <span class="hljs-comment">// To hold the start and end offset to the ANR trace file respectively.</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];        <span class="hljs-type">File</span> <span class="hljs-variable">tracesFile</span> <span class="hljs-operator">=</span> ActivityManagerService.dumpStackTraces(firstPids,                isSilentAnr ? <span class="hljs-literal">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-literal">null</span> : lastPids,                nativePids, tracesFileException, offsets, annotation);        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;            mService.updateCpuStatsNow();            mService.mAppProfiler.printCurrentCpuState(report, anrTime);            info.append(processCpuTracker.printCurrentLoad());            info.append(report);        &#125;        report.append(tracesFileException.getBuffer());        info.append(processCpuTracker.printCurrentState(anrTime));        Slog.e(TAG, info.toString());        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h2 id="load-average"><a href="#load-average" class="headerlink" title="load average"></a>load average</h2><p>用进程数来描述 CPU 负载压力</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(...)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;            mService.updateCpuStatsNow();            <span class="hljs-keyword">synchronized</span> (mService.mProcessCpuTracker) &#123;                report.append(mService.mProcessCpuTracker.printCurrentState(anrTime));            &#125;            info.append(processCpuTracker.printCurrentLoad());  <span class="hljs-comment">// 这里输出系统平均负载</span>            info.append(report);        &#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;    <span class="hljs-comment">// 三个值分别对应 mLoad1, mLoad5 和 mLoad15</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printCurrentLoad</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastPrintWriter</span>(sw, <span class="hljs-literal">false</span>, <span class="hljs-number">128</span>);        pw.print(<span class="hljs-string">&quot;Load: &quot;</span>);        pw.print(mLoad1);        pw.print(<span class="hljs-string">&quot; / &quot;</span>);        pw.print(mLoad5);        pw.print(<span class="hljs-string">&quot; / &quot;</span>);        pw.println(mLoad15);        pw.flush();        <span class="hljs-keyword">return</span> sw.toString();    &#125;        <span class="hljs-comment">// 这三个变量来自 /proc/loadavg</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[] loadAverages = mLoadAverageData;        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/loadavg&quot;</span>, LOAD_AVERAGE_FORMAT,                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, loadAverages)) &#123;            <span class="hljs-type">float</span> <span class="hljs-variable">load1</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">0</span>];            <span class="hljs-type">float</span> <span class="hljs-variable">load5</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">1</span>];            <span class="hljs-type">float</span> <span class="hljs-variable">load15</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span> (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) &#123;                mLoad1 = load1;                mLoad5 = load5;                mLoad15 = load15;                onLoadChanged(load1, load5, load15);            &#125;        &#125;        <span class="hljs-comment">// ...</span>    &#125;    &#125;</code></pre></div><blockquote><p>man proc.5</p><p>/proc/loadavg</p><p>The  first  three  fields in this file are load average figures giving the number of jobs in the run queue (state R) or waiting for disk I/O (state D) averaged over 1, 5, and 15 minutes.  They are the same as the load average numbers given by uptime(1) and other programs.  </p><p>The fourth field consists of two numbers separated by a slash (/).  The first of these is the number of currently  runnable  kernel  scheduling entities (processes, threads).  The value after the slash is the number of kernel scheduling entities that currently exist on the system.  </p><p>The fifth field is the PID of the process that was most recently created on the system.</p></blockquote><p>在绿联 6812（4 x <a href="mailto:&#x41;&#53;&#x33;&#x40;&#49;&#46;&#x35;&#x47;">&#x41;&#53;&#x33;&#x40;&#49;&#46;&#x35;&#x47;</a>）上获取的值是 <code>13.31 13.74 13.81 2/1167 3888</code></p><ul><li>在过去的 1, 5, 15 分钟内 CPU 的平均负载是 13.31, 13.74, 13.81</li><li>当前有 1167 个进程，其中有 2 个正在运行</li><li>最近创建的一个进程是 3888</li></ul><blockquote><p>在 Linux 系统中，uptime、w、top 等命令都会有系统平均负载 load average 的输出，系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数</p><p>如果一个进程满足以下条件则其就会位于运行队列中：它没有在等待 I/O 操作的结果，它没有主动进入等待状态(也就是没有调用’wait’)，没有被停止(例如：等待终止)</p><p>例如：<br><br>[root@opendigest root]# uptime <br><br>7:51pm up 2 days, 5:43, 2 users, load average: 8.13, 5.90, 4.94 <br><br>命令输出的最后内容表示在过去的 1、5、15 分钟内运行队列中的平均进程数量</p><p>一般来说只要每个 CPU 的当前活动进程数不大于 3 那么系统的性能就是良好的，如果每个 CPU 的任务数大于 5 那么就表示这台机器的性能有严重问题。对于上面的例子来说，假设系统有两个 CPU 那么其每个 CPU 的当前任务数为：8.13 / 2 = 4.065，这表示该系统的性能是可以接受的</p></blockquote><p>这么看来 <code>13.81 / 4 = 3.45</code> 这块绿联屏的性能还是可以接受的</p><h2 id="PSI-Pressure-Stall-Information"><a href="#PSI-Pressure-Stall-Information" class="headerlink" title="PSI (Pressure Stall Information)"></a>PSI (Pressure Stall Information)</h2><blockquote><p>Pressure Stall Information 提供了一种评估系统资源压力的方法。系统有三个基础资源：CPU、Memory 和 IO，无论这些资源配置如何增加，似乎永远无法满足软件的需求。一旦产生资源竞争，就有可能带来延迟增大，使用户体验到卡顿</p><p>如果没有一种相对准确的方法检测系统的资源压力程度，有两种后果：一种是资源使用者过度克制，没有充分使用系统资源；另一种是经常产生资源竞争，过度使用资源导致等待延迟过大。准确的检测方法可以帮忙资源使用者确定合适的工作量，同时也可以帮助系统制定高效的资源调度策略，最大化利用系统资源，最大化改善用户体验</p><p>Facebook 在 2018 年开源了一套解决重要计算集群管理问题的 Linux 内核组件和相关工具，PSI 是其中重要的资源度量工具，它提供了一种实时检测系统资源竞争程度的方法，以竞争等待时间的方式呈现，简单而准确地供用户以及资源调度者进行决策</p><p>在此之前，Linux 也有一些资源压力的评估方法，最具代表性的是 load average 和 vmpressure</p></blockquote><p>每类资源的压力信息都通过 proc 文件系统的独立文件来提供，路径为：<code>/proc/pressure/memory</code>，<code>/proc/pressure/cpu</code> 和 <code>/proc/pressure/io</code>，其中 /proc/pressure/io 输出格式如下：</p><div class="code-wrapper"><pre><code class="hljs log">some avg10=0.30 avg60=0.12 avg300=0.02 total=4170757full avg10=0.12 avg60=0.05 avg300=0.01 total=1856503</code></pre></div><ul><li>avg10、avg60、avg300 分别代表 10s、60s、300s 的时间周期内的阻塞时间百分比</li><li>total 是总累计时间，以毫秒为单位</li><li>some 这一行，代表至少有一个任务在某个资源上阻塞的时间占比</li><li>full 这一行，代表所有的非 idle 任务同时被阻塞的时间占比，这期间 cpu 被完全浪费，会带来严重的性能问题</li></ul><p>我们以 IO 的 some 和 full 来举例说明，假设在 60 秒的时间段内，系统有两个 task，在 60 秒的周期内的运行情况如下图所示：</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/proc_pressure_io_1.png" alt="proc_pressure_io_1"></p><p>红色阴影部分表示任务由于等待 IO 资源而进入阻塞状态。Task A 和 Task B 同时阻塞的部分为 full，占比 16.66%；至少有一个任务阻塞（仅 Task B 阻塞的部分也计算入内）的部分为 some，占比 50%</p><p>some 和 full 都是在某一时间段内阻塞时间占比的总和，阻塞时间不一定连续，如下图所示：</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/proc_pressure_io_2.png" alt="proc_pressure_io_2"></p><p>IO 和 memory 都有 some 和 full 两个维度，那是因为的确有可能系统中的所有任务都阻塞在 IO 或者 memory 资源，同时 CPU 进入 idle 状态</p><p>但是 CPU 资源不可能出现这个情况：不可能全部的 runnable 的任务都等待 CPU 资源，至少有一个 runnable 任务会被调度器选中占有 CPU 资源，因此 CPU 资源没有 full 维度的 PSI 信息呈现</p><p>通过这些阻塞占比数据，我们可以看到短期以及中长期一段时间内各种资源的压力情况，可以较精确的确定时延抖动原因，并制定对应的负载管理策略</p><div class="code-wrapper"><pre><code class="hljs log">09-29 16:03:03.457  1763 29602 E ActivityManager: ----- Output from /proc/pressure/memory -----09-29 16:03:03.457  1763 29602 E ActivityManager: some avg10=0.00 avg60=0.00 avg300=0.02 total=3299562509-29 16:03:03.457  1763 29602 E ActivityManager: full avg10=0.00 avg60=0.00 avg300=0.00 total=1159118309-29 16:03:03.457  1763 29602 E ActivityManager: ----- End output from /proc/pressure/memory -----</code></pre></div><p>现在我们来看看 anr logcat 里输出的 /proc/pressure/memory 内容，full 都为零说明任务同时阻塞在内存资源上的情况没有出现，some - avg300=0.02 表明在有任务阻塞在内存资源上 6s（300s * 0.02，注意这 6s 是总和，不一定是连续的）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryPressureUtil</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FILE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/proc/pressure/memory&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MemoryPressure&quot;</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a stanza about memory PSI to add to a report.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">currentPsiState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">final</span> StrictMode.<span class="hljs-type">ThreadPolicy</span> <span class="hljs-variable">savedPolicy</span> <span class="hljs-operator">=</span> StrictMode.allowThreadDiskReads();        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">contents</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(FILE).exists()) &#123;                contents.append(<span class="hljs-string">&quot;----- Output from /proc/pressure/memory -----\n&quot;</span>);                contents.append(IoUtils.readFileAsString(FILE));                contents.append(<span class="hljs-string">&quot;----- End output from /proc/pressure/memory -----\n\n&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            Slog.e(TAG, <span class="hljs-string">&quot;Could not read &quot;</span> + FILE, e);        &#125; <span class="hljs-keyword">finally</span> &#123;            StrictMode.setThreadPolicy(savedPolicy);        &#125;        <span class="hljs-keyword">return</span> contents.toString();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MemoryPressureUtil</span><span class="hljs-params">()</span>&#123;&#125;&#125;</code></pre></div><h2 id="CPU-usage"><a href="#CPU-usage" class="headerlink" title="CPU usage"></a>CPU usage</h2><p><code>ProcessCpuTracker</code> 顾名思义是用来跟踪进程 CPU 使用率的，它的数据是在 <code>ProcessCpuTracker.update()</code> 里采集的（<code>/proc/stat</code>, <code>/proc/[pid]/stat</code>），<code>mCurrentSampleTime</code> 是上一次执行 <code>ProcessCpuTracker.update()</code> 的时间（既是数据快照的时间，也是两次数据快照差值的结束时间），而 <code>mLastSampleTime</code> 是上上次执行 <code>ProcessCpuTracker.update()</code> 的时间（也是两次数据快照差值的开始时间），<code>now</code> 是发生 ANR 的时间，它们的关系有：</p><ol><li>如果是 <code>anr - mLastSampleTime - mCurrentSampleTime</code>，说明 ANR 发生在两次快照差值（统计时间段）之前，对应的是 <code>later</code></li><li>如果是 <code>mLastSampleTime - mCurrentSampleTime - anr</code>，说明 ANR 发生在两次快照差值（统计时间段）之后，对应的是 <code>ago</code></li></ol><div class="code-wrapper"><pre><code class="hljs log">// 第一段 CPU Usage 是由 mService.mAppProfiler.printCurrentCpuState(report, anrTime) 打印出来的09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 0ms to 14680ms later (2021-09-29 16:02:48.726 to 2021-09-29 16:03:03.406):...// 第二段 CPU Usage 是由 info.append(processCpuTracker.printCurrentState(anrTime)) 打印出来的09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 57ms to 615ms later (2021-09-29 16:02:48.783 to 2021-09-29 16:02:49.341):...</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span><span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        report.append(MemoryPressureUtil.currentPsiState());        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;            mService.updateCpuStatsNow();            mService.mAppProfiler.printCurrentCpuState(report, anrTime);            info.append(processCpuTracker.printCurrentLoad());            info.append(report);        &#125;        report.append(tracesFileException.getBuffer());        info.append(processCpuTracker.printCurrentState(anrTime));        Slog.e(TAG, info.toString());       <span class="hljs-comment">// info 是输出至 logcat system 的日志文本</span>        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppProfiler</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCurrentCpuState</span><span class="hljs-params">(StringBuilder report, <span class="hljs-type">long</span> time)</span> &#123;        <span class="hljs-keyword">synchronized</span> (mProcessCpuTracker) &#123;            report.append(mProcessCpuTracker.printCurrentState(time));        &#125;    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printCurrentState</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);        buildWorkingProcs();        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastPrintWriter</span>(sw, <span class="hljs-literal">false</span>, <span class="hljs-number">1024</span>);        pw.print(<span class="hljs-string">&quot;CPU usage from &quot;</span>);        <span class="hljs-keyword">if</span> (now &gt; mLastSampleTime) &#123;            pw.print(now-mLastSampleTime);            pw.print(<span class="hljs-string">&quot;ms to &quot;</span>);            pw.print(now-mCurrentSampleTime);            pw.print(<span class="hljs-string">&quot;ms ago&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            pw.print(mLastSampleTime-now);            pw.print(<span class="hljs-string">&quot;ms to &quot;</span>);            pw.print(mCurrentSampleTime-now);            pw.print(<span class="hljs-string">&quot;ms later&quot;</span>);        &#125;        pw.print(<span class="hljs-string">&quot; (&quot;</span>);        pw.print(sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(mLastSampleWallTime)));        pw.print(<span class="hljs-string">&quot; to &quot;</span>);        pw.print(sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(mCurrentSampleWallTime)));        pw.print(<span class="hljs-string">&quot;)&quot;</span>);        <span class="hljs-type">long</span> <span class="hljs-variable">sampleTime</span> <span class="hljs-operator">=</span> mCurrentSampleTime - mLastSampleTime;        <span class="hljs-type">long</span> <span class="hljs-variable">sampleRealTime</span> <span class="hljs-operator">=</span> mCurrentSampleRealTime - mLastSampleRealTime;        <span class="hljs-type">long</span> <span class="hljs-variable">percAwake</span> <span class="hljs-operator">=</span> sampleRealTime &gt; <span class="hljs-number">0</span> ? ((sampleTime*<span class="hljs-number">100</span>) / sampleRealTime) : <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (percAwake != <span class="hljs-number">100</span>) &#123;            pw.print(<span class="hljs-string">&quot; with &quot;</span>);            pw.print(percAwake);            pw.print(<span class="hljs-string">&quot;% awake&quot;</span>);        &#125;        pw.println(<span class="hljs-string">&quot;:&quot;</span>);        <span class="hljs-comment">// ...</span>    &#125;    &#125;</code></pre></div><h3 id="收集进程-proc-pid"><a href="#收集进程-proc-pid" class="headerlink" title="收集进程 /proc/[pid]"></a>收集进程 <code>/proc/[pid]</code></h3><p><code>Process.getPids(dir, array)</code> 遍历目录 <code>dir</code> （这里传入的是 <code>/proc</code>）下的条目，找到纯数字的条目（即为 <code>pid</code>）加入到 <code>array</code>（pid array），<code>array</code> 会复用，只有当 <code>pid</code> 的数量超过 <code>array</code> 容量时才分配新的数组</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Process.getPids(dir, array)</span><span class="hljs-comment">// 从 /proc 获取 pid 列表到 array</span><span class="hljs-function">jintArray <span class="hljs-title">android_os_Process_getPids</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><span class="hljs-params"><span class="hljs-function">                                     jstring file <span class="hljs-comment">/* /proc */</span>, jintArray lastArray)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (file8 == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    DIR* dirp = <span class="hljs-built_in">opendir</span>(file8);    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);    <span class="hljs-keyword">if</span>(dirp == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    jsize curCount = <span class="hljs-number">0</span>;    jint* curData = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span> (lastArray != <span class="hljs-literal">NULL</span>) &#123;        curCount = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(lastArray);        curData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(lastArray, <span class="hljs-number">0</span>);    &#125;    jint curPos = <span class="hljs-number">0</span>;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span>* entry;    <span class="hljs-keyword">while</span> ((entry=<span class="hljs-built_in">readdir</span>(dirp)) != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = entry-&gt;d_name;        <span class="hljs-keyword">while</span> (*p) &#123;            <span class="hljs-keyword">if</span> (*p &lt; <span class="hljs-string">&#x27;0&#x27;</span> || *p &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;            p++;        &#125;        <span class="hljs-keyword">if</span> (*p != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">char</span>* end;        <span class="hljs-type">int</span> pid = <span class="hljs-built_in">strtol</span>(entry-&gt;d_name, &amp;end, <span class="hljs-number">10</span>);        <span class="hljs-comment">//ALOGI(&quot;File %s pid=%d\n&quot;, entry-&gt;d_name, pid);</span>        <span class="hljs-keyword">if</span> (curPos &gt;= curCount) &#123;            jsize newCount = (curCount == <span class="hljs-number">0</span>) ? <span class="hljs-number">10</span> : (curCount*<span class="hljs-number">2</span>);            jintArray newArray = env-&gt;<span class="hljs-built_in">NewIntArray</span>(newCount);            <span class="hljs-keyword">if</span> (newArray == <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-built_in">closedir</span>(dirp);                <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;            &#125;            jint* newData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(newArray, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-built_in">memcpy</span>(newData, curData, <span class="hljs-built_in">sizeof</span>(jint)*curCount);                env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(lastArray, curData, <span class="hljs-number">0</span>);            &#125;            lastArray = newArray;            curCount = newCount;            curData = newData;        &#125;        curData[curPos] = pid;        curPos++;    &#125;    <span class="hljs-built_in">closedir</span>(dirp);    <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span> &amp;&amp; curPos &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">qsort</span>(curData, curPos, <span class="hljs-built_in">sizeof</span>(jint), pid_compare);    &#125;    <span class="hljs-keyword">while</span> (curPos &lt; curCount) &#123;        curData[curPos] = <span class="hljs-number">-1</span>;        curPos++;    &#125;    <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span>) &#123;        env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(lastArray, curData, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">return</span> lastArray;&#125;</code></pre></div><h3 id="进程概览-proc-pid-stat"><a href="#进程概览-proc-pid-stat" class="headerlink" title="进程概览 /proc/[pid]/stat"></a>进程概览 <code>/proc/[pid]/stat</code></h3><p>在 MI 9 上通过 <code>cat /proc/8538/stat</code> 打印出的内容如下（8538 是通过 <code>ps -A | grep com.tencent.mm</code> 查找出的微信的 pid）：</p><div class="code-wrapper"><pre><code class="hljs shell">cepheus:/proc $ cat /proc/8538/stat8538 (com.tencent.mm) S 690 690 0 0 -1 1077952832 2355958 1597 22562 6 39676 24386 2 1 20 0 209 0 464604 73654394880 26729 18446744073709551615 1 1 0 0 0 0 4608 4097 1073775868 0 0 0 17 0 0 0 2401 0 0 0 0 0 0 0 0 0 0</code></pre></div><p>一些重要字段的含义如下（来自 <code>man proc.5</code> 里的 <code>/proc/[pid]/stat</code> 章节）：</p><table><thead><tr><th>index</th><th>name</th><th>value</th><th>desc</th></tr></thead><tbody><tr><td>0</td><td>pid</td><td>8538</td><td>pid</td></tr><tr><td>1</td><td>comm</td><td>(com.tencent.mm)</td><td>command, The filename of the executable, 这里是包名</td></tr><tr><td>2</td><td>state</td><td>S</td><td>process state，进程状态：R - Running, S - Sleeping(interruptible), D - Waiting(uninterruptible), Z - Zombie …</td></tr><tr><td>3</td><td>ppid</td><td>690</td><td>父进程的 PID</td></tr><tr><td>4</td><td>pgrp</td><td>690</td><td>group ID</td></tr><tr><td>5</td><td></td><td>0</td><td></td></tr><tr><td>6</td><td></td><td>0</td><td></td></tr><tr><td>7</td><td></td><td>-1</td><td></td></tr><tr><td>8</td><td></td><td>1077952832</td><td></td></tr><tr><td>9</td><td>minflt</td><td>2355958</td><td>minor page faults (which have not required loading a memory page from disk), 加载 CPU 指令时发生缺页错误，但指令以及加载至物理内存，只需将虚存映射到物理内存即可</td></tr><tr><td>10</td><td>cminflt</td><td>1597</td><td></td></tr><tr><td>11</td><td>majflt</td><td>22562</td><td>major page faults (which have required loading a memory page from disk), 同样是加载 CPU 指令时发生缺页错误，但此时需要从磁盘读取指令，比上面的情况要严重</td></tr><tr><td>12</td><td>cmajflt</td><td>6</td><td></td></tr><tr><td>13</td><td>utime</td><td>39676</td><td>Amount of time that this process has been scheduled in user mode, 进程运行在用户态的 CPU 时间</td></tr><tr><td>14</td><td>stime</td><td>24386</td><td>Amount of time that this process has been scheduled in kernel mode, 进程运行在内核态的 CPU 时间</td></tr><tr><td>15</td><td>cutime</td><td>2</td><td></td></tr><tr><td>16</td><td>cstime</td><td>1</td><td></td></tr><tr><td>17</td><td>priority</td><td>20</td><td>优先级（在创建进程的时候就设置好后续不能更改）</td></tr><tr><td>18</td><td>nice</td><td>0</td><td>进程最终优先级 = priorty + nice，nice 值可以在运行时动态修改</td></tr><tr><td>19</td><td>num_threads</td><td>209</td><td></td></tr><tr><td>20</td><td></td><td>0</td><td></td></tr><tr><td>21</td><td>starttime</td><td>464604</td><td>The time the process started after system boot, 进程的运行时间（是一个从系统启动时间开始算起的相对值）</td></tr><tr><td>22</td><td>vsize</td><td>73654394880</td><td>Virtual memory size in bytes</td></tr></tbody></table><blockquote><p>Linux 对于物理内存的管理方法</p><p>由 MMU 把物理内存分割成众多个 page，每个 page 是 4KB. 然后把 page 映射到进程的虚拟内存空间，CPU 在执行进程中的指令时以虚拟内存地址为基础，通过 map 映射进而找到物理内存中实际存放指令的地址</p><p>缺页错误 (page fault)</p><p>严格说这里指的是 major page fault，名字听起来挺严重，实际上并不是什么”错误”</p><p>大致是这样，一个程序可能占几 MB，但并不是所有的指令都要同时运行，有些是在初始化时运行，有些是在特定条件下才会去运行。因此 linux 并不会把所有的指令都从磁盘加载到物理内存，那么当 cpu 在执行指令时如果发现下一条要执行的指令不在物理内存时，就会 raise a page fault 通知 MMU 把下面要执行的指令从磁盘加载到物理内存中</p><p>还有另一种就是 minor fault</p><p>minor page fault 指的是要执行的指令实际上已经在物理内存，只是这个 page 没有映射到当前进程的虚拟内存，这时就会 raise a minor page fault 让 MMU 把这个 page 映射进当前进程的虚拟内存，因此 minor page fault 并不需要去访问磁盘</p><p>What a Swap?</p><p>当物理内存不够时，把一些物理内存 page 写入到磁盘以腾出一些空闲的 page 出来供进程使用，这就是 swap out；反过来说当 CPU 要执行的指令被发现已经 swap out 到了磁盘中，这时就需要从磁盘把这些指令再 swap in 到物理内存中让CPU去执行</p><p>swap in 和 swap out 的操作都是比较耗时的, 频繁的 swap in 和 swap out 操作很影响系统性能</p></blockquote><p><code>ProcessCpuTracker.update</code> 和 <code>ProcessCpuTracker.collectStats</code> 读取并解析 <code>/proc/[pid]/stat</code> 文件内容为 <code>Stats</code> 结构，保存在 <code>ProcessCpuTracker.mProcStats</code> 以供后续打印，它的重要字段有：</p><table><thead><tr><th>field</th><th>desc</th></tr></thead><tbody><tr><td>pid</td><td>进程 ID，来自 <code>/proc</code> 目录下的纯数字目录</td></tr><tr><td>name</td><td>进程名，来自 <code>/proc/[pid]/stat#comm</code></td></tr><tr><td>base_uptime</td><td>取自 <code>SystemClock.uptimeMillis()</code></td></tr><tr><td>base_utime</td><td>运行在用户态的 CPU 时间</td></tr><tr><td>base_stime</td><td>运行在核心态的 CPU 时间</td></tr><tr><td>base_majfaults</td><td>major page faults</td></tr><tr><td>base_minfaults</td><td>minor page faults</td></tr><tr><td>rel_uptime</td><td></td></tr><tr><td>rel_utime</td><td></td></tr><tr><td>rel_stime</td><td></td></tr><tr><td>rel_majfaults</td><td></td></tr><tr><td>rel_minfaults</td><td></td></tr></tbody></table><p>第一次遇到进程时（构造 <code>State</code>）将初始值填入 <code>base_xxx</code>，下次遇到进程时给 <code>rel_xxx</code> 赋值：<code>rel_xxx = [now] - base_xxx</code> 并更新 <code>base_xxx</code> 为当前值 <code>[now]</code>，也就是说 <code>base_xxx</code> 是当前快照而 <code>rel_xxx</code> 是当前与上一次快照的差值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Update: &quot;</span> + <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowUptime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowRealtime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowWallTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] sysCpu = mSystemCpuData;        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/stat&quot;</span>, SYSTEM_CPU_FORMAT,                <span class="hljs-literal">null</span>, sysCpu, <span class="hljs-literal">null</span>)) &#123;            <span class="hljs-comment">// Total user time is user + nice time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">usertime</span> <span class="hljs-operator">=</span> (sysCpu[<span class="hljs-number">0</span>]+sysCpu[<span class="hljs-number">1</span>]) * mJiffyMillis;            <span class="hljs-comment">// Total system time is simply system time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">systemtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">2</span>] * mJiffyMillis;            <span class="hljs-comment">// Total idle time is simply idle time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">idletime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">3</span>] * mJiffyMillis;            <span class="hljs-comment">// Total irq time is iowait + irq + softirq time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">iowaittime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">4</span>] * mJiffyMillis;            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">irqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">5</span>] * mJiffyMillis;            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">softirqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">6</span>] * mJiffyMillis;            <span class="hljs-comment">// This code is trying to avoid issues with idle time going backwards,</span>            <span class="hljs-comment">// but currently it gets into situations where it triggers most of the time. :(</span>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> || (usertime &gt;= mBaseUserTime &amp;&amp; systemtime &gt;= mBaseSystemTime                    &amp;&amp; iowaittime &gt;= mBaseIoWaitTime &amp;&amp; irqtime &gt;= mBaseIrqTime                    &amp;&amp; softirqtime &gt;= mBaseSoftIrqTime &amp;&amp; idletime &gt;= mBaseIdleTime)) &#123;                mRelUserTime = (<span class="hljs-type">int</span>)(usertime - mBaseUserTime);                mRelSystemTime = (<span class="hljs-type">int</span>)(systemtime - mBaseSystemTime);                mRelIoWaitTime = (<span class="hljs-type">int</span>)(iowaittime - mBaseIoWaitTime);                mRelIrqTime = (<span class="hljs-type">int</span>)(irqtime - mBaseIrqTime);                mRelSoftIrqTime = (<span class="hljs-type">int</span>)(softirqtime - mBaseSoftIrqTime);                mRelIdleTime = (<span class="hljs-type">int</span>)(idletime - mBaseIdleTime);                mRelStatsAreGood = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span> (DEBUG) &#123;                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Total U:&quot;</span> + (sysCpu[<span class="hljs-number">0</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; N:&quot;</span> + (sysCpu[<span class="hljs-number">1</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; S:&quot;</span> + (sysCpu[<span class="hljs-number">2</span>]*mJiffyMillis) + <span class="hljs-string">&quot; I:&quot;</span> + (sysCpu[<span class="hljs-number">3</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; W:&quot;</span> + (sysCpu[<span class="hljs-number">4</span>]*mJiffyMillis) + <span class="hljs-string">&quot; Q:&quot;</span> + (sysCpu[<span class="hljs-number">5</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; O:&quot;</span> + (sysCpu[<span class="hljs-number">6</span>]*mJiffyMillis));                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Rel U:&quot;</span> + mRelUserTime + <span class="hljs-string">&quot; S:&quot;</span> + mRelSystemTime                          + <span class="hljs-string">&quot; I:&quot;</span> + mRelIdleTime + <span class="hljs-string">&quot; Q:&quot;</span> + mRelIrqTime);                &#125;                mBaseUserTime = usertime;                mBaseSystemTime = systemtime;                mBaseIoWaitTime = iowaittime;                mBaseIrqTime = irqtime;                mBaseSoftIrqTime = softirqtime;                mBaseIdleTime = idletime;            &#125; <span class="hljs-keyword">else</span> &#123;                mRelUserTime = <span class="hljs-number">0</span>;                mRelSystemTime = <span class="hljs-number">0</span>;                mRelIoWaitTime = <span class="hljs-number">0</span>;                mRelIrqTime = <span class="hljs-number">0</span>;                mRelSoftIrqTime = <span class="hljs-number">0</span>;                mRelIdleTime = <span class="hljs-number">0</span>;                mRelStatsAreGood = <span class="hljs-literal">false</span>;                Slog.w(TAG, <span class="hljs-string">&quot;/proc/stats has gone backwards; skipping CPU update&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        mLastSampleTime = mCurrentSampleTime;        mCurrentSampleTime = nowUptime;        mLastSampleRealTime = mCurrentSampleRealTime;        mCurrentSampleRealTime = nowRealtime;        mLastSampleWallTime = mCurrentSampleWallTime;        mCurrentSampleWallTime = nowWallTime;        <span class="hljs-keyword">final</span> StrictMode.<span class="hljs-type">ThreadPolicy</span> <span class="hljs-variable">savedPolicy</span> <span class="hljs-operator">=</span> StrictMode.allowThreadDiskReads();        <span class="hljs-keyword">try</span> &#123;            mCurPids = collectStats(<span class="hljs-string">&quot;/proc&quot;</span>, -<span class="hljs-number">1</span>, mFirst, mCurPids, mProcStats);        &#125; <span class="hljs-keyword">finally</span> &#123;            StrictMode.setThreadPolicy(savedPolicy);        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[] loadAverages = mLoadAverageData;        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/loadavg&quot;</span>, LOAD_AVERAGE_FORMAT,                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, loadAverages)) &#123;            <span class="hljs-type">float</span> <span class="hljs-variable">load1</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">0</span>];            <span class="hljs-type">float</span> <span class="hljs-variable">load5</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">1</span>];            <span class="hljs-type">float</span> <span class="hljs-variable">load15</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span> (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) &#123;                mLoad1 = load1;                mLoad5 = load5;                mLoad15 = load15;                onLoadChanged(load1, load5, load15);            &#125;        &#125;        <span class="hljs-keyword">if</span> (DEBUG) Slog.i(TAG, <span class="hljs-string">&quot;*** TIME TO COLLECT STATS: &quot;</span>                + (SystemClock.uptimeMillis()-mCurrentSampleTime));        mWorkingProcsSorted = <span class="hljs-literal">false</span>;        mFirst = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] collectStats(String statsFile, <span class="hljs-type">int</span> parentPid, <span class="hljs-type">boolean</span> first,            <span class="hljs-type">int</span>[] curPids, ArrayList&lt;Stats&gt; allProcs) &#123;        <span class="hljs-type">int</span>[] pids = Process.getPids(statsFile, curPids);        <span class="hljs-type">int</span> <span class="hljs-variable">NP</span> <span class="hljs-operator">=</span> (pids == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : pids.length;        <span class="hljs-type">int</span> <span class="hljs-variable">NS</span> <span class="hljs-operator">=</span> allProcs.size();        <span class="hljs-type">int</span> <span class="hljs-variable">curStatsIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NP; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> pids[i];            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;                NP = pid;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-type">Stats</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> curStatsIndex &lt; NS ? allProcs.get(curStatsIndex) : <span class="hljs-literal">null</span>;            <span class="hljs-keyword">if</span> (st != <span class="hljs-literal">null</span> &amp;&amp; st.pid == pid) &#123;                <span class="hljs-comment">// Update an existing process...</span>                st.added = <span class="hljs-literal">false</span>;                st.working = <span class="hljs-literal">false</span>;                curStatsIndex++;                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Existing &quot;</span>                        + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)                        + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);                <span class="hljs-keyword">if</span> (st.interesting) &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">uptime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] procStats = mProcessStatsData;                    <span class="hljs-keyword">if</span> (!Process.readProcFile(st.statFile.toString(),                            PROCESS_STATS_FORMAT, <span class="hljs-literal">null</span>, procStats, <span class="hljs-literal">null</span>)) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">minfaults</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_MINOR_FAULTS];                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">majfaults</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_MAJOR_FAULTS];                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">utime</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_UTIME] * mJiffyMillis;                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">stime</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_STIME] * mJiffyMillis;                    <span class="hljs-keyword">if</span> (utime == st.base_utime &amp;&amp; stime == st.base_stime) &#123;                        st.rel_utime = <span class="hljs-number">0</span>;                        st.rel_stime = <span class="hljs-number">0</span>;                        st.rel_minfaults = <span class="hljs-number">0</span>;                        st.rel_majfaults = <span class="hljs-number">0</span>;                        <span class="hljs-keyword">if</span> (st.active) &#123;                            st.active = <span class="hljs-literal">false</span>;                        &#125;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">if</span> (!st.active) &#123;                        st.active = <span class="hljs-literal">true</span>;                    &#125;                    <span class="hljs-keyword">if</span> (parentPid &lt; <span class="hljs-number">0</span>) &#123;                        getName(st, st.cmdlineFile);                        <span class="hljs-keyword">if</span> (st.threadStats != <span class="hljs-literal">null</span>) &#123;                            mCurThreadPids = collectStats(st.threadsDir, pid, <span class="hljs-literal">false</span>,                                    mCurThreadPids, st.threadStats);                        &#125;                    &#125;                    <span class="hljs-keyword">if</span> (DEBUG) Slog.v(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Stats changed &quot;</span> + st.name + <span class="hljs-string">&quot; pid=&quot;</span> + st.pid                            + <span class="hljs-string">&quot; utime=&quot;</span> + utime + <span class="hljs-string">&quot;-&quot;</span> + st.base_utime                            + <span class="hljs-string">&quot; stime=&quot;</span> + stime + <span class="hljs-string">&quot;-&quot;</span> + st.base_stime                            + <span class="hljs-string">&quot; minfaults=&quot;</span> + minfaults + <span class="hljs-string">&quot;-&quot;</span> + st.base_minfaults                            + <span class="hljs-string">&quot; majfaults=&quot;</span> + majfaults + <span class="hljs-string">&quot;-&quot;</span> + st.base_majfaults);                    st.rel_uptime = uptime - st.base_uptime;                    st.base_uptime = uptime;                    st.rel_utime = (<span class="hljs-type">int</span>)(utime - st.base_utime);                    st.rel_stime = (<span class="hljs-type">int</span>)(stime - st.base_stime);                    st.base_utime = utime;                    st.base_stime = stime;                    st.rel_minfaults = (<span class="hljs-type">int</span>)(minfaults - st.base_minfaults);                    st.rel_majfaults = (<span class="hljs-type">int</span>)(majfaults - st.base_majfaults);                    st.base_minfaults = minfaults;                    st.base_majfaults = majfaults;                    st.working = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (st == <span class="hljs-literal">null</span> || st.pid &gt; pid) &#123;                <span class="hljs-comment">// We have a new process!</span>                st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stats</span>(pid, parentPid, mIncludeThreads);                allProcs.add(curStatsIndex, st);                curStatsIndex++;                NS++;                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;New &quot;</span>                        + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)                        + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);                <span class="hljs-keyword">final</span> String[] procStatsString = mProcessFullStatsStringData;                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] procStats = mProcessFullStatsData;                st.base_uptime = SystemClock.uptimeMillis();                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> st.statFile.toString();                <span class="hljs-comment">//Slog.d(TAG, &quot;Reading proc file: &quot; + path);</span>                <span class="hljs-keyword">if</span> (Process.readProcFile(path, PROCESS_FULL_STATS_FORMAT, procStatsString,                        procStats, <span class="hljs-literal">null</span>)) &#123;                    <span class="hljs-comment">// This is a possible way to filter out processes that</span>                    <span class="hljs-comment">// are actually kernel threads...  do we want to?  Some</span>                    <span class="hljs-comment">// of them do use CPU, but there can be a *lot* that are</span>                    <span class="hljs-comment">// not doing anything.</span>                    st.vsize = procStats[PROCESS_FULL_STAT_VSIZE];                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> || procStats[PROCESS_FULL_STAT_VSIZE] != <span class="hljs-number">0</span>) &#123;                        st.interesting = <span class="hljs-literal">true</span>;                        st.baseName = procStatsString[<span class="hljs-number">0</span>];                        st.base_minfaults = procStats[PROCESS_FULL_STAT_MINOR_FAULTS];                        st.base_majfaults = procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];                        st.base_utime = procStats[PROCESS_FULL_STAT_UTIME] * mJiffyMillis;                        st.base_stime = procStats[PROCESS_FULL_STAT_STIME] * mJiffyMillis;                    &#125; <span class="hljs-keyword">else</span> &#123;                        Slog.i(TAG, <span class="hljs-string">&quot;Skipping kernel process pid &quot;</span> + pid                                + <span class="hljs-string">&quot; name &quot;</span> + procStatsString[<span class="hljs-number">0</span>]);                        st.baseName = procStatsString[<span class="hljs-number">0</span>];                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    Slog.w(TAG, <span class="hljs-string">&quot;Skipping unknown process pid &quot;</span> + pid);                    st.baseName = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;                    st.base_utime = st.base_stime = <span class="hljs-number">0</span>;                    st.base_minfaults = st.base_majfaults = <span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">if</span> (parentPid &lt; <span class="hljs-number">0</span>) &#123;                    getName(st, st.cmdlineFile);                    <span class="hljs-keyword">if</span> (st.threadStats != <span class="hljs-literal">null</span>) &#123;                        mCurThreadPids = collectStats(st.threadsDir, pid, <span class="hljs-literal">true</span>,                                mCurThreadPids, st.threadStats);                    &#125;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.interesting) &#123;                    st.name = st.baseName;                    st.nameWidth = onMeasureProcessName(st.name);                &#125;                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Stats added &quot;</span> + st.name + <span class="hljs-string">&quot; pid=&quot;</span> + st.pid                        + <span class="hljs-string">&quot; utime=&quot;</span> + st.base_utime + <span class="hljs-string">&quot; stime=&quot;</span> + st.base_stime                        + <span class="hljs-string">&quot; minfaults=&quot;</span> + st.base_minfaults + <span class="hljs-string">&quot; majfaults=&quot;</span> + st.base_majfaults);                st.rel_utime = <span class="hljs-number">0</span>;                st.rel_stime = <span class="hljs-number">0</span>;                st.rel_minfaults = <span class="hljs-number">0</span>;                st.rel_majfaults = <span class="hljs-number">0</span>;                st.added = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span> (!first &amp;&amp; st.interesting) &#123;                    st.working = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// This process has gone away!</span>            st.rel_utime = <span class="hljs-number">0</span>;            st.rel_stime = <span class="hljs-number">0</span>;            st.rel_minfaults = <span class="hljs-number">0</span>;            st.rel_majfaults = <span class="hljs-number">0</span>;            st.removed = <span class="hljs-literal">true</span>;            st.working = <span class="hljs-literal">true</span>;            allProcs.remove(curStatsIndex);            NS--;            <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Removed &quot;</span>                    + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)                    + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);            <span class="hljs-comment">// Decrement the loop counter so that we process the current pid</span>            <span class="hljs-comment">// again the next time through the loop.</span>            i--;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">while</span> (curStatsIndex &lt; NS) &#123;            <span class="hljs-comment">// This process has gone away!</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Stats</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> allProcs.get(curStatsIndex);            st.rel_utime = <span class="hljs-number">0</span>;            st.rel_stime = <span class="hljs-number">0</span>;            st.rel_minfaults = <span class="hljs-number">0</span>;            st.rel_majfaults = <span class="hljs-number">0</span>;            st.removed = <span class="hljs-literal">true</span>;            st.working = <span class="hljs-literal">true</span>;            allProcs.remove(curStatsIndex);            NS--;            <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Removed pid &quot;</span> + st.pid + <span class="hljs-string">&quot;: &quot;</span> + st);        &#125;        <span class="hljs-keyword">return</span> pids;    &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">jboolean <span class="hljs-title">android_os_Process_readProcFile</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><span class="hljs-params"><span class="hljs-function">        jstring file, jintArray format, jobjectArray outStrings,</span></span><span class="hljs-params"><span class="hljs-function">        jlongArray outLongs, jfloatArray outFloats)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span> || format == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> JNI_FALSE;    &#125;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (file8 == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> JNI_FALSE;    &#125;    ::android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(open(file8, O_RDONLY | O_CLOEXEC))</span></span>;    <span class="hljs-keyword">if</span> (!fd.<span class="hljs-built_in">ok</span>()) &#123;        <span class="hljs-keyword">if</span> (kDebugProc) &#123;            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Unable to open process file: %s\n&quot;</span>, file8);        &#125;        env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);        <span class="hljs-keyword">return</span> JNI_FALSE;    &#125;    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);    <span class="hljs-comment">// Most proc files we read are small, so we only go through the</span>    <span class="hljs-comment">// loop once and use the stack buffer.  We allocate a buffer big</span>    <span class="hljs-comment">// enough for the whole file.</span>    <span class="hljs-type">char</span> readBufferStack[kProcReadStackBufferSize];    std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; readBufferHeap;    <span class="hljs-type">char</span>* readBuffer = &amp;readBufferStack[<span class="hljs-number">0</span>];    <span class="hljs-type">ssize_t</span> readBufferSize = kProcReadStackBufferSize;    <span class="hljs-type">ssize_t</span> numberBytesRead;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-comment">// By using pread, we can avoid an lseek to rewind the FD</span>        <span class="hljs-comment">// before retry, saving a system call.</span>        numberBytesRead = <span class="hljs-built_in">pread</span>(fd, readBuffer, readBufferSize, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (numberBytesRead &lt; <span class="hljs-number">0</span> &amp;&amp; errno == EINTR) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (numberBytesRead &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (kDebugProc) &#123;                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Unable to open process file: %s fd=%d\n&quot;</span>, file8, fd.<span class="hljs-built_in">get</span>());            &#125;            <span class="hljs-keyword">return</span> JNI_FALSE;        &#125;        <span class="hljs-keyword">if</span> (numberBytesRead &lt; readBufferSize) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (readBufferSize &gt; std::numeric_limits&lt;<span class="hljs-type">ssize_t</span>&gt;::<span class="hljs-built_in">max</span>() / <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span> (kDebugProc) &#123;                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Proc file too big: %s fd=%d\n&quot;</span>, file8, fd.<span class="hljs-built_in">get</span>());            &#125;            <span class="hljs-keyword">return</span> JNI_FALSE;        &#125;        readBufferSize = std::<span class="hljs-built_in">max</span>(readBufferSize * <span class="hljs-number">2</span>,                                  kProcReadMinHeapBufferSize);        readBufferHeap.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// Free address space before getting more.</span>        readBufferHeap = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">char</span>[]&gt;(readBufferSize);        <span class="hljs-keyword">if</span> (!readBufferHeap) &#123;            <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">return</span> JNI_FALSE;        &#125;        readBuffer = readBufferHeap.<span class="hljs-built_in">get</span>();    &#125;    <span class="hljs-comment">// parseProcLineArray below modifies the buffer while parsing!</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">android_os_Process_parseProcLineArray</span>(        env, clazz, readBuffer, <span class="hljs-number">0</span>, numberBytesRead,        format, outStrings, outLongs, outFloats);&#125;<span class="hljs-function">jboolean <span class="hljs-title">android_os_Process_parseProcLineArray</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">char</span>* buffer, jint startIndex, jint endIndex, jintArray format,</span></span><span class="hljs-params"><span class="hljs-function">        jobjectArray outStrings, jlongArray outLongs, jfloatArray outFloats)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">const</span> jsize NF = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(format);    <span class="hljs-type">const</span> jsize NS = outStrings ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outStrings) : <span class="hljs-number">0</span>;    <span class="hljs-type">const</span> jsize NL = outLongs ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outLongs) : <span class="hljs-number">0</span>;    <span class="hljs-type">const</span> jsize NR = outFloats ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outFloats) : <span class="hljs-number">0</span>;    jint* formatData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(format, <span class="hljs-number">0</span>);    jlong* longsData = outLongs ?        env-&gt;<span class="hljs-built_in">GetLongArrayElements</span>(outLongs, <span class="hljs-number">0</span>) : <span class="hljs-literal">NULL</span>;    jfloat* floatsData = outFloats ?        env-&gt;<span class="hljs-built_in">GetFloatArrayElements</span>(outFloats, <span class="hljs-number">0</span>) : <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span> (formatData == <span class="hljs-literal">NULL</span> || (NL &gt; <span class="hljs-number">0</span> &amp;&amp; longsData == <span class="hljs-literal">NULL</span>)            || (NR &gt; <span class="hljs-number">0</span> &amp;&amp; floatsData == <span class="hljs-literal">NULL</span>)) &#123;        <span class="hljs-keyword">if</span> (formatData != <span class="hljs-literal">NULL</span>) &#123;            env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(format, formatData, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span> (longsData != <span class="hljs-literal">NULL</span>) &#123;            env-&gt;<span class="hljs-built_in">ReleaseLongArrayElements</span>(outLongs, longsData, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span> (floatsData != <span class="hljs-literal">NULL</span>) &#123;            env-&gt;<span class="hljs-built_in">ReleaseFloatArrayElements</span>(outFloats, floatsData, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> JNI_FALSE;    &#125;    jsize i = startIndex;    jsize di = <span class="hljs-number">0</span>;    jboolean res = JNI_TRUE;    <span class="hljs-keyword">for</span> (jsize fi=<span class="hljs-number">0</span>; fi&lt;NF; fi++) &#123;        jint mode = formatData[fi];        <span class="hljs-keyword">if</span> ((mode&amp;PROC_PARENS) != <span class="hljs-number">0</span>) &#123;            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode&amp;PROC_QUOTES) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (buffer[i] == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;                i++;            &#125; <span class="hljs-keyword">else</span> &#123;                mode &amp;= ~PROC_QUOTES;            &#125;        &#125;        <span class="hljs-type">const</span> <span class="hljs-type">char</span> term = (<span class="hljs-type">char</span>)(mode&amp;PROC_TERM_MASK);        <span class="hljs-type">const</span> jsize start = i;        <span class="hljs-keyword">if</span> (i &gt;= endIndex) &#123;            <span class="hljs-keyword">if</span> (kDebugProc) &#123;                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Ran off end of data @%d&quot;</span>, i);            &#125;            res = JNI_FALSE;            <span class="hljs-keyword">break</span>;        &#125;        jsize end = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span> ((mode&amp;PROC_PARENS) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] != <span class="hljs-string">&#x27;)&#x27;</span>) &#123;                i++;            &#125;            end = i;            i++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode&amp;PROC_QUOTES) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (buffer[i] != <span class="hljs-string">&#x27;&quot;&#x27;</span> &amp;&amp; i &lt; endIndex) &#123;                i++;            &#125;            end = i;            i++;        &#125;        <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] != term) &#123;            i++;        &#125;        <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;            end = i;        &#125;        <span class="hljs-keyword">if</span> (i &lt; endIndex) &#123;            i++;            <span class="hljs-keyword">if</span> ((mode&amp;PROC_COMBINE) != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] == term) &#123;                    i++;                &#125;            &#125;        &#125;        <span class="hljs-comment">//ALOGI(&quot;Field %&quot; PRId32 &quot;: %&quot; PRId32 &quot;-%&quot; PRId32 &quot; dest=%&quot; PRId32 &quot; mode=0x%&quot; PRIx32 &quot;\n&quot;, i, start, end, di, mode);</span>        <span class="hljs-keyword">if</span> ((mode&amp;(PROC_OUT_FLOAT|PROC_OUT_LONG|PROC_OUT_STRING)) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">char</span> c = buffer[end];            buffer[end] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_FLOAT) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NR) &#123;                <span class="hljs-type">char</span>* end;                floatsData[di] = <span class="hljs-built_in">strtof</span>(buffer+start, &amp;end);            &#125;            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_LONG) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NL) &#123;                <span class="hljs-keyword">if</span> ((mode&amp;PROC_CHAR) != <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// Caller wants single first character returned as one long.</span>                    longsData[di] = buffer[start];                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-type">char</span>* end;                    longsData[di] = <span class="hljs-built_in">strtoll</span>(buffer+start, &amp;end, <span class="hljs-number">10</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_STRING) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NS) &#123;                jstring str = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(buffer+start);                env-&gt;<span class="hljs-built_in">SetObjectArrayElement</span>(outStrings, di, str);            &#125;            buffer[end] = c;            di++;        &#125;    &#125;    env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(format, formatData, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (longsData != <span class="hljs-literal">NULL</span>) &#123;        env-&gt;<span class="hljs-built_in">ReleaseLongArrayElements</span>(outLongs, longsData, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">if</span> (floatsData != <span class="hljs-literal">NULL</span>) &#123;        env-&gt;<span class="hljs-built_in">ReleaseFloatArrayElements</span>(outFloats, floatsData, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="CPU-概览-proc-stat"><a href="#CPU-概览-proc-stat" class="headerlink" title="CPU 概览 /proc/stat"></a>CPU 概览 <code>/proc/stat</code></h3><p><code>ProcessCpuTracker.update()</code> 同时也从 <code>/proc/stat</code> 收集了某个时间段内总的 CPU 时间用以计算各进程的 CPU 使用率；下面是从 MI 9 上获取的 <code>/proc/stat</code> 文件内容，看得出来它有八个核心（骁龙 855），CPU 时间的单位为 <code>jiffies</code>，各字段的含义如下：</p><blockquote><p><code>jiffies</code> 是内核中的一个全局变量，用来记录自系统启动以来产生的 <strong>节拍数</strong>，在 linux 中一个节拍大致可理解为操作系统进程调度的最小时间片，不同 linux 内核可能值有不同，通常在 1ms 到 10ms 之间</p></blockquote><table><thead><tr><th>index</th><th>name</th><th>desc</th></tr></thead><tbody><tr><td>0</td><td>user</td><td>处于用户态的运行时间（nice &lt;= 0 的进程）</td></tr><tr><td>1</td><td>nice</td><td>处于用户态的运行时间（nice &gt; 0 的进程）</td></tr><tr><td>2</td><td>system</td><td>处于核心态的运行时间</td></tr><tr><td>3</td><td>idle</td><td>除 IO 等待时间以外的其它等待时间</td></tr><tr><td>4</td><td>iowait</td><td>IO等待时间</td></tr><tr><td>5</td><td>irq</td><td>硬中断时间</td></tr><tr><td>6</td><td>softirq</td><td>软中断时间</td></tr><tr><td>7</td><td>steal</td><td>被盗时间，虚拟化环境中运行其他操作系统上花费的时间（since Linux 2.6.11）</td></tr><tr><td>8</td><td>guest</td><td>来宾时间，操作系统运行虚拟CPU花费的时间(since Linux 2.6.24)</td></tr><tr><td>9</td><td>guest_nice</td><td>nice 来宾时间，运行一个带 nice 值的 guest 花费的时间(since Linux 2.6.33)</td></tr></tbody></table><p>可以看到跟 <code>进程概览</code> 一样，<code>mBaseXxxTime</code> 记录的是当前值，<code>mRelXxxTime</code> 记录的是当前与上一次的差值</p><div class="code-wrapper"><pre><code class="hljs shell">cepheus:/ $ cat /proc/statcpu  1908033 248762 1291479 9313559 21704 241034 75778 0 0 0cpu0 261151 61609 246778 2138176 9728 89991 29646 0 0 0cpu1 280460 61787 257071 884928 2710 43158 18528 0 0 0cpu2 280724 62167 252355 892787 2211 44246 9462 0 0 0cpu3 184034 10677 205483 975756 2070 33267 12197 0 0 0cpu4 283943 16128 102688 1078345 1403 9754 1747 0 0 0cpu5 289844 13063 106131 1078167 1614 10022 1788 0 0 0cpu6 292748 12779 104992 1080547 1446 9863 1902 0 0 0cpu7 35125 10548 15978 1184849 520 730 504 0 0 0intr 195962347 0 0 0 0 26288625 0 2879495 0 2097574 0 0 0 0 280 76 0 11 0 2 0 199 0 2 0 2 92 0 0 2 30 0 0 390294 340099 0 35976 0 0 0 0 0 0 0 0 0 0 0 138 0 0 0 0 0 0 0 1 0 147 0 102 0 0 66880 0 0 0 0 0 0 6032 0 0 0 0 0 0 0 0 0 0 0 0 0 212 0 0 0 0 0 0 0 0 0 0 0 0 5551 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2308413 6080542 16668 0 0 29 0 0 0 0 0 0 0 2938 1213 12 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3135 0 0 0 0 0 0 0 0 0 0 0 0 467941 0 0 0 0 0 0 0 0 0 0 0 16029 443134 6 192353 303384 26156 0 0 0 0 0 226499 103608 771093 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 498 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 153671 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 4 52028 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65667 0 77 0 0 0 0 0 0 0 330476 0 0 0 0 1342751 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 1 0 1 0 0 0 25847 0 0 72 0 0 0 527 4 0 2 2 0 0 3 0 0 5 0 0 0 0 0 62695 0 0 0 0 0 23 0 0 0 0 0 0 0 0 4 2 0 7 0 0 0 0 0 0 0 6 7 7 0 7 0 30 351 0 0 0 0 0 0 0 0 0 7 0 0 7 0 0 1034 504 0 760 2 0 0 1 0 0 0 0 0 0 0 0 22385 1250 4578494 1293217 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 455534 0 0 23167ctxt 292922052btime 1634510913processes 215684procs_running 1procs_blocked 0softirq 28955158 6101535 6564415 106706 1458910 1999704 0 1242328 6001922 0 5479638</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Update: &quot;</span> + <span class="hljs-built_in">this</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowUptime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowRealtime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowWallTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] sysCpu = mSystemCpuData;        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/stat&quot;</span>, SYSTEM_CPU_FORMAT,                <span class="hljs-literal">null</span>, sysCpu, <span class="hljs-literal">null</span>)) &#123;            <span class="hljs-comment">// Total user time is user + nice time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">usertime</span> <span class="hljs-operator">=</span> (sysCpu[<span class="hljs-number">0</span>]+sysCpu[<span class="hljs-number">1</span>]) * mJiffyMillis;            <span class="hljs-comment">// Total system time is simply system time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">systemtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">2</span>] * mJiffyMillis;            <span class="hljs-comment">// Total idle time is simply idle time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">idletime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">3</span>] * mJiffyMillis;            <span class="hljs-comment">// Total irq time is iowait + irq + softirq time.</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">iowaittime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">4</span>] * mJiffyMillis;            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">irqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">5</span>] * mJiffyMillis;            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">softirqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">6</span>] * mJiffyMillis;            <span class="hljs-comment">// This code is trying to avoid issues with idle time going backwards,</span>            <span class="hljs-comment">// but currently it gets into situations where it triggers most of the time. :(</span>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> || (usertime &gt;= mBaseUserTime &amp;&amp; systemtime &gt;= mBaseSystemTime                    &amp;&amp; iowaittime &gt;= mBaseIoWaitTime &amp;&amp; irqtime &gt;= mBaseIrqTime                    &amp;&amp; softirqtime &gt;= mBaseSoftIrqTime &amp;&amp; idletime &gt;= mBaseIdleTime)) &#123;                mRelUserTime = (<span class="hljs-type">int</span>)(usertime - mBaseUserTime);                mRelSystemTime = (<span class="hljs-type">int</span>)(systemtime - mBaseSystemTime);                mRelIoWaitTime = (<span class="hljs-type">int</span>)(iowaittime - mBaseIoWaitTime);                mRelIrqTime = (<span class="hljs-type">int</span>)(irqtime - mBaseIrqTime);                mRelSoftIrqTime = (<span class="hljs-type">int</span>)(softirqtime - mBaseSoftIrqTime);                mRelIdleTime = (<span class="hljs-type">int</span>)(idletime - mBaseIdleTime);                mRelStatsAreGood = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span> (DEBUG) &#123;                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Total U:&quot;</span> + (sysCpu[<span class="hljs-number">0</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; N:&quot;</span> + (sysCpu[<span class="hljs-number">1</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; S:&quot;</span> + (sysCpu[<span class="hljs-number">2</span>]*mJiffyMillis) + <span class="hljs-string">&quot; I:&quot;</span> + (sysCpu[<span class="hljs-number">3</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; W:&quot;</span> + (sysCpu[<span class="hljs-number">4</span>]*mJiffyMillis) + <span class="hljs-string">&quot; Q:&quot;</span> + (sysCpu[<span class="hljs-number">5</span>]*mJiffyMillis)                          + <span class="hljs-string">&quot; O:&quot;</span> + (sysCpu[<span class="hljs-number">6</span>]*mJiffyMillis));                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Rel U:&quot;</span> + mRelUserTime + <span class="hljs-string">&quot; S:&quot;</span> + mRelSystemTime                          + <span class="hljs-string">&quot; I:&quot;</span> + mRelIdleTime + <span class="hljs-string">&quot; Q:&quot;</span> + mRelIrqTime);                &#125;                mBaseUserTime = usertime;                mBaseSystemTime = systemtime;                mBaseIoWaitTime = iowaittime;                mBaseIrqTime = irqtime;                mBaseSoftIrqTime = softirqtime;                mBaseIdleTime = idletime;            &#125; <span class="hljs-keyword">else</span> &#123;                mRelUserTime = <span class="hljs-number">0</span>;                mRelSystemTime = <span class="hljs-number">0</span>;                mRelIoWaitTime = <span class="hljs-number">0</span>;                mRelIrqTime = <span class="hljs-number">0</span>;                mRelSoftIrqTime = <span class="hljs-number">0</span>;                mRelIdleTime = <span class="hljs-number">0</span>;                mRelStatsAreGood = <span class="hljs-literal">false</span>;                Slog.w(TAG, <span class="hljs-string">&quot;/proc/stats has gone backwards; skipping CPU update&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        mLastSampleTime = mCurrentSampleTime;        mCurrentSampleTime = nowUptime;        mLastSampleRealTime = mCurrentSampleRealTime;        mCurrentSampleRealTime = nowRealtime;        mLastSampleWallTime = mCurrentSampleWallTime;        mCurrentSampleWallTime = nowWallTime;        <span class="hljs-comment">// ...</span>    &#125;    &#125;</code></pre></div><h3 id="打印进程概览"><a href="#打印进程概览" class="headerlink" title="打印进程概览"></a>打印进程概览</h3><p><code>printProcessCPU(prefix, pid, label, totalTime, user, system, iowait, irg, softIrq, minFaults, majFaults)</code> 打印出一行的 CPU 使用率（一行对应一个进程）</p><p><code>ProcessCpuTracker.printCurrentState</code> 会输出两类 CPU 使用率：</p><ol><li>在进程生存的时间段内（<code>SystemClock.uptimeMillis()</code>），分配给进程的 CPU 时间的占比，细分用户态和内核态</li><li>在两个采集点（<code>ProcessCpuTracker.update</code>）之间的时间段内，CPU 的整体使用率（idle time 表示空闲）</li></ol><div class="code-wrapper"><pre><code class="hljs log">[prefix][(user + system + iowait + irq + softIrq) / totalTime]% [pid]/[label]: [user/totalTime]% user + [system/totalTime]% kernel + [iowait/totalTime]% iowait + [irq/totalTime]% irq + [softirq/totalTime]% softirq / faults: [minFaults] minor [majFaults] major32% 8356/com.taobao.taobao: 17% user + 15% kernel / faults: 9334 minor 85 major19% TOTAL: 8% user + 9.2% kernel + 0.6% iowait + 0.9% irq + 0.4% softirq</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printCurrentState</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">totalTime</span> <span class="hljs-operator">=</span> mRelUserTime + mRelSystemTime + mRelIoWaitTime                + mRelIrqTime + mRelSoftIrqTime + mRelIdleTime;        <span class="hljs-keyword">if</span> (DEBUG) Slog.i(TAG, <span class="hljs-string">&quot;totalTime &quot;</span> + totalTime + <span class="hljs-string">&quot; over sample time &quot;</span>                + (mCurrentSampleTime-mLastSampleTime));        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> mWorkingProcs.size();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;            <span class="hljs-type">Stats</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> mWorkingProcs.get(i);            printProcessCPU(pw, st.added ? <span class="hljs-string">&quot; +&quot;</span> : (st.removed ? <span class="hljs-string">&quot; -&quot;</span>: <span class="hljs-string">&quot;  &quot;</span>),                    st.pid, st.name, (<span class="hljs-type">int</span>)st.rel_uptime,                    st.rel_utime, st.rel_stime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, st.rel_minfaults, st.rel_majfaults);            <span class="hljs-keyword">if</span> (!st.removed &amp;&amp; st.workingThreads != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> st.workingThreads.size();                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;M; j++) &#123;                    <span class="hljs-type">Stats</span> <span class="hljs-variable">tst</span> <span class="hljs-operator">=</span> st.workingThreads.get(j);                    printProcessCPU(pw,                            tst.added ? <span class="hljs-string">&quot;   +&quot;</span> : (tst.removed ? <span class="hljs-string">&quot;   -&quot;</span>: <span class="hljs-string">&quot;    &quot;</span>),                            tst.pid, tst.name, (<span class="hljs-type">int</span>)st.rel_uptime,                            tst.rel_utime, tst.rel_stime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                &#125;            &#125;        &#125;        printProcessCPU(pw, <span class="hljs-string">&quot;&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;TOTAL&quot;</span>, totalTime, mRelUserTime, mRelSystemTime,                mRelIoWaitTime, mRelIrqTime, mRelSoftIrqTime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        pw.flush();        <span class="hljs-keyword">return</span> sw.toString();    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcessCPU</span><span class="hljs-params">(PrintWriter pw, String prefix, <span class="hljs-type">int</span> pid, String label,</span><span class="hljs-params">            <span class="hljs-type">int</span> totalTime, <span class="hljs-type">int</span> user, <span class="hljs-type">int</span> system, <span class="hljs-type">int</span> iowait, <span class="hljs-type">int</span> irq, <span class="hljs-type">int</span> softIrq,</span><span class="hljs-params">            <span class="hljs-type">int</span> minFaults, <span class="hljs-type">int</span> majFaults)</span> &#123;        pw.print(prefix);        <span class="hljs-keyword">if</span> (totalTime == <span class="hljs-number">0</span>) totalTime = <span class="hljs-number">1</span>;        printRatio(pw, user+system+iowait+irq+softIrq, totalTime);        pw.print(<span class="hljs-string">&quot;% &quot;</span>);        <span class="hljs-keyword">if</span> (pid &gt;= <span class="hljs-number">0</span>) &#123;            pw.print(pid);            pw.print(<span class="hljs-string">&quot;/&quot;</span>);        &#125;        pw.print(label);        pw.print(<span class="hljs-string">&quot;: &quot;</span>);        printRatio(pw, user, totalTime);        pw.print(<span class="hljs-string">&quot;% user + &quot;</span>);        printRatio(pw, system, totalTime);        pw.print(<span class="hljs-string">&quot;% kernel&quot;</span>);        <span class="hljs-keyword">if</span> (iowait &gt; <span class="hljs-number">0</span>) &#123;            pw.print(<span class="hljs-string">&quot; + &quot;</span>);            printRatio(pw, iowait, totalTime);            pw.print(<span class="hljs-string">&quot;% iowait&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (irq &gt; <span class="hljs-number">0</span>) &#123;            pw.print(<span class="hljs-string">&quot; + &quot;</span>);            printRatio(pw, irq, totalTime);            pw.print(<span class="hljs-string">&quot;% irq&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (softIrq &gt; <span class="hljs-number">0</span>) &#123;            pw.print(<span class="hljs-string">&quot; + &quot;</span>);            printRatio(pw, softIrq, totalTime);            pw.print(<span class="hljs-string">&quot;% softirq&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (minFaults &gt; <span class="hljs-number">0</span> || majFaults &gt; <span class="hljs-number">0</span>) &#123;            pw.print(<span class="hljs-string">&quot; / faults:&quot;</span>);            <span class="hljs-keyword">if</span> (minFaults &gt; <span class="hljs-number">0</span>) &#123;                pw.print(<span class="hljs-string">&quot; &quot;</span>);                pw.print(minFaults);                pw.print(<span class="hljs-string">&quot; minor&quot;</span>);            &#125;            <span class="hljs-keyword">if</span> (majFaults &gt; <span class="hljs-number">0</span>) &#123;                pw.print(<span class="hljs-string">&quot; &quot;</span>);                pw.print(majFaults);                pw.print(<span class="hljs-string">&quot; major&quot;</span>);            &#125;        &#125;        pw.println();    &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">     * 打印 numerator / denominator 至 pw，最多保留一位小数位</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printRatio</span><span class="hljs-params">(PrintWriter pw, <span class="hljs-type">long</span> numerator, <span class="hljs-type">long</span> denominator)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">thousands</span> <span class="hljs-operator">=</span> (numerator*<span class="hljs-number">1000</span>)/denominator;        <span class="hljs-type">long</span> <span class="hljs-variable">hundreds</span> <span class="hljs-operator">=</span> thousands/<span class="hljs-number">10</span>;        pw.print(hundreds);        <span class="hljs-keyword">if</span> (hundreds &lt; <span class="hljs-number">10</span>) &#123;            <span class="hljs-type">long</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> thousands - (hundreds*<span class="hljs-number">10</span>);            <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;                pw.print(<span class="hljs-string">&#x27;.&#x27;</span>);                pw.print(remainder);            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="ANR-日志文件"><a href="#ANR-日志文件" class="headerlink" title="ANR 日志文件"></a>ANR 日志文件</h1><p>ANR 日志文件太大了，下面仅展示日志的基本结构，整个示例文件可以在 <a href="../../../../files/2021-06-27-deep-drive-into-anr/anr_2021-09-29-16-02-49-393">这里</a> 下载</p><p>日志文件包含多个进程，每个进程以 <code>----- pid [pid] at [time] -----</code> 开始，以 <code>----- end [pid] -----</code> 结束，而且很明显地分为 <code>java process</code> 和 <code>native process</code></p><div class="code-wrapper"><pre><code class="hljs log"># java process 包含了 JVM 各种统计信息以及 thread trace----- pid 001 at 2021-09-29 16:02:49 -----Cmd line: com.example.myapplication...DALVIK THREADS (16):&quot;main&quot; prio=5 tid=1 Sleeping  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x72313478 self=0xb400007f542bbc00  | sysTid=27750 nice=-10 cgrp=default sched=0/0 handle=0x7f559584f8  | state=S schedstat=( 439366137 82406360 402 ) utm=36 stm=7 core=0 HZ=100  | stack=0x7ffd85d000-0x7ffd85f000 stackSize=8192KB  | held mutexes=  at java.lang.Thread.sleep(Native method)  - sleeping on &lt;0x0bd69ce3&gt; (a java.lang.Object)  at java.lang.Thread.sleep(Thread.java:442)  - locked &lt;0x0bd69ce3&gt; (a java.lang.Object)  at java.lang.Thread.sleep(Thread.java:358)  at com.example.myapplication.MainActivity.onCreate$lambda-0(MainActivity.kt:20)  at com.example.myapplication.MainActivity.lambda$b-o9DaQhxOUy1smA7kVJfKXtbVM(MainActivity.kt:-1)  at com.example.myapplication.-$$Lambda$MainActivity$b-o9DaQhxOUy1smA7kVJfKXtbVM.onClick(lambda:-1)  at android.view.View.performClick(View.java:7509)  at android.view.View.performClickInternal(View.java:7486)  at android.view.View.access$3600(View.java:841)  at android.view.View$PerformClick.run(View.java:28709)  at android.os.Handler.handleCallback(Handler.java:938)  at android.os.Handler.dispatchMessage(Handler.java:99)  at android.os.Looper.loop(Looper.java:236)  at android.app.ActivityThread.main(ActivityThread.java:8061)  at java.lang.reflect.Method.invoke(Native method)  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)...----- end 001 -----# native process 就只有各个线程的 PC 寄存器值----- pid 002 at 2021-09-29 16:02:52 -----Cmd line: media.codecABI: &#x27;arm&#x27;&quot;omx@1.0-service&quot; sysTid=1464    #00 pc 000a0644  /apex/com.android.runtime/lib/bionic/libc.so (__ioctl+8) (BuildId: 3516bc395829323390a814b64aaaf5a1)    #01 pc 0006c56b  /apex/com.android.runtime/lib/bionic/libc.so (ioctl+26) (BuildId: 3516bc395829323390a814b64aaaf5a1)    #02 pc 0005f5f3  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::talkWithDriver(bool)+190) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)    #03 pc 0005f79f  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::getAndExecuteCommand()+22) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)    #04 pc 00060671  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::joinThreadPool(bool)+100) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)    #05 pc 00002389  /vendor/bin/hw/android.hardware.media.omx@1.0-service (main+936) (BuildId: 116b35d790a6fac142d3d1eac096a1b8)    #06 pc 0005fddb  /apex/com.android.runtime/lib/bionic/libc.so (__libc_init+66) (BuildId: 3516bc395829323390a814b64aaaf5a1)...----- end 002 -----</code></pre></div><h2 id="目录和文件名"><a href="#目录和文件名" class="headerlink" title="目录和文件名"></a>目录和文件名</h2><p><code>ProcessErrorStateRecord.appNotResponding</code> 在输出 logcat 日志的同时也输出了更加详细的 ANR Trace 至文件里，如下代码所示，<code>ActivityManagerService.dumpStackTraces</code> 创建了日志文件 <code>/data/anr/anr_[yyyy-MM-dd-HH-mm-ss-SSS]</code></p><p><code>/data/anr</code> 目录下超过一天，或者超过 64 个日志文件后最旧的，都会被清理掉</p><blockquote><p>旧版本的 Android 上日志文件在 /data/anr/traces.txt</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ANR_TRACE_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/data/anr&quot;</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ANR_FILE_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;anr_&quot;</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span><span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];        <span class="hljs-type">File</span> <span class="hljs-variable">tracesFile</span> <span class="hljs-operator">=</span> ActivityManagerService.dumpStackTraces(firstPids,                isSilentAnr ? <span class="hljs-literal">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-literal">null</span> : lastPids,                nativePids, tracesFileException, offsets, annotation);        <span class="hljs-comment">// ...                </span>        <span class="hljs-keyword">if</span> (tracesFile == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// There is no trace file, so dump (only) the alleged culprit&#x27;s threads to the log</span>            Process.sendSignal(pid, Process.SIGNAL_QUIT);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsets[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// We&#x27;ve dumped into the trace file successfully</span>            mService.mProcessList.mAppExitInfoTracker.scheduleLogAnrTrace(                    pid, mApp.uid, mApp.getPackageList(), tracesFile, offsets[<span class="hljs-number">0</span>], offsets[<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-comment">// ...</span>    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;    <span class="hljs-comment">/* package */</span> <span class="hljs-keyword">static</span> File <span class="hljs-title function_">dumpStackTraces</span><span class="hljs-params">(ArrayList&lt;Integer&gt; firstPids,</span><span class="hljs-params">            ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,</span><span class="hljs-params">            ArrayList&lt;Integer&gt; nativePids, StringWriter logExceptionCreatingFile,</span><span class="hljs-params">            <span class="hljs-type">long</span>[] firstPidOffsets, String subject)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">tracesDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(ANR_TRACE_DIR);        <span class="hljs-comment">// Each set of ANR traces is written to a separate file and dumpstate will process</span>        <span class="hljs-comment">// all such files and add them to a captured bug report if they&#x27;re recent enough.</span>        maybePruneOldTraces(tracesDir);        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We should consider creating the file in native code atomically once we&#x27;ve</span>        <span class="hljs-comment">// gotten rid of the old scheme of dumping and lot of the code that deals with paths</span>        <span class="hljs-comment">// can be removed.</span>        File tracesFile;        <span class="hljs-keyword">try</span> &#123;            tracesFile = createAnrDumpFile(tracesDir);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            Slog.w(TAG, <span class="hljs-string">&quot;Exception creating ANR dump file:&quot;</span>, e);            <span class="hljs-keyword">if</span> (logExceptionCreatingFile != <span class="hljs-literal">null</span>) &#123;                logExceptionCreatingFile.append(<span class="hljs-string">&quot;----- Exception creating ANR dump file -----\n&quot;</span>);                e.printStackTrace(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(logExceptionCreatingFile));            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> File <span class="hljs-title function_">createAnrDumpFile</span><span class="hljs-params">(File tracesDir)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-keyword">if</span> (sAnrFileDateFormat == <span class="hljs-literal">null</span>) &#123;            sAnrFileDateFormat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd-HH-mm-ss-SSS&quot;</span>);        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">formattedDate</span> <span class="hljs-operator">=</span> sAnrFileDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">anrFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tracesDir, ANR_FILE_PREFIX + formattedDate);        <span class="hljs-keyword">if</span> (anrFile.createNewFile()) &#123;            FileUtils.setPermissions(anrFile.getAbsolutePath(), <span class="hljs-number">0600</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// -rw-------</span>            <span class="hljs-keyword">return</span> anrFile;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to create ANR dump file: createNewFile failed&quot;</span>);        &#125;    &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * Prune all trace files that are more than a day old.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> It might make sense to move this functionality to tombstoned eventually, along with a</span><span class="hljs-comment">     * shift away from anr_XX and tombstone_XX to a more descriptive name. We do it here for now</span><span class="hljs-comment">     * since it&#x27;s the system_server that creates trace files for most ANRs.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maybePruneOldTraces</span><span class="hljs-params">(File tracesDir)</span> &#123;        <span class="hljs-keyword">final</span> File[] files = tracesDir.listFiles();        <span class="hljs-keyword">if</span> (files == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> SystemProperties.getInt(<span class="hljs-string">&quot;tombstoned.max_anr_count&quot;</span>, <span class="hljs-number">64</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">try</span> &#123;            Arrays.sort(files, Comparator.comparingLong(File::lastModified).reversed());            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; files.length; ++i) &#123;                <span class="hljs-keyword">if</span> (i &gt; max || (now - files[i].lastModified()) &gt; DAY_IN_MILLIS) &#123;                    <span class="hljs-keyword">if</span> (!files[i].delete()) &#123;                        Slog.w(TAG, <span class="hljs-string">&quot;Unable to prune stale trace file: &quot;</span> + files[i]);                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;            <span class="hljs-comment">// The modification times changed while we were sorting. Bail...</span>            <span class="hljs-comment">// https://issuetracker.google.com/169836837</span>            Slog.w(TAG, <span class="hljs-string">&quot;tombstone modification times changed while sorting; not pruning&quot;</span>, e);        &#125;    &#125;          &#125;</code></pre></div><p>但是没有 root 权限的 adb 是没法查看文件的，也就没法通过 <code>adb pull</code> 把日志拉取出来进行分析，想要拿到 ANR Trace 只能通过 <code>adb bugreport</code>（参考 <a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a> 和 <a href="https://developer.android.com/studio/debug/bug-report">Bug Reports</a>）</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/data_anr_permission.png" alt="data_anr_permission"></p><h2 id="进程的次序"><a href="#进程的次序" class="headerlink" title="进程的次序"></a>进程的次序</h2><p>日志文件是由一个个的进程信息组成，而这些进程在 dump 的时候是有次序的，如下代码所示：</p><ol><li>第一个是发生 ANR 的进程的 pid</li><li>第二个是 parent pid（有的话）</li><li>第三个是 system server 进程</li><li>其他 APP 进程（受 AMS 管理的进程，保存在 <code>ActivityManagerService.mProcessList</code>）</li><li>然后是 native processes，其实就是进程的 <code>cmdline</code> 包含在 <code>WatchDog.NATIVE_STACKS_OF_INTEREST</code> 里的进程；进程的 <code>cmdline</code> 读取自 <code>/proc/[pid]/cmdline</code>，APP 是包名，其他则是可执行程序的路径</li><li>最后是 <code>lastPids</code>，它们是 <code>ActivityManagerService.mProcessList</code> 里不正常的进程（比如 ANR process）</li></ol><p>如果进程很多，那么 dump processes 耗费的时间也是很可观的，所以整个 dump processes 的过程有个时间上限 20s，超过这个阈值即使还有进程没有 dump 也会将其忽略，这也就解释了为什么要按上面的逻辑对进程进行排序，因为要优先打印重要的进程信息</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span><span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;        ArrayList&lt;Integer&gt; firstPids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">5</span>);        SparseArray&lt;Boolean&gt; lastPids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;&gt;(<span class="hljs-number">20</span>);        <span class="hljs-keyword">synchronized</span> (mService) &#123;            <span class="hljs-comment">// ...</span>            <span class="hljs-comment">// Dump thread traces as quickly as we can, starting with &quot;interesting&quot; processes.</span>            firstPids.add(pid);            <span class="hljs-comment">// Don&#x27;t dump other PIDs if it&#x27;s a background ANR or is requested to only dump self.</span>            isSilentAnr = isSilentAnr();            <span class="hljs-keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">parentPid</span> <span class="hljs-operator">=</span> pid;                <span class="hljs-keyword">if</span> (parentProcess != <span class="hljs-literal">null</span> &amp;&amp; parentProcess.getPid() &gt; <span class="hljs-number">0</span>) &#123;                    parentPid = parentProcess.getPid();                &#125;                <span class="hljs-keyword">if</span> (parentPid != pid) firstPids.add(parentPid);                <span class="hljs-keyword">if</span> (MY_PID != pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ppid</span> <span class="hljs-operator">=</span> parentPid;                mService.mProcessList.forEachLruProcessesLOSP(<span class="hljs-literal">false</span>, r -&gt; &#123;                    <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span> &amp;&amp; r.getThread() != <span class="hljs-literal">null</span>) &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">myPid</span> <span class="hljs-operator">=</span> r.getPid();                        <span class="hljs-keyword">if</span> (myPid &gt; <span class="hljs-number">0</span> &amp;&amp; myPid != pid &amp;&amp; myPid != ppid &amp;&amp; myPid != MY_PID) &#123;                            <span class="hljs-keyword">if</span> (r.isPersistent()) &#123;                                firstPids.add(myPid);                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding persistent proc: &quot;</span> + r);                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.mServices.isTreatedLikeActivity()) &#123;                                firstPids.add(myPid);                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding likely IME: &quot;</span> + r);                            &#125; <span class="hljs-keyword">else</span> &#123;                                lastPids.put(myPid, Boolean.TRUE);                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding ANR proc: &quot;</span> + r);                            &#125;                        &#125;                    &#125;                &#125;);            &#125;        &#125;        <span class="hljs-comment">// Log the ANR to the main log ...</span>        <span class="hljs-comment">// don&#x27;t dump native PIDs for background ANRs unless it is the process of interest</span>        String[] nativeProcs = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (isSilentAnr || onlyDumpSelf) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;                <span class="hljs-keyword">if</span> (NATIVE_STACKS_OF_INTEREST[i].equals(mApp.processName)) &#123;                    nativeProcs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; mApp.processName &#125;;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            nativeProcs = NATIVE_STACKS_OF_INTEREST;        &#125;        <span class="hljs-type">int</span>[] pids = nativeProcs == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : Process.getPidsForCommands(nativeProcs);        ArrayList&lt;Integer&gt; nativePids = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (pids != <span class="hljs-literal">null</span>) &#123;            nativePids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(pids.length);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : pids) &#123;                nativePids.add(i);            &#125;        &#125;        <span class="hljs-comment">// For background ANRs, don&#x27;t pass the ProcessCpuTracker to</span>        <span class="hljs-comment">// avoid spending 1/2 second collecting stats to rank lastPids.</span>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">tracesFileException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();        <span class="hljs-comment">// To hold the start and end offset to the ANR trace file respectively.</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];        <span class="hljs-type">File</span> <span class="hljs-variable">tracesFile</span> <span class="hljs-operator">=</span> ActivityManagerService.dumpStackTraces(firstPids,                isSilentAnr ? <span class="hljs-literal">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-literal">null</span> : lastPids,                nativePids, tracesFileException, offsets, annotation);        <span class="hljs-comment">// ...</span>    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">WatchDog</span> &#123;    <span class="hljs-comment">// Which native processes to dump into dropbox&#x27;s stack traces</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NATIVE_STACKS_OF_INTEREST = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;        <span class="hljs-string">&quot;/system/bin/audioserver&quot;</span>,        <span class="hljs-string">&quot;/system/bin/cameraserver&quot;</span>,        <span class="hljs-string">&quot;/system/bin/drmserver&quot;</span>,        <span class="hljs-string">&quot;/system/bin/keystore2&quot;</span>,        <span class="hljs-string">&quot;/system/bin/mediadrmserver&quot;</span>,        <span class="hljs-string">&quot;/system/bin/mediaserver&quot;</span>,        <span class="hljs-string">&quot;/system/bin/netd&quot;</span>,        <span class="hljs-string">&quot;/system/bin/sdcard&quot;</span>,        <span class="hljs-string">&quot;/system/bin/surfaceflinger&quot;</span>,        <span class="hljs-string">&quot;/system/bin/vold&quot;</span>,        <span class="hljs-string">&quot;media.extractor&quot;</span>, <span class="hljs-comment">// system/bin/mediaextractor</span>        <span class="hljs-string">&quot;media.metrics&quot;</span>, <span class="hljs-comment">// system/bin/mediametrics</span>        <span class="hljs-string">&quot;media.codec&quot;</span>, <span class="hljs-comment">// vendor/bin/hw/android.hardware.media.omx@1.0-service</span>        <span class="hljs-string">&quot;media.swcodec&quot;</span>, <span class="hljs-comment">// /apex/com.android.media.swcodec/bin/mediaswcodec</span>        <span class="hljs-string">&quot;media.transcoding&quot;</span>, <span class="hljs-comment">// Media transcoding service</span>        <span class="hljs-string">&quot;com.android.bluetooth&quot;</span>,  <span class="hljs-comment">// Bluetooth service</span>        <span class="hljs-string">&quot;/apex/com.android.os.statsd/bin/statsd&quot;</span>,  <span class="hljs-comment">// Stats daemon</span>    &#125;;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;Long, Long&gt; <span class="hljs-title function_">dumpStackTraces</span><span class="hljs-params">(String tracesFile, ArrayList&lt;Integer&gt; firstPids,</span><span class="hljs-params">            ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids)</span> &#123;        Slog.i(TAG, <span class="hljs-string">&quot;Dumping to &quot;</span> + tracesFile);        <span class="hljs-comment">// We don&#x27;t need any sort of inotify based monitoring when we&#x27;re dumping traces via</span>        <span class="hljs-comment">// tombstoned. Data is piped to an &quot;intercept&quot; FD installed in tombstoned so we&#x27;re in full</span>        <span class="hljs-comment">// control of all writes to the file in question.</span>        <span class="hljs-comment">// We must complete all stack dumps within 20 seconds.</span>        <span class="hljs-type">long</span> <span class="hljs-variable">remainingTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span> * <span class="hljs-number">1000</span> * Build.HW_TIMEOUT_MULTIPLIER;        <span class="hljs-comment">// As applications are usually interested with the ANR stack traces, but we can&#x27;t share with</span>        <span class="hljs-comment">// them the stack traces other than their own stacks. So after the very first PID is</span>        <span class="hljs-comment">// dumped, remember the current file size.</span>        <span class="hljs-type">long</span> <span class="hljs-variable">firstPidStart</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-type">long</span> <span class="hljs-variable">firstPidEnd</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-comment">// First collect all of the stacks of the most important pids.</span>        <span class="hljs-keyword">if</span> (firstPids != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> firstPids.size();            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> firstPids.get(i);                <span class="hljs-comment">// We don&#x27;t copy ANR traces from the system_server intentionally.</span>                <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">firstPid</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> &amp;&amp; MY_PID != pid;                <span class="hljs-type">File</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">if</span> (firstPid) &#123;                    tf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tracesFile);                    firstPidStart = tf.exists() ? tf.length() : <span class="hljs-number">0</span>;                &#125;                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for pid &quot;</span> + pid);                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> dumpJavaTracesTombstoned(pid, tracesFile,                                                                remainingTime);                remainingTime -= timeTaken;                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current firstPid=&quot;</span> + pid                            + <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;                &#125;                <span class="hljs-keyword">if</span> (firstPid) &#123;                    firstPidEnd = tf.length();                &#125;                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;                    Slog.d(TAG, <span class="hljs-string">&quot;Done with pid &quot;</span> + firstPids.get(i) + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);                &#125;            &#125;        &#125;        <span class="hljs-comment">// Next collect the stacks of the native pids</span>        <span class="hljs-keyword">if</span> (nativePids != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pid : nativePids) &#123;                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for native pid &quot;</span> + pid);                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nativeDumpTimeoutMs</span> <span class="hljs-operator">=</span> Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();                Debug.dumpNativeBacktraceToFileTimeout(                        pid, tracesFile, (<span class="hljs-type">int</span>) (nativeDumpTimeoutMs / <span class="hljs-number">1000</span>));                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime() - start;                remainingTime -= timeTaken;                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current native pid=&quot;</span> + pid +                        <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;                &#125;                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;                    Slog.d(TAG, <span class="hljs-string">&quot;Done with native pid &quot;</span> + pid + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);                &#125;            &#125;        &#125;        <span class="hljs-comment">// Lastly, dump stacks for all extra PIDs from the CPU tracker.</span>        <span class="hljs-keyword">if</span> (extraPids != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pid : extraPids) &#123;                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for extra pid &quot;</span> + pid);                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);                remainingTime -= timeTaken;                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current extra pid=&quot;</span> + pid +                            <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;                &#125;                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;                    Slog.d(TAG, <span class="hljs-string">&quot;Done with extra pid &quot;</span> + pid + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);                &#125;            &#125;        &#125;        Slog.i(TAG, <span class="hljs-string">&quot;Done dumping&quot;</span>);        <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">jintArray <span class="hljs-title">android_os_Process_getPidsForCommands</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><span class="hljs-params"><span class="hljs-function">        jobjectArray commandNames)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (commandNames == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    Vector&lt;String8&gt; commands;    jsize count = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(commandNames);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;        jobject obj = env-&gt;<span class="hljs-built_in">GetObjectArrayElement</span>(commandNames, i);        <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>((jstring)obj, <span class="hljs-literal">NULL</span>);            <span class="hljs-keyword">if</span> (str8 == <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;Element in commandNames&quot;</span>);                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;            &#125;            commands.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">String8</span>(str8));            env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>((jstring)obj, str8);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;Element in commandNames&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;    &#125;    Vector&lt;jint&gt; pids;    DIR *proc = <span class="hljs-built_in">opendir</span>(<span class="hljs-string">&quot;/proc&quot;</span>);    <span class="hljs-keyword">if</span> (proc == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;/proc: %s\n&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *d;    <span class="hljs-keyword">while</span> ((d = <span class="hljs-built_in">readdir</span>(proc))) &#123;        <span class="hljs-type">int</span> pid = <span class="hljs-built_in">atoi</span>(d-&gt;d_name);        <span class="hljs-keyword">if</span> (pid &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-type">char</span> path[PATH_MAX];        <span class="hljs-type">char</span> data[PATH_MAX];        <span class="hljs-built_in">snprintf</span>(path, <span class="hljs-built_in">sizeof</span>(path), <span class="hljs-string">&quot;/proc/%d/cmdline&quot;</span>, pid);        <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY | O_CLOEXEC);        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-type">const</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(fd, data, <span class="hljs-built_in">sizeof</span>(data)<span class="hljs-number">-1</span>);        <span class="hljs-built_in">close</span>(fd);        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        data[len] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;                data[i] = <span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;commands.<span class="hljs-built_in">size</span>(); i++) &#123;            <span class="hljs-keyword">if</span> (commands[i] == data) &#123;                pids.<span class="hljs-built_in">add</span>(pid);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-built_in">closedir</span>(proc);    jintArray pidArray = env-&gt;<span class="hljs-built_in">NewIntArray</span>(pids.<span class="hljs-built_in">size</span>());    <span class="hljs-keyword">if</span> (pidArray == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">if</span> (pids.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;        env-&gt;<span class="hljs-built_in">SetIntArrayRegion</span>(pidArray, <span class="hljs-number">0</span>, pids.<span class="hljs-built_in">size</span>(), pids.<span class="hljs-built_in">array</span>());    &#125;    <span class="hljs-keyword">return</span> pidArray;&#125;</code></pre></div><h2 id="dump-java-traces"><a href="#dump-java-traces" class="headerlink" title="dump java traces"></a>dump java traces</h2><p>dump process 时分为 <code>java process</code> 和 <code>native process</code>，此章节将讨论 dump java process</p><p>跟着下面的代码一路跟踪下去最终会来到 <code>debuggerd_trigger_dump</code>，大概过一遍发现此方法并没有实现 dump java process 逻辑，那它都干了些什么：</p><ol><li>创建一条 <a href="https://man7.org/linux/man-pages/man7/pipe.7.html">管道</a>：<code>pipe_read</code> - <code>pipe_write</code></li><li>创建一个 unix domain socket 连接到 <code>/dev/socket/tombstoned_intercept</code> 并将需要被 dump 的进程的 <code>pid</code>、<code>dumpType</code> 和 <code>pipe_write</code> 发送过去（将 <code>pipe_write</code> 注册到 <code>debuggerd.tombstoned</code>）</li><li>给 <code>pid</code> 进程发送信号 <code>SIGQUIT</code>，进程里的 <code>Signal Catcher</code> 线程被唤醒进行 process dump 操作，并从 <code>debuggerd.tombstoned</code> 拿到 <code>pipe_write</code> 将 dump 写入</li><li>在一个 <code>while(true)</code> 循环里等待 <code>pipe_read</code> 直到可读/有数据（<a href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll</code></a>，参考 <a href="../../../../2021/05/11/nonblocking-io/">网络 IO 演变发展过程和模型介绍</a>），将数据写入日志文件，这里的数据就是 process dump 的内容；同时上面有讲过 dump 是有时间上限的，所以循环里还要时刻检查是否还有剩余时间</li></ol><blockquote><p>man pipe.7</p><p>Pipes provide a unidirectional interprocess communication channel.  A pipe has a read end and a write end.  Data written to the write end of a pipe can be read from the read end of the pipe.</p><p>If a process attempts to read from an empty pipe, then read(2) will block until data is available.  If a process attempts to write to a full pipe (see below), then write(2) blocks until sufficient data has been read from &gt; the pipe to allow the write to complete.</p><p>A pipe has a limited capacity.  If the pipe is full, then a write(2) will block or fail, depending on whether the O_NONBLOCK flag is set (see below).  Different implementations have different limits for the pipe capacity.</p><p>In Linux versions before 2.6.11, the capacity of a pipe was the same as the system page size (e.g., 4096 bytes on i386).  </p><p>Since Linux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536 bytes in a system with a page size  of  4096 bytes).  </p><p>Since Linux 2.6.35, the default pipe capacity is 16 pages, but the capacity can be queried and set using the fcntl(2) F_GETPIPE_SZ and F_SETPIPE_SZ operations. </p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dumpJavaTracesTombstoned</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, String fileName, <span class="hljs-type">long</span> timeoutMs)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeStart</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();        <span class="hljs-type">boolean</span> <span class="hljs-variable">javaSuccess</span> <span class="hljs-operator">=</span> Debug.dumpJavaBacktraceToFileTimeout(pid, fileName,                (<span class="hljs-type">int</span>) (timeoutMs / <span class="hljs-number">1000</span>));        <span class="hljs-keyword">if</span> (javaSuccess) &#123;            <span class="hljs-comment">// Check that something is in the file, actually. Try-catch should not be necessary,</span>            <span class="hljs-comment">// but better safe than sorry.</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(fileName).length();                <span class="hljs-keyword">if</span> (size &lt; JAVA_DUMP_MINIMUM_SIZE) &#123;                    Slog.w(TAG, <span class="hljs-string">&quot;Successfully created Java ANR file is empty!&quot;</span>);                    javaSuccess = <span class="hljs-literal">false</span>;                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                Slog.w(TAG, <span class="hljs-string">&quot;Unable to get ANR file size&quot;</span>, e);                javaSuccess = <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (!javaSuccess) &#123;            Slog.w(TAG, <span class="hljs-string">&quot;Dumping Java threads failed, initiating native stack dump.&quot;</span>);            <span class="hljs-keyword">if</span> (!Debug.dumpNativeBacktraceToFileTimeout(pid, fileName,                    (NATIVE_DUMP_TIMEOUT_MS / <span class="hljs-number">1000</span>))) &#123;                Slog.w(TAG, <span class="hljs-string">&quot;Native stack dump failed!&quot;</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> SystemClock.elapsedRealtime() - timeStart;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> jboolean <span class="hljs-title">android_os_Debug_dumpJavaBacktraceToFileTimeout</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><span class="hljs-params"><span class="hljs-function">        jint pid, jstring fileName, jint timeoutSecs)</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">dumpTraces</span>(env, pid, fileName, timeoutSecs, kDebuggerdJavaBacktrace);    <span class="hljs-keyword">return</span> ret ? JNI_TRUE : JNI_FALSE;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">dumpTraces</span><span class="hljs-params">(JNIEnv* env, jint pid, jstring fileName, jint timeoutSecs,</span></span><span class="hljs-params"><span class="hljs-function">                       DebuggerdDumpType dumpType)</span> </span>&#123;    <span class="hljs-function"><span class="hljs-type">const</span> ScopedUtfChars <span class="hljs-title">fileNameChars</span><span class="hljs-params">(env, fileName)</span></span>;    <span class="hljs-keyword">if</span> (fileNameChars.<span class="hljs-built_in">c_str</span>() == <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(open(fileNameChars.c_str(),</span></span><span class="hljs-params"><span class="hljs-function">                                     O_CREAT | O_WRONLY | O_NOFOLLOW | O_CLOEXEC | O_APPEND,</span></span><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-number">0666</span>))</span></span>;    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t open &quot;</span> &lt;&lt; fileNameChars.<span class="hljs-built_in">c_str</span>();        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dump_backtrace_to_file_timeout</span>(pid, dumpType, timeoutSecs, fd);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdatasync</span>(fd.<span class="hljs-built_in">get</span>()) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed flushing trace.&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> res == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dump_backtrace_to_file_timeout</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="hljs-type">int</span> timeout_secs,</span></span><span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">int</span> fd)</span> </span>&#123;  android::<span class="hljs-function">base::unique_fd <span class="hljs-title">copy</span><span class="hljs-params">(dup(fd))</span></span>;  <span class="hljs-keyword">if</span> (copy == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;  <span class="hljs-comment">// debuggerd_trigger_dump results in every thread in the process being interrupted</span>  <span class="hljs-comment">// by a signal, so we need to fetch the wchan data before calling that.</span>  std::string wchan_data = <span class="hljs-built_in">get_wchan_data</span>(fd, tid);  <span class="hljs-type">int</span> timeout_ms = timeout_secs &gt; <span class="hljs-number">0</span> ? timeout_secs * <span class="hljs-number">1000</span> : <span class="hljs-number">0</span>;  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">debuggerd_trigger_dump</span>(tid, dump_type, timeout_ms, std::<span class="hljs-built_in">move</span>(copy)) ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;  <span class="hljs-comment">// Dump wchan data, since only privileged processes (CAP_SYS_ADMIN) can read</span>  <span class="hljs-comment">// kernel stack traces (/proc/*/stack).</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteStringToFd</span>(wchan_data, fd)) &#123;    <span class="hljs-built_in">LOG</span>(WARNING) &lt;&lt; TAG <span class="hljs-string">&quot;Failed to dump wchan data for pid: &quot;</span> &lt;&lt; tid;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">debuggerd_trigger_dump</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> timeout_ms,</span></span><span class="hljs-params"><span class="hljs-function">                            unique_fd output_fd)</span> </span>&#123;  <span class="hljs-type">pid_t</span> pid = tid;  <span class="hljs-keyword">if</span> (dump_type == kDebuggerdJavaBacktrace) &#123;    <span class="hljs-comment">// Java dumps always get sent to the tgid, so we need to resolve our tid to a tgid.</span>    android::procinfo::ProcessInfo procinfo;    std::string error;    <span class="hljs-keyword">if</span> (!android::procinfo::<span class="hljs-built_in">GetProcessInfo</span>(tid, &amp;procinfo, &amp;error)) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to get process info: %s&quot;</span>, error.<span class="hljs-built_in">c_str</span>());      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    pid = procinfo.pid;  &#125;  <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; TAG <span class="hljs-string">&quot;started dumping process &quot;</span> &lt;&lt; pid;  <span class="hljs-comment">// Rather than try to deal with poll() all the way through the flow, we update</span>  <span class="hljs-comment">// the socket timeout between each step (and only use poll() during the final</span>  <span class="hljs-comment">// copy loop).</span>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">milliseconds</span>(timeout_ms);  <span class="hljs-keyword">auto</span> update_timeout = [timeout_ms, &amp;output_fd](<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">auto</span> end) &#123;    <span class="hljs-keyword">if</span> (timeout_ms &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">auto</span> remaining = end - std::chrono::steady_clock::<span class="hljs-built_in">now</span>();    <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-keyword">decltype</span>(remaining)::<span class="hljs-built_in">zero</span>()) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> timeout;    <span class="hljs-built_in">populate_timeval</span>(&amp;timeout, remaining);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, <span class="hljs-built_in">sizeof</span>(timeout)) != <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set receive timeout&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, <span class="hljs-built_in">sizeof</span>(timeout)) != <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set send timeout&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;;  <span class="hljs-function">unique_fd <span class="hljs-title">sockfd</span><span class="hljs-params">(socket(AF_LOCAL, SOCK_SEQPACKET, <span class="hljs-number">0</span>))</span></span>;  <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to create socket&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">socket_local_client_connect</span>(sockfd.<span class="hljs-built_in">get</span>(), kTombstonedInterceptSocketName,                                  ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET) == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to connect to tombstoned&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  InterceptRequest req = &#123;      .dump_type = dump_type,      .pid = pid,  &#125;;  <span class="hljs-comment">// Create an intermediate pipe to pass to the other end.</span>  unique_fd pipe_read, pipe_write;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Pipe</span>(&amp;pipe_read, &amp;pipe_write)) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to create pipe&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  std::string pipe_size_str;  <span class="hljs-type">int</span> pipe_buffer_size = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;  <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/sys/fs/pipe-max-size&quot;</span>, &amp;pipe_size_str)) &#123;    pipe_size_str = android::base::<span class="hljs-built_in">Trim</span>(pipe_size_str);    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">ParseInt</span>(pipe_size_str.<span class="hljs-built_in">c_str</span>(), &amp;pipe_buffer_size, <span class="hljs-number">0</span>)) &#123;      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;failed to parse pipe max size &#x27;&quot;</span> &lt;&lt; pipe_size_str &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(pipe_read.<span class="hljs-built_in">get</span>(), F_SETPIPE_SZ, pipe_buffer_size) != pipe_buffer_size) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set pipe buffer size&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-type">ssize_t</span> rc = <span class="hljs-built_in">SendFileDescriptors</span>(sockfd, &amp;req, <span class="hljs-built_in">sizeof</span>(req), pipe_write.<span class="hljs-built_in">get</span>());  pipe_write.<span class="hljs-built_in">reset</span>();  <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in">sizeof</span>(req)) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to send output fd to tombstoned&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-keyword">auto</span> get_response = [&amp;output_fd](<span class="hljs-type">const</span> <span class="hljs-type">char</span>* kind, <span class="hljs-type">int</span> sockfd, InterceptResponse* response) &#123;    <span class="hljs-type">ssize_t</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">recv</span>(sockfd, response, <span class="hljs-built_in">sizeof</span>(*response), MSG_TRUNC));    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to read %s response from tombstoned: timeout reached?&quot;</span>, kind);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to read %s response from tombstoned&quot;</span>, kind);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in">sizeof</span>(*response)) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>,                <span class="hljs-string">&quot;received packet of unexpected length from tombstoned while reading %s response: &quot;</span>                <span class="hljs-string">&quot;expected %zd, received %zd&quot;</span>,                kind, <span class="hljs-built_in">sizeof</span>(response), rc);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;;  <span class="hljs-comment">// Check to make sure we&#x27;ve successfully registered.</span>  InterceptResponse response;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_response</span>(<span class="hljs-string">&quot;initial&quot;</span>, sockfd, &amp;response)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (response.status != InterceptStatus::kRegistered) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;unexpected registration response: %d&quot;</span>,              <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(response.status));    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// Send the signal.</span>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> signal = (dump_type == kDebuggerdJavaBacktrace) ? SIGQUIT : BIONIC_SIGNAL_DEBUGGER;  sigval val = &#123;.sival_int = (dump_type == kDebuggerdNativeBacktrace) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigqueue</span>(pid, signal, val) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to send signal to pid %d&quot;</span>, pid);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_response</span>(<span class="hljs-string">&quot;status&quot;</span>, sockfd, &amp;response)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (response.status != InterceptStatus::kStarted) &#123;    response.error_message[<span class="hljs-built_in">sizeof</span>(response.error_message) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;tombstoned reported failure: %s&quot;</span>, response.error_message);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// Forward output from the pipe to the output fd.</span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">auto</span> remaining = end - std::chrono::steady_clock::<span class="hljs-built_in">now</span>();    <span class="hljs-keyword">auto</span> remaining_ms = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(remaining).<span class="hljs-built_in">count</span>();    <span class="hljs-keyword">if</span> (timeout_ms &lt;= <span class="hljs-number">0</span>) &#123;      remaining_ms = <span class="hljs-number">-1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remaining_ms &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> pfd = &#123;        .fd = pipe_read.<span class="hljs-built_in">get</span>(), .events = POLLIN, .revents = <span class="hljs-number">0</span>,    &#125;;    rc = <span class="hljs-built_in">poll</span>(&amp;pfd, <span class="hljs-number">1</span>, remaining_ms);    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;      <span class="hljs-keyword">if</span> (errno == EINTR) &#123;        <span class="hljs-keyword">continue</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while polling&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];    rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(pipe_read.<span class="hljs-built_in">get</span>(), buf, <span class="hljs-built_in">sizeof</span>(buf)));    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// Done.</span>      <span class="hljs-keyword">break</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while reading&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">WriteFully</span>(output_fd.<span class="hljs-built_in">get</span>(), buf, rc)) &#123;      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while writing&quot;</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; TAG <span class="hljs-string">&quot;done dumping process &quot;</span> &lt;&lt; pid;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// Helper for SendFileDescriptorVector that constructs a std::vector for you, e.g.:</span><span class="hljs-comment">//   SendFileDescriptors(sock, &quot;foo&quot;, 3, std::move(fd1), std::move(fd2))</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">SendFileDescriptors</span><span class="hljs-params">(borrowed_fd sock, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> len, Args&amp;&amp;... sent_fds)</span> </span>&#123;  <span class="hljs-comment">// Do not allow implicit conversion to int: people might try to do something along the lines of:</span>  <span class="hljs-comment">//   SendFileDescriptors(..., std::move(a_unique_fd))</span>  <span class="hljs-comment">// and be surprised when the unique_fd isn&#x27;t closed afterwards.</span>  <span class="hljs-built_in">AssertType</span>&lt;<span class="hljs-type">int</span>&gt;(std::forward&lt;Args&gt;(sent_fds)...);  std::vector&lt;<span class="hljs-type">int</span>&gt; fds;  <span class="hljs-built_in">Append</span>(fds, std::forward&lt;Args&gt;(sent_fds)...);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">SendFileDescriptorVector</span>(sock, data, len, fds);&#125;<span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">SendFileDescriptorVector</span><span class="hljs-params">(borrowed_fd sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> len,</span></span><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; fds)</span> </span>&#123;  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> page_size = <span class="hljs-built_in">sysconf</span>(_SC_PAGE_SIZE);  <span class="hljs-type">size_t</span> cmsg_space = <span class="hljs-built_in">CMSG_SPACE</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * fds.<span class="hljs-built_in">size</span>());  <span class="hljs-type">size_t</span> cmsg_len = <span class="hljs-built_in">CMSG_LEN</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * fds.<span class="hljs-built_in">size</span>());  <span class="hljs-keyword">if</span> (cmsg_space &gt;= page_size) &#123;    errno = ENOMEM;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;  <span class="hljs-built_in">alignas</span>(<span class="hljs-keyword">struct</span> cmsghdr) <span class="hljs-type">char</span> cmsg_buf[cmsg_space];  iovec iov = &#123;.iov_base = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(data), .iov_len = len&#125;;  msghdr msg = &#123;      .msg_name = <span class="hljs-literal">nullptr</span>,      .msg_namelen = <span class="hljs-number">0</span>,      .msg_iov = &amp;iov,      .msg_iovlen = <span class="hljs-number">1</span>,      .msg_control = cmsg_buf,      <span class="hljs-comment">// We can&#x27;t cast to the actual type of the field, because it&#x27;s different across platforms.</span>      .msg_controllen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(cmsg_space),      .msg_flags = <span class="hljs-number">0</span>,  &#125;;  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmsghdr</span>* cmsg = <span class="hljs-built_in">CMSG_FIRSTHDR</span>(&amp;msg);  cmsg-&gt;cmsg_level = SOL_SOCKET;  cmsg-&gt;cmsg_type = SCM_RIGHTS;  cmsg-&gt;cmsg_len = cmsg_len;  <span class="hljs-type">int</span>* cmsg_fds = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">CMSG_DATA</span>(cmsg));  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; fds.<span class="hljs-built_in">size</span>(); ++i) &#123;    cmsg_fds[i] = fds[i];  &#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__linux__)</span>  <span class="hljs-type">int</span> flags = MSG_NOSIGNAL;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  <span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">sendmsg</span>(sockfd.<span class="hljs-built_in">get</span>(), &amp;msg, flags));&#125;</code></pre></div><h3 id="Unix-Domain-Socket"><a href="#Unix-Domain-Socket" class="headerlink" title="Unix Domain Socket"></a>Unix Domain Socket</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><span class="hljs-comment"> * man socket.2</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * domain: </span><span class="hljs-comment"> *   AF_UNIX/AF_LOCAL Local communication</span><span class="hljs-comment"> *   AF_INET          IPv4 Internet protocols</span><span class="hljs-comment"> *   AF_INET6         IPv6 Internet protocols</span><span class="hljs-comment"> *   ...</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * type: </span><span class="hljs-comment"> *   SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams, 网络协议簇上的实现就是 TCP</span><span class="hljs-comment"> *   SOCK_DGRAM      connectionless, unreliable messages of a fixed maximum length, 网络协议簇上的实现就是 UDP</span><span class="hljs-comment"> *   SOCK_SEQPACKET  Provides a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length</span><span class="hljs-comment"> *                   a consumer is required to read an entire packet with each input system call</span><span class="hljs-comment"> *                   看起来像是 TCP + UDP</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span></code></pre></div><p>使用 Java/Kotlin 编程 <code>socket</code> 一般就是代表 <a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">网络协议簇</a> 中的传输层协议 TCP 和 UDP，但在 C 里 <a href="https://man7.org/linux/man-pages/man7/socket.7.html">socket</a> 包含一整套 API 如下图：</p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/socket.jpg" alt="socket"></p><p><code>Unix Domain Socket</code>，也就是 <code>socket(AF_UNIX/AF_LOCAL, ...)</code> 则是一种 <code>IPC</code> 机制，对标的是 <code>pipe</code>、<code>FIFO</code>、<code>signal</code>，它不走网络协议簇（性能好）却又可以使用上图所示丰富的 API 实现双向的、全双工的、多路复用的 IPC。相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 Unix Domain Socket 通讯的</p><p>Unix Domain Socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 <code>sockaddr_un</code> 表示，网络编程的地址是 <code>ip:port</code> 而 Unix Domain Socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个文件在 <code>bind</code> 调用时创建，如果该文件已存在则 <code>bind</code> 错误返回，<code>close</code> 后需要自己主动删除</p><h3 id="SignalCatcher-amp-SIGQUIT"><a href="#SignalCatcher-amp-SIGQUIT" class="headerlink" title="SignalCatcher &amp; SIGQUIT"></a>SignalCatcher &amp; SIGQUIT</h3><p>如下图所示，<code>zygote</code> fork 出 system server 和 app process 后会创建一个叫 <code>Signal Catcher</code> 的 native thread 并将其绑定到 VM，它的 routine 是 <code> SignalCatcher::Run</code>，main loop 是等待并响应信号 <code>SIGQUIT</code> 和 <code>SIGUSR1</code></p><p><img src="../../../../image/2021-07-10-deep-drive-into-anr/signal_catcher_thread.png" alt="signal_catcher_thread"></p><blockquote><p>int sigwait(const sigset_t *set, int *sig)</p><p>The  sigwait()  function  suspends execution of the calling thread until one of the signals specified in the signal set set becomes pending.  The function accepts the signal (removes it from the pending list of signals), and returns the signal number in sig</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/runtime.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::InitNonZygoteOrPostFork</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    JNIEnv* env,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> is_system_server,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// This is true when we are initializing a child-zygote. It requires</span></span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// native bridge initialization to be able to run guest native code in</span></span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// doPreload().</span></span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> is_child_zygote,</span></span><span class="hljs-params"><span class="hljs-function">    NativeBridgeAction action,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* isa,</span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> profile_system_server)</span> </span>&#123;        <span class="hljs-comment">// ...</span>    <span class="hljs-built_in">StartSignalCatcher</span>();    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::StartSignalCatcher</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (!is_zygote_) &#123;    signal_catcher_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SignalCatcher</span>();  &#125;&#125;<span class="hljs-comment">// art/runtime/signal_catcher.cc</span>SignalCatcher::<span class="hljs-built_in">SignalCatcher</span>()    : <span class="hljs-built_in">lock_</span>(<span class="hljs-string">&quot;SignalCatcher lock&quot;</span>),      <span class="hljs-built_in">cond_</span>(<span class="hljs-string">&quot;SignalCatcher::cond_&quot;</span>, lock_),      <span class="hljs-built_in">thread_</span>(<span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-built_in">SetHaltFlag</span>(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// Create a raw pthread; its start routine will attach to the runtime.</span>  <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_create, (&amp;pthread_, <span class="hljs-literal">nullptr</span>, &amp;Run, <span class="hljs-keyword">this</span>), <span class="hljs-string">&quot;signal catcher thread&quot;</span>);  Thread* self = Thread::<span class="hljs-built_in">Current</span>();  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, lock_)</span></span>;  <span class="hljs-keyword">while</span> (thread_ == <span class="hljs-literal">nullptr</span>) &#123;    cond_.<span class="hljs-built_in">Wait</span>(self);  &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">SignalCatcher::Run</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;  SignalCatcher* signal_catcher = <span class="hljs-built_in">reinterpret_cast</span>&lt;SignalCatcher*&gt;(arg);  <span class="hljs-built_in">CHECK</span>(signal_catcher != <span class="hljs-literal">nullptr</span>);  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();  <span class="hljs-built_in">CHECK</span>(runtime-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(<span class="hljs-string">&quot;Signal Catcher&quot;</span>, <span class="hljs-literal">true</span>, runtime-&gt;<span class="hljs-built_in">GetSystemThreadGroup</span>(),                                     !runtime-&gt;<span class="hljs-built_in">IsAotCompiler</span>()));  Thread* self = Thread::<span class="hljs-built_in">Current</span>();  <span class="hljs-built_in">DCHECK_NE</span>(self-&gt;<span class="hljs-built_in">GetState</span>(), kRunnable);  &#123;    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, signal_catcher-&gt;lock_)</span></span>;    signal_catcher-&gt;thread_ = self;    signal_catcher-&gt;cond_.<span class="hljs-built_in">Broadcast</span>(self);  &#125;  <span class="hljs-comment">// Set up mask with signals we want to handle.</span>  SignalSet signals;  signals.<span class="hljs-built_in">Add</span>(SIGQUIT);  signals.<span class="hljs-built_in">Add</span>(SIGUSR1);  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-type">int</span> signal_number = signal_catcher-&gt;<span class="hljs-built_in">WaitForSignal</span>(self, signals);    <span class="hljs-keyword">if</span> (signal_catcher-&gt;<span class="hljs-built_in">ShouldHalt</span>()) &#123;      runtime-&gt;<span class="hljs-built_in">DetachCurrentThread</span>();      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    &#125;    <span class="hljs-keyword">switch</span> (signal_number) &#123;    <span class="hljs-keyword">case</span> SIGQUIT:      signal_catcher-&gt;<span class="hljs-built_in">HandleSigQuit</span>();      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> SIGUSR1:      signal_catcher-&gt;<span class="hljs-built_in">HandleSigUsr1</span>();      <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:      <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unexpected signal %d&quot;</span> &lt;&lt; signal_number;      <span class="hljs-keyword">break</span>;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SignalCatcher::WaitForSignal</span><span class="hljs-params">(Thread* self, SignalSet&amp; signals)</span> </span>&#123;  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(self, kWaitingInMainSignalCatcherLoop)</span></span>;  <span class="hljs-comment">// Signals for sigwait() must be blocked but not ignored.  We</span>  <span class="hljs-comment">// block signals like SIGQUIT for all threads, so the condition</span>  <span class="hljs-comment">// is met.  When the signal hits, we wake up, without any signal</span>  <span class="hljs-comment">// handlers being invoked.</span>  <span class="hljs-type">int</span> signal_number = signals.<span class="hljs-built_in">Wait</span>();  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ShouldHalt</span>()) &#123;    <span class="hljs-comment">// Let the user know we got the signal, just in case the system&#x27;s too screwed for us to</span>    <span class="hljs-comment">// actually do what they want us to do...</span>    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; *self &lt;&lt; <span class="hljs-string">&quot;: reacting to signal &quot;</span> &lt;&lt; signal_number;    <span class="hljs-comment">// If anyone&#x27;s holding locks (which might prevent us from getting back into state Runnable), say so...</span>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">DumpLockHolders</span>(<span class="hljs-built_in">LOG_STREAM</span>(INFO));  &#125;  <span class="hljs-keyword">return</span> signal_number;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalSet</span> &#123;<span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Sleep in sigwait() until a signal arrives. gdb causes EINTR failures.</span>    <span class="hljs-type">int</span> signal_number;    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">sigwait64</span>(&amp;set_, &amp;signal_number));    <span class="hljs-keyword">if</span> (rc != <span class="hljs-number">0</span>) &#123;      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;sigwait failed&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> signal_number;  &#125;&#125;;</code></pre></div><h3 id="proces-thread-dump"><a href="#proces-thread-dump" class="headerlink" title="proces/thread dump"></a>proces/thread dump</h3><p>APP 在收到信号 <code>SIGQUIT(3)</code> 后，<code>Signal Catcher</code> 线程会将有关 VM 的信息 dump 出来，如下面的代码所示，是不是跟 ANR Traces 日志里的内容很相似？这样我们就可以看着代码一点点地分析出日志里各段的含义</p><div class="code-wrapper"><pre><code class="hljs log">// 以下日志来自 SignalCatcher::HandleSigQuit----- pid 27750(当前进程，也就是被 dump 的进程) at 2021-09-29 16:02:49(输出这段日志的时间) -----Cmd line: com.example.myapplication(来自 /proc/pid/cmdline)Build fingerprint: &#x27;Xiaomi/cepheus/cepheus:11/RKQ1.200826.002/V12.5.4.0.RFACNXM:user/release-keys&#x27;ABI: &#x27;arm64&#x27;Build type: optimized(debug or optimized)// ClassLinker::DumpForSigQuitZygote loaded classes=15972 post zygote classes=782 (为了节省内存 zygote 会加载一些必要的 class，这样 fork 出来的 APP 进程就可以通过父子进程的 Copy-On-Write 机制共享之，15972 是 zygote 加载的 class 数量，782 是 APP 进程额外加载的 class 数量)Dumping registered class loaders (打印 classloader 实例数组)#0 dalvik.system.PathClassLoader: [], parent #1#1 java.lang.BootClassLoader: [], no parent#2 dalvik.system.PathClassLoader: [/system/framework/tcmclient.jar], parent #0#3 dalvik.system.PathClassLoader: [], parent #0#4 dalvik.system.PathClassLoader: [/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes4.dex:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes3.dex:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes2.dex], parent #1#5 dalvik.system.PathClassLoader: [/system/app/MiuiContentCatcher/MiuiContentCatcher.apk], parent #1#6 dalvik.system.PathClassLoader: [/system/app/CatcherPatch/CatcherPatch.apk], parent #1Done dumping class loadersClasses initialized: 371 in 14.764ms/*  * InternTable::DumpForSigQuit *  * Class InternTable used to intern strings. * There are actually two tables: one that holds strong references to its strings, and one that holds weak references.  * The former is used for string literals, for which there is an effective reference from the constant pool.  * The latter is used for strings interned at runtime via String.intern.  * Some code (XML parsers being a prime example) relies on being able to intern arbitrarily many strings for the duration of a parse without permanently increasing the memory footprint. *  * 这个 InternTable 其实就是 String.intern() 方法描述里说的那个字符串池（A pool of strings, initially empty, is maintained privately by the class String） * 它包含两个 table，字符串字面量（来自于字符串常量池）的引用保存在 string table，通过 String.intern() 添加进来的字符串引用保存在 weak table *  * String.intern() 将搜索 InternTable，如果 InternTable 存在相同的字符串则返回它的引用，否则将当前字符串添加到 InternTable 里，这样的好处是可以降低字符串处理程序的内存波动 *  */Intern table: 32394 strong; 523 weak//  JavaVMExt::DumpForSigQuit (JNI 相关，不太懂)JNI: CheckJNI is on; globals=735 (plus 64 weak)Libraries: /data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!/lib/arm64-v8a/libnative-lib.so libandroid.so libaudioeffect_jni.so libcompiler_rt.so libicu_jni.so libjavacore.so libjavacrypto.so libjnigraphics.so libmedia_jni.so libmiuinative.so libopenjdk.so libqti_performance.so librs_jni.so libsfplugin_ccodec.so libsoundpool.so libstats_jni.so libwebviewchromium_loader.so (17)// Heap::DumpForSigQuitHeap: 47% free, 2796KB/5303KB; 71822 objects (VM 堆相关情况，堆申请了 5303KB 的内存，用了 2795KB 剩余 47% 的内存，堆里一共有 71822 个对象)// Heap::DumpGcPerformanceInfo (GC 相关信息)Dumping cumulative Gc timingsStart Dumping histograms for 1 iterations for concurrent copyingScanImmuneSpaces:Sum: 12.444ms 99% C.I. 12.444ms-12.444ms Avg: 12.444ms Max: 12.444msProcessMarkStack:Sum: 12.292ms 99% C.I. 12.292ms-12.292ms Avg: 12.292ms Max: 12.292msVisitConcurrentRoots:Sum: 6.499ms 99% C.I. 6.499ms-6.499ms Avg: 6.499ms Max: 6.499msScanCardsForSpace:Sum: 1.231ms 99% C.I. 1.231ms-1.231ms Avg: 1.231ms Max: 1.231msSweepSystemWeaks:Sum: 924us 99% C.I. 924us-924us Avg: 924us Max: 924usGrayAllDirtyImmuneObjects:Sum: 792us 99% C.I. 792us-792us Avg: 792us Max: 792usClearFromSpace:Sum: 777us 99% C.I. 777us-777us Avg: 777us Max: 777usInitializePhase:Sum: 544us 99% C.I. 544us-544us Avg: 544us Max: 544usFlipOtherThreads:Sum: 309us 99% C.I. 309us-309us Avg: 309us Max: 309usVisitNonThreadRoots:Sum: 270us 99% C.I. 270us-270us Avg: 270us Max: 270usRecordFree:Sum: 95us 99% C.I. 95us-95us Avg: 95us Max: 95usCopyingPhase:Sum: 82us 99% C.I. 82us-82us Avg: 82us Max: 82usForwardSoftReferences:Sum: 77us 99% C.I. 77us-77us Avg: 77us Max: 77usEnqueueFinalizerReferences:Sum: 60us 99% C.I. 60us-60us Avg: 60us Max: 60usMarkZygoteLargeObjects:Sum: 56us 99% C.I. 56us-56us Avg: 56us Max: 56usProcessReferences:Sum: 55us 99% C.I. 8us-47us Avg: 27.500us Max: 47us(Paused)GrayAllNewlyDirtyImmuneObjects:Sum: 40us 99% C.I. 40us-40us Avg: 40us Max: 40usSweepLargeObjects:Sum: 38us 99% C.I. 38us-38us Avg: 38us Max: 38usSwapBitmaps:Sum: 36us 99% C.I. 36us-36us Avg: 36us Max: 36usThreadListFlip:Sum: 35us 99% C.I. 35us-35us Avg: 35us Max: 35usSweepAllocSpace:Sum: 26us 99% C.I. 26us-26us Avg: 26us Max: 26usMarkStackAsLive:Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18usReclaimPhase:Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14usEmptyRBMarkBitStack:Sum: 13us 99% C.I. 13us-13us Avg: 13us Max: 13us(Paused)FlipCallback:Sum: 11us 99% C.I. 11us-11us Avg: 11us Max: 11usResumeRunnableThreads:Sum: 10us 99% C.I. 10us-10us Avg: 10us Max: 10us(Paused)SetFromSpace:Sum: 8us 99% C.I. 8us-8us Avg: 8us Max: 8usUnBindBitmaps:Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7usFlipThreadRoots:Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6usSweep:Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5us(Paused)ClearCards:Sum: 3us 99% C.I. 250ns-1000ns Avg: 142ns Max: 1000nsResumeOtherThreads:Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2usDone Dumping histogramsconcurrent copying paused:Sum: 101us 99% C.I. 101us-101us Avg: 101us Max: 101usconcurrent copying freed-bytes: Avg: 138KB Max: 138KB Min: 138KBFreed-bytes histogram: 0:1concurrent copying total time: 36.779ms mean time: 36.779msconcurrent copying freed: 1138 objects with total size 138KBconcurrent copying throughput: 31611.1/s / 3844KB/s  per cpu-time: 4429000/s / 4325KB/sAverage major GC reclaim bytes ratio 0.841027 over 1 GC cyclesAverage major GC copied live bytes ratio 0.757154 over 5 major GCsCumulative bytes moved 13614368Cumulative objects moved 237506Peak regions allocated 35 (8960KB) / 1024 (256MB)Start Dumping histograms for 1 iterations for young concurrent copyingScanImmuneSpaces:Sum: 9.300ms 99% C.I. 9.300ms-9.300ms Avg: 9.300ms Max: 9.300msProcessMarkStack:Sum: 2.551ms 99% C.I. 2.551ms-2.551ms Avg: 2.551ms Max: 2.551msVisitConcurrentRoots:Sum: 1.263ms 99% C.I. 1.263ms-1.263ms Avg: 1.263ms Max: 1.263msSweepSystemWeaks:Sum: 530us 99% C.I. 530us-530us Avg: 530us Max: 530usClearFromSpace:Sum: 390us 99% C.I. 390us-390us Avg: 390us Max: 390usInitializePhase:Sum: 289us 99% C.I. 289us-289us Avg: 289us Max: 289usGrayAllDirtyImmuneObjects:Sum: 163us 99% C.I. 163us-163us Avg: 163us Max: 163usScanCardsForSpace:Sum: 129us 99% C.I. 129us-129us Avg: 129us Max: 129usFlipOtherThreads:Sum: 75us 99% C.I. 75us-75us Avg: 75us Max: 75usVisitNonThreadRoots:Sum: 54us 99% C.I. 54us-54us Avg: 54us Max: 54usEnqueueFinalizerReferences:Sum: 45us 99% C.I. 45us-45us Avg: 45us Max: 45usSweepArray:Sum: 21us 99% C.I. 21us-21us Avg: 21us Max: 21usProcessReferences:Sum: 20us 99% C.I. 1us-19us Avg: 10us Max: 19usRecordFree:Sum: 19us 99% C.I. 0.250us-19us Avg: 9.500us Max: 19us(Paused)GrayAllNewlyDirtyImmuneObjects:Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18usCopyingPhase:Sum: 15us 99% C.I. 15us-15us Avg: 15us Max: 15usForwardSoftReferences:Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14usFreeList:Sum: 13us 99% C.I. 13us-13us Avg: 13us Max: 13usThreadListFlip:Sum: 8us 99% C.I. 8us-8us Avg: 8us Max: 8usSwapBitmaps:Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7usReclaimPhase:Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6usMarkZygoteLargeObjects:Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5usResetStack:Sum: 4us 99% C.I. 4us-4us Avg: 4us Max: 4usEmptyRBMarkBitStack:Sum: 3us 99% C.I. 3us-3us Avg: 3us Max: 3us(Paused)FlipCallback:Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us(Paused)SetFromSpace:Sum: 1us 99% C.I. 1us-1us Avg: 1us Max: 1us(Paused)ClearCards:Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0nsDone Dumping histogramsyoung concurrent copying paused:Sum: 33us 99% C.I. 33us-33us Avg: 33us Max: 33usyoung concurrent copying freed-bytes: Avg: 4116KB Max: 4116KB Min: 4116KBFreed-bytes histogram: 3840:1young concurrent copying total time: 14.952ms mean time: 14.952msyoung concurrent copying freed: 48492 objects with total size 4116KByoung concurrent copying throughput: 3.46371e+06/s / 287MB/s  per cpu-time: 602219428/s / 574MB/sAverage minor GC reclaim bytes ratio 1.88288 over 1 GC cyclesAverage minor GC copied live bytes ratio 0.126374 over 3 minor GCsCumulative bytes moved 2004720Cumulative objects moved 28694Peak regions allocated 35 (8960KB) / 1024 (256MB)Total time spent in GC: 51.731msMean GC size throughput: 80MB/s per cpu-time: 103MB/sMean GC object throughput: 959386 objects/sTotal number of allocations 121452Total bytes allocated 7051KBTotal bytes freed 4255KBFree memory 2506KBFree memory until GC 2506KBFree memory until OOME 253MBTotal memory 5303KBMax memory 256MBZygote space size 3464KBTotal mutator paused time: 134usTotal time waiting for GC to complete: 11.571msTotal GC count: 2Total GC time: 51.731msTotal blocking GC count: 0Total blocking GC time: 0Histogram of GC count per 10000 ms: 0:16,1:1Histogram of blocking GC count per 10000 ms: 0:17Native bytes total: 21234628 registered: 60540Total native bytes at last GC: 20854836// OatFileManager::DumpForSigQuit/data/dalvik-cache/arm64/system@priv-app@RtMiCloudSDK@RtMiCloudSDK.apk@classes.dex: speed/data/dalvik-cache/arm64/system@app@MiuiContentCatcher@MiuiContentCatcher.apk@classes.dex: speed/data/dalvik-cache/arm64/system@app@CatcherPatch@CatcherPatch.apk@classes.dex: speed// Jit::DumpForSigQuit (JIT 相关)Current JIT code cache size (used / resident): 5KB / 32KBCurrent JIT data cache size (used / resident): 10KB / 32KBZygote JIT code cache size (at point of fork): 60KB / 64KBZygote JIT data cache size (at point of fork): 54KB / 60KBCurrent JIT mini-debug-info size: 44KBCurrent JIT capacity: 64KBCurrent number of JIT JNI stub entries: 0Current number of JIT code cache entries: 64Total number of JIT compilations: 17Total number of JIT compilations for on stack replacement: 0Total number of JIT code cache collections: 0Memory used for stack maps: Avg: 67B Max: 272B Min: 16BMemory used for compiled code: Avg: 304B Max: 1320B Min: 20BMemory used for profiling info: Avg: 111B Max: 728B Min: 32BStart Dumping histograms for 64 iterations for JIT timingsCompiling:Sum: 143.499ms 99% C.I. 0.115ms-18.703ms Avg: 2.242ms Max: 22.565msTrimMaps:Sum: 4.510ms 99% C.I. 8us-707.999us Avg: 70.468us Max: 864usDone Dumping histogramsMemory used for compilation: Avg: 139KB Max: 837KB Min: 15KB// ProfileSaver::DumpInstanceInfoProfileSaver total_bytes_written=2330ProfileSaver total_number_of_writes=1ProfileSaver total_number_of_code_cache_queries=2ProfileSaver total_number_of_skipped_writes=1ProfileSaver total_number_of_failed_writes=0ProfileSaver total_ms_of_sleep=312878ProfileSaver total_ms_of_work=4ProfileSaver total_number_of_hot_spikes=0ProfileSaver total_number_of_wake_ups=1// ThreadList::DumpForSigQuitsuspend all histogram:Sum: 289us 99% C.I. 2us-164us Avg: 20.642us Max: 164us (应该是中断所有线程的执行耗费的时间)// ThreadList::Dump (已绑定到 VM 的线程)DALVIK THREADS (16):// Thread::Dump&quot;main&quot;(线程名) [daemon(如果是 daemon thread)] prio=5(优先级) tid=1(线程 ID) Sleeping(可以是：NEW, RUNNABLE, TIMED_WAITTING|SLEEPING, WAITTING, BLOCKED 和 TERMINATED，参考 art::ThreadState)  | group=&quot;main&quot;(线程组)     /**   * Thread::tls32_::suspend_count, A non-zero value is used to tell the current thread to enter a safe point at the next poll.   *    * save point 是 JVM 里的一个概念，可以认为是一个函数，被 JVM 安插在各个地方：循环末尾、函数执行前/后、抛出异常时...    * 那它有什么用呢？比如 GC/dump 时需要 Stop-The-World 吧，debug 时打断点/单步调试需要中断线程的执行吧，   * 那怎么才能让正在执行 CPU 指令的 java 线程暂停呢？靠的就是安插在各处的 save point 去检查某个指示线程是否可以继续执行的标识   *    * 在 SafePoint 保存了其他位置没有的一些当前线程的运行信息供其他线程读取，包括：线程上下文的任何信息、对象或者非对象的内部指针等等   * 我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息才是确定的，也只有这个时候才知道这个线程用了哪些内存，没有用哪些   * 并且只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到   * 之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候才会感知   *    * 也就是说当 sCount 非零时会进入 save point，非零时会跳过 save point   * 从 ANR Trace 看只有 Signal Catcher 的 sCount 才会为零，猜测 process dump 是需要中断除 Signal Catcher 之外其他线程的执行，只留 Signal Catcher 进行 thread dump 操作   */  sCount=1     /**   * Thread::tls32_::debug_suspend_count   * How much of &#x27;suspend_count_&#x27; is by request of the debugger, used to set things right when the debugger detaches. Must be &lt;= suspend_count_.   * debugger 可以修改 suspend_count（打断点？）但在此之前需要把 suspend_count 的值备份在这个字段，以便退出 debug 的时候可以恢复   *   */  dsCount=0     /**   * Thread::tls32_::state_and_flags::as_struct::flags, bitmap field   *    * enum ThreadFlag &#123;   *   kSuspendRequest         = 1,  // If set implies that suspend_count_ &gt; 0 and the Thread should enter the safepoint handler.   *   kCheckpointRequest      = 2,  // Request that the thread do some checkpoint work and then continue.   *   kEmptyCheckpointRequest = 4,  // Request that the thread do empty checkpoint and then continue.   *   kActiveSuspendBarrier   = 8,  // Register that at least 1 suspend barrier needs to be passed.   * &#125;;   */  flags=1     obj=0x72313478 (Thread::tlsPtr_::opeer, Our managed peer (an instance of java.lang.Thread)，应该是此线程对应的 java thread object 地址)  self=0xb400007f542bbc00 (reinterpret_cast&lt;const void*&gt;(thread), native art::Thread 对象地址)  sysTid=27750 (此线程在宿主系统上的 ID, ps -A -T)   nice=-10 (thread nice value，含义类似于 process nice value，可以动态调整的线程优先级)  cgrp=default (执行此线程的 cpu 的 cpu group，来自于 /proc/self/task/[tid]/cgroup)    /**   * 左边的数字来自 sched_getscheduler(tid)，cpu scheduling policy，有以下值：   *    * non-real-time   * SCHED_NORMAL/SCHED_OTHER = 0   the standard round-robin time-sharing policy   * SCHED_BATCH              = 3   for &quot;batch&quot; style execution of processes   * SCHED_IDLE               = 5   for running very low priority background jobs   *    * real-time   * SCHED_FIFO               = 1   a first-in, first-out policy   * SCHED_RR                 = 2   a round-robin policy   *   * 右边的数字来自于 sched_getparam, scheduling parameters，跟上面的 scheduling policy 配合使用   *   * 这两个都属于 cpu 调度相关，详见 man sched.7   */  sched=0/0   handle=0x7f559584f8 (Thread::tlsPtr_::pthread_self, 底层的 pthread_t 地址)  /**   * 来自 /proc/[pid]/task/[tid]/schedstat，分别是 CPU 上执行的时间、线程的等待时间和线程执行的时间片   */  schedstat=( 439366137 82406360 402 )  /**   * 来自 /proc/[pid]/task/[tid]/stat，里面的字段跟 /proc/[pid]/stat 类似   * state=S(SLEEPING) 线程状态为休眠中   * utm(utime) 线程运行在用户态的时间   * stm(stime) 线程运行在内核态的时间   * core(task_cpu) 运行在哪个 CPU 上   */  state=S  utm=36 stm=7 core=0   HZ=100 (sysconf(_SC_CLK_TCK)，每秒种的内核时钟滴答数)  /**   * Thread::tlsPtr_::stack_begin - Thread::tlsPtr_::stack_end   * 方法栈的开始地址、结束地址和栈大小   */  stack=0x7ffd85d000-0x7ffd85f000 stackSize=8192KB    /**   * 此线程锁持有的锁类型，定义在 art/runtime/base/locks.h，有：   * LockLevel::kLoggingLock, LockLevel::kSwapMutexesLock, ...   */  held mutexes=  at java.lang.Thread.sleep(Native method)  - sleeping on &lt;0x0bd69ce3&gt; (a java.lang.Object)  at java.lang.Thread.sleep(Thread.java:442)  - locked &lt;0x0bd69ce3&gt; (a java.lang.Object)  at java.lang.Thread.sleep(Thread.java:358)  at com.example.myapplication.MainActivity.onCreate$lambda-0(MainActivity.kt:20)  at com.example.myapplication.MainActivity.lambda$b-o9DaQhxOUy1smA7kVJfKXtbVM(MainActivity.kt:-1)  at com.example.myapplication.-$$Lambda$MainActivity$b-o9DaQhxOUy1smA7kVJfKXtbVM.onClick(lambda:-1)  at android.view.View.performClick(View.java:7509)  at android.view.View.performClickInternal(View.java:7486)  at android.view.View.access$3600(View.java:841)  at android.view.View$PerformClick.run(View.java:28709)  at android.os.Handler.handleCallback(Handler.java:938)  at android.os.Handler.dispatchMessage(Handler.java:99)  at android.os.Looper.loop(Looper.java:236)  at android.app.ActivityThread.main(ActivityThread.java:8061)  at java.lang.reflect.Method.invoke(Native method)  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)&quot;Signal Catcher&quot; daemon prio=10 tid=4 Runnable  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x12d80260 self=0xb400007ebd813800  | sysTid=27771 nice=-20 cgrp=default sched=0/0 handle=0x7ebdf73cc0  | state=R schedstat=( 11436460 2051300 7 ) utm=0 stm=0 core=4 HZ=100  | stack=0x7ebde7c000-0x7ebde7e000 stackSize=995KB  | held mutexes= &quot;mutator lock&quot;(shared held)  native: #00 pc 000000000047c188  /apex/com.android.art/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)  native: #01 pc 0000000000581444  /apex/com.android.art/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, bool, BacktraceMap*, bool) const+380)  native: #02 pc 000000000059e288  /apex/com.android.art/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+924)  native: #03 pc 0000000000597c2c  /apex/com.android.art/lib64/libart.so (art::ThreadList::RunCheckpoint(art::Closure*, art::Closure*)+536)  native: #04 pc 0000000000596cb4  /apex/com.android.art/lib64/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, bool)+1928)  native: #05 pc 000000000059614c  /apex/com.android.art/lib64/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;)+776)  native: #06 pc 0000000000543c68  /apex/com.android.art/lib64/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;)+196)  native: #07 pc 0000000000559810  /apex/com.android.art/lib64/libart.so (art::SignalCatcher::HandleSigQuit()+1400)  native: #08 pc 00000000005587d8  /apex/com.android.art/lib64/libart.so (art::SignalCatcher::Run(void*)+348)  native: #09 pc 00000000000f4204  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+64)  native: #10 pc 000000000008ec64  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)  (no managed stack frames)</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SignalCatcher::HandleSigQuit</span><span class="hljs-params">()</span> </span>&#123;  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();  std::ostringstream os;  os &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>      &lt;&lt; <span class="hljs-string">&quot;----- pid &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; <span class="hljs-built_in">GetIsoDate</span>() &lt;&lt; <span class="hljs-string">&quot; -----\n&quot;</span>;  <span class="hljs-built_in">DumpCmdLine</span>(os);  <span class="hljs-comment">// Note: The strings &quot;Build fingerprint:&quot; and &quot;ABI:&quot; are chosen to match the format used by</span>  <span class="hljs-comment">// debuggerd. This allows, for example, the stack tool to work.</span>  std::string fingerprint = runtime-&gt;<span class="hljs-built_in">GetFingerprint</span>();  os &lt;&lt; <span class="hljs-string">&quot;Build fingerprint: &#x27;&quot;</span> &lt;&lt; (fingerprint.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;unknown&quot;</span> : fingerprint) &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;  os &lt;&lt; <span class="hljs-string">&quot;ABI: &#x27;&quot;</span> &lt;&lt; <span class="hljs-built_in">GetInstructionSetString</span>(runtime-&gt;<span class="hljs-built_in">GetInstructionSet</span>()) &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;  os &lt;&lt; <span class="hljs-string">&quot;Build type: &quot;</span> &lt;&lt; (kIsDebugBuild ? <span class="hljs-string">&quot;debug&quot;</span> : <span class="hljs-string">&quot;optimized&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  runtime-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  <span class="hljs-keyword">if</span> ((<span class="hljs-literal">false</span>)) &#123;    std::string maps;    <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, &amp;maps)) &#123;      os &lt;&lt; <span class="hljs-string">&quot;/proc/self/maps:\n&quot;</span> &lt;&lt; maps;    &#125;  &#125;  os &lt;&lt; <span class="hljs-string">&quot;----- end &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; -----\n&quot;</span>;  <span class="hljs-built_in">Output</span>(os.<span class="hljs-built_in">str</span>());&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::DumpForSigQuit</span><span class="hljs-params">(std::ostream&amp; os)</span> </span>&#123;  <span class="hljs-built_in">GetClassLinker</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  <span class="hljs-built_in">GetInternTable</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  <span class="hljs-built_in">GetJavaVM</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  <span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  oat_file_manager_-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetJit</span>() != <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-built_in">GetJit</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  &#125; <span class="hljs-keyword">else</span> &#123;    os &lt;&lt; <span class="hljs-string">&quot;Running non JIT\n&quot;</span>;  &#125;  <span class="hljs-built_in">DumpDeoptimizations</span>(os);  TrackedAllocators::<span class="hljs-built_in">Dump</span>(os);  <span class="hljs-built_in">GetMetrics</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  os &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  thread_list_-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);  BaseMutex::<span class="hljs-built_in">DumpAll</span>(os);  <span class="hljs-comment">// Inform anyone else who is interested in SigQuit.</span>  &#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(Thread::Current())</span></span>;    callbacks_-&gt;<span class="hljs-built_in">SigQuit</span>();  &#125;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DumpCmdLine</span><span class="hljs-params">(std::ostream&amp; os)</span> </span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__linux__)</span>  <span class="hljs-comment">// Show the original command line, and the current command line too if it&#x27;s changed.</span>  <span class="hljs-comment">// On Android, /proc/self/cmdline will have been rewritten to something like &quot;system_server&quot;.</span>  <span class="hljs-comment">// Note: The string &quot;Cmd line:&quot; is chosen to match the format used by debuggerd.</span>  std::string current_cmd_line;  <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/self/cmdline&quot;</span>, &amp;current_cmd_line)) &#123;    current_cmd_line.<span class="hljs-built_in">resize</span>(current_cmd_line.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&#x27;\0&#x27;</span>) + <span class="hljs-number">1</span>);  <span class="hljs-comment">// trim trailing &#x27;\0&#x27;s</span>    std::<span class="hljs-built_in">replace</span>(current_cmd_line.<span class="hljs-built_in">begin</span>(), current_cmd_line.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);    os &lt;&lt; <span class="hljs-string">&quot;Cmd line: &quot;</span> &lt;&lt; current_cmd_line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* stashed_cmd_line = <span class="hljs-built_in">GetCmdLine</span>();    <span class="hljs-keyword">if</span> (stashed_cmd_line != <span class="hljs-literal">nullptr</span> &amp;&amp; current_cmd_line != stashed_cmd_line            &amp;&amp; <span class="hljs-built_in">strcmp</span>(stashed_cmd_line, <span class="hljs-string">&quot;&lt;unset&gt;&quot;</span>) != <span class="hljs-number">0</span>) &#123;      os &lt;&lt; <span class="hljs-string">&quot;Original command line: &quot;</span> &lt;&lt; stashed_cmd_line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;  &#125;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  os &lt;&lt; <span class="hljs-string">&quot;Cmd line: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetCmdLine</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;</code></pre></div><h3 id="debuggerd-tombstoned"><a href="#debuggerd-tombstoned" class="headerlink" title="debuggerd.tombstoned"></a>debuggerd.tombstoned</h3><p>上一章节构造了 dump 字符串，下面我们来看看它被输出到哪里：</p><ol><li>通过 unix domain socket 连接到 <code>/dev/socket/tombstoned_java_trace</code> (<code>ANDROID_SOCKET_NAMESPACE_RESERVED</code> + <code>kTombstonedJavaTraceSocketName</code>，看名字像是一个叫 <code>debuggerd.tombstoned</code> 的服务)</li><li>将 <code>pid</code>、<code>dumpType</code> 等参数发送过去，返回一个 output fd (这个 fd 其实就是上面介绍过的 <code>debuggerd_trigger_dump</code> 里管道的 write fd，它被注册到 <code>debuggerd.tombstoned</code>)</li><li>把 dump 字符串写入 output fd</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SignalCatcher::Output</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(Thread::Current(), kWaitingForSignalCatcherOutput)</span></span>;  <span class="hljs-type">palette_status_t</span> status = <span class="hljs-built_in">PaletteWriteCrashThreadStacks</span>(s.<span class="hljs-built_in">data</span>(), s.<span class="hljs-built_in">size</span>());  <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Wrote stack traces to tombstoned&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">CHECK</span>(status == PALETTE_STATUS_FAILED_CHECK_LOG);    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to write stack traces to tombstoned&quot;</span>;  &#125;&#125;<span class="hljs-comment">// system/libartpalette/palette_android.cc</span><span class="hljs-function"><span class="hljs-type">palette_status_t</span> <span class="hljs-title">PaletteWriteCrashThreadStacks</span><span class="hljs-params">(<span class="hljs-comment">/*in*/</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* stacks, <span class="hljs-type">size_t</span> stacks_len)</span> </span>&#123;    android::base::unique_fd tombstone_fd;    android::base::unique_fd output_fd;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">tombstoned_connect</span>(<span class="hljs-built_in">getpid</span>(), &amp;tombstone_fd, &amp;output_fd, kDebuggerdJavaBacktrace)) &#123;        <span class="hljs-comment">// Failure here could be due to file descriptor resource exhaustion</span>        <span class="hljs-comment">// so write the stack trace message to the log in case it helps</span>        <span class="hljs-comment">// debug that.</span>        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; std::<span class="hljs-built_in">string_view</span>(stacks, stacks_len);        <span class="hljs-comment">// tombstoned_connect() logs failure reason.</span>        <span class="hljs-keyword">return</span> PALETTE_STATUS_FAILED_CHECK_LOG;    &#125;    <span class="hljs-type">palette_status_t</span> status = PALETTE_STATUS_OK;    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">WriteFully</span>(output_fd, stacks, stacks_len)) &#123;        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to write tombstoned output&quot;</span>;        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">ftruncate</span>(output_fd, <span class="hljs-number">0</span>));        status = PALETTE_STATUS_FAILED_CHECK_LOG;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fdatasync</span>(output_fd)) == <span class="hljs-number">-1</span> &amp;&amp; errno != EINVAL) &#123;        <span class="hljs-comment">// Ignore EINVAL so we don&#x27;t report failure if we just tried to flush a pipe</span>        <span class="hljs-comment">// or socket.</span>        <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to fsync tombstoned output&quot;</span>;            status = PALETTE_STATUS_FAILED_CHECK_LOG;        &#125;        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">ftruncate</span>(output_fd, <span class="hljs-number">0</span>));        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fdatasync</span>(output_fd));    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">close</span>(output_fd.<span class="hljs-built_in">release</span>()) == <span class="hljs-number">-1</span> &amp;&amp; errno != EINTR) &#123;        <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to close tombstoned output&quot;</span>;            status = PALETTE_STATUS_FAILED_CHECK_LOG;        &#125;    &#125;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">tombstoned_notify_completion</span>(tombstone_fd)) &#123;        <span class="hljs-comment">// tombstoned_notify_completion() logs failure.</span>        status = PALETTE_STATUS_FAILED_CHECK_LOG;    &#125;    <span class="hljs-keyword">return</span> status;&#125;<span class="hljs-comment">// system/core/debuggerd/tombstoned/tombstoned_client.cpp</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tombstoned_connect</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, unique_fd* tombstoned_socket, unique_fd* text_output_fd,</span></span><span class="hljs-params"><span class="hljs-function">                        unique_fd* proto_output_fd, DebuggerdDumpType dump_type)</span> </span>&#123;  <span class="hljs-function">unique_fd <span class="hljs-title">sockfd</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      socket_local_client((dump_type != kDebuggerdJavaBacktrace ? kTombstonedCrashSocketName</span></span><span class="hljs-params"><span class="hljs-function">                                                                : kTombstonedJavaTraceSocketName),</span></span><span class="hljs-params"><span class="hljs-function">                          ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET))</span></span>;  <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to connect to tombstoned: %s&quot;</span>,                          <span class="hljs-built_in">strerror</span>(errno));    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  TombstonedCrashPacket packet = &#123;&#125;;  packet.packet_type = CrashPacketType::kDumpRequest;  packet.packet.dump_request.pid = pid;  packet.packet.dump_request.dump_type = dump_type;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">write</span>(sockfd, &amp;packet, <span class="hljs-built_in">sizeof</span>(packet))) != <span class="hljs-built_in">sizeof</span>(packet)) &#123;    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to write DumpRequest packet: %s&quot;</span>,                          <span class="hljs-built_in">strerror</span>(errno));    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  unique_fd tmp_output_fd, tmp_proto_fd;  <span class="hljs-type">ssize_t</span> rc = <span class="hljs-number">-1</span>;  <span class="hljs-keyword">if</span> (dump_type == kDebuggerdTombstoneProto) &#123;    rc = <span class="hljs-built_in">ReceiveFileDescriptors</span>(sockfd, &amp;packet, <span class="hljs-built_in">sizeof</span>(packet), &amp;tmp_output_fd, &amp;tmp_proto_fd);  &#125; <span class="hljs-keyword">else</span> &#123;    rc = <span class="hljs-built_in">ReceiveFileDescriptors</span>(sockfd, &amp;packet, <span class="hljs-built_in">sizeof</span>(packet), &amp;tmp_output_fd);  &#125;  <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>,                          <span class="hljs-string">&quot;failed to read response to DumpRequest packet: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in">sizeof</span>(packet)) &#123;    <span class="hljs-built_in">async_safe_format_log</span>(        ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>,        <span class="hljs-string">&quot;received DumpRequest response packet of incorrect length (expected %zu, got %zd)&quot;</span>,        <span class="hljs-built_in">sizeof</span>(packet), rc);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// Make the fd O_APPEND so that our output is guaranteed to be at the end of a file.</span>  <span class="hljs-comment">// (This also makes selinux rules consistent, because selinux distinguishes between writing to</span>  <span class="hljs-comment">// a regular fd, and writing to an fd with O_APPEND).</span>  <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(tmp_output_fd.<span class="hljs-built_in">get</span>(), F_GETFL);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(tmp_output_fd.<span class="hljs-built_in">get</span>(), F_SETFL, flags | O_APPEND) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_WARN, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to set output fd flags: %s&quot;</span>,                          <span class="hljs-built_in">strerror</span>(errno));  &#125;  *tombstoned_socket = std::<span class="hljs-built_in">move</span>(sockfd);  *text_output_fd = std::<span class="hljs-built_in">move</span>(tmp_output_fd);  <span class="hljs-keyword">if</span> (proto_output_fd) &#123;    *proto_output_fd = std::<span class="hljs-built_in">move</span>(tmp_proto_fd);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h2 id="dump-native-traces"><a href="#dump-native-traces" class="headerlink" title="dump native traces"></a>dump native traces</h2><p>最终还是来到 <code>debuggerd_trigger_dump</code>，只不过此时 <code>dump_type</code> 是 <code>kDebuggerdNativeBacktrace</code></p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Debug</span>.</span></span>dump<span class="hljs-constructor">NativeBacktraceToFileTimeout(<span class="hljs-params">pid</span>, <span class="hljs-params">file</span>, <span class="hljs-params">timeoutSecs</span>)</span>android_os_Debug_dumpNativeBacktraceToFileTimeoutdump<span class="hljs-constructor">Traces(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jint</span> <span class="hljs-params">pid</span>, <span class="hljs-params">jstring</span> <span class="hljs-params">fileName</span>, <span class="hljs-params">jint</span> <span class="hljs-params">timeoutSecs</span>, DebuggerdDumpType <span class="hljs-params">dumpType</span>)</span>dump<span class="hljs-constructor">_backtrace_to_file_timeout(<span class="hljs-params">pid_t</span> <span class="hljs-params">tid</span>, DebuggerdDumpType <span class="hljs-params">dump_type</span>, <span class="hljs-params">int</span> <span class="hljs-params">timeout_secs</span>, <span class="hljs-params">int</span> <span class="hljs-params">fd</span>)</span>debuggerd<span class="hljs-constructor">_trigger_dump(<span class="hljs-params">pid_t</span> <span class="hljs-params">tid</span>, DebuggerdDumpType <span class="hljs-params">dump_type</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">timeout_ms</span>, <span class="hljs-params">unique_fd</span> <span class="hljs-params">output_fd</span>)</span></code></pre></div><h1 id="ANR-Dialog"><a href="#ANR-Dialog" class="headerlink" title="ANR Dialog"></a>ANR Dialog</h1><p>在 <code>ActivityManagerService.mUiHandler</code> 里打开 <code>AppNotRespondingDialog</code>，这个对话框一般会包含两个按钮：等待和关闭，如果选择关闭则会通过 <code>kill(pid, SIGKILL)</code> 杀死 ANR 进程</p><div class="code-wrapper"><pre><code class="hljs java">ProcessRecord.ErrorDialogController.showAnrDialogsProcessRecord.ErrorDialogController.scheduleForAllDialogsProcessRecord.ErrorDialogController.forAllDialogs<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppNotRespondingDialog</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;            <span class="hljs-type">Intent</span> <span class="hljs-variable">appErrorIntent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            MetricsLogger.action(getContext(), MetricsProto.MetricsEvent.ACTION_APP_ANR,                    msg.what);            <span class="hljs-keyword">switch</span> (msg.what) &#123;                <span class="hljs-keyword">case</span> FORCE_CLOSE:                    <span class="hljs-comment">// Kill the application.</span>                    mService.killAppAtUsersRequest(mProc);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> WAIT_AND_REPORT:                <span class="hljs-keyword">case</span> WAIT:                    <span class="hljs-comment">// Continue waiting for the application.</span>                    <span class="hljs-keyword">synchronized</span> (mService) &#123;                        <span class="hljs-type">ProcessRecord</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> mProc;                        <span class="hljs-keyword">final</span> <span class="hljs-type">ProcessErrorStateRecord</span> <span class="hljs-variable">errState</span> <span class="hljs-operator">=</span> app.mErrorState;                        <span class="hljs-keyword">if</span> (msg.what == WAIT_AND_REPORT) &#123;                            appErrorIntent = mService.mAppErrors.createAppErrorIntentLOSP(app,                                    System.currentTimeMillis(), <span class="hljs-literal">null</span>);                        &#125;                        <span class="hljs-keyword">synchronized</span> (mService.mProcLock) &#123;                            errState.setNotResponding(<span class="hljs-literal">false</span>);                            errState.setNotRespondingReport(<span class="hljs-literal">null</span>);                            errState.getDialogController().clearAnrDialogs();                        &#125;                        mService.mServices.scheduleServiceTimeoutLocked(app);                    &#125;                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (appErrorIntent != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    getContext().startActivity(appErrorIntent);                &#125; <span class="hljs-keyword">catch</span> (ActivityNotFoundException e) &#123;                    Slog.w(TAG, <span class="hljs-string">&quot;bug report receiver dissappeared&quot;</span>, e);                &#125;            &#125;            dismiss();        &#125;    &#125;;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">killAppAtUsersRequest</span><span class="hljs-params">(ProcessRecord app)</span> &#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;            mAppErrors.killAppAtUserRequestLocked(app);        &#125;    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppErrors</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">killAppAtUserRequestLocked</span><span class="hljs-params">(ProcessRecord app)</span> &#123;        <span class="hljs-type">ErrorDialogController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> app.mErrorState.getDialogController();        <span class="hljs-type">int</span> <span class="hljs-variable">reasonCode</span> <span class="hljs-operator">=</span> ApplicationExitInfo.REASON_ANR;        <span class="hljs-type">int</span> <span class="hljs-variable">subReason</span> <span class="hljs-operator">=</span> ApplicationExitInfo.SUBREASON_UNKNOWN;        <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;            <span class="hljs-keyword">if</span> (controller.hasDebugWaitingDialog()) &#123;                reasonCode = ApplicationExitInfo.REASON_OTHER;                subReason = ApplicationExitInfo.SUBREASON_WAIT_FOR_DEBUGGER;            &#125;            controller.clearAllErrorDialogs();            killAppImmediateLSP(app, reasonCode, subReason,                    <span class="hljs-string">&quot;user-terminated&quot;</span>, <span class="hljs-string">&quot;user request after error&quot;</span>);        &#125;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">killAppImmediateLSP</span><span class="hljs-params">(ProcessRecord app, <span class="hljs-type">int</span> reasonCode, <span class="hljs-type">int</span> subReason,</span><span class="hljs-params">            String reason, String killReason)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">ProcessErrorStateRecord</span> <span class="hljs-variable">errState</span> <span class="hljs-operator">=</span> app.mErrorState;        errState.setCrashing(<span class="hljs-literal">false</span>);        errState.setCrashingReport(<span class="hljs-literal">null</span>);        errState.setNotResponding(<span class="hljs-literal">false</span>);        errState.setNotRespondingReport(<span class="hljs-literal">null</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> errState.mApp.getPid();        <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span> &amp;&amp; pid != MY_PID) &#123;            <span class="hljs-keyword">synchronized</span> (mBadProcessLock) &#123;                handleAppCrashLSPB(app, reason,                        <span class="hljs-literal">null</span> <span class="hljs-comment">/*shortMsg*/</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/*longMsg*/</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/*stackTrace*/</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/*data*/</span>);            &#125;            app.killLocked(killReason, reasonCode, subReason, <span class="hljs-literal">true</span>);        &#125;    &#125;     &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessRecord</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">killLocked</span><span class="hljs-params">(String reason, <span class="hljs-meta">@Reason</span> <span class="hljs-type">int</span> reasonCode, <span class="hljs-meta">@SubReason</span> <span class="hljs-type">int</span> subReason,</span><span class="hljs-params">            <span class="hljs-type">boolean</span> noisy)</span> &#123;        <span class="hljs-keyword">if</span> (!mKilledByAm) &#123;            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;kill&quot;</span>);            <span class="hljs-keyword">if</span> (mService != <span class="hljs-literal">null</span> &amp;&amp; (noisy || info.uid == mService.mCurOomAdjUid)) &#123;                mService.reportUidInfoMessageLocked(TAG,                        <span class="hljs-string">&quot;Killing &quot;</span> + toShortString() + <span class="hljs-string">&quot; (adj &quot;</span> + mState.getSetAdj()                        + <span class="hljs-string">&quot;): &quot;</span> + reason, info.uid);            &#125;            <span class="hljs-keyword">if</span> (mPid &gt; <span class="hljs-number">0</span>) &#123;                mService.mProcessList.noteAppKill(<span class="hljs-built_in">this</span>, reasonCode, subReason, reason);                EventLog.writeEvent(EventLogTags.AM_KILL,                        userId, mPid, processName, mState.getSetAdj(), reason);                Process.killProcessQuiet(mPid);                ProcessList.killProcessGroup(uid, mPid);            &#125; <span class="hljs-keyword">else</span> &#123;                mPendingStart = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">if</span> (!mPersistent) &#123;                <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;                    mKilled = <span class="hljs-literal">true</span>;                    mKilledByAm = <span class="hljs-literal">true</span>;                    mKillTime = SystemClock.uptimeMillis();                &#125;            &#125;            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        &#125;    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Process</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL_KILL</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">killProcessQuiet</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span> &#123;        sendSignalQuiet(pid, SIGNAL_KILL);    &#125;    &#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">android_os_Process_sendSignalQuiet</span><span class="hljs-params">(JNIEnv* env, jobject clazz, jint pid, jint sig)</span>&#123;    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;        kill(pid, sig);    &#125;&#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/f9b8c139c2ed">Linux对内存的管理, 以及page fault的概念</a></li><li><a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">Understanding page faults and memory swap-in/outs: when should you worry?</a></li><li><a href="https://developer.android.com/topic/performance/vitals/anr">Android Developer ANRs</a></li><li><a href="https://developer.android.com/studio/debug/bug-report">Android Developer Bug Reports</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649288031&idx=1&sn=91c94e16460a4685a9c0c8e1b9c362a6">微信Android客户端的ANR监控方案</a></li><li><a href="https://www.jianshu.com/p/6058e5c6332a">每日一面 - 什么是 Safepoint？</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>anr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MP4 文件结构浅析</title>
    <link href="/2021/07/05/mp4-structure/"/>
    <url>/2021/07/05/mp4-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>mp4</code> 文件由一个个连续的 <code>box</code> 组成</p><div class="code-wrapper"><pre><code class="hljs fsharp">mp4 <span class="hljs-operator">=</span> <span class="hljs-built_in">box</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">box</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">box</span> <span class="hljs-operator">+</span> <span class="hljs-operator">...</span></code></pre></div><p>box 的类型繁多，没必要去死记它们的类型，记住两个关键 box 即可：</p><ol><li><code>moov</code> - 保存了 SPS、PPS、track-chunk-sample 映射等关键信息</li><li><code>mdat</code> - 保存了 H264 NALU</li></ol><p>本文的目的是通过解析各种 box 从而了解 mp4 文件结构的核心概念</p><h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><p>一个 mp4 文件可以包含多个 <code>track</code>（视频、音频和字幕），而每个 track 则由多个 <code>chunk</code> 组成</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">mp4</span> = video track + audio track + subtitle track + ...<span class="hljs-attr">track</span> = chunk + chunk + chunk + ...</code></pre></div><p><code>Stco Box</code> 描述了一个 track 有多少个 chunk 以及每个 chunk 在 mp4 文件里的偏移量，这样就具有了快速定位（<code>seek</code>）chunk 的能力</p><p>比如下图说明 track 有 486 个 chunk，每个 chunk 在文件里的偏移量都记录在后面的表里</p><p><img src="../../../../image/2021-07-05-mp4-structure/stco.webp" alt="stco box"></p><h1 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h1><p><code>sample</code>（采样）相当于一帧，解码的过程就是计算出一帧帧的图像，每个 chunk 包含多个 <code>sample</code></p><div class="code-wrapper"><pre><code class="hljs glsl">chunk = <span class="hljs-keyword">sample</span> + <span class="hljs-keyword">sample</span> + <span class="hljs-keyword">sample</span> + ...</code></pre></div><p>具体哪个 chunk 包含哪几个 sample 由 <code>Stsc Box</code> 描述： <code>stsc = entry count + (first chunk + samples per chunk + sample description index)</code>，如下图，它是这么描述的：</p><ol><li>第 1 个 chunk 包含 15 个 sample</li><li>第 2 - 485 个 chunk 包含 14 个 sample</li><li>第 486 个 chunk 包含 5 个 sample</li></ol><p>那么可以计算出这个 track 共有 486 个 chunk（和上面 Stco Box 的描述一致） 和 <code>15 + 485 * 14 + 5 = 4796</code> 个 sample</p><p><img src="../../../../image/2021-07-05-mp4-structure/stsc.webp" alt="stsc box"></p><p>至此我们可以通过 <code>sample id -&gt; chunk id -&gt; chunk offset</code> 这个链条定位某个 sample 所在的 chunk 及其偏移，但 sample 偏移还是没法得知，而 <code>Stsz Box</code> 正是记录了每个 sample 的大小，如下图：</p><ol><li>sample count = 6796，与上面我们计算出的数据一致</li><li>sample size 是一张记录了每个 sample 大小的表（所以 stsz box 会很大）</li></ol><p>那么 sample 在文件里的偏移就可以通过 chunk offset 前进 n 个排在前面的 sample 的长度得出：<code>sample offset = chunk offset + samples before in the chunk</code></p><p><img src="../../../../image/2021-07-05-mp4-structure/stsz.webp" alt="stsz box"></p><h1 id="DTS-和-PTS"><a href="#DTS-和-PTS" class="headerlink" title="DTS 和 PTS"></a>DTS 和 PTS</h1><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>I frame</td><td>帧内编码帧，解码不依赖于任何的其它的帧，通常是每个 GOP 的第一个帧，做为随机访问的参考点</td></tr><tr><td>P frame</td><td>前向预测编码帧，解码则依赖于其前面的 I/P frame</td></tr><tr><td>B frame</td><td>双向预测内插编码帧，解码依赖于其前的最近的一个 I/P frame 及其后的最近的一个 P frame</td></tr><tr><td>GOP</td><td>两个 I frame 之间形成一个 GOP，如果有 B frame 则最后一个一定是 P frame</td></tr><tr><td>PTS</td><td>用于度量解码后的视频帧什么时候被显示出来</td></tr><tr><td>DTS</td><td>标识视频流在什么时候开始送入解码器中进行解码</td></tr></tbody></table><p>在没有 B frame 的情况下 DTS 和 PTS 的输出顺序是一样的，有 B frame 的话就不一样了，如下图：</p><p><img src="../../../../image/2021-07-05-mp4-structure/dts-pts.jpg" alt="dts-pts"></p><p><code>Stts Box</code> 是 sample id 和解码时间 DTS 之间的映射表，通过这个表格我们可以找到任何时间的 sample，如下图：</p><ol><li>sample delta 值一样说明是固定帧率，帧率为 <code>30000 / 1001 = 29.97</code></li><li>可以计算出该 video track 的时长为 <code>6796 * 1001 = 6802796</code>（6796 跟上面我们计算的 sample 数量一致），换算成秒就是 <code>6802796 / 30000 = 226.75s</code>（30000 是 mvhd box 里定义的时间单位）</li></ol><p><img src="../../../../image/2021-07-05-mp4-structure/stts.webp" alt="stts box"></p><p><code>Ctts Box</code> 描述了每个 sample 的 <code>composition time</code> 和 <code>decode time</code> 之间的差值，通过 composition time 就可以计算出 PTS，如下图：</p><ul><li>entry count   - 描述了下面 sample count 和 sample delta 组成的二元组个数</li><li>sample count  - 连续相同 offset 的 sample 个数</li><li>sample offset - CT 和 DT 之间的 offset</li></ul><p><img src="../../../../image/2021-07-05-mp4-structure/ctts.webp" alt="ctts box"></p><p>计算前面 5 个 sample 的 DTS 和 PTS</p><table><thead><tr><th></th><th>0 frame</th><th>1 frame</th><th>2 frame</th><th>3 frame</th><th>4 frame</th></tr></thead><tbody><tr><td>sample detla</td><td>1001</td><td>1001</td><td>1001</td><td>1001</td><td>1001</td></tr><tr><td>sample offset</td><td>2002</td><td>5005</td><td>2002</td><td>0</td><td>1001</td></tr><tr><td>DTS</td><td>0</td><td>1001</td><td>2002</td><td>3003</td><td>4004</td></tr><tr><td>PTS</td><td>2002</td><td>6006</td><td>4004</td><td>3003</td><td>5005</td></tr></tbody></table><p>解码：0 - 1 - 2 - 3 - 4</p><p>显示：0 - 3 - 2 - 4 - 1</p><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p><img src="../../../../image/2021-07-05-mp4-structure/overview.jpg" alt="overview"></p><h1 id="应用之-seek"><a href="#应用之-seek" class="headerlink" title="应用之 seek"></a>应用之 seek</h1><p>拖动视频进度条，进度条对应的应该是 PTS，那么根据 PTS 找到对应的 sample，如果是 P/B frame 还需要往前寻找所在 GOP 的 I frame，然后找到它所在的 chunk 而从定位到它的偏移值，从这个偏移值开始读取整个 GOP 长度的数据流并解码</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NTMxMjA1MQ==&mid=2247483932&idx=1&sn=60d7bc3d4330c362e0e49a287d72a9d7&chksm=e9513d40de26b4569f1d664d026d7f5b3df556f454db9b35d4a2981abbae631ad7fd4746558f&scene=21#wechat_redirect">音视频封装：MP4结构概述和分析工具</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NTMxMjA1MQ==&mid=2247484020&idx=1&sn=e1f99ff04dac96ab31154f66492cbb1c&chksm=e9513d28de26b43e0ac6e2fa88a36840b8c9ff651f4bdd0c343d4cf85a198060182fb57461ab&cur_album_id=1440947813877202945&scene=189#rd">音视频解封装：MP4核心Box详解及H264&amp;AAC打包方案</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mp4</tag>
      
      <tag>pts</tag>
      
      <tag>dts</tag>
      
      <tag>box</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志库 Logan</title>
    <link href="/2021/06/28/logan/"/>
    <url>/2021/06/28/logan/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/Meituan-Dianping/Logan">Logan</a> 是 <a href="https://github.com/meituan">美团点评技术团队</a> 开源的包含前端 SDK 和后端 Server 的一整套日志系统，也是公司日志库 <code>VLog</code> 的基础</p><p>Logan Android SDK 提供了这么几个 API：</p><table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody><tr><td>Logan#w(log, type)</td><td>写日志（严谨地说应该是发送日志请求，因为日志是放在消息队列里等待被处理的）</td></tr><tr><td>Logan#init</td><td>初始化</td></tr><tr><td>Logan#f</td><td>Logan 内部有个内存缓存（memory/mmap），日志首先被写入到缓存里，只有到达一定大小时（1/3）才写入文件，这里请求立刻写入到文件里去</td></tr><tr><td>Logan#s</td><td>根据日期 获取/发送 日志文件</td></tr><tr><td>Logan#getAllFilesInfo</td><td>获取所有的日志文件，key 是日期，value 是日志文件大小</td></tr><tr><td>Logan#setDebug</td><td>设置为 debug 模式后，会有更加详细的 native 日志，但是默认实现只是输出到 stdout 没有写入 android log</td></tr><tr><td>Logan#setOnLoganProtocolStatus</td><td>可以拿到一些 Java 的关键日志</td></tr></tbody></table><p>LoganConfig 是初始化配置参数：</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>path</td><td>存放日志文件的目录，日志是按日期（天）存放的，文件名是当天零时零分零秒的时间戳</td></tr><tr><td>cachePath</td><td>内存缓存对应的 mmap 文件所在的目录</td></tr><tr><td>maxFile</td><td>当日志文件超过此大小时，就不能再继续往 buffer 里写入日志</td></tr><tr><td>day</td><td>只保留 n 天内的日志文件，旧的都删掉</td></tr><tr><td>minSDCard</td><td>当可用的存储容量超过此阈值时才写入日志</td></tr><tr><td>encryptKey16</td><td>AES 加密参数 KEY</td></tr><tr><td>encryptIv16</td><td>AES 加密参数 IV</td></tr></tbody></table><h3 id="日志队列与-生产者-消费者-模型"><a href="#日志队列与-生产者-消费者-模型" class="headerlink" title="日志队列与 生产者-消费者 模型"></a>日志队列与 生产者-消费者 模型</h3><p>调用 <code>Logan.w</code> 的线程是日志的生产者，日志写入请求被放入日志队列（<code>Queue</code>）里等待处理，<code>LoganThread</code> 线程作为消费者不断地执行日志队列里的任务</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logan</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> log  表示日志内容</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 表示日志类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@brief</span> Logan写入日志</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">w</span><span class="hljs-params">(String log, <span class="hljs-type">int</span> type)</span> &#123;        <span class="hljs-keyword">if</span> (sLoganControlCenter == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Please initialize Logan first&quot;</span>);        &#125;        sLoganControlCenter.write(log, type);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganControlCenter</span> &#123;    <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;LoganModel&gt; mCacheLogQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();    <span class="hljs-keyword">private</span> LoganThread mLoganThread;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String log, <span class="hljs-type">int</span> flag)</span> &#123;        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(log)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">LoganModel</span> <span class="hljs-variable">model</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoganModel</span>();        model.action = LoganModel.Action.WRITE;        <span class="hljs-type">WriteAction</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteAction</span>();        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();        <span class="hljs-type">long</span> <span class="hljs-variable">threadLog</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();        <span class="hljs-type">boolean</span> <span class="hljs-variable">isMain</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;            isMain = <span class="hljs-literal">true</span>;        &#125;        action.log = log;        action.localTime = System.currentTimeMillis();        action.flag = flag;        action.isMainThread = isMain;        action.threadId = threadLog;        action.threadName = threadName;        model.writeAction = action;        <span class="hljs-keyword">if</span> (mCacheLogQueue.size() &lt; mMaxQueue) &#123;            mCacheLogQueue.add(model);            <span class="hljs-keyword">if</span> (mLoganThread != <span class="hljs-literal">null</span>) &#123;                mLoganThread.notifyRun();            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (mLoganThread == <span class="hljs-literal">null</span>) &#123;            mLoganThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoganThread</span>(mCacheLogQueue, mCachePath, mPath, mSaveTime,                    mMaxLogFile, mMinSDCard, mEncryptKey16, mEncryptIv16);            mLoganThread.setName(<span class="hljs-string">&quot;logan-thread&quot;</span>);            mLoganThread.start();        &#125;    &#125;    &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">super</span>.run();        <span class="hljs-keyword">while</span> (mIsRun) &#123;            <span class="hljs-keyword">synchronized</span> (sync) &#123;                mIsWorking = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-type">LoganModel</span> <span class="hljs-variable">model</span> <span class="hljs-operator">=</span> mCacheLogQueue.poll();                    <span class="hljs-keyword">if</span> (model == <span class="hljs-literal">null</span>) &#123;                        mIsWorking = <span class="hljs-literal">false</span>;                        sync.wait();                        mIsWorking = <span class="hljs-literal">true</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        action(model);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                    mIsWorking = <span class="hljs-literal">false</span>;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="内存缓存-Buffer"><a href="#内存缓存-Buffer" class="headerlink" title="内存缓存 Buffer"></a>内存缓存 Buffer</h3><p>并不是每次日志请求都立刻写入到日志文件里，而是在内存中开辟一段缓存（默认为 150K）作为 buffer，当 buffer 里的数据积累得足够多时（1/3 buffer 大小）才写入文件</p><div class="code-wrapper"><pre><code class="hljs cpp">LoganThread.doWriteLog2FileLoganProtocol.logan_writeCLoganProtocol.logan_writeCLoganProtocol.<span class="hljs-function">clogan_write</span><span class="hljs-function">Java_com_dianping_logan_CLoganProtocol_clogan_1write</span><span class="hljs-function">clogan_write</span><span class="hljs-function">clogan_write_section</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clogan_write2</span><span class="hljs-params">(<span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> length)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != logan_model &amp;&amp; logan_model-&gt;is_ok) &#123;        <span class="hljs-built_in">clogan_zlib_compress</span>(logan_model, data, length);    <span class="hljs-comment">// 压缩和加密后的数据放在内存 buffer 里</span>        <span class="hljs-built_in">update_length_clogan</span>(logan_model);        <span class="hljs-type">int</span> is_gzip_end = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_type == LOGAN_MMAP_MMAP &amp;&amp;                   logan_model-&gt;total_len &gt;=                   buffer_length / LOGAN_WRITEPROTOCOL_DEVIDE_VALUE) &#123;  <span class="hljs-comment">// 只有当数据大小到达阈值（1/3 buffer 容量）时才写入文件</span>            isWrite = <span class="hljs-number">1</span>;            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;clogan_write2 &gt; write type MMAP \n&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (isWrite) &#123;  <span class="hljs-comment">// 写入文件</span>            <span class="hljs-built_in">write_flush_clogan</span>();            &#125;&#125;</code></pre></div><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>当 APP 因为崩溃而被 kill 或者被其他进程 kill 时，保存在内存中的日志缓存就会失去回写文件的机会，从而导致日志的丢失</p><p>使用 <code>mmap</code> 可以在虚拟内存中开辟一片内存空间作为 buffer，它对应了一个 file backed，系统会选择合适的机会将 buffer 回写至文件，而且在进程被 kill 时系统可以确保 buffer 被正确地回写，确保进程异常时不会丢失日志</p><p>mmap file 位于 <code>&#123;cacheDir&#125;/logan_cache/logan.mmap2</code>，buffer 和 mmap file 的大小默认为 150K</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOGAN_MMAP_LENGTH</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGAN_MMAP_LENGTH 150 * 1024 <span class="hljs-comment">//150k</span></span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">// 创建MMAP缓存buffer或者内存buffer</span><span class="hljs-comment">// _filepath: mmap file 地址</span><span class="hljs-comment">// buffer: mmap buffer</span><span class="hljs-comment">// cache: 如果 mmap 失败则使用内存缓存</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open_mmap_file_clogan</span><span class="hljs-params">(<span class="hljs-type">char</span> *_filepath, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **buffer, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **cache)</span> </span>&#123;    <span class="hljs-type">int</span> back = LOGAN_MMAP_FAIL;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == _filepath || <span class="hljs-number">0</span> == <span class="hljs-built_in">strnlen</span>(_filepath, <span class="hljs-number">128</span>)) &#123;        back = LOGAN_MMAP_MEMORY;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p_map = <span class="hljs-literal">NULL</span>;        <span class="hljs-type">int</span> size = LOGAN_MMAP_LENGTH;        <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(_filepath, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP); <span class="hljs-comment">//后两个添加权限</span>        <span class="hljs-type">int</span> isNeedCheck = <span class="hljs-number">0</span>; <span class="hljs-comment">//是否需要检查mmap缓存文件重新检查</span>        <span class="hljs-keyword">if</span> (fd != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//保护</span>            <span class="hljs-type">int</span> isFileOk = <span class="hljs-number">0</span>;            FILE *file = <span class="hljs-built_in">fopen</span>(_filepath, <span class="hljs-string">&quot;rb+&quot;</span>); <span class="hljs-comment">//先判断文件是否有值，再mmap内存映射</span>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != file) &#123;                <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_END);                <span class="hljs-type">long</span> longBytes = <span class="hljs-built_in">ftell</span>(file);                <span class="hljs-keyword">if</span> (longBytes &lt; LOGAN_MMAP_LENGTH) &#123;                    <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_SET);                    <span class="hljs-type">char</span> zero_data[size];                    <span class="hljs-built_in">memset</span>(zero_data, <span class="hljs-number">0</span>, size);                    <span class="hljs-type">size_t</span> _size = <span class="hljs-number">0</span>;                    _size = <span class="hljs-built_in">fwrite</span>(zero_data, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), size, file);                    <span class="hljs-built_in">fflush</span>(file);                    <span class="hljs-keyword">if</span> (_size == size) &#123;                        <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;copy data 2 mmap file success\n&quot;</span>);                        isFileOk = <span class="hljs-number">1</span>;                        isNeedCheck = <span class="hljs-number">1</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        isFileOk = <span class="hljs-number">0</span>;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    isFileOk = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-built_in">fclose</span>(file);            &#125; <span class="hljs-keyword">else</span> &#123;                isFileOk = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span> (isNeedCheck) &#123; <span class="hljs-comment">//加强保护，对映射的文件要有一个适合长度的文件</span>                FILE *file = <span class="hljs-built_in">fopen</span>(_filepath, <span class="hljs-string">&quot;rb&quot;</span>);                <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">NULL</span>) &#123;                    <span class="hljs-built_in">fseek</span>(file, <span class="hljs-number">0</span>, SEEK_END);                    <span class="hljs-type">long</span> longBytes = <span class="hljs-built_in">ftell</span>(file);                    <span class="hljs-keyword">if</span> (longBytes &gt;= LOGAN_MMAP_LENGTH) &#123;                        isFileOk = <span class="hljs-number">1</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        isFileOk = <span class="hljs-number">0</span>;                    &#125;                    <span class="hljs-built_in">fclose</span>(file);                &#125; <span class="hljs-keyword">else</span> &#123;                    isFileOk = <span class="hljs-number">0</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (isFileOk) &#123;                p_map = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) <span class="hljs-built_in">mmap</span>(<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);            &#125;            <span class="hljs-keyword">if</span> (p_map != MAP_FAILED &amp;&amp; <span class="hljs-literal">NULL</span> != p_map &amp;&amp; isFileOk) &#123;                back = LOGAN_MMAP_MMAP;            &#125; <span class="hljs-keyword">else</span> &#123;                back = LOGAN_MMAP_MEMORY;                <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;open mmap fail , reason : %s \n&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));            &#125;            <span class="hljs-built_in">close</span>(fd);            <span class="hljs-keyword">if</span> (back == LOGAN_MMAP_MMAP &amp;&amp;                <span class="hljs-built_in">access</span>(_filepath, F_OK) != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//在返回mmap前,做最后一道判断，如果有mmap文件才用mmap</span>                back = LOGAN_MMAP_MMAP;                *buffer = p_map;            &#125; <span class="hljs-keyword">else</span> &#123;                back = LOGAN_MMAP_MEMORY;                <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != p_map)                    <span class="hljs-built_in">munmap</span>(p_map, size);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;open(%s) fail: %s\n&quot;</span>, _filepath, <span class="hljs-built_in">strerror</span>(errno));        &#125;    &#125;    <span class="hljs-type">int</span> size = LOGAN_MEMORY_LENGTH;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *tempData = <span class="hljs-built_in">malloc</span>(size);    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != tempData) &#123;        <span class="hljs-built_in">memset</span>(tempData, <span class="hljs-number">0</span>, size);        *cache = tempData;        <span class="hljs-keyword">if</span> (back != LOGAN_MMAP_MMAP) &#123;            *buffer = tempData;            back = LOGAN_MMAP_MEMORY; <span class="hljs-comment">//如果文件打开失败、如果mmap映射失败，走内存缓存</span>        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (back != LOGAN_MMAP_MMAP)            back = LOGAN_MMAP_FAIL;    &#125;    <span class="hljs-keyword">return</span> back;&#125;</code></pre></div><h3 id="flush-回写日志文件"><a href="#flush-回写日志文件" class="headerlink" title="flush 回写日志文件"></a>flush 回写日志文件</h3><p>因为有 buffer 的存在，<code>Logan.w(log, type)</code> 先将日志写入内存缓存，只有当缓存超过阈值（50K）时才回写文件系统，<code>Logan.f()</code> 使 buffer 立刻回写至文件系统</p><p>使用 <code>fopen</code>、<code>fseek</code>、<code>ftell</code>、<code>fwrite</code>、<code>fflush</code>、<code>fclose</code> 等高级 IO API，它们是具有缓存的</p><div class="code-wrapper"><pre><code class="hljs cpp">Logan.<span class="hljs-built_in">f</span>()LoganControlCenter.<span class="hljs-built_in">flush</span>()LoganThread.<span class="hljs-built_in">doFlushLog2File</span>()LoganProtocol.<span class="hljs-built_in">logan_flush</span>()CLoganProtocol.<span class="hljs-built_in">logan_flush</span>()CLoganProtocol.<span class="hljs-built_in">clogan_flush</span>()<span class="hljs-function">Java_com_dianping_logan_CLoganProtocol_clogan_1flush</span><span class="hljs-function">clogan_flush</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_flush_clogan</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (logan_model-&gt;zlib_type == LOGAN_ZLIB_ING) &#123;        <span class="hljs-built_in">clogan_zlib_end_compress</span>(logan_model);        <span class="hljs-built_in">update_length_clogan</span>(logan_model);    &#125;    <span class="hljs-keyword">if</span> (logan_model-&gt;total_len &gt; LOGAN_WRITEPROTOCOL_HEAER_LENGTH) &#123;        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *point = logan_model-&gt;total_point;        point += LOGAN_MMAP_TOTALLEN;        <span class="hljs-built_in">write_dest_clogan</span>(point, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), logan_model-&gt;total_len, logan_model);        <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;write_flush_clogan &gt; logan total len : %d \n&quot;</span>, logan_model-&gt;total_len);        <span class="hljs-built_in">clear_clogan</span>(logan_model);    &#125;&#125;<span class="hljs-comment">//文件写入磁盘、更新文件大小</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_dest_clogan</span><span class="hljs-params">(<span class="hljs-type">void</span> *point, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> length, cLogan_model *loganModel)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_file_exist_clogan</span>(loganModel-&gt;file_path)) &#123; <span class="hljs-comment">//如果文件被删除,再创建一个文件</span>        <span class="hljs-keyword">if</span> (logan_model-&gt;file_stream_type == LOGAN_FILE_OPEN) &#123;            <span class="hljs-built_in">fclose</span>(logan_model-&gt;file);            logan_model-&gt;file_stream_type = LOGAN_FILE_CLOSE;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != _dir_path) &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_file_exist_clogan</span>(_dir_path)) &#123;                <span class="hljs-built_in">makedir_clogan</span>(_dir_path);            &#125;            <span class="hljs-built_in">init_file_clogan</span>(logan_model);            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;clogan_write &gt; create log file , restore open file stream \n&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">if</span> (CLOGAN_EMPTY_FILE == loganModel-&gt;file_len) &#123; <span class="hljs-comment">//如果是空文件插入一行CLogan的头文件</span>        <span class="hljs-built_in">insert_header_file_clogan</span>(loganModel);    &#125;    <span class="hljs-built_in">fwrite</span>(point, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), logan_model-&gt;total_len, logan_model-&gt;file);<span class="hljs-comment">//写入到文件中</span>    <span class="hljs-built_in">fflush</span>(logan_model-&gt;file);    loganModel-&gt;file_len += loganModel-&gt;total_len; <span class="hljs-comment">//修改文件大小</span>&#125;</code></pre></div><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>日志文件保存在目录 <code>LoganConfig.Builder.setPath(path)</code>，日志按日期存储，文件名是日期当天零时零分零秒的 <code>时间戳</code></p><p><img src="../../../../image/2021-06-28-logan/files.png" alt="files.png"></p><p>日志经过 gzip 压缩和 AES 加密，其格式是 JSON，每个日志文件的第一条总是 <code>clogan header</code></p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;c&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;clogan header&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 日志内容</span>    <span class="hljs-attr">&quot;f&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>                  <span class="hljs-comment">// flag，Logan.w(log, type) 中的 type 传入</span>    <span class="hljs-attr">&quot;l&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;init&quot;</span><span class="hljs-punctuation">,</span>             <span class="hljs-comment">// local time，本地时间</span>    <span class="hljs-attr">&quot;n&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;clogan&quot;</span><span class="hljs-punctuation">,</span>           <span class="hljs-comment">// thread name，线程名称</span>    <span class="hljs-attr">&quot;i&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>                  <span class="hljs-comment">// thread id，线程 ID</span>    <span class="hljs-attr">&quot;m&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span>                <span class="hljs-comment">// main thread，是否主线程</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;c&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;I/Fridge-okhttp.OkHttpClient：[ (AndroidLog.kt:84)#androidLog$okhttp ] [ (AndroidLog.kt:39)#publish ] domain: video&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;f&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;l&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2021-09-07 00:00:00.000&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;n&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;RxCachedThreadScheduler-15&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;i&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">174</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;m&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;c&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;I/Fridge-okhttp.OkHttpClient：[ (AndroidLog.kt:84)#androidLog$okhttp ] [ (AndroidLog.kt:39)#publish ] Authorization_v1: U5xQjeKDh4Dkgx4Z&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;f&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;l&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2021-09-07 00:00:00.001&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;n&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;RxCachedThreadScheduler-15&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;i&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">174</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;m&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>每次写日志时，都会判断下当前日期是否与日志文件的日期一致；如果不一致说明跨天了，创建当天的日志文件，并删除 <code>LoganConfig.Builder.setDay(long)</code> 前的日志文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWriteLog2File</span><span class="hljs-params">(WriteAction action)</span> &#123;        <span class="hljs-keyword">if</span> (Logan.sDebug) &#123;            Log.d(TAG, <span class="hljs-string">&quot;Logan write start&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (mFileDirectory == <span class="hljs-literal">null</span>) &#123;            mFileDirectory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(mPath);        &#125;        <span class="hljs-keyword">if</span> (!isDay()) &#123;            <span class="hljs-type">long</span> <span class="hljs-variable">tempCurrentDay</span> <span class="hljs-operator">=</span> Util.getCurrentTime();            <span class="hljs-comment">//save时间</span>            <span class="hljs-type">long</span> <span class="hljs-variable">deleteTime</span> <span class="hljs-operator">=</span> tempCurrentDay - mSaveTime;            deleteExpiredFile(deleteTime);            mCurrentDay = tempCurrentDay;            mLoganProtocol.logan_open(String.valueOf(mCurrentDay));        &#125;        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//每隔1分钟判断一次</span>        <span class="hljs-keyword">if</span> (currentTime - mLastTime &gt; MINUTE) &#123;            mIsSDCard = isCanWriteSDCard();        &#125;        mLastTime = System.currentTimeMillis();        <span class="hljs-keyword">if</span> (!mIsSDCard) &#123; <span class="hljs-comment">//如果大于50M 不让再次写入</span>            <span class="hljs-keyword">return</span>;        &#125;        mLoganProtocol.logan_write(action.flag, action.log, action.localTime, action.threadName,                action.threadId, action.isMainThread);    &#125;&#125;</code></pre></div><h3 id="写入失败"><a href="#写入失败" class="headerlink" title="写入失败"></a>写入失败</h3><p>有以下原因会导致日志写入失败：</p><ol><li>日志内容为空</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganControlCenter</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String log, <span class="hljs-type">int</span> flag)</span> &#123;        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(log)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><ol start="2"><li>任务队列满了</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganControlCenter</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mMaxQueue;     <span class="hljs-comment">// 最大队列数</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LoganControlCenter</span><span class="hljs-params">(LoganConfig config)</span> &#123;        <span class="hljs-keyword">if</span> (!config.isValid()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;config&#x27;s param is invalid&quot;</span>);        &#125;        mPath = config.mPathPath;        mCachePath = config.mCachePath;        mSaveTime = config.mDay;        mMinSDCard = config.mMinSDCard;        mMaxLogFile = config.mMaxFile;        mMaxQueue = config.mMaxQueue;        mEncryptKey16 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(config.mEncryptKey16);        mEncryptIv16 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(config.mEncryptIv16);        init();    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String log, <span class="hljs-type">int</span> flag)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">if</span> (mCacheLogQueue.size() &lt; mMaxQueue) &#123;            mCacheLogQueue.add(model);            <span class="hljs-keyword">if</span> (mLoganThread != <span class="hljs-literal">null</span>) &#123;                mLoganThread.notifyRun();            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganConfig</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;    <span class="hljs-type">long</span> <span class="hljs-variable">mMaxQueue</span> <span class="hljs-operator">=</span> DEFAULT_QUEUE;     <span class="hljs-comment">// 没有公开 getter/setter</span>&#125;</code></pre></div><ol start="3"><li>存储设备容量不足（默认至少 50M）</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mMinSDCard;    LoganThread(            ConcurrentLinkedQueue&lt;LoganModel&gt; cacheLogQueue, String cachePath,            String path, <span class="hljs-type">long</span> saveTime, <span class="hljs-type">long</span> maxLogFile, <span class="hljs-type">long</span> minSDCard, String encryptKey16,            String encryptIv16) &#123;        mCacheLogQueue = cacheLogQueue;        mCachePath = cachePath;        mPath = path;        mSaveTime = saveTime;        mMaxLogFile = maxLogFile;        mMinSDCard = minSDCard;        mEncryptKey16 = encryptKey16;        mEncryptIv16 = encryptIv16;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWriteLog2File</span><span class="hljs-params">(WriteAction action)</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis(); <span class="hljs-comment">//每隔1分钟判断一次</span>        <span class="hljs-keyword">if</span> (currentTime - mLastTime &gt; MINUTE) &#123;            mIsSDCard = isCanWriteSDCard();        &#125;        mLastTime = System.currentTimeMillis();        <span class="hljs-keyword">if</span> (!mIsSDCard) &#123; <span class="hljs-comment">//如果大于50M 不让再次写入</span>            <span class="hljs-keyword">return</span>;        &#125;        mLoganProtocol.logan_write(action.flag, action.log, action.localTime, action.threadName,                action.threadId, action.isMainThread);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCanWriteSDCard</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">StatFs</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StatFs</span>(mPath);            <span class="hljs-type">long</span> <span class="hljs-variable">blockSize</span> <span class="hljs-operator">=</span> stat.getBlockSize();            <span class="hljs-type">long</span> <span class="hljs-variable">availableBlocks</span> <span class="hljs-operator">=</span> stat.getAvailableBlocks();            <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> availableBlocks * blockSize;            <span class="hljs-keyword">if</span> (total &gt; mMinSDCard) &#123; <span class="hljs-comment">//判断SDK卡</span>                item = <span class="hljs-literal">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> item;    &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganConfig</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;                  <span class="hljs-comment">// M</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">DEFAULT_MIN_SDCARD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span> * M; <span class="hljs-comment">// 最小的 SD 卡小于这个大小不写入</span>    <span class="hljs-type">long</span> <span class="hljs-variable">mMinSDCard</span> <span class="hljs-operator">=</span> DEFAULT_MIN_SDCARD_SIZE;                  <span class="hljs-comment">// 最小 sd 卡大小，通过 LoganConfig.Builder#setMinSDCard 配置</span>&#125;</code></pre></div><ol start="4"><li>日志文件大小超过限制</li></ol><p>默认 10M，<code>LoganConfig</code> 未公开 setter</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoganConfig</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">//M</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">DEFAULT_FILE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * M;    <span class="hljs-type">long</span> <span class="hljs-variable">mMaxFile</span> <span class="hljs-operator">=</span> DEFAULT_FILE_SIZE; <span class="hljs-comment">// 删除文件最大值（实际并不会删除，只是不再写入）</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGAN_LOGFILE_MAXLENGTH 10 * 1024 * 1024</span><span class="hljs-type">static</span> <span class="hljs-type">long</span> max_file_len = LOGAN_LOGFILE_MAXLENGTH;<span class="hljs-function"><span class="hljs-type">int</span></span><span class="hljs-function"><span class="hljs-title">clogan_write</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">char</span> *log, <span class="hljs-type">long</span> <span class="hljs-type">long</span> local_time, <span class="hljs-type">char</span> *thread_name, <span class="hljs-type">long</span> <span class="hljs-type">long</span> thread_id,</span></span><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">int</span> is_main)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_file_exist_clogan</span>(logan_model-&gt;file_path)) &#123;        <span class="hljs-keyword">if</span> (logan_model-&gt;file_len &gt; max_file_len) &#123;            <span class="hljs-built_in">printf_clogan</span>(<span class="hljs-string">&quot;clogan_write &gt; beyond max file , cant write log\n&quot;</span>);            back = CLOAGN_WRITE_FAIL_MAXFILE;            <span class="hljs-keyword">return</span> back;        &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h3 id="公司内部日志库-VLog"><a href="#公司内部日志库-VLog" class="headerlink" title="公司内部日志库 VLog"></a>公司内部日志库 VLog</h3><p>VLog 使用 Logan 来持久化 <code>Android.util.Log</code> 的日志输出，以便下发指令远程抓取用户日志，通过 gradle plugin Transform 和 ASM 将 <code>Log.XXX</code> 替换为 <code>VLog.XXX</code>，从而达到透明重定向日志输出的目的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogHandleTransform</span>(project: Project, ext: LogExtension?) : Transform() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> classProcessor: ClassProcessor = ClassProcessor()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> logExtension: LogExtension? = ext    override fun <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>: String &#123;        <span class="hljs-keyword">return</span> NAME    &#125;    override fun <span class="hljs-title function_">getInputTypes</span><span class="hljs-params">()</span>: MutableSet&lt;QualifiedContent.ContentType&gt; &#123;        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS    &#125;    override fun <span class="hljs-title function_">getScopes</span><span class="hljs-params">()</span>: MutableSet&lt;in QualifiedContent.Scope&gt; &#123;        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT    &#125;    override fun <span class="hljs-title function_">isIncremental</span><span class="hljs-params">()</span>: Boolean &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * NOTCHANGED: 当前文件不需处理，甚至复制操作都不用</span><span class="hljs-comment">     * ADDED、CHANGED: 正常处理，输出给下一个任务</span><span class="hljs-comment">     * REMOVED: 移除outputProvider获取路径对应的文件</span><span class="hljs-comment">     */</span>    override fun <span class="hljs-title function_">transform</span><span class="hljs-params">(transformInvocation: TransformInvocation)</span> &#123;        <span class="hljs-built_in">super</span>.transform(transformInvocation)        <span class="hljs-type">val</span> <span class="hljs-variable">inputs</span> <span class="hljs-operator">=</span> transformInvocation.inputs        <span class="hljs-type">val</span> <span class="hljs-variable">outputProvider</span> <span class="hljs-operator">=</span> transformInvocation.outputProvider        <span class="hljs-type">val</span> <span class="hljs-variable">isIncremental</span> <span class="hljs-operator">=</span> transformInvocation.isIncremental        <span class="hljs-comment">//如果非增量，则清空旧的输出内容</span>        <span class="hljs-keyword">if</span> (!isIncremental) &#123;            outputProvider.deleteAll()        &#125;        Logger.w(<span class="hljs-string">&quot;isIncremental: $isIncremental&quot;</span>)        inputs.stream().forEach &#123; transformInput: TransformInput -&gt;            <span class="hljs-comment">//jar</span>            transformInput.jarInputs.stream().forEach &#123; jarInput: JarInput -&gt;                <span class="hljs-type">val</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> jarInput.status                val src: File = jarInput.file                <span class="hljs-type">var</span> <span class="hljs-variable">destName</span> <span class="hljs-operator">=</span> src.name                <span class="hljs-title function_">if</span> <span class="hljs-params">(destName.endsWith(<span class="hljs-string">&quot;.jar&quot;</span>)</span>) &#123;                    destName = destName.substring(<span class="hljs-number">0</span>, destName.length - <span class="hljs-number">4</span>);                &#125;                <span class="hljs-type">val</span> <span class="hljs-variable">hexName</span> <span class="hljs-operator">=</span> DigestUtils.md5Hex(src.absolutePath)                val dest: File =                    transformInvocation.outputProvider.getContentLocation(                        <span class="hljs-comment">//destName + &quot;_&quot; + hexName,</span>                        jarInput.name,                        jarInput.contentTypes,                        jarInput.scopes,                        Format.JAR                    )                Logger.w(<span class="hljs-string">&quot;jar origin path: $&#123;src.absolutePath&#125;, jar output path: $&#123;dest.absolutePath&#125;, jar status $&#123;status.name&#125;&quot;</span>)                <span class="hljs-keyword">if</span> (status == <span class="hljs-literal">null</span> || !isIncremental) &#123;                    processJar(src, dest)                &#125; <span class="hljs-keyword">else</span> &#123;                    when (status) &#123;                        Status.NOTCHANGED -&gt; &#123;                            <span class="hljs-comment">//nothing</span>                        &#125;                        Status.ADDED, Status.CHANGED -&gt; &#123;                            processJar(jarInput.file, dest)                        &#125;                        Status.REMOVED -&gt; <span class="hljs-keyword">if</span> (dest.exists()) &#123;                            <span class="hljs-comment">//delete dest</span>                            FileUtils.forceDelete(dest)                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//dir</span>            transformInput.directoryInputs.stream().forEach &#123; directoryInput: DirectoryInput -&gt;                val src: File = directoryInput.file                val dest: File =                    transformInvocation.outputProvider.getContentLocation(                        directoryInput.name,                        directoryInput.contentTypes,                        directoryInput.scopes,                        Format.DIRECTORY                    )                Logger.w(<span class="hljs-string">&quot;dir origin path: $&#123;src.absolutePath&#125;, dir output path: $&#123;dest.absolutePath&#125;&quot;</span>)                <span class="hljs-keyword">if</span> (isIncremental) &#123;                    <span class="hljs-type">val</span> <span class="hljs-variable">srcDirPath</span> <span class="hljs-operator">=</span> src.absolutePath                    <span class="hljs-type">val</span> <span class="hljs-variable">destDirPath</span> <span class="hljs-operator">=</span> dest.absolutePath                    <span class="hljs-type">val</span> <span class="hljs-variable">fileStatusMap</span> <span class="hljs-operator">=</span> directoryInput.changedFiles                    <span class="hljs-comment">//Logger.w(&quot;dir change file: $fileStatusMap&quot;)</span>                    <span class="hljs-keyword">for</span> ((inputFile: File, status: Status) in fileStatusMap) &#123;                        val destFilePath: String =                            inputFile.absolutePath.replace(srcDirPath, destDirPath)                        <span class="hljs-comment">//Logger.w(&quot;incremental dir handle origin file: $&#123;inputFile.absolutePath&#125;, dir output path: $destFilePath&quot;)</span>                        <span class="hljs-type">val</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> File(destFilePath)                        when (status) &#123;                            Status.NOTCHANGED -&gt; &#123;                                <span class="hljs-comment">//nothing</span>                            &#125;                            Status.REMOVED -&gt; <span class="hljs-keyword">if</span> (destFile.exists()) &#123;                                <span class="hljs-comment">//delete dest</span>                                FileUtils.forceDelete(destFile)                            &#125;                            Status.ADDED, Status.CHANGED -&gt; &#123;                                FileUtils.touch(destFile)                                <span class="hljs-comment">//例如/intermediates/transforms/ASMPLUGIN/debug/235/META-INF</span>                                <span class="hljs-keyword">if</span> (inputFile.isDirectory) &#123;                                    handleDirectoryInput(                                        inputFile,                                        dest,                                        src.absolutePath                                    )                                &#125; <span class="hljs-keyword">else</span> &#123;                                    <span class="hljs-keyword">if</span> (inputFile.name.endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;                                        processClassFile(inputFile, destFile)                                    &#125; <span class="hljs-keyword">else</span> &#123;                                        FileUtils.copyFile(inputFile, destFile)                                    &#125;                                &#125;                            &#125;                        &#125;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    handleDirectoryInput(src, dest, src.absolutePath)                &#125;                <span class="hljs-comment">//直接复制</span>                <span class="hljs-comment">//FileUtils.copyDirectory(directoryInput.file, dest)</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">handleDirectoryInput</span><span class="hljs-params">(file: File, targetDirFile: File, relativePath: String)</span> &#123;        <span class="hljs-keyword">if</span> (file.isDirectory) &#123;            <span class="hljs-keyword">for</span> (f in file.listFiles()) &#123;                handleDirectoryInput(f, targetDirFile, relativePath)            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            val targetPath: String =                file.absolutePath.replace(relativePath, targetDirFile.absolutePath)            <span class="hljs-type">val</span> <span class="hljs-variable">targetFile</span> <span class="hljs-operator">=</span> File(targetPath)            <span class="hljs-comment">//Logger.w(&quot;handleDirectoryInput targetDir: $&#123;targetDirFile.absolutePath&#125;, origin file: $&#123;file.absolutePath&#125;, output file: $targetPath&quot;)</span>            <span class="hljs-keyword">if</span> (file.name.endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;                processClassFile(file, targetFile)            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">val</span> <span class="hljs-variable">destFile</span> <span class="hljs-operator">=</span> File(targetPath)                FileUtils.copyFile(file, destFile)            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">processClassFile</span><span class="hljs-params">(src: File, targetFile: File)</span> &#123;        <span class="hljs-keyword">var</span> bytes: ByteArray? = <span class="hljs-literal">null</span>        <span class="hljs-keyword">try</span> &#123;            bytes = classProcessor.process(FileUtils.readFileToByteArray(src))        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;            e.printStackTrace()        &#125;        <span class="hljs-keyword">if</span> (!targetFile.parentFile.exists()) &#123;            targetFile.parentFile.mkdirs()        &#125;        <span class="hljs-keyword">try</span> &#123;            FileUtils.writeByteArrayToFile(targetFile, bytes)        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;            e.printStackTrace()        &#125;    &#125;    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">processJar</span><span class="hljs-params">(zipFile: File, destFile: File)</span> &#123;        <span class="hljs-type">val</span> <span class="hljs-variable">zos</span> <span class="hljs-operator">=</span> ZipOutputStream(FileOutputStream(destFile))        <span class="hljs-type">val</span> <span class="hljs-variable">zis</span> <span class="hljs-operator">=</span> JarFile(zipFile)        val enumeration: Enumeration&lt;JarEntry&gt; = zis.entries()        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements()) &#123;            val jarEntry: JarEntry = enumeration.nextElement() as JarEntry            val entryName: String = jarEntry.name            <span class="hljs-comment">//Logger.w(&quot;jar content name: $entryName&quot;)</span>            <span class="hljs-keyword">if</span> (jarEntry.isDirectory) <span class="hljs-keyword">continue</span>            <span class="hljs-comment">//为新的jar创建zipEntry</span>            <span class="hljs-type">val</span> <span class="hljs-variable">zipEntry</span> <span class="hljs-operator">=</span> ZipEntry(entryName)            zos.putNextEntry(zipEntry)            val inputStream: InputStream = zis.getInputStream(jarEntry)            <span class="hljs-comment">//inputStream to byte，我看bytex也是用的这个</span>            val src: ByteArray = ByteStreams.toByteArray(inputStream)            <span class="hljs-comment">//com/viomi/vlog此包下面的类不处理，Logan库里面的Log也不处理</span>            <span class="hljs-keyword">if</span> (needHandle(entryName)) &#123;                val bytes: ByteArray = classProcessor.process(src)                zos.write(bytes)            &#125; <span class="hljs-keyword">else</span> &#123;                zos.write(src)            &#125;            zos.closeEntry()            inputStream.close()        &#125;        zis.close()        zos.close()    &#125;    <span class="hljs-keyword">private</span> fun <span class="hljs-title function_">needHandle</span><span class="hljs-params">(entryName: String)</span>: Boolean &#123;        <span class="hljs-keyword">if</span> (!entryName.endsWith(<span class="hljs-string">&quot;.class&quot;</span>)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-keyword">if</span> (entryName.contains(LOG_LIB_PKG) || entryName.contains(LOGAN_LIB_PKG)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-type">var</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>        logExtension?.let &#123;            <span class="hljs-keyword">for</span> (name in logExtension!!.whiteList) &#123;                <span class="hljs-keyword">if</span> (entryName.contains(LogExtension.transform(name))) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> handle    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassProcessor</span> &#123;    fun <span class="hljs-title function_">process</span><span class="hljs-params">(src: ByteArray)</span>: ByteArray &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">val</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> ClassReader(src)            <span class="hljs-type">val</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)            <span class="hljs-type">val</span> <span class="hljs-variable">monitorClassVisitor</span> <span class="hljs-operator">=</span> LogClassVisitor(ASM_API, cw)            classReader.accept(monitorClassVisitor, ClassReader.EXPAND_FRAMES)            <span class="hljs-keyword">return</span> cw.toByteArray()        &#125; <span class="hljs-keyword">catch</span> (e: MethodCallOptException) &#123;            <span class="hljs-keyword">return</span> src        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LogClassVisitor</span>(api: Int, cv: ClassVisitor) : ClassVisitor(api, cv) &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> className: String? = <span class="hljs-literal">null</span>    override fun <span class="hljs-title function_">visit</span><span class="hljs-params">(</span><span class="hljs-params">        version: Int,</span><span class="hljs-params">        access: Int,</span><span class="hljs-params">        name: String?,</span><span class="hljs-params">        signature: String?,</span><span class="hljs-params">        superName: String?,</span><span class="hljs-params">        interfaces: Array&lt;out String&gt;?</span><span class="hljs-params">    )</span> &#123;        <span class="hljs-built_in">super</span>.visit(version, access, name, signature, superName, interfaces)        className = name    &#125;    override fun <span class="hljs-title function_">visitMethod</span><span class="hljs-params">(</span><span class="hljs-params">        access: Int,</span><span class="hljs-params">        name: String?,</span><span class="hljs-params">        desc: String?,</span><span class="hljs-params">        signature: String?,</span><span class="hljs-params">        exceptions: Array&lt;out String&gt;?</span><span class="hljs-params">    )</span>: MethodVisitor &#123;        val methodVisitor: MethodVisitor =            <span class="hljs-built_in">super</span>.visitMethod(access, name, desc, signature, exceptions)        <span class="hljs-keyword">return</span> MethodVisit(methodVisitor, className, ASM_API, access, name, desc)    &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodVisit</span>(        methodVisitor: MethodVisitor,        className: String?,        api: Int,        access: Int,        name: String?,        desc: String?    ) : AdviceAdapter(api, methodVisitor, access, name, desc) &#123;        override fun <span class="hljs-title function_">visitMethodInsn</span><span class="hljs-params">(</span><span class="hljs-params">            opcode: Int,</span><span class="hljs-params">            owner: String,</span><span class="hljs-params">            name: String,</span><span class="hljs-params">            descriptor: String,</span><span class="hljs-params">            isInterface: Boolean</span><span class="hljs-params">        )</span> &#123;            val ext: LogExt? = LogExt.needRep(owner, name, descriptor)            <span class="hljs-keyword">if</span> (ext != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-built_in">super</span>.visitMethodInsn(opcode, LOG_LIB_CLASS, name, descriptor, isInterface)            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">super</span>.visitMethodInsn(opcode, owner, name, descriptor, isInterface)            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>如果需要在没有 server 的情况下解压/解密，可以使用 <a href="https://github.com/Meituan-Dianping/Logan/issues/351#issue-909155178">这个 Python 脚本</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>log</tag>
      
      <tag>logcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>崩溃日志收集库 xCrash 浅析</title>
    <link href="/2021/06/22/xcrash/"/>
    <url>/2021/06/22/xcrash/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/iqiyi/xCrash">xCrash</a> 是爱奇艺团队开源的一款崩溃日志收集库，可以收集 <strong>java crash</strong>、<strong>native crash</strong> 和 <strong>ANR</strong> 日志</p><p>日志格式为专用格式，内容还算丰富：<strong>机器信息</strong>、<strong>崩溃线程和其他线程的方法栈</strong>、<strong>logcat</strong>、<strong>打开的 fd</strong> 等等 …</p><p>默认配置为：</p><ol><li><code>java crash</code>、<code>native crash</code> 和 <code>ANR</code> 都会被捕获</li><li>日志目录在 <code>/data/data/[pkg]/files/tombstones</code></li><li><code>java crash</code> 日志文件为 <code>tombstone_[加载 xCrash 的时间，单位为秒的时间戳，宽度为 20]_[app version]__[process name].java.xcrash</code></li><li><code>native crash</code> 日志文件为 <code>tombstone_[加载 xCrash 的时间，单位为秒的时间戳，宽度为 20]_[app version]__[process name].native.xcrash</code></li><li><code>ANR</code> 日志文件为 <code>tombstone_[加载 xCrash 的时间，单位为秒的时间戳，宽度为 20]_[app version]__[process name].trace.xcrash</code></li></ol><h2 id="Java-Crash"><a href="#Java-Crash" class="headerlink" title="Java Crash"></a>Java Crash</h2><p>捕获 Java Crash 用的是 <code>DefaultUncaughtExceptionHandler</code>，相关的基础知识参考 <a href="../../../../2021/06/18/uncaught-exception-handler/">Uncaught Exception Handling</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaCrashHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UncaughtExceptionHandler</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread thread, Throwable throwable)</span> &#123;        <span class="hljs-keyword">if</span> (defaultHandler != <span class="hljs-literal">null</span>) &#123;            Thread.setDefaultUncaughtExceptionHandler(defaultHandler);        &#125;        <span class="hljs-keyword">try</span> &#123;            handleException(thread, throwable);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler handleException failed&quot;</span>, e);        &#125;        <span class="hljs-comment">// 可以选择重新抛出给上一个 handler，或者杀死 app</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.rethrow) &#123;            <span class="hljs-keyword">if</span> (defaultHandler != <span class="hljs-literal">null</span>) &#123;                defaultHandler.uncaughtException(thread, throwable);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            ActivityMonitor.getInstance().finishAllActivities();            Process.killProcess(<span class="hljs-built_in">this</span>.pid);            System.exit(<span class="hljs-number">10</span>);        &#125;    &#125;    <span class="hljs-comment">// 收集各种各样的信息，写入到日志文件</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleException</span><span class="hljs-params">(Thread thread, Throwable throwable)</span> &#123;        <span class="hljs-type">Date</span> <span class="hljs-variable">crashTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();        <span class="hljs-comment">//notify the java crash</span>        NativeHandler.getInstance().notifyJavaCrashed();        AnrHandler.getInstance().notifyJavaCrashed();        <span class="hljs-comment">//create log file</span>        <span class="hljs-type">File</span> <span class="hljs-variable">logFile</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">logPath</span> <span class="hljs-operator">=</span> String.format(Locale.US, <span class="hljs-string">&quot;%s/%s_%020d_%s__%s%s&quot;</span>, logDir, Util.logPrefix, startTime.getTime() * <span class="hljs-number">1000</span>, appVersion, processName, Util.javaLogSuffix);            logFile = FileManager.getInstance().createLogFile(logPath);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler createLogFile failed&quot;</span>, e);        &#125;        <span class="hljs-comment">//get emergency</span>        <span class="hljs-type">String</span> <span class="hljs-variable">emergency</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            emergency = getEmergency(crashTime, thread, throwable);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler getEmergency failed&quot;</span>, e);        &#125;        <span class="hljs-comment">//write info to log file</span>        <span class="hljs-keyword">if</span> (logFile != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">try</span> &#123;                raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(logFile, <span class="hljs-string">&quot;rws&quot;</span>);                <span class="hljs-comment">//write emergency info</span>                <span class="hljs-keyword">if</span> (emergency != <span class="hljs-literal">null</span>) &#123;                    raf.write(emergency.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                &#125;                <span class="hljs-comment">//If we wrote the emergency info successfully, we don&#x27;t need to return it from callback again.</span>                emergency = <span class="hljs-literal">null</span>;                <span class="hljs-comment">//write logcat</span>                <span class="hljs-keyword">if</span> (logcatMainLines &gt; <span class="hljs-number">0</span> || logcatSystemLines &gt; <span class="hljs-number">0</span> || logcatEventsLines &gt; <span class="hljs-number">0</span>) &#123;                    raf.write(Util.getLogcat(logcatMainLines, logcatSystemLines, logcatEventsLines).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                &#125;                <span class="hljs-comment">//write fds</span>                <span class="hljs-keyword">if</span> (dumpFds) &#123;                    raf.write(Util.getFds().getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                &#125;                <span class="hljs-comment">//write network info</span>                <span class="hljs-keyword">if</span> (dumpNetworkInfo) &#123;                    raf.write(Util.getNetworkInfo().getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                &#125;                <span class="hljs-comment">//write memory info</span>                raf.write(Util.getMemoryInfo().getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                <span class="hljs-comment">//write background / foreground</span>                raf.write((<span class="hljs-string">&quot;foreground:\n&quot;</span> + (ActivityMonitor.getInstance().isApplicationForeground() ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>) + <span class="hljs-string">&quot;\n\n&quot;</span>).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                <span class="hljs-comment">//write other threads info</span>                <span class="hljs-keyword">if</span> (dumpAllThreads) &#123;                    raf.write(getOtherThreadsInfo(thread).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                XCrash.getLogger().e(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler write log file failed&quot;</span>, e);            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">if</span> (raf != <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-keyword">try</span> &#123;                        raf.close();                    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">//callback</span>        <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                callback.onCrash(logFile == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : logFile.getAbsolutePath(), emergency);            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;            &#125;        &#125;    &#125;        &#125;</code></pre></div><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getEmergency</span><span class="hljs-params">(Date crashTime, Thread thread, Throwable throwable)</span> &#123;    <span class="hljs-comment">//stack stace</span>    <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(sw);    throwable.printStackTrace(pw);    <span class="hljs-type">String</span> <span class="hljs-variable">stacktrace</span> <span class="hljs-operator">=</span> sw.toString();    <span class="hljs-keyword">return</span> Util.getLogHeader(startTime, crashTime, Util.javaCrashType, appId, appVersion)            + <span class="hljs-string">&quot;pid: &quot;</span> + pid + <span class="hljs-string">&quot;, tid: &quot;</span> + Process.myTid() + <span class="hljs-string">&quot;, name: &quot;</span> + thread.getName() + <span class="hljs-string">&quot;  &gt;&gt;&gt; &quot;</span> + processName + <span class="hljs-string">&quot; &lt;&lt;&lt;\n&quot;</span>            + <span class="hljs-string">&quot;\n&quot;</span>            + <span class="hljs-string">&quot;java stacktrace:\n&quot;</span>            + stacktrace            + <span class="hljs-string">&quot;\n&quot;</span>            + getBuildId(stacktrace);&#125;<span class="hljs-keyword">static</span> String <span class="hljs-title function_">getLogHeader</span><span class="hljs-params">(Date startTime, Date crashTime, String crashType, String appId, String appVersion)</span> &#123;    <span class="hljs-type">DateFormat</span> <span class="hljs-variable">timeFormatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(Util.timeFormatterStr, Locale.US);    <span class="hljs-keyword">return</span> Util.sepHead + <span class="hljs-string">&quot;\n&quot;</span>        + <span class="hljs-string">&quot;Tombstone maker: &#x27;&quot;</span> + Version.fullVersion + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Crash type: &#x27;&quot;</span> + crashType + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Start time: &#x27;&quot;</span> + timeFormatter.format(startTime) + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Crash time: &#x27;&quot;</span> + timeFormatter.format(crashTime) + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;App ID: &#x27;&quot;</span> + appId + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;App version: &#x27;&quot;</span> + appVersion + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Rooted: &#x27;&quot;</span> + (Util.isRoot() ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;API level: &#x27;&quot;</span> + Build.VERSION.SDK_INT + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;OS version: &#x27;&quot;</span> + Build.VERSION.RELEASE + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;ABI list: &#x27;&quot;</span> + Util.getAbiList() + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Manufacturer: &#x27;&quot;</span> + Build.MANUFACTURER + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Brand: &#x27;&quot;</span> + Build.BRAND + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Model: &#x27;&quot;</span> + Util.getMobileModel() + <span class="hljs-string">&quot;&#x27;\n&quot;</span>        + <span class="hljs-string">&quot;Build fingerprint: &#x27;&quot;</span> + Build.FINGERPRINT + <span class="hljs-string">&quot;&#x27;\n&quot;</span>;&#125;<span class="hljs-keyword">private</span> String <span class="hljs-title function_">getBuildId</span><span class="hljs-params">(String stktrace)</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">buildId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;    List&lt;String&gt; libPathList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();    <span class="hljs-keyword">if</span> (stktrace.contains(<span class="hljs-string">&quot;UnsatisfiedLinkError&quot;</span>)) &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">libInfo</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        String[] tempLibPathStr;        tempLibPathStr = stktrace.split(<span class="hljs-string">&quot;\&quot;&quot;</span>); <span class="hljs-comment">// &quot; is the delimiter</span>        <span class="hljs-keyword">for</span> (String libPathStr :  tempLibPathStr) &#123;            <span class="hljs-keyword">if</span> (libPathStr.isEmpty() || !libPathStr.endsWith(<span class="hljs-string">&quot;.so&quot;</span>)) <span class="hljs-keyword">continue</span>;            libPathList.add(libPathStr);            <span class="hljs-type">String</span> <span class="hljs-variable">libName</span> <span class="hljs-operator">=</span> libPathStr.substring(libPathStr.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>);            libPathList.add(XCrash.nativeLibDir + <span class="hljs-string">&quot;/&quot;</span> + libName);            libPathList.add(<span class="hljs-string">&quot;/vendor/lib/&quot;</span> + libName);            libPathList.add(<span class="hljs-string">&quot;/vendor/lib64/&quot;</span> + libName);            libPathList.add(<span class="hljs-string">&quot;/system/lib/&quot;</span> + libName);            libPathList.add(<span class="hljs-string">&quot;/system/lib64/&quot;</span> + libName);            libInfo = getLibInfo(libPathList);        &#125;        buildId = <span class="hljs-string">&quot;build id:&quot;</span>                + <span class="hljs-string">&quot;\n&quot;</span>                + libInfo                + <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> buildId;&#125;</code></pre></div><p>输出的日志内容如下：</p><div class="code-wrapper"><pre><code class="hljs text">*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***Tombstone maker: &#x27;xCrash 2.4.6&#x27;                                                                    // xCrash 把日志叫做 tombstone，这里指的是生成 tombstone 的 xCrash 的版本Crash type: &#x27;java&#x27;                                                                                 // 指明 crash 类型，此日志包含的是 java crash（此外还有 native crash 和 ANR）Start time: &#x27;2019-10-12T03:23:19.580+0800&#x27;                                                         // 初始化 xCrash 的时间，也就是调用 XCrash.init 的时间Crash time: &#x27;2019-10-12T03:23:25.533+0800&#x27;                                                         // 发生崩溃的时间App ID: &#x27;xcrash.sample&#x27;                                                                            // 发生崩溃的 APP 的包名App version: &#x27;1.2.3-beta456-patch789&#x27;                                                              // APP version nameRooted: &#x27;No&#x27;                                                                                       API level: &#x27;29&#x27;OS version: &#x27;10&#x27;ABI list: &#x27;arm64-v8a,armeabi-v7a,armeabi&#x27;Manufacturer: &#x27;Google&#x27;Brand: &#x27;google&#x27;Model: &#x27;Pixel&#x27;Build fingerprint: &#x27;google/sailfish/sailfish:10/QP1A.190711.020/5800535:user/release-keys&#x27;pid: 21356, tid: 21356, name: main  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:                                                                                    // 崩溃线程的调用栈java.lang.IllegalStateException: Could not execute method for android:onClickat androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:402)at android.view.View.performClick(View.java:7140)at android.view.View.performClickInternal(View.java:7117)at android.view.View.access$3500(View.java:801)at android.view.View$PerformClick.run(View.java:27351)at android.os.Handler.handleCallback(Handler.java:883)at android.os.Handler.dispatchMessage(Handler.java:100)at android.os.Looper.loop(Looper.java:214)at android.app.ActivityThread.main(ActivityThread.java:7356)at java.lang.reflect.Method.invoke(Native Method)at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)Caused by: java.lang.reflect.InvocationTargetExceptionat java.lang.reflect.Method.invoke(Native Method)at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)... 11 moreCaused by: java.lang.RuntimeException: test java exceptionat xcrash.XCrash.testJavaCrash(XCrash.java:847)at xcrash.sample.MainActivity.testJavaCrashInMainThread_onClick(MainActivity.java:67)... 13 more</code></pre></div><h3 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a>logcat</h3><p>其实就是调用 <code>logcat</code> 命令获取崩溃时的 <code>main</code>、<code>system</code> 和 <code>events</code> 三个 buffer 的日志，如：<code>/system/bin/logcat -b main -d -v threadtime -t 200 --pid 21356 *:D</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">getLogcat</span><span class="hljs-params">(<span class="hljs-type">int</span> logcatMainLines, <span class="hljs-type">int</span> logcatSystemLines, <span class="hljs-type">int</span> logcatEventsLines)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> android.os.Process.myPid();    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    sb.append(<span class="hljs-string">&quot;logcat:\n&quot;</span>);    <span class="hljs-keyword">if</span> (logcatMainLines &gt; <span class="hljs-number">0</span>) &#123;        getLogcatByBufferName(pid, sb, <span class="hljs-string">&quot;main&quot;</span>, logcatMainLines, <span class="hljs-string">&#x27;D&#x27;</span>);    &#125;    <span class="hljs-keyword">if</span> (logcatSystemLines &gt; <span class="hljs-number">0</span>) &#123;        getLogcatByBufferName(pid, sb, <span class="hljs-string">&quot;system&quot;</span>, logcatSystemLines, <span class="hljs-string">&#x27;W&#x27;</span>);    &#125;    <span class="hljs-keyword">if</span> (logcatEventsLines &gt; <span class="hljs-number">0</span>) &#123;        getLogcatByBufferName(pid, sb, <span class="hljs-string">&quot;events&quot;</span>, logcatSystemLines, <span class="hljs-string">&#x27;I&#x27;</span>);    &#125;    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span> sb.toString();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getLogcatByBufferName</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, StringBuilder sb, String bufferName, <span class="hljs-type">int</span> lines, <span class="hljs-type">char</span> priority)</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-variable">withPid</span> <span class="hljs-operator">=</span> (android.os.Build.VERSION.SDK_INT &gt;= <span class="hljs-number">24</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">pidString</span> <span class="hljs-operator">=</span> Integer.toString(pid);    <span class="hljs-type">String</span> <span class="hljs-variable">pidLabel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span> + pidString + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-comment">//command for ProcessBuilder</span>    List&lt;String&gt; command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();    command.add(<span class="hljs-string">&quot;/system/bin/logcat&quot;</span>);    command.add(<span class="hljs-string">&quot;-b&quot;</span>);    command.add(bufferName);    command.add(<span class="hljs-string">&quot;-d&quot;</span>);    command.add(<span class="hljs-string">&quot;-v&quot;</span>);    command.add(<span class="hljs-string">&quot;threadtime&quot;</span>);    command.add(<span class="hljs-string">&quot;-t&quot;</span>);    command.add(Integer.toString(withPid ? lines : (<span class="hljs-type">int</span>) (lines * <span class="hljs-number">1.2</span>)));    <span class="hljs-keyword">if</span> (withPid) &#123;        command.add(<span class="hljs-string">&quot;--pid&quot;</span>);        command.add(pidString);    &#125;    command.add(<span class="hljs-string">&quot;*:&quot;</span> + priority);    <span class="hljs-comment">//append the command line</span>    Object[] commandArray = command.toArray();    sb.append(<span class="hljs-string">&quot;--------- tail end of log &quot;</span>).append(bufferName);    sb.append(<span class="hljs-string">&quot; (&quot;</span>).append(android.text.TextUtils.join(<span class="hljs-string">&quot; &quot;</span>, commandArray)).append(<span class="hljs-string">&quot;)\n&quot;</span>);    <span class="hljs-comment">//append logs</span>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    String line;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>().command(command).start();        br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(process.getInputStream()));        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (withPid || line.contains(pidLabel)) &#123;                sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        XCrash.getLogger().w(Util.TAG, <span class="hljs-string">&quot;Util run logcat command failed&quot;</span>, e);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                br.close();            &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs text">logcat:--------- tail end of log main (/system/bin/logcat -b main -d -v threadtime -t 200 --pid 21356 *:D)10-12 03:23:19.356 21356 21356 I xcrash.sample: Late-enabling -Xcheck:jni10-12 03:23:19.398 21356 21356 E xcrash.sample: Unknown bits set in runtime_flags: 0x800010-12 03:23:19.571 21356 21356 D xcrash_sample: xCrash SDK init: start10-12 03:23:19.586 21356 21356 D xcrash_sample: xCrash SDK init: end10-12 03:23:19.757 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (greylist, reflection, allowed)10-12 03:23:19.758 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/ViewGroup;-&gt;makeOptionalFitsSystemWindows()V (greylist, reflection, allowed)10-12 03:23:19.829 21356 21356 I WebViewFactory: Loading com.google.android.webview version 77.0.3865.92 (code 386509238)10-12 03:23:19.874 21356 21356 I cr_LibraryLoader: Time to load native libraries: 4 ms (timestamps 1922-1926)10-12 03:23:19.920 21356 21356 I chromium: [INFO:library_loader_hooks.cc(51)] Chromium logging enabled: level = 0, default verbosity = 010-12 03:23:19.921 21356 21356 I cr_LibraryLoader: Expected native library version number &quot;77.0.3865.92&quot;, actual native library version number &quot;77.0.3865.92&quot;10-12 03:23:19.926 21356 21402 W cr_ChildProcLH: Create a new ChildConnectionAllocator with package name = com.google.android.webview, sandboxed = true10-12 03:23:19.930 21356 21402 W xcrash.sample: Accessing hidden method Landroid/content/Context;-&gt;bindServiceAsUser(Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/Handler;Landroid/os/UserHandle;)Z (greylist, reflection, allowed)10-12 03:23:19.934 21356 21356 I cr_BrowserStartup: Initializing chromium process, singleProcess=false10-12 03:23:19.979 21356 21430 W chromium: [WARNING:dns_config_service_posix.cc(339)] Failed to read DnsConfig.10-12 03:23:20.031 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker;-&gt;&lt;init&gt;(Landroid/content/Context;I)V (greylist, reflection, allowed)10-12 03:23:20.031 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker;-&gt;logEvent(Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;)V (greylist, reflection, allowed)10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionStarted(I)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionModified(II)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionModified(IILandroid/view/textclassifier/TextClassification;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionModified(IILandroid/view/textclassifier/TextSelection;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionAction(III)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;-&gt;selectionAction(IIILandroid/view/textclassifier/TextClassification;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)10-12 03:23:20.143 21356 21395 I Adreno  : QUALCOMM build                   : 4a00b69, I4e7e88806510-12 03:23:20.143 21356 21395 I Adreno  : Build Date                       : 04/09/1910-12 03:23:20.143 21356 21395 I Adreno  : OpenGL ES Shader Compiler Version: EV031.26.06.0010-12 03:23:20.143 21356 21395 I Adreno  : Local Branch                     : mybranche95ae4c8-d77f-f18d-a9ef-1458d0b52ae810-12 03:23:20.143 21356 21395 I Adreno  : Remote Branch                    : quic/gfx-adreno.lnx.1.010-12 03:23:20.143 21356 21395 I Adreno  : Remote Branch                    : NONE10-12 03:23:20.143 21356 21395 I Adreno  : Reconstruct Branch               : NOTHING10-12 03:23:20.143 21356 21395 I Adreno  : Build Config                     : S L 8.0.5 AArch6410-12 03:23:20.146 21356 21395 I Adreno  : PFP: 0x005ff110, ME: 0x005ff06610-12 03:23:20.198 21356 21395 W Gralloc3: mapper 3.x is not supported10-12 03:23:25.531 21356 21356 D AndroidRuntime: Shutting down VM--------- tail end of log system (/system/bin/logcat -b system -d -v threadtime -t 50 --pid 21356 *:W)--------- tail end of log events (/system/bin/logcat -b events -d -v threadtime -t 50 --pid 21356 *:I)10-12 03:23:20.046 21356 21356 I am_on_create_called: [0,xcrash.sample.MainActivity,performCreate]10-12 03:23:20.053 21356 21356 I am_on_start_called: [0,xcrash.sample.MainActivity,handleStartActivity]10-12 03:23:20.056 21356 21356 I am_on_resume_called: [0,xcrash.sample.MainActivity,RESUME_ACTIVITY]10-12 03:23:20.083 21356 21356 I am_on_top_resumed_gained_called: [0,xcrash.sample.MainActivity,topStateChangedWhenResumed]</code></pre></div><h3 id="Opened-FD"><a href="#Opened-FD" class="headerlink" title="Opened FD"></a>Opened FD</h3><p>打印已打开的 FD 及其路径，已打开的 FD 在目录 <code>/proc/self/fd</code> 下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">getFds</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;open files:\n&quot;</span>);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/proc/self/fd&quot;</span>);        File[] fds = dir.listFiles(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FilenameFilter</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(File dir, String name)</span> &#123;                <span class="hljs-keyword">return</span> TextUtils.isDigitsOnly(name);            &#125;        &#125;);        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (fds != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (File fd : fds) &#123;                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>) &#123;                        path = Os.readlink(fd.getAbsolutePath());                    &#125; <span class="hljs-keyword">else</span> &#123;                        path = fd.getCanonicalPath();                    &#125;                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;                &#125;                sb.append(<span class="hljs-string">&quot;    fd &quot;</span>).append(fd.getName()).append(<span class="hljs-string">&quot;: &quot;</span>)                    .append(TextUtils.isEmpty(path) ? <span class="hljs-string">&quot;???&quot;</span> : path.trim()).append(<span class="hljs-string">&#x27;\n&#x27;</span>);                count++;                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1024</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (fds.length &gt; <span class="hljs-number">1024</span>) &#123;                sb.append(<span class="hljs-string">&quot;    ......\n&quot;</span>);            &#125;            sb.append(<span class="hljs-string">&quot;    (number of FDs: &quot;</span>).append(fds.length).append(<span class="hljs-string">&quot;)\n&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;    &#125;    sb.append(<span class="hljs-string">&#x27;\n&#x27;</span>);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs text">open files:    fd 0: /dev/null    fd 1: /dev/null    fd 2: /dev/null    fd 3: /proc/21356/fd/3    fd 4: /proc/21356/fd/4    fd 5: /proc/21356/fd/5    fd 6: /dev/null    fd 7: /dev/null    fd 8: /dev/null    fd 9: /apex/com.android.runtime/javalib/core-oj.jar    fd 10: /apex/com.android.runtime/javalib/core-libart.jar    fd 11: /apex/com.android.runtime/javalib/okhttp.jar    fd 12: /apex/com.android.runtime/javalib/bouncycastle.jar    fd 13: /apex/com.android.runtime/javalib/apache-xml.jar    fd 14: /system/framework/framework.jar    fd 15: /system/framework/ext.jar    fd 16: /system/framework/telephony-common.jar    fd 17: /system/framework/voip-common.jar    fd 18: /system/framework/ims-common.jar    fd 19: /dev/null    fd 20: /dev/null    fd 21: /system/framework/android.test.base.jar    fd 22: /apex/com.android.conscrypt/javalib/conscrypt.jar    fd 23: /apex/com.android.media/javalib/updatable-media.jar    fd 24: /system/framework/framework-res.apk    fd 25: /system/product/overlay/GoogleConfigOverlay.apk    fd 26: /system/product/overlay/GoogleWebViewOverlay.apk    fd 27: /vendor/overlay/framework-res__auto_generated_rro_vendor.apk    fd 28: /system/product/overlay/PixelConfigOverlayCommon.apk    fd 29: /system/product/overlay/framework-res__auto_generated_rro_product.apk    fd 30: /dev/null    fd 31: /dev/binder    fd 32: /proc/21356/fd/32    fd 33: /proc/21356/fd/33    fd 34: /proc/21356/fd/34    fd 35: /proc/21356/fd/35    fd 36: /proc/21356/fd/36    fd 37: /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/base.apk    fd 38: /proc/21356/fd/38    fd 39: /proc/21356/fd/39    fd 40: /system/product/overlay/NavigationBarModeGestural/NavigationBarModeGesturalOverlay.apk    fd 41: /dev/null    fd 42: /dev/null    fd 43: /dev/null    fd 44: /dev/null    fd 45: /proc/21356/fd/45    fd 46: /proc/21356/fd/46    fd 47: /proc/21356/fd/47    fd 48: /proc/21356/fd/48    fd 49: /dev/ashmem    fd 50: /proc/21356/fd/50    fd 51: /proc/21356/fd/51    fd 52: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk    fd 53: /proc/21356/fd/53    fd 54: /data/data/xcrash.sample/files/tombstones/tombstone_00001570821799580000_1.2.3-beta456-patch789__xcrash.sample.java.xcrash    fd 55: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk    fd 56: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk    fd 57: /data/data/xcrash.sample/app_webview/webview_data.lock    fd 58: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk    fd 59: /system/product/overlay/NavigationBarModeGestural/NavigationBarModeGesturalOverlay.apk    fd 60: /proc/21356/fd/60    fd 61: /proc/21356/fd/61    fd 62: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk    fd 63: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk    fd 64: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk    fd 65: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk    fd 66: /dev/urandom    fd 67: /proc/21356/fd/67    fd 68: /proc/21356/fd/68    fd 69: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk    fd 70: /proc/21356/fd/70    fd 71: /proc/21356/fd/71    fd 72: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk    fd 73: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk    fd 74: /proc/21356/fd/74    fd 75: /proc/21356/fd/75    fd 76: /proc/21356/fd/76    fd 77: /proc/21356/fd/77    fd 78: /proc/21356/fd/78    fd 79: /proc/21356/fd/79    fd 80: /proc/21356/fd/80    fd 81: /proc/21356/fd/81    fd 82: /proc/21356/fd/82    fd 83: /proc/21356/fd/83    fd 84: /proc/21356/fd/84    fd 85: /proc/21356/fd/85    fd 86: /proc/21356/fd/86    fd 87: /proc/21356/fd/87    fd 88: /proc/21356/fd/88    fd 89: /proc/21356/fd/89    fd 90: /proc/21356/fd/90    fd 91: /dev/ashmem    fd 92: /dev/ashmem    fd 93: /dev/ashmem    fd 94: /data/data/xcrash.sample/app_webview/Web Data    fd 95: /proc/21356/fd/95    fd 96: /proc/21356/fd/96    fd 97: /dev/ashmem    fd 98: /dev/ion    fd 99: /proc/21356/fd/99    fd 100: /proc/21356/fd/100    fd 101: /proc/21356/fd/101    fd 102: /dev/ashmem    fd 103: /dev/kgsl-3d0    fd 104: /dev/ion    fd 105: /dev/hwbinder    fd 106: /proc/21356/fd/106    fd 107: /proc/21356/fd/107    fd 110: /proc/21356/fd/110    fd 111: /proc/21356/fd/111    fd 113: /proc/21356/fd/113    fd 114: /proc/21356/fd/114    fd 115: /proc/21356/fd/115    fd 116: /proc/21356/fd/116    fd 117: /proc/21356/fd/117    (number of FDs: 115)</code></pre></div><h3 id="System-Memory-Summary"><a href="#System-Memory-Summary" class="headerlink" title="System Memory Summary"></a>System Memory Summary</h3><div class="code-wrapper"><pre><code class="hljs text">System Summary (From: /proc/meminfo) MemTotal:        3855796 kB MemFree:           90124 kB MemAvailable:    1452636 kB Buffers:           77420 kB Cached:          1461900 kB SwapCached:        10232 kB Active:          1771504 kB Inactive:        1014432 kB Active(anon):    1046604 kB Inactive(anon):   368348 kB Active(file):     724900 kB Inactive(file):   646084 kB Unevictable:      151672 kB Mlocked:          151672 kB SwapTotal:        524284 kB SwapFree:         271320 kB Dirty:               136 kB Writeback:             0 kB AnonPages:       1391280 kB Mapped:           620988 kB Shmem:             16660 kB Slab:             231556 kB SReclaimable:      92700 kB SUnreclaim:       138856 kB KernelStack:       44448 kB PageTables:        57544 kB NFS_Unstable:          0 kB Bounce:                0 kB WritebackTmp:          0 kB CommitLimit:     2452180 kB Committed_AS:   67847232 kB VmallocTotal:   258998208 kB VmallocUsed:      223632 kB VmallocChunk:   258675172 kB</code></pre></div><h3 id="APP-Process-Summary"><a href="#APP-Process-Summary" class="headerlink" title="APP Process Summary"></a>APP Process Summary</h3><div class="code-wrapper"><pre><code class="hljs text">Process Status (From: /proc/PID/status) Name:xcrash.sample State:R (running) Tgid:21356 Pid:21356 PPid:626 TracerPid:0 Uid:10180101801018010180 Gid:10180101801018010180 Ngid:0 FDSize:128 Groups:9997 20180 50180 VmPeak: 5659228 kB VmSize: 5542192 kB VmLck:       0 kB VmPin:       0 kB VmHWM:   94624 kB VmRSS:   94396 kB VmData: 5051840 kB VmStk:    8192 kB VmExe:      28 kB VmLib:  166580 kB VmPTE:    1068 kB VmSwap:    6476 kB Threads:37 SigQ:0/13891 SigPnd:0000000000000000 ShdPnd:0000000000000000 SigBlk:0000000080001200 SigIgn:0000000000000001 SigCgt:0000000e400084fc CapInh:0000000000000000 CapPrm:0000000000000000 CapEff:0000000000000000 CapBnd:0000000000000000 CapAmb:0000000000000000 Seccomp:2 Cpus_allowed:f Cpus_allowed_list:0-3 Mems_allowed:1 Mems_allowed_list:0 voluntary_ctxt_switches:343 nonvoluntary_ctxt_switches:301</code></pre></div><h3 id="APP-Process-Limits"><a href="#APP-Process-Limits" class="headerlink" title="APP Process Limits"></a>APP Process Limits</h3><div class="code-wrapper"><pre><code class="hljs text">Process Limits (From: /proc/PID/limits) Limit                     Soft Limit           Hard Limit           Units Max cpu time              unlimited            unlimited            seconds Max file size             unlimited            unlimited            bytes Max data size             unlimited            unlimited            bytes Max stack size            8388608              unlimited            bytes Max core file size        0                    unlimited            bytes Max resident set          unlimited            unlimited            bytes Max processes             13891                13891                processes Max open files            32768                32768                files Max locked memory         65536                65536                bytes Max address space         unlimited            unlimited            bytes Max file locks            unlimited            unlimited            locks Max pending signals       13891                13891                signals Max msgqueue size         819200               819200               bytes Max nice priority         40                   40 Max realtime priority     0                    0 Max realtime timeout      unlimited            unlimited            us</code></pre></div><h3 id="APP-Memory-Summary"><a href="#APP-Memory-Summary" class="headerlink" title="APP Memory Summary"></a>APP Memory Summary</h3><div class="code-wrapper"><pre><code class="hljs text">Process Summary (From: android.os.Debug.MemoryInfo)                       Pss(KB)                        ------           Java Heap:     7632         Native Heap:    10932                Code:    19064               Stack:       56            Graphics:     1104       Private Other:     3448              System:     4414               TOTAL:    46650           TOTAL SWAP:     6460</code></pre></div><h3 id="Other-StackTraces"><a href="#Other-StackTraces" class="headerlink" title="Other StackTraces"></a>Other StackTraces</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getOtherThreadsInfo</span><span class="hljs-params">(Thread crashedThread)</span> &#123;    <span class="hljs-comment">// 其他线程可能有很多，所以有“白名单”机制</span>    <span class="hljs-type">int</span> <span class="hljs-variable">thdMatchedRegex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">thdIgnoredByLimit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">thdDumped</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//build whitelist regex list</span>    ArrayList&lt;Pattern&gt; whiteList = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (dumpAllThreadsWhiteList != <span class="hljs-literal">null</span>) &#123;        whiteList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Pattern&gt;();        <span class="hljs-keyword">for</span> (String s : dumpAllThreadsWhiteList) &#123;            <span class="hljs-keyword">try</span> &#123;                whiteList.add(Pattern.compile(s));            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                XCrash.getLogger().w(Util.TAG, <span class="hljs-string">&quot;JavaCrashHandler pattern compile failed&quot;</span>, e);            &#125;        &#125;    &#125;    <span class="hljs-comment">// dump trace</span>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();    <span class="hljs-keyword">for</span> (Map.Entry&lt;Thread, StackTraceElement[]&gt; entry : map.entrySet()) &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">thd</span> <span class="hljs-operator">=</span> entry.getKey();        StackTraceElement[] stacktrace = entry.getValue();        <span class="hljs-comment">//skip the crashed thread</span>        <span class="hljs-keyword">if</span> (thd.getName().equals(crashedThread.getName())) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//check regex for thread name</span>        <span class="hljs-keyword">if</span> (whiteList != <span class="hljs-literal">null</span> &amp;&amp; !matchThreadName(whiteList, thd.getName())) <span class="hljs-keyword">continue</span>;        thdMatchedRegex++;        <span class="hljs-comment">//check dump count limit</span>        <span class="hljs-keyword">if</span> (dumpAllThreadsCountMax &gt; <span class="hljs-number">0</span> &amp;&amp; thdDumped &gt;= dumpAllThreadsCountMax) &#123;            thdIgnoredByLimit++;            <span class="hljs-keyword">continue</span>;        &#125;        sb.append(Util.sepOtherThreads + <span class="hljs-string">&quot;\n&quot;</span>);        sb.append(<span class="hljs-string">&quot;pid: &quot;</span>).append(pid).append(<span class="hljs-string">&quot;, tid: &quot;</span>).append(thd.getId()).append(<span class="hljs-string">&quot;, name: &quot;</span>).append(thd.getName()).append(<span class="hljs-string">&quot;  &gt;&gt;&gt; &quot;</span>).append(processName).append(<span class="hljs-string">&quot; &lt;&lt;&lt;\n&quot;</span>);        sb.append(<span class="hljs-string">&quot;\n&quot;</span>);        sb.append(<span class="hljs-string">&quot;java stacktrace:\n&quot;</span>);        <span class="hljs-keyword">for</span> (StackTraceElement element : stacktrace) &#123;            sb.append(<span class="hljs-string">&quot;    at &quot;</span>).append(element.toString()).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        sb.append(<span class="hljs-string">&quot;\n&quot;</span>);        thdDumped++;    &#125;    <span class="hljs-comment">// 统计</span>    <span class="hljs-keyword">if</span> (map.size() &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> (thdDumped == <span class="hljs-number">0</span>) &#123;            sb.append(Util.sepOtherThreads + <span class="hljs-string">&quot;\n&quot;</span>);        &#125;        sb.append(<span class="hljs-string">&quot;total JVM threads (exclude the crashed thread): &quot;</span>).append(map.size() - <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">if</span> (whiteList != <span class="hljs-literal">null</span>) &#123;            sb.append(<span class="hljs-string">&quot;JVM threads matched whitelist: &quot;</span>).append(thdMatchedRegex).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (dumpAllThreadsCountMax &gt; <span class="hljs-number">0</span>) &#123;            sb.append(<span class="hljs-string">&quot;JVM threads ignored by max count limit: &quot;</span>).append(thdIgnoredByLimit).append(<span class="hljs-string">&quot;\n&quot;</span>);        &#125;        sb.append(<span class="hljs-string">&quot;dumped JVM threads:&quot;</span>).append(thdDumped).append(<span class="hljs-string">&quot;\n&quot;</span>);        sb.append(Util.sepOtherThreadsEnding + <span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs text">--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4364, name: RenderThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4349, name: Jit thread pool worker thread 0  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4357, name: Binder:21356_2  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4374, name: NetworkService  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4353, name: ReferenceQueueDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at java.lang.Object.wait(Native Method)    at java.lang.Object.wait(Object.java:442)    at java.lang.Object.wait(Object.java:568)    at java.lang.Daemons$ReferenceQueueDaemon.runInternal(Daemons.java:215)    at java.lang.Daemons$Daemon.run(Daemons.java:137)    at java.lang.Thread.run(Thread.java:919)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4359, name: Profile Saver  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4371, name: GoogleApiHandler  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at android.os.MessageQueue.nativePollOnce(Native Method)    at android.os.MessageQueue.next(MessageQueue.java:336)    at android.os.Looper.loop(Looper.java:174)    at android.os.HandlerThread.run(HandlerThread.java:67)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4362, name: xcrash_trace_dp  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4361, name: xcrash_crash_cb  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4352, name: HeapTaskDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4354, name: FinalizerDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at java.lang.Object.wait(Native Method)    at java.lang.Object.wait(Object.java:442)    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:190)    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:211)    at java.lang.Daemons$FinalizerDaemon.runInternal(Daemons.java:271)    at java.lang.Daemons$Daemon.run(Daemons.java:137)    at java.lang.Thread.run(Thread.java:919)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4372, name: Chrome_IOThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4370, name: CrAsyncTask #2  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at sun.misc.Unsafe.park(Native Method)    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2109)    at java.util.concurrent.ArrayBlockingQueue.poll(ArrayBlockingQueue.java:402)    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)    at Js.run(PG:2)    at java.lang.Thread.run(Thread.java:919)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4375, name: PlatformServiceBridgeHandlerThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at android.os.MessageQueue.nativePollOnce(Native Method)    at android.os.MessageQueue.next(MessageQueue.java:336)    at android.os.Looper.loop(Looper.java:174)    at android.os.HandlerThread.run(HandlerThread.java:67)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4355, name: FinalizerWatchdogDaemon  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at java.lang.Thread.sleep(Native Method)    at java.lang.Thread.sleep(Thread.java:440)    at java.lang.Thread.sleep(Thread.java:356)    at java.lang.Daemons$FinalizerWatchdogDaemon.sleepForMillis(Daemons.java:383)    at java.lang.Daemons$FinalizerWatchdogDaemon.waitForFinalization(Daemons.java:411)    at java.lang.Daemons$FinalizerWatchdogDaemon.runInternal(Daemons.java:323)    at java.lang.Daemons$Daemon.run(Daemons.java:137)    at java.lang.Thread.run(Thread.java:919)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4378, name: process reaper  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at sun.misc.Unsafe.park(Native Method)    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)    at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:461)    at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)    at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:937)    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)    at java.lang.Thread.run(Thread.java:919)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4377, name: CleanupReference  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at java.lang.Object.wait(Native Method)    at java.lang.Object.wait(Object.java:442)    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:190)    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:211)    at Po.run(PG:2)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4350, name: Signal Catcher  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4373, name: ThreadPoolForeg  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4369, name: Chrome_ProcessLauncherThread  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at android.os.MessageQueue.nativePollOnce(Native Method)    at android.os.MessageQueue.next(MessageQueue.java:336)    at android.os.Looper.loop(Looper.java:174)    at android.os.HandlerThread.run(HandlerThread.java:67)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4358, name: Binder:21356_3  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4366, name: CrAsyncTask #1  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:    at sun.misc.Unsafe.park(Native Method)    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2109)    at java.util.concurrent.ArrayBlockingQueue.poll(ArrayBlockingQueue.java:402)    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)    at Js.run(PG:2)    at java.lang.Thread.run(Thread.java:919)--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4376, name: ThreadPoolForeg  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---pid: 21356, tid: 4356, name: Binder:21356_1  &gt;&gt;&gt; xcrash.sample &lt;&lt;&lt;java stacktrace:total JVM threads (exclude the crashed thread): 24dumped JVM threads:24</code></pre></div><h2 id="Native-Crash"><a href="#Native-Crash" class="headerlink" title="Native Crash"></a>Native Crash</h2><p>捕获 Native Crash 靠的是信号处理器（<code>sigaction</code>），比如说访问非法地址时，APP 进程会收到 <code>SIGSEGV</code>，对应的信号处理器就可以在这个时间点收集堆栈信息</p><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>signal 产生后会处于几种状态中：<br>    1. blocked，让内核先持有信号不要分发（deliver），在 unblocked 之前都不会被分发出去；被 blocked 的信号集合叫做 singal mask，每个线程都有自己的 signal mask<br>    2. pending，内核正在分发信号给指定的进程/线程（但还没分发出去）</p><p>signal 可以是进程范围的，比如内核产生的信号、kill 和 sigqueue；也可以是线程范围的，比如因执行机器指令而导致的硬件异常（SIGSEGV、SIGFPE）、通过 tgkill 或者 pthread_kill 指定目标线程</p><p>进程范围的信号会随机选择一个 signal unblocked 的线程来消费（deliver）</p><p><code>sigaction</code> 用来注册信号处理器，是升级版的 <code>signal</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果 act != null，它被注册为新的信号处理器；如果 oldact != null，上一个信号处理器将被保存在此</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span></span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> &#123;    <span class="hljs-built_in">void</span>     (*sa_handler)(<span class="hljs-type">int</span>);                        <span class="hljs-comment">// 只收到 signal 作为参数的处理器</span>    <span class="hljs-built_in">void</span>     (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *); <span class="hljs-comment">// 当指定 SA_SIGINFO 时，替代 sa_handler 作为处理器（能收到三个参数）</span>    <span class="hljs-type">sigset_t</span>   sa_mask;                                 <span class="hljs-comment">// 处理器运行时，暂时屏蔽指定信号（将它们加到线程的 signal mask）</span>    <span class="hljs-type">int</span>        sa_flags;    <span class="hljs-built_in">void</span>     (*sa_restorer)(<span class="hljs-type">void</span>);                      <span class="hljs-comment">// not for app</span>&#125;;<span class="hljs-comment">// sa_flags:</span><span class="hljs-comment">//     SA_SIGINFO 使用 sa_sigaction 作为处理器</span><span class="hljs-comment">//     SA_RESTART 当线程阻塞在系统调用/库函数上，因为信号的到来转而进入信号处理器，退出信号处理器后如何恢复上一个系统调用/库函数；</span><span class="hljs-comment">//                默认是使其返回失败码，此 flag 指示重新执行系统调用/库函数</span><span class="hljs-comment">//     SA_ONSTACK 用另一个方法调用栈来执行处理器函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sa_sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">siginfo_t</span> *info, <span class="hljs-type">void</span> *ucontext)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">siginfo_t</span> </span>&#123;    <span class="hljs-type">int</span>      si_signo;     <span class="hljs-comment">/* Signal number */</span>    <span class="hljs-type">int</span>      si_errno;     <span class="hljs-comment">/* An errno value */</span>    <span class="hljs-type">int</span>      si_code;      <span class="hljs-comment">/* Signal code */</span>    <span class="hljs-type">int</span>      si_trapno;    <span class="hljs-comment">/* Trap number that caused</span><span class="hljs-comment">                              hardware-generated signal</span><span class="hljs-comment">                              (unused on most architectures) */</span>    <span class="hljs-type">pid_t</span>    si_pid;       <span class="hljs-comment">/* Sending process ID */</span>    <span class="hljs-type">uid_t</span>    si_uid;       <span class="hljs-comment">/* Real user ID of sending process */</span>    <span class="hljs-type">int</span>      si_status;    <span class="hljs-comment">/* Exit value or signal */</span>    <span class="hljs-type">clock_t</span>  si_utime;     <span class="hljs-comment">/* User time consumed */</span>    <span class="hljs-type">clock_t</span>  si_stime;     <span class="hljs-comment">/* System time consumed */</span>    <span class="hljs-type">sigval_t</span> si_value;     <span class="hljs-comment">/* Signal value */</span>    <span class="hljs-type">int</span>      si_int;       <span class="hljs-comment">/* POSIX.1b signal */</span>    <span class="hljs-type">void</span>    *si_ptr;       <span class="hljs-comment">/* POSIX.1b signal */</span>    <span class="hljs-type">int</span>      si_overrun;   <span class="hljs-comment">/* Timer overrun count;</span><span class="hljs-comment">                              POSIX.1b timers */</span>    <span class="hljs-type">int</span>      si_timerid;   <span class="hljs-comment">/* Timer ID; POSIX.1b timers */</span>    <span class="hljs-type">void</span>    *si_addr;      <span class="hljs-comment">/* Memory location which caused fault */</span>    <span class="hljs-type">long</span>     si_band;      <span class="hljs-comment">/* Band event (was int in</span><span class="hljs-comment">                              glibc 2.3.2 and earlier) */</span>    <span class="hljs-type">int</span>      si_fd;        <span class="hljs-comment">/* File descriptor */</span>    <span class="hljs-type">short</span>    si_addr_lsb;  <span class="hljs-comment">/* Least significant bit of address</span><span class="hljs-comment">                              (since Linux 2.6.32) */</span>    <span class="hljs-type">void</span>    *si_lower;     <span class="hljs-comment">/* Lower bound when address violation</span><span class="hljs-comment">                              occurred (since Linux 3.19) */</span>    <span class="hljs-type">void</span>    *si_upper;     <span class="hljs-comment">/* Upper bound when address violation</span><span class="hljs-comment">                              occurred (since Linux 3.19) */</span>    <span class="hljs-type">int</span>      si_pkey;      <span class="hljs-comment">/* Protection key on PTE that caused</span><span class="hljs-comment">                              fault (since Linux 4.6) */</span>    <span class="hljs-type">void</span>    *si_call_addr; <span class="hljs-comment">/* Address of system call instruction</span><span class="hljs-comment">                              (since Linux 3.5) */</span>    <span class="hljs-type">int</span>      si_syscall;   <span class="hljs-comment">/* Number of attempted system call</span><span class="hljs-comment">                              (since Linux 3.5) */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> si_arch;  <span class="hljs-comment">/* Architecture of attempted system call</span><span class="hljs-comment">                              (since Linux 3.5) */</span>&#125;</code></pre></div><h3 id="sigaltstack"><a href="#sigaltstack" class="headerlink" title="sigaltstack"></a>sigaltstack</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/** </span><span class="hljs-comment"> * 为当前进程设置一个新的（获取上一个）信号处理器调用栈，其实就是为信号处理器预先分配一块内存，作为其调用栈</span><span class="hljs-comment"> * The most common usage of an alternate signal stack is to handle the SIGSEGV signal </span><span class="hljs-comment"> * that is generated if the space available for the normal process stack is exhausted: </span><span class="hljs-comment"> * in this case, a signal handler for SIGSEGV cannot be invoked on the process stack; </span><span class="hljs-comment"> * if we wish to handle it, we must use an alternate signal stack</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaltstack</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">stack_t</span> *ss, <span class="hljs-type">stack_t</span> *old_ss)</span></span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-type">void</span>  *ss_sp;     <span class="hljs-comment">/* Base address of stack */</span>    <span class="hljs-type">int</span>    ss_flags;  <span class="hljs-comment">/* Flags */</span>    <span class="hljs-type">size_t</span> ss_size;   <span class="hljs-comment">/* Number of bytes in stack */</span>&#125; <span class="hljs-type">stack_t</span>;</code></pre></div><h3 id="xc-crash-signal-handler"><a href="#xc-crash-signal-handler" class="headerlink" title="xc_crash_signal_handler"></a>xc_crash_signal_handler</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// XCrash.init</span><span class="hljs-comment">// NativeHandler.initialize</span><span class="hljs-comment">// NativeHandler.nativeInit</span><span class="hljs-comment">// xc_jni_init</span><span class="hljs-comment">// xc_crash_init</span><span class="hljs-comment">// 需要捕获的信号</span><span class="hljs-type">static</span> <span class="hljs-type">xcc_signal_crash_info_t</span> xcc_signal_crash_info[] =&#123;    &#123;.signum = SIGABRT&#125;,    &#123;.signum = SIGBUS&#125;,    &#123;.signum = SIGFPE&#125;,    &#123;.signum = SIGILL&#125;,    &#123;.signum = SIGSEGV&#125;,    &#123;.signum = SIGTRAP&#125;,    &#123;.signum = SIGSYS&#125;,    &#123;.signum = SIGSTKFLT&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xcc_signal_crash_register</span><span class="hljs-params">(<span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 预先为处理器分配一块内存</span>    <span class="hljs-type">stack_t</span> ss;    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (ss.ss_sp = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, XCC_SIGNAL_CRASH_STACK_SIZE))) <span class="hljs-keyword">return</span> XCC_ERRNO_NOMEM;    ss.ss_size  = XCC_SIGNAL_CRASH_STACK_SIZE;    ss.ss_flags = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">sigaltstack</span>(&amp;ss, <span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;    <span class="hljs-built_in">memset</span>(&amp;act, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(act));    <span class="hljs-built_in">sigfillset</span>(&amp;act.sa_mask);    act.sa_sigaction = handler;    act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;        <span class="hljs-comment">// 为上述信号注册处理器</span>    <span class="hljs-type">size_t</span> i;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(xcc_signal_crash_info) / <span class="hljs-built_in">sizeof</span>(xcc_signal_crash_info[<span class="hljs-number">0</span>]); i++)        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">sigaction</span>(xcc_signal_crash_info[i].signum, &amp;act, &amp;(xcc_signal_crash_info[i].oldact)))            <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 信号处理器，跟上面的 JavaCrashHandler 一样，主要是收集各种信息，写入 tombstone 文件</span><span class="hljs-comment">// 比较复杂，下一章节进行分析</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">xc_crash_signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">siginfo_t</span> *si, <span class="hljs-type">void</span> *uc)</span></span></code></pre></div><h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ol><li>信号处理器（<code>xc_crash_signal_handler</code>，在 APP 进程）收集相关的信息到 <code>xc_crash_spot</code></li><li><code>fork</code> 出子进程 dumper，子进程继承了父进程的内存布局，也就捕获到了 APP 进程 crash 时刻的内存布局</li><li>dumper 进程的入口点是 <code>xc_crash_exec_dumper</code>，signal handler 线程通过 <code>waitpid</code> 阻塞直到 dumper 进程完成工作</li><li>dumper 将 signal 和调用堆栈等信息写入管道，然后加载程序 <code>libxcrash_dumper.so</code> 替换当前的内存空间（旧的内存空间的所有信息将被清空）</li><li><code>xcd_core.c</code> 里的 main 函数从管道里读取 <code>xc_crash_spot</code> 并写入 tombstone 日志文件，退出</li><li>signal handler 线程从阻塞中恢复，退出 APP 进程</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// APP 进程，signal hander 线程，dump 开始的地方</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">xc_crash_signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">siginfo_t</span> *si, <span class="hljs-type">void</span> *uc)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// set crash spot info</span>    xc_crash_spot.crash_time = xc_crash_time;    xc_crash_spot.crash_tid = xc_crash_tid;    <span class="hljs-built_in">memcpy</span>(&amp;(xc_crash_spot.siginfo), si, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">siginfo_t</span>));    <span class="hljs-built_in">memcpy</span>(&amp;(xc_crash_spot.ucontext), uc, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">ucontext_t</span>));    xc_crash_spot.log_pathname_len = <span class="hljs-built_in">strlen</span>(xc_crash_log_pathname);    <span class="hljs-comment">// spawn crash dumper process</span>    <span class="hljs-type">pid_t</span> dumper_pid = <span class="hljs-built_in">xc_crash_fork</span>(xc_crash_exec_dumper);    <span class="hljs-comment">// wait the crash dumper process terminated</span>    <span class="hljs-type">int</span> wait_r = <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">waitpid</span>(dumper_pid, &amp;status, __WALL));    <span class="hljs-comment">// exit</span>&#125;<span class="hljs-comment">// dumper 进程的入口</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">xc_crash_exec_dumper</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 创建一个管道，第一个用来读，第二个用来写</span>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">pipe2</span>(pipefd, O_CLOEXEC))    <span class="hljs-comment">// 将 xc_crash_spot 写入管道</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> iovs[<span class="hljs-number">12</span>] = &#123;        &#123;.iov_base = &amp;xc_crash_spot,                      .iov_len = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">xcc_spot_t</span>)&#125;,        &#123;.iov_base = xc_crash_log_pathname,               .iov_len = xc_crash_spot.log_pathname_len&#125;,        &#123;.iov_base = xc_common_os_version,                .iov_len = xc_crash_spot.os_version_len&#125;,        &#123;.iov_base = xc_common_kernel_version,            .iov_len = xc_crash_spot.kernel_version_len&#125;,        &#123;.iov_base = xc_common_abi_list,                  .iov_len = xc_crash_spot.abi_list_len&#125;,        &#123;.iov_base = xc_common_manufacturer,              .iov_len = xc_crash_spot.manufacturer_len&#125;,        &#123;.iov_base = xc_common_brand,                     .iov_len = xc_crash_spot.brand_len&#125;,        &#123;.iov_base = xc_common_model,                     .iov_len = xc_crash_spot.model_len&#125;,        &#123;.iov_base = xc_common_build_fingerprint,         .iov_len = xc_crash_spot.build_fingerprint_len&#125;,        &#123;.iov_base = xc_common_app_id,                    .iov_len = xc_crash_spot.app_id_len&#125;,        &#123;.iov_base = xc_common_app_version,               .iov_len = xc_crash_spot.app_version_len&#125;,        &#123;.iov_base = xc_crash_dump_all_threads_whitelist, .iov_len = xc_crash_spot.dump_all_threads_whitelist_len&#125;    &#125;;    <span class="hljs-type">int</span> iovs_cnt = (<span class="hljs-number">0</span> == xc_crash_spot.dump_all_threads_whitelist_len ? <span class="hljs-number">11</span> : <span class="hljs-number">12</span>);    <span class="hljs-type">ssize_t</span> ret = <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">writev</span>(pipefd[<span class="hljs-number">1</span>], iovs, iovs_cnt));    <span class="hljs-comment">// 将 stdin (fd 0) 指向管道的读端口</span>    <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">dup2</span>(pipefd[<span class="hljs-number">0</span>], STDIN_FILENO));        <span class="hljs-built_in">syscall</span>(SYS_close, pipefd[<span class="hljs-number">0</span>]);    <span class="hljs-built_in">syscall</span>(SYS_close, pipefd[<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 加载程序 libxcrash_dumper.so 替换当前的内存空间</span>    <span class="hljs-built_in">execl</span>(xc_crash_dumper_pathname, XCC_UTIL_XCRASH_DUMPER_FILENAME, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> + errno;&#125;<span class="hljs-comment">// libxcrash_dumper.so 的入口点，在 xcd_core.c</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 从 stdin 读取 xc_crash_spot</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_core_read_args</span>()) <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">//open log file</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &gt; (xcd_core_log_fd = <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">open</span>(xcd_core_log_pathname, O_WRONLY | O_CLOEXEC)))) <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">//create process object</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_process_create</span>(&amp;xcd_core_proc,                               xcd_core_spot.crash_pid,                               xcd_core_spot.crash_tid,                               &amp;(xcd_core_spot.siginfo),                               &amp;(xcd_core_spot.ucontext))) <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">//suspend all threads in the process</span>    <span class="hljs-built_in">xcd_process_suspend_threads</span>(xcd_core_proc);    <span class="hljs-comment">//load process info</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_process_load_info</span>(xcd_core_proc)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">//record system info</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_sys_record</span>(xcd_core_log_fd,                           xcd_core_spot.time_zone,                           xcd_core_spot.start_time,                           xcd_core_spot.crash_time,                           xcd_core_app_id,                           xcd_core_app_version,                           xcd_core_spot.api_level,                           xcd_core_os_version,                           xcd_core_kernel_version,                           xcd_core_abi_list,                           xcd_core_manufacturer,                           xcd_core_brand,                           xcd_core_model,                           xcd_core_build_fingerprint)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">//record process info</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcd_process_record</span>(xcd_core_proc,                               xcd_core_log_fd,                               xcd_core_spot.logcat_system_lines,                               xcd_core_spot.logcat_events_lines,                               xcd_core_spot.logcat_main_lines,                               xcd_core_spot.dump_elf_hash,                               xcd_core_spot.dump_map,                               xcd_core_spot.dump_fds,                               xcd_core_spot.dump_network_info,                               xcd_core_spot.dump_all_threads,                               xcd_core_spot.dump_all_threads_count_max,                               xcd_core_dump_all_threads_whitelist,                               xcd_core_spot.api_level)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">6</span>);    <span class="hljs-comment">//resume all threads in the process</span>    <span class="hljs-built_in">xcd_process_resume_threads</span>(xcd_core_proc);    <span class="hljs-comment">// exit</span>&#125;</code></pre></div><h3 id="Signal-Info"><a href="#Signal-Info" class="headerlink" title="Signal Info"></a>Signal Info</h3><p>打印导致 Native Crash 的 Signal 的基本信息，可以从 <code>sigaction</code> 的信号处理器（<code>xc_crash_signal_handler</code>）的参数列表里拿到（<code>siginfo_t</code>）</p><ul><li>信号码（<code>siginfo_t.si_signo</code>），比如：SIGKILL(9)、SIGSEGV(11)，更多参考 <code>man signal.7</code></li><li>信号错误码（<code>siginfo_t.si_code</code>），描述此信号的更详细的信息，比如对于 SIGSEGV 有以下错误码：<ul><li>SEGV_MAPERR Address not mapped to object.</li><li>SEGV_ACCERR Invalid permissions for mapped object.</li><li>SEGV_BNDERR (since Linux 3.19) Failed address bound checks.</li><li>SEGV_PKUERR (since Linux 4.6) Access was denied by memory protection keys.  See pkeys(7).  The protection key which applied to this access is available via si_pkey.</li></ul></li><li>SIGSEGV 会将错误地址写入 <code>siginfo_t.si_addr</code></li><li>有关 <code>siginfo_t</code> 的更详细信息请参考 <code>man sigaction.2</code></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">xcd_process_record_signal_info</span><span class="hljs-params">(<span class="hljs-type">xcd_process_t</span> *self, <span class="hljs-type">int</span> log_fd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//fault addr</span>    <span class="hljs-type">char</span> addr_desc[<span class="hljs-number">64</span>];    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">xcc_util_signal_has_si_addr</span>(self-&gt;si))    &#123;        <span class="hljs-type">void</span> *addr = self-&gt;si-&gt;si_addr;        <span class="hljs-keyword">if</span>(self-&gt;si-&gt;si_signo == SIGILL)        &#123;            <span class="hljs-type">uint32_t</span> instruction = <span class="hljs-number">0</span>;            <span class="hljs-built_in">xcd_util_ptrace_read</span>(self-&gt;pid, (<span class="hljs-type">uintptr_t</span>)addr, &amp;instruction, <span class="hljs-built_in">sizeof</span>(instruction));            <span class="hljs-built_in">snprintf</span>(addr_desc, <span class="hljs-built_in">sizeof</span>(addr_desc), <span class="hljs-string">&quot;%p (*pc=%#08x)&quot;</span>, addr, instruction);        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">snprintf</span>(addr_desc, <span class="hljs-built_in">sizeof</span>(addr_desc), <span class="hljs-string">&quot;%p&quot;</span>, addr);        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">snprintf</span>(addr_desc, <span class="hljs-built_in">sizeof</span>(addr_desc), <span class="hljs-string">&quot;--------&quot;</span>);    &#125;    <span class="hljs-comment">//from</span>    <span class="hljs-type">char</span> sender_desc[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">xcc_util_signal_has_sender</span>(self-&gt;si, self-&gt;pid))    &#123;        <span class="hljs-built_in">snprintf</span>(sender_desc, <span class="hljs-built_in">sizeof</span>(sender_desc), <span class="hljs-string">&quot; from pid %d, uid %d&quot;</span>, self-&gt;si-&gt;si_pid, self-&gt;si-&gt;si_uid);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">xcc_util_write_format</span>(log_fd, <span class="hljs-string">&quot;signal %d (%s), code %d (%s%s), fault addr %s\n&quot;</span>,                                 self-&gt;si-&gt;si_signo, <span class="hljs-built_in">xcc_util_get_signame</span>(self-&gt;si),                                 self-&gt;si-&gt;si_code, <span class="hljs-built_in">xcc_util_get_sigcodename</span>(self-&gt;si),                                 sender_desc, addr_desc);&#125;</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs text">signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0</code></pre></div><h3 id="Registers-Info"><a href="#Registers-Info" class="headerlink" title="Registers Info"></a>Registers Info</h3><p>打印寄存器（<code>Register</code>）的值，下面是 ARM64 的例子，它有 30 个通用寄存器</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>x0</td><td>一般表示返回值</td></tr><tr><td>x1 ~ x7</td><td>般是函数的参数，大于 8 个的会通过堆传参</td></tr><tr><td>lr</td><td>链接寄存器，存放着函数的返回地址</td></tr><tr><td>sp</td><td>堆栈顶寄存器，用于指向每个函数调用栈的栈顶</td></tr><tr><td>pc</td><td>表示当前执行的指令的地址</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs text">x0  0000000000000003  x1  0000000000000000  x2  000000751128fd60  x3  0000007511290020x4  000000751128fd60  x5  00000075a26c1708  x6  000000751128fd50  x7  00000075200a59dcx8  0000000000000000  x9  79fc7e30c0ff4d9e  x10 00000000000003e8  x11 0000000000000000x12 0000000000004100  x13 0000000000000001  x14 0000000000080100  x15 0000000000000000x16 00000074b9be4d20  x17 00000074b9bcc86c  x18 00000075a57fa000  x19 00000075a4f52000x20 0000000000000000  x21 00000075a4f52000  x22 0000007fe0ef23a0  x23 00000074bb1b62fex24 0000000000000004  x25 00000075a5107020  x26 00000075a4f520b0  x27 0000000000000001x28 0000007fe0ef2130  x29 0000007fe0ef2090sp  0000007fe0ef2070  lr  00000074b9bcc8cc  pc  00000074b9bcc884</code></pre></div><p>通过 <code>ptrace</code>，一个线程（<code>tracer</code>）可以观察并控制另一线程（<code>tracee</code>）的执行、读取/修改它的内存和寄存器，比如单步调试（debugger）；tracer 和 tracee 都是线程，而不是进程（虽然 ptrace 的参数里写的是 pid）；它的一般用法是这样的：</p><ul><li><code>PTRACE_ATTACH</code>：使当前线程成为 tracer，pid 指定的线程成为 tracee</li><li><code>waitpid</code>：PTRACE_ATTACH 发送 SIGSTOP 给 tracee 但它不一定立刻 stop，所以需要 tracer 等待 tracee</li><li><code>PTRACE_PEEKDATA</code>（读内存）、 <code>PTRACE_POKEDATA</code>（写内存）、<code>PTRACE_GETREGS</code>（读寄存器）、<code>PTRACE_SETREGS</code>（写寄存器）…</li><li><code>PTRACE_DETACH</code></li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">ptrace</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> __ptrace_request request, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">void</span> *addr, <span class="hljs-type">void</span> *data)</span></span>;<span class="hljs-comment">// 通过 ptrace 获取寄存器的值并保存到 xcd_thread_t.regs</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xcd_thread_load_regs</span><span class="hljs-params">(<span class="hljs-type">xcd_thread_t</span> *self)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">uintptr_t</span> regs[<span class="hljs-number">64</span>]; <span class="hljs-comment">//big enough for all architectures</span>    <span class="hljs-type">size_t</span>    regs_len;    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">ptrace</span>(PTRACE_GETREGS, self-&gt;tid, <span class="hljs-literal">NULL</span>, &amp;regs))    &#123;        <span class="hljs-built_in">XCD_LOG_ERROR</span>(<span class="hljs-string">&quot;THREAD: ptrace GETREGS failed, errno=%d&quot;</span>, errno);        self-&gt;status = XCD_THREAD_STATUS_REGS;        <span class="hljs-keyword">return</span>;    &#125;    regs_len = XCD_REGS_USER_NUM;    <span class="hljs-built_in">xcd_regs_load_from_ptregs</span>(&amp;(self-&gt;regs), regs, regs_len);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">xcd_regs_load_from_ptregs</span><span class="hljs-params">(<span class="hljs-type">xcd_regs_t</span> *self, <span class="hljs-type">uintptr_t</span> *regs, <span class="hljs-type">size_t</span> regs_len)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(regs_len &gt; XCD_REGS_USER_NUM) regs_len = XCD_REGS_USER_NUM;    <span class="hljs-built_in">memcpy</span>(&amp;(self-&gt;r), regs, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uintptr_t</span>) * regs_len);&#125;<span class="hljs-comment">// 打印寄存器的值</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xcd_regs_record</span><span class="hljs-params">(<span class="hljs-type">xcd_regs_t</span> *self, <span class="hljs-type">int</span> log_fd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">xcc_util_write_format</span>(log_fd,                                 <span class="hljs-string">&quot;    x0  %016lx  x1  %016lx  x2  %016lx  x3  %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x4  %016lx  x5  %016lx  x6  %016lx  x7  %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x8  %016lx  x9  %016lx  x10 %016lx  x11 %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x12 %016lx  x13 %016lx  x14 %016lx  x15 %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x16 %016lx  x17 %016lx  x18 %016lx  x19 %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x20 %016lx  x21 %016lx  x22 %016lx  x23 %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x24 %016lx  x25 %016lx  x26 %016lx  x27 %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    x28 %016lx  x29 %016lx\n&quot;</span>                                 <span class="hljs-string">&quot;    sp  %016lx  lr  %016lx  pc  %016lx\n\n&quot;</span>,                                 self-&gt;r[XCD_REGS_X0],  self-&gt;r[XCD_REGS_X1],  self-&gt;r[XCD_REGS_X2],  self-&gt;r[XCD_REGS_X3],                                 self-&gt;r[XCD_REGS_X4],  self-&gt;r[XCD_REGS_X5],  self-&gt;r[XCD_REGS_X6],  self-&gt;r[XCD_REGS_X7],                                 self-&gt;r[XCD_REGS_X8],  self-&gt;r[XCD_REGS_X9],  self-&gt;r[XCD_REGS_X10], self-&gt;r[XCD_REGS_X11],                                 self-&gt;r[XCD_REGS_X12], self-&gt;r[XCD_REGS_X13], self-&gt;r[XCD_REGS_X14], self-&gt;r[XCD_REGS_X15],                                 self-&gt;r[XCD_REGS_X16], self-&gt;r[XCD_REGS_X17], self-&gt;r[XCD_REGS_X18], self-&gt;r[XCD_REGS_X19],                                 self-&gt;r[XCD_REGS_X20], self-&gt;r[XCD_REGS_X21], self-&gt;r[XCD_REGS_X22], self-&gt;r[XCD_REGS_X23],                                 self-&gt;r[XCD_REGS_X24], self-&gt;r[XCD_REGS_X25], self-&gt;r[XCD_REGS_X26], self-&gt;r[XCD_REGS_X27],                                 self-&gt;r[XCD_REGS_X28], self-&gt;r[XCD_REGS_X29],                                 self-&gt;r[XCD_REGS_SP],  self-&gt;r[XCD_REGS_LR],  self-&gt;r[XCD_REGS_PC]);&#125;</code></pre></div><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><h4 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/pid/maps"></a>/proc/pid/maps</h4><p><code>/proc/pid/maps</code> 包含了进程所有的内存映射（<code>mmap</code>）信息，后续的步骤需要用它来查找 <strong>函数名</strong> 及其所在的 <strong>文件路径</strong>，它的内容大概是这样的（参考 <code>man mmap.2</code> &amp; <code>man proc.5</code>）：</p><table><thead><tr><th>列</th><th>描述</th></tr></thead><tbody><tr><td>address</td><td>内存映射所在的进程的虚拟地址空间（开始地址 - 结束地址）</td></tr><tr><td>perms</td><td>这块内存的读写权限：r = read，w = write，x = execute，s = shared，p = private (copy on write)</td></tr><tr><td>offset</td><td>映射至内存的文件（或者其他东西）的起始偏移</td></tr><tr><td>dev</td><td>文件所在的设备（major:minor）</td></tr><tr><td>inode</td><td>文件的 inode</td></tr><tr><td>path</td><td>文件的路径</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs text">address                perms  offset    dev     inode     pathname12c00000-32c00000      rw-p   00000000  00:00   0         [anon:dalvik-main space (region space)]70fb9000-71248000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot.art]71248000-712a3000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-core-libart.art]712a3000-7136f000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-core-icu4j.art]7136f000-713a6000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-okhttp.art]713a6000-713ea000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-bouncycastle.art]713ea000-713f9000      rw-p   00000000  00:00   0         [anon:dalvik-/apex/com.android.art/javalib/boot-apache-xml.art]713f9000-71479000      r--p   00000000  fc:00   150       /apex/com.android.art/javalib/arm64/boot.oat...                                                       7e1f72d000-7e1f778000  r--s   00000000  fc:00   2605      /system/fonts/Roboto-Medium.ttf7e1f778000-7e1f779000  r--p   00000000  fc:00   6422      /system/system_ext/lib64/libqti-at.so7e1f779000-7e1f77a000  r-xp   00001000  fc:00   6422      /system/system_ext/lib64/libqti-at.so7e1f77a000-7e1f77b000  r--p   00002000  fc:00   6422      /system/system_ext/lib64/libqti-at.so7e1f7a0000-7e1f7ab000  r--p   00000000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so7e1f7ab000-7e1f7b5000  r-xp   0000b000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so7e1f7b5000-7e1f7b7000  r--p   00015000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so7e1f7b7000-7e1f7b8000  rw-p   00016000  fc:00   6522      /system/system_ext/lib64/vendor.qti.hardware.perf@2.0.so7e1f86b000-7e1fb0e000  r--p   00000000  103:0f  5128711   /data/data/xcrash.sample/code_cache/.overlay/base.apk/classes.dex7e1fb0e000-7e1fbd4000  r-xp   00000000  103:0f  5096166   /data/data/xcrash.sample/code_cache/startup_agents/e4ee8c59-agent.so7e1fbd4000-7e1fbe3000  ---p   00000000  00:00   0         7e1fbe3000-7e1fbec000  rw-p   000c5000  103:0f  5096166   /data/data/xcrash.sample/code_cache/startup_agents/e4ee8c59-agent.so...                                                       7e24946000-7e24987000  r--s   0001d000  103:0f  180482    /data/app/~~jln4G3nGOa7-pv4aJFN6jg==/xcrash.sample-icj_DCtDvU5ZX6MZSDcn4Q==/base.apk...                                                        7e347f9000-7e34800000  r--s   001be000  103:0f  180482    /data/app/~~jln4G3nGOa7-pv4aJFN6jg==/xcrash.sample-icj_DCtDvU5ZX6MZSDcn4Q==/base.apk...</code></pre></div><h4 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h4><p><img src="../../../../image/2021-06-22-xcrash/elf.png" alt="ELF Format"></p><p>Linux 下的可执行文件（<code>executable</code>）和共享库文件（<code>so - Shared Object</code>）都是 ELF 格式（<code>Executable and Linking Format</code>）</p><p><code>ELF Header</code> 里的 <code>e_type</code> 指明这是一个什么类型的文件：</p><table><thead><tr><th>e_type</th><th>desc</th></tr></thead><tbody><tr><td>ET_NONE</td><td>An unknown type</td></tr><tr><td>ET_REL</td><td>A relocatable file</td></tr><tr><td>ET_EXEC</td><td>An executable file</td></tr><tr><td>ET_DYN</td><td>A shared object</td></tr><tr><td>ET_CORE</td><td>A core file</td></tr></tbody></table><p>ELF 里有很多 <code>Section</code>，每个 Section 都是一段连续的地址保存了相同类型的数据，具体到哪个 Section 在哪里有多大定义在 <code>Section Header</code> 里，它的一些重要成员属性有：</p><table><thead><tr><th>Fields</th><th>Desc</th></tr></thead><tbody><tr><td>sh_name</td><td>name of the section. Its value is an index into the string section</td></tr><tr><td>sh_type</td><td>SHT_SYMTAB（符号表）、SHT_STRTAB（字符串表）等等</td></tr><tr><td>sh_offset</td><td>Section 在文件里的位置</td></tr><tr><td>sh_size</td><td>Section 的大小</td></tr></tbody></table><p>所有的 Section Header 组成一个数组 <code>Section Header Table</code>，它的位置和大小则是在 ELF Header 里定义的：</p><table><thead><tr><th>Fields</th><th>desc</th></tr></thead><tbody><tr><td>e_shoff</td><td>SHT 所在的位置</td></tr><tr><td>e_shsize</td><td>SHT 的大小</td></tr><tr><td>e_shentsize</td><td>每个 Section Header 的大小</td></tr><tr><td>e_shnum</td><td>Section Header 的数量</td></tr><tr><td>e_shstrndx</td><td>Name Section 在 SHT 的索引（所谓的 Name Section 其实就是专门保存字符串的 Section，类似于 dex 里的字符串池）</td></tr></tbody></table><p><code>Symbol Table</code> 是一个很重要的 Section，它的结构如下：</p><table><thead><tr><th>Fields</th><th>Desc</th></tr></thead><tbody><tr><td>st_name</td><td>symbol name (index of string section)</td></tr><tr><td>st_value</td><td>symbol value</td></tr><tr><td>st_size</td><td>This member holds zero if the symbol has no size or an unknown size</td></tr><tr><td>st_info</td><td>type and binding attributes <br> STT_FUNC (a function or other executable code) <br> STT_OBJECT (data object) <br> STB_LOCAL (Local symbols are not visible outside the object file) <br> STB_GLOBAL (Global symbols are visible to all object files being combined)…</td></tr><tr><td>st_other</td><td>symbol visibility <br> STV_DEFAULT (Global and weak symbols are available to other modules; references in the local module can be interposed by definitions in other modules) <br> STV_HIDDEN (Symbol is unavailable to other modules) <br> STV_PROTECTED (Symbol is available to other modules)</td></tr></tbody></table><p>可以用 <code>readelf</code> 命令查看 ELF 文件的结构，以 <code>/apex/com.android.art/lib64/libart.so</code> 为例，<code>readelf -S -W libart.so</code> 输出 Section Header Table</p><div class="code-wrapper"><pre><code class="hljs text">There are 28 section headers, starting at offset 0x7d8af8:Section Headers:  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0  [ 1] .note.android.ident NOTE            0000000000000270 000270 000018 00   A  0   0  4  [ 2] .note.gnu.build-id NOTE            0000000000000288 000288 000020 00   A  0   0  4  [ 3] .dynsym           DYNSYM          00000000000002a8 0002a8 021d50 18   A  7   1  8  [ 4] .gnu.version      VERSYM          0000000000021ff8 021ff8 002d1c 02   A  3   0  2  [ 5] .gnu.version_r    VERNEED         0000000000024d14 024d14 000100 00   A  7   7  4  [ 6] .gnu.hash         GNU_HASH        0000000000024e18 024e18 0085d4 00   A  3   0  8  [ 7] .dynstr           STRTAB          000000000002d3ec 02d3ec 05c8eb 00   A  0   0  1  [ 8] .rela.dyn         LOOS+0x2        0000000000089cd8 089cd8 0005f9 01   A  3   0  8  [ 9] .relr.dyn         LOOS+0xfffff00  000000000008a2d8 08a2d8 000490 08   A  0   0  8  [10] .rela.plt         RELA            000000000008a768 08a768 002fb8 18   A  3  21  8  [11] .rodata           PROGBITS        000000000008d720 08d720 03cec6 00 AMS  0   0 16  [12] .eh_frame_hdr     PROGBITS        00000000000ca5e8 0ca5e8 01083c 00   A  0   0  4  [13] .eh_frame         PROGBITS        00000000000dae28 0dae28 04de74 00   A  0   0  8  [14] .text             PROGBITS        0000000000129000 129000 51c160 00  AX  0   0 512  [15] .plt              PROGBITS        0000000000645160 645160 001ff0 00  AX  0   0 16  [16] .data.rel.ro      PROGBITS        0000000000648000 648000 00e808 00  WA  0   0  8  [17] .fini_array       FINI_ARRAY      0000000000656808 656808 000010 00  WA  0   0  8  [18] .init_array       INIT_ARRAY      0000000000656818 656818 000060 00  WA  0   0  8  [19] .dynamic          DYNAMIC         0000000000656878 656878 0002b0 10  WA  7   0  8  [20] .got              PROGBITS        0000000000656b28 656b28 000978 00  WA  0   0  8  [21] .got.plt          PROGBITS        00000000006574a0 6574a0 001000 00  WA  0   0  8  [22] .data             PROGBITS        00000000006594a0 6584a0 002879 00  WA  0   0  8  [23] .bss              NOBITS          000000000065bd20 65ad19 002c90 00  WA  0   0  8  [24] .comment          PROGBITS        0000000000000000 65ad19 00016b 01  MS  0   0  1  [25] .symtab           SYMTAB          0000000000000000 65ae88 08d678 18     27 18360  8  [26] .shstrtab         STRTAB          0000000000000000 6e8500 00010c 00      0   0  1  [27] .strtab           STRTAB          0000000000000000 6e860c 0f04e7 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  p (processor specific)</code></pre></div><p><code>readelf -p .dynstr libart.so</code> 输出字符串表：</p><div class="code-wrapper"><pre><code class="hljs text">String dump of section &#x27;.dynstr&#x27;:  [     1]  __cxa_atexit  [     e]  __cxa_finalize  [    1d]  _ZN3art14AotClassLinkerC2EPNS_11InternTableE  [    4a]  _ZN3art11ClassLinkerC2EPNS_11InternTableEb  [    75]  _ZN3art14AotClassLinkerD2Ev  [    91]  _ZN3art11ClassLinkerD2Ev  [    aa]  _ZN3art14AotClassLinkerD0Ev  [    c6]  _ZdlPv  [    cd]  _ZN3art14AotClassLinker13CanAllocClassEv  [    f6]  _ZNK3art7Runtime19IsActiveTransactionEv  [   11e]  _ZN3art7Runtime34AbortTransactionAndThrowAbortErrorEPNS_6ThreadERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE  [   1a1]  _ZN3art14AotClassLinker15InitializeClassEPNS_6ThreadENS_6HandleINS_6mirror5ClassEEEbb  [   1f7]  _ZNK3art7Runtime29IsActiveStrictTransactionModeEv  [   229]  _ZN3art11ClassLinker15InitializeClassEPNS_6ThreadENS_6HandleINS_6mirror5ClassEEEbb  [   27c]  _ZNK3art2gc4Heap24ObjectIsInBootImageSpaceENS_6ObjPtrINS_6mirror6ObjectEEE  [   2c7]  _ZN3art6mirror6Object12PrettyTypeOfEv  [   2ed]  _ZN3art6mirror5Class16IsThrowableClassEv  [   316]  _ZN7android4base10LogMessageC1EPKcjNS0_11LogSeverityES3_i</code></pre></div><p><code>readelf -s libart.so</code> 输出符号表：</p><div class="code-wrapper"><pre><code class="hljs text">Symbol table &#x27;.dynsym&#x27; contains 5774 entries:   Num:    Value          Size Type    Bind   Vis      Ndx Name     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND      1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZdlPv     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _ZN7android4base10LogMess   ...   809: 0000000000132340   620 FUNC    LOCAL  HIDDEN    14 art_quick_invoke_stub   810: 00000000001325b0   640 FUNC    LOCAL  HIDDEN    14 art_quick_invoke_static_s   811: 000000000013ba10   292 FUNC    LOCAL  HIDDEN    14 art_quick_proxy_invoke_ha   812: 000000000013c100   256 FUNC    LOCAL  HIDDEN    14 art_quick_instrumentation   813: 000000000013be40   336 FUNC    LOCAL  HIDDEN    14 art_quick_generic_jni_tra   814: 000000000013bfa0   248 FUNC    LOCAL  HIDDEN    14 art_quick_to_interpreter_   815: 000000000013c210   480 FUNC    LOCAL  HIDDEN    14 art_quick_instrumentation   816: 000000000013bd00   304 FUNC    LOCAL  HIDDEN    14 art_quick_resolution_tram   817: 000000000013bb40   432 FUNC    LOCAL  HIDDEN    14 art_quick_imt_conflict_tr   818: 000000000013c0a0    80 FUNC    LOCAL  HIDDEN    14 art_invoke_obsolete_metho   819: 000000000013c400   164 FUNC    LOCAL  HIDDEN    14 art_quick_deoptimize   ...</code></pre></div><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>通过 <code>ptrace</code> 可以拿到 PC 寄存器的值，它指向正在执行的代码的地址；拿 pc 去 <code>/proc/pid/maps</code> 里找，看 pc 落在哪块 <code>mmap</code> 上，从而得知这段代码在哪个 so 文件里；so 文件是 ELF 结构，解析出它里面的符号表及其偏移，pc - mmap.start 就是这段代码在这块 mmap 上的偏移，再加上 mmap.offset 内存映射的偏移就是这段代码在 so 文件里的偏移，从而得知这段代码在哪个符号/函数里（函数名）</p><blockquote><p>但是怎么从 pc 回溯整个函数调用栈我还没有想明白</p></blockquote><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>打印调用栈，别看代码这么长，其实关键就是这么几个：</p><table><thead><tr><th>Fields</th><th>Desc</th></tr></thead><tbody><tr><td>xcd_frame.rel_pc</td><td>函数在它所在的内存映射的偏移</td></tr><tr><td>xcd_frame.map.name</td><td>函数所在 so 文件路径</td></tr><tr><td>xcd_frame.func_name</td><td>函数名</td></tr><tr><td>xcd_frame.func_offset</td><td>函数与 pc 的偏移</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xcd_thread_record_backtrace</span><span class="hljs-params">(<span class="hljs-type">xcd_thread_t</span> *self, <span class="hljs-type">int</span> log_fd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(XCD_THREAD_STATUS_OK != self-&gt;status) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//ignore</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">xcd_frames_record_backtrace</span>(self-&gt;frames, log_fd);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xcd_frames_record_backtrace</span><span class="hljs-params">(<span class="hljs-type">xcd_frames_t</span> *self, <span class="hljs-type">int</span> log_fd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">xcd_frame_t</span> *frame;    <span class="hljs-type">xcd_elf_t</span>   *elf;    <span class="hljs-type">char</span>        *name;    <span class="hljs-type">char</span>         name_buf[<span class="hljs-number">512</span>];    <span class="hljs-type">char</span>        *name_embedded;    <span class="hljs-type">char</span>        *offset;    <span class="hljs-type">char</span>         offset_buf[<span class="hljs-number">64</span>];    <span class="hljs-type">char</span>        *func;    <span class="hljs-type">char</span>         func_buf[<span class="hljs-number">512</span>];    <span class="hljs-type">int</span>          r;    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_util_write_str</span>(log_fd, <span class="hljs-string">&quot;backtrace:\n&quot;</span>))) <span class="hljs-keyword">return</span> r;        <span class="hljs-built_in">TAILQ_FOREACH</span>(frame, &amp;(self-&gt;frames), link)    &#123;        <span class="hljs-comment">//name</span>        name = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == frame-&gt;map)        &#123;            name = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == frame-&gt;map-&gt;name || <span class="hljs-string">&#x27;\0&#x27;</span> == frame-&gt;map-&gt;name[<span class="hljs-number">0</span>])        &#123;            <span class="hljs-built_in">snprintf</span>(name_buf, <span class="hljs-built_in">sizeof</span>(name_buf), <span class="hljs-string">&quot;&lt;anonymous:%&quot;</span>XCC_UTIL_FMT_ADDR<span class="hljs-string">&quot;&gt;&quot;</span>, frame-&gt;map-&gt;start);            name = name_buf;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != frame-&gt;map-&gt;elf_start_offset)            &#123;                elf = <span class="hljs-built_in">xcd_map_get_elf</span>(frame-&gt;map, self-&gt;pid, (<span class="hljs-type">void</span> *)self-&gt;maps);                <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != elf)                &#123;                    name_embedded = <span class="hljs-built_in">xcd_elf_get_so_name</span>(elf);                    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != name_embedded &amp;&amp; <span class="hljs-built_in">strlen</span>(name_embedded) &gt; <span class="hljs-number">0</span>)                    &#123;                        <span class="hljs-built_in">snprintf</span>(name_buf, <span class="hljs-built_in">sizeof</span>(name_buf), <span class="hljs-string">&quot;%s!%s&quot;</span>, frame-&gt;map-&gt;name, name_embedded);                        name = name_buf;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == name) name = frame-&gt;map-&gt;name;        &#125;        <span class="hljs-comment">//offset</span>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != frame-&gt;map &amp;&amp; <span class="hljs-number">0</span> != frame-&gt;map-&gt;elf_start_offset)        &#123;            <span class="hljs-built_in">snprintf</span>(offset_buf, <span class="hljs-built_in">sizeof</span>(offset_buf), <span class="hljs-string">&quot; (offset 0x%&quot;</span>PRIxPTR<span class="hljs-string">&quot;)&quot;</span>, frame-&gt;map-&gt;elf_start_offset);            offset = offset_buf;        &#125;        <span class="hljs-keyword">else</span>        &#123;            offset = <span class="hljs-string">&quot;&quot;</span>;        &#125;        <span class="hljs-comment">//func</span>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != frame-&gt;func_name)        &#123;            <span class="hljs-keyword">if</span>(frame-&gt;func_offset &gt; <span class="hljs-number">0</span>)                <span class="hljs-built_in">snprintf</span>(func_buf, <span class="hljs-built_in">sizeof</span>(func_buf), <span class="hljs-string">&quot; (%s+%zu)&quot;</span>, frame-&gt;func_name, frame-&gt;func_offset);            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">snprintf</span>(func_buf, <span class="hljs-built_in">sizeof</span>(func_buf), <span class="hljs-string">&quot; (%s)&quot;</span>, frame-&gt;func_name);            func = func_buf;        &#125;        <span class="hljs-keyword">else</span>        &#123;            func = <span class="hljs-string">&quot;&quot;</span>;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_util_write_format</span>(log_fd, <span class="hljs-string">&quot;    #%02zu pc %0&quot;</span>XCC_UTIL_FMT_ADDR<span class="hljs-string">&quot;  %s%s%s\n&quot;</span>,                                           frame-&gt;num, frame-&gt;rel_pc, name, offset, func))) <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_util_write_str</span>(log_fd, <span class="hljs-string">&quot;\n&quot;</span>))) <span class="hljs-keyword">return</span> r;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs text">backtrace:    #00 pc 000000000000b884  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_4+24)    #01 pc 000000000000b8c8  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_3+24)    #02 pc 000000000000b8f8  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_2+24)    #03 pc 000000000000b920  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_1+16)    #04 pc 000000000000b9b4  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_crash+124)    #05 pc 000000000013f350  /apex/com.android.runtime/lib64/libart.so (art_quick_generic_jni_trampoline+144)    #06 pc 00000000001365b8  /apex/com.android.runtime/lib64/libart.so (art_quick_invoke_static_stub+568)    #07 pc 0000000000145084  /apex/com.android.runtime/lib64/libart.so (_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc+276)    #08 pc 00000000002e3bc0  /apex/com.android.runtime/lib64/libart.so (_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPNS_11ShadowFrameEtPNS_6JValueE+384)    #09 pc 00000000002deab8  /apex/com.android.runtime/lib64/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+928)    #10 pc 00000000005a4e3c  /apex/com.android.runtime/lib64/libart.so (MterpInvokeStatic+368)    #11 pc 0000000000130994  /apex/com.android.runtime/lib64/libart.so (mterp_op_invoke_static+20)    #12 pc 00000000005a2564  /apex/com.android.runtime/lib64/libart.so (MterpInvokeVirtual+1456)    #13 pc 0000000000130814  /apex/com.android.runtime/lib64/libart.so (mterp_op_invoke_virtual+20)    #14 pc 00000000005a5154  /apex/com.android.runtime/lib64/libart.so (MterpInvokeStatic+1160)    #15 pc 0000000000130994  /apex/com.android.runtime/lib64/libart.so (mterp_op_invoke_static+20)    ...</code></pre></div><h3 id="Stack-Per-Frame"><a href="#Stack-Per-Frame" class="headerlink" title="Stack (Per Frame)"></a>Stack (Per Frame)</h3><p>这里打印的是上个章节 <code>Backtrace</code> 描述的函数调用栈里，每一帧（<code>Frame</code>）对应的栈内存，sp 寄存器指向栈顶</p><div class="code-wrapper"><pre><code class="hljs text">stack:         0000007fe0ef1ff0  0000000be0ef2260         0000007fe0ef1ff8  00000075a5107020         0000007fe0ef2000  0000007fe0ef2001  [stack]         0000007fe0ef2008  0000007511197000         0000007fe0ef2010  00000000000fd000         0000007fe0ef2018  0000007511290018         0000007fe0ef2020  0000007511197000         0000007fe0ef2028  0000007511290018         0000007fe0ef2030  0000007f00000000         0000007fe0ef2038  0000007511197000         0000007fe0ef2040  00000000000f8d50         0000007fe0ef2048  0000000000001000         0000007fe0ef2050  0000000000000000         0000007fe0ef2058  0000000000000000         0000007fe0ef2060  00000075a4ff8000  [anon:libc_malloc]         0000007fe0ef2068  000000006f5df020  /system/framework/arm64/boot-framework.art    #00  0000007fe0ef2070  0000000000000000         0000007fe0ef2078  000000030000ddd5    #01  0000007fe0ef2080  0000007fe0ef2130  [stack]         0000007fe0ef2088  0000000200000001         0000007fe0ef2090  0000007fe0ef20b0  [stack]         0000007fe0ef2098  00000074b9bcc8fc  /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/lib/arm64/libxcrash.so (xc_test_call_2+28)    #02  0000007fe0ef20a0  0000000000000004         0000007fe0ef20a8  0000000100000000         0000007fe0ef20b0  0000007fe0ef20d0  [stack]</code></pre></div><h3 id="Memory-Near-XX"><a href="#Memory-Near-XX" class="headerlink" title="Memory Near XX"></a>Memory Near XX</h3><p>打印所有寄存器地址附近的内存，寄存器的值可以通过 <code>ptrace</code> 拿到</p><div class="code-wrapper"><pre><code class="hljs text">memory near x2:    000000751128fd40 0000000000000000 0000000000000000  ................    000000751128fd50 000000751138cd50 0000000000000000  P.8.u...........    000000751128fd60 00005015000050c4 0000007f00000000  .P...P..........    000000751128fd70 0000007511197000 00000000000f8d50  .p..u...P.......    000000751128fd80 0000000000001000 0000000000000000  ................    000000751128fd90 0000000000000000 00000075a4ff8000  ............u...    000000751128fda0 0000000000000003 0000000000000000  ................    000000751128fdb0 00000074b9bcc9dc 0000000000000000  ....t...........    000000751128fdc0 0000000000000000 00000075a4e67000  .........p..u...    000000751128fdd0 00000074c5b3b000 0000000000000001  ....t...........    000000751128fde0 0000007511197000 00000000000fd000  .p..u...........    000000751128fdf0 0000000000000000 0000000000000000  ................    000000751128fe00 0000000000000000 0000000000000000  ................    000000751128fe10 0000000000000000 0000000000000000  ................    000000751128fe20 0000000000000000 0000000000000000  ................    000000751128fe30 0000000000000000 0000000000000000  ................memory near x3:    0000007511290000 0000007511290060 0000000000000000  `.).u...........    0000007511290010 0000000000000000 0000007511290060  ........`.).u...    0000007511290020 00000075a2606c90 000000751128fd50  .l`.u...P.(.u...    0000007511290030 0000000000000000 0000000000000000  ................    0000007511290040 0000000000000000 79fc7e30c0ff4d9e  .........M..0~.y    0000007511290050 0000000000000000 0000000000000000  ................    0000007511290060 0000000000000000 0000000000000000  ................    0000007511290070 0000000000000000 0000000000000000  ................    0000007511290080 0000000000000000 0000000000000000  ................    0000007511290090 0000000000000000 0000000000000000  ................    00000075112900a0 0000000000000000 0000000000000000  ................    00000075112900b0 0000000000000000 0000000000000000  ................    00000075112900c0 0000000000000000 0000000000000000  ................    00000075112900d0 0000000000000000 0000000000000000  ................    00000075112900e0 0000000000000000 0000000000000000  ................    00000075112900f0 0000000000000000 0000000000000000  ................</code></pre></div><h3 id="Memory-Map"><a href="#Memory-Map" class="headerlink" title="Memory Map"></a>Memory Map</h3><p>也就是 <code>/proc/pid/maps</code> 内存映射</p><div class="code-wrapper"><pre><code class="hljs text">memory map:    0000000012c00000-00000000133c0000 rw-        0   7c0000 [anon:dalvik-main space (region space)]    00000000133c0000-0000000013dc0000 ---        0   a00000 &gt;    0000000013dc0000-0000000013f80000 ---        0   1c0000 &gt;    0000000013f80000-0000000013fc0000 rw-        0    40000 &gt;    0000000013fc0000-0000000014100000 ---        0   140000 &gt;    0000000014100000-0000000014140000 rw-        0    40000 &gt;    0000000014140000-0000000014200000 ---        0    c0000 &gt;    0000000014200000-0000000014280000 ---        0    80000 &gt;    0000000014280000-00000000163c0000 ---        0  2140000 &gt;    00000000163c0000-0000000032c00000 rw-        0 1c840000 &gt;    000000006f1a9000-000000006f430000 rw-        0   287000 /system/framework/arm64/boot.art    000000006f430000-000000006f51f000 rw-        0    ef000 /system/framework/arm64/boot-core-libart.art    000000006f51f000-000000006f555000 rw-        0    36000 /system/framework/arm64/boot-okhttp.art    000000006f555000-000000006f596000 rw-        0    41000 /system/framework/arm64/boot-bouncycastle.art    000000006f596000-000000006f5a6000 rw-        0    10000 /system/framework/arm64/boot-apache-xml.art    000000006f5a6000-000000006fe62000 rw-        0   8bc000 /system/framework/arm64/boot-framework.art    000000006fe62000-000000006fe95000 rw-        0    33000 /system/framework/arm64/boot-ext.art    000000006fe95000-000000006ff8c000 rw-        0    f7000 /system/framework/arm64/boot-telephony-common.art    000000006ff8c000-000000006ff9a000 rw-        0     e000 /system/framework/arm64/boot-voip-common.art    000000006ff9a000-000000006ffaf000 rw-        0    15000 /system/framework/arm64/boot-ims-common.art    000000006ffaf000-000000006ffb2000 rw-        0     3000 /system/framework/arm64/boot-android.test.base.art    000000006ffb2000-000000007006b000 r--        0    b9000 /system/framework/arm64/boot.oat    000000007006b000-0000000070300000 r-x    b9000   295000 &gt;    0000000070300000-0000000070301000 rw-        0     1000 [anon:.bss]    0000000070301000-0000000070303000 r--        0     2000 /system/framework/boot.vdex    0000000070303000-0000000070304000 r--   34e000     1000 /system/framework/arm64/boot.oat    0000000070304000-0000000070305000 rw-   34f000     1000 &gt;    0000000070305000-000000007034e000 r--        0    49000 /system/framework/arm64/boot-core-libart.oat    000000007034e000-0000000070453000 r-x    49000   105000 &gt;    0000000070453000-0000000070454000 rw-        0     1000 [anon:.bss]    0000000070454000-0000000070455000 r--        0     1000 /system/framework/boot-core-libart.vdex    0000000070455000-0000000070456000 r--   14e000     1000 /system/framework/arm64/boot-core-libart.oat    0000000070456000-0000000070457000 rw-   14f000     1000 &gt;    0000000070457000-0000000070466000 r--        0     f000 /system/framework/arm64/boot-okhttp.oat</code></pre></div><h2 id="ANR-Trace"><a href="#ANR-Trace" class="headerlink" title="ANR Trace"></a>ANR Trace</h2><ol><li>给主线程注册 <code>SIGQUIT</code> 的信号处理器 <code>xc_trace_handler</code>，当主线程收到 SIGQUIT 信号时，恢复 <code>xc_trace_dumper</code>（dumper 线程），也就是说发生 ANR 时主线程是被 SIGQUIT 中断的而不是 SIGKILL (?)</li><li>启动 xc_trace_dumper（dumper 线程），挂起等待被主线程唤醒</li><li>在内存里找到生成 ANR 报告的函数符号：<code>_ZN3art7Runtime14DumpForSigQuitERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE</code></li><li>将 <code>STDERR_FILENO</code> 指向日志文件，调用 ANR 报告函数（它会把 ANR 日志写入 <code>STDERR_FILENO</code>），这样就捕获了 ANR 日志</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// XCrash.init</span><span class="hljs-comment">// NativeHandler.initialize</span><span class="hljs-comment">// NativeHandler.nativeInit</span><span class="hljs-comment">// xc_jni_init</span><span class="hljs-comment">// 起 dumper 线程，注册 SIGQUIT 处理器</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xc_trace_init</span><span class="hljs-params">(JNIEnv *env,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> rethrow,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> logcat_system_lines,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> logcat_events_lines,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> logcat_main_lines,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> dump_fds,</span></span><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">int</span> dump_network_info)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> r;    <span class="hljs-type">pthread_t</span> thd;    <span class="hljs-comment">//capture SIGQUIT only for ART</span>    <span class="hljs-keyword">if</span>(xc_common_api_level &lt; <span class="hljs-number">21</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//is Android Lollipop (5.x)?</span>    xc_trace_is_lollipop = ((<span class="hljs-number">21</span> == xc_common_api_level || <span class="hljs-number">22</span> == xc_common_api_level) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);    xc_trace_dump_status = XC_TRACE_DUMP_NOT_START;    xc_trace_rethrow = rethrow;    xc_trace_logcat_system_lines = logcat_system_lines;    xc_trace_logcat_events_lines = logcat_events_lines;    xc_trace_logcat_main_lines = logcat_main_lines;    xc_trace_dump_fds = dump_fds;    xc_trace_dump_network_info = dump_network_info;    <span class="hljs-comment">//init for JNI callback</span>    <span class="hljs-built_in">xc_trace_init_callback</span>(env);    <span class="hljs-comment">//create event FD</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &gt; (xc_trace_notifier = <span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_CLOEXEC))) <span class="hljs-keyword">return</span> XCC_ERRNO_SYS;    <span class="hljs-comment">//register signal handler</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">xcc_signal_trace_register</span>(xc_trace_handler))) <span class="hljs-keyword">goto</span> err2;    <span class="hljs-comment">//create thread for dump trace</span>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != (r = <span class="hljs-built_in">pthread_create</span>(&amp;thd, <span class="hljs-literal">NULL</span>, xc_trace_dumper, <span class="hljs-literal">NULL</span>))) <span class="hljs-keyword">goto</span> err1;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; err1:    <span class="hljs-built_in">xcc_signal_trace_unregister</span>(); err2:    <span class="hljs-built_in">close</span>(xc_trace_notifier);    xc_trace_notifier = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-comment">// ANR 发生时，收到 SIGQUIT，此 dumper 线程唤醒，调用 ANR 报告函数</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">xc_trace_dumper</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><span class="hljs-function"></span>&#123;    JNIEnv         *env = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">uint64_t</span>        data;    <span class="hljs-type">uint64_t</span>        trace_time;    <span class="hljs-type">int</span>             fd;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span>  tv;    <span class="hljs-type">char</span>            pathname[<span class="hljs-number">1024</span>];    jstring         j_pathname;        (<span class="hljs-type">void</span>)arg;        <span class="hljs-built_in">pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());    JavaVMAttachArgs attach_args = &#123;        .version = XC_JNI_VERSION,        .name    = <span class="hljs-string">&quot;xcrash_trace_dp&quot;</span>,        .group   = <span class="hljs-literal">NULL</span>    &#125;;    <span class="hljs-keyword">if</span>(JNI_OK != (*xc_common_vm)-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(xc_common_vm, &amp;env, &amp;attach_args)) <span class="hljs-keyword">goto</span> exit;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        <span class="hljs-comment">//block here, waiting for sigquit</span>        <span class="hljs-built_in">XCC_UTIL_TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(xc_trace_notifier, &amp;data, <span class="hljs-built_in">sizeof</span>(data)));                <span class="hljs-comment">//check if process already crashed</span>        <span class="hljs-keyword">if</span>(xc_common_native_crashed || xc_common_java_crashed) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//trace time</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">gettimeofday</span>(&amp;tv, <span class="hljs-literal">NULL</span>)) <span class="hljs-keyword">break</span>;        trace_time = (<span class="hljs-type">uint64_t</span>)(tv.tv_sec) * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> + (<span class="hljs-type">uint64_t</span>)tv.tv_usec;        <span class="hljs-comment">//Keep only one current trace.</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_logs_clean</span>()) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//create and open log file</span>        <span class="hljs-keyword">if</span>((fd = <span class="hljs-built_in">xc_common_open_trace_log</span>(pathname, <span class="hljs-built_in">sizeof</span>(pathname), trace_time)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//write header info</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_write_header</span>(fd, trace_time)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-comment">//write trace info from ART runtime</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_format</span>(fd, XCC_UTIL_THREAD_SEP<span class="hljs-string">&quot;Cmd line: %s\n&quot;</span>, xc_common_process_name)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Mode: ART DumpForSigQuit\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_load_symbols</span>())        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to load symbols.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;            <span class="hljs-keyword">goto</span> skip;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xc_trace_check_address_valid</span>())        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to check runtime address.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;            <span class="hljs-keyword">goto</span> skip;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dup2</span>(fd, STDERR_FILENO) &lt; <span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;Failed to duplicate FD.\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;            <span class="hljs-keyword">goto</span> skip;        &#125;        xc_trace_dump_status = XC_TRACE_DUMP_ON_GOING;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sigsetjmp</span>(jmpenv, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)         &#123;            <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)                <span class="hljs-built_in">xc_trace_libart_dbg_suspend</span>();            <span class="hljs-built_in">xc_trace_libart_runtime_dump</span>(*xc_trace_libart_runtime_instance, xc_trace_libcpp_cerr);            <span class="hljs-keyword">if</span>(xc_trace_is_lollipop)                <span class="hljs-built_in">xc_trace_libart_dbg_resume</span>();        &#125;         <span class="hljs-keyword">else</span>         &#123;            <span class="hljs-built_in">fflush</span>(<span class="hljs-literal">NULL</span>);            <span class="hljs-built_in">XCD_LOG_WARN</span>(<span class="hljs-string">&quot;longjmp to skip dumping trace\n&quot;</span>);        &#125;        <span class="hljs-built_in">dup2</span>(xc_common_fd_null, STDERR_FILENO);                                skip:        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_write_str</span>(fd, <span class="hljs-string">&quot;\n&quot;</span>XCC_UTIL_THREAD_END<span class="hljs-string">&quot;\n&quot;</span>)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-comment">//write other info</span>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_logcat</span>(fd, xc_common_process_id, xc_common_api_level, xc_trace_logcat_system_lines, xc_trace_logcat_events_lines, xc_trace_logcat_main_lines)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(xc_trace_dump_fds)            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_fds</span>(fd, xc_common_process_id)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(xc_trace_dump_network_info)            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_util_record_network_info</span>(fd, xc_common_process_id, xc_common_api_level)) <span class="hljs-keyword">goto</span> end;        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> != <span class="hljs-built_in">xcc_meminfo_record</span>(fd, xc_common_process_id)) <span class="hljs-keyword">goto</span> end;    end:        <span class="hljs-comment">//close log file</span>        <span class="hljs-built_in">xc_common_close_trace_log</span>(fd);        <span class="hljs-comment">//rethrow SIGQUIT to ART Signal Catcher</span>        <span class="hljs-keyword">if</span>(xc_trace_rethrow &amp;&amp; (XC_TRACE_DUMP_ART_CRASH != xc_trace_dump_status)) <span class="hljs-built_in">xc_trace_send_sigquit</span>();        xc_trace_dump_status = XC_TRACE_DUMP_END;        <span class="hljs-comment">//JNI callback</span>        <span class="hljs-comment">//Do we need to implement an emergency buffer for disk exhausted?</span>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == xc_trace_cb_method) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == (j_pathname = (*env)-&gt;<span class="hljs-built_in">NewStringUTF</span>(env, pathname))) <span class="hljs-keyword">continue</span>;        (*env)-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(env, xc_common_cb_class, xc_trace_cb_method, j_pathname, <span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">XC_JNI_IGNORE_PENDING_EXCEPTION</span>();        (*env)-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(env, j_pathname);    &#125;        (*xc_common_vm)-&gt;<span class="hljs-built_in">DetachCurrentThread</span>(xc_common_vm); exit:    xc_trace_notifier = <span class="hljs-number">-1</span>;    <span class="hljs-built_in">close</span>(xc_trace_notifier);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>uncaught exception</tag>
      
      <tag>exception</tag>
      
      <tag>崩溃</tag>
      
      <tag>崩溃日志</tag>
      
      <tag>crash</tag>
      
      <tag>xcrash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>killProcess 和 exit 的区别</title>
    <link href="/2021/06/20/kill-exit/"/>
    <url>/2021/06/20/kill-exit/</url>
    
    <content type="html"><![CDATA[<h2 id="Process-killProcess-pid"><a href="#Process-killProcess-pid" class="headerlink" title="Process.killProcess(pid)"></a>Process.killProcess(pid)</h2><p>最终执行系统调用 <code>kill</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Process</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL_KILL</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">killProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span> &#123;        sendSignal(pid, SIGNAL_KILL);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, <span class="hljs-type">int</span> signal)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// android_util_Process.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">android_os_Process_sendSignal</span><span class="hljs-params">(JNIEnv* env, jobject clazz, jint pid, jint sig)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;Sending signal. PID: %&quot;</span> PRId32 <span class="hljs-string">&quot; SIG: %&quot;</span> PRId32, pid, sig);        <span class="hljs-built_in">kill</span>(pid, sig);    &#125;&#125;</code></pre></div><h3 id="signal（信号）"><a href="#signal（信号）" class="headerlink" title="signal（信号）"></a>signal（信号）</h3><p><strong>信号</strong> 是一个古老的、异步的 IPC 机制，一个进程可以给另一个进程发送信号（<code>kill</code>），收到信号（<code>SIGxxx</code>）的进程会暂停并进入相应的信号处理程序（<code>Signal Handlers</code>），信号处理程序是可以配置的</p><div class="code-wrapper"><pre><code class="hljs shell">kill -s sig pid</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">kill</span>(pid, sig)<span class="hljs-comment">// 自定义信号处理程序</span><span class="hljs-comment">// handler 可以是：SIG_IGN 忽略此信号，SIG_DFL 设置默认的信号处理程序，函数地址</span><span class="hljs-comment">// SIGKILL 和 SIGSTOP 是不可以忽略和自定义的</span><span class="hljs-built_in">signal</span>(signum, handler)</code></pre></div><h4 id="常见的信号"><a href="#常见的信号" class="headerlink" title="常见的信号"></a>常见的信号</h4><table><thead><tr><th>Singal</th><th>Number</th><th>Default Action</th><th>Desc</th></tr></thead><tbody><tr><td>SIGKILL</td><td>9</td><td>Terminate (core dump)</td><td>Kill (cannot be caught or ignored)</td></tr><tr><td>SIGSEGV</td><td>11</td><td>Terminate (core dump)</td><td>Invalid memory reference</td></tr><tr><td>SIGINT</td><td>2</td><td>Terminate</td><td>Terminal interrupt signal，常见于在控制台由 Ctrl-C 触发</td></tr><tr><td>SIGSTOP</td><td></td><td>Stop</td><td>Stop executing (cannot be caught or ignored)，常见于在控制台由 Ctrl-Z 触发</td></tr></tbody></table><h2 id="System-exit-status"><a href="#System-exit-status" class="headerlink" title="System.exit(status)"></a>System.exit(status)</h2><p>退出 VM 回到 native 代码，能够保证 shutdown hook 执行完，native 代码甚至可以重新进入 VM 或者做其他的事，进程没有被杀死，其他 native thread 也在正常运行</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">System</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;        Runtime.getRuntime().exit(status);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;        <span class="hljs-comment">// Make sure we don&#x27;t try this several times</span>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;            <span class="hljs-keyword">if</span> (!shuttingDown) &#123;                shuttingDown = <span class="hljs-literal">true</span>;                Thread[] hooks;                <span class="hljs-keyword">synchronized</span> (shutdownHooks) &#123;                    <span class="hljs-comment">// create a copy of the hooks</span>                    hooks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[shutdownHooks.size()];                    shutdownHooks.toArray(hooks);                &#125;                <span class="hljs-comment">// Start all shutdown hooks concurrently</span>                <span class="hljs-keyword">for</span> (Thread hook : hooks) &#123;                    hook.start();                &#125;                <span class="hljs-comment">// Wait for all shutdown hooks to finish</span>                <span class="hljs-keyword">for</span> (Thread hook : hooks) &#123;                    <span class="hljs-keyword">try</span> &#123;                        hook.join();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;                        <span class="hljs-comment">// Ignore, since we are at VM shutdown.</span>                    &#125;                &#125;                <span class="hljs-comment">// Ensure finalization on exit, if requested</span>                <span class="hljs-keyword">if</span> (finalizeOnExit) &#123;                    runFinalization();                &#125;                <span class="hljs-comment">// Get out of here finally...</span>                nativeExit(status);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="shutdown-hook"><a href="#shutdown-hook" class="headerlink" title="shutdown hook"></a>shutdown hook</h3><p>通过 <code>Runtime.addShutdownHook(Thread)</code> 添加的任务确实可以在 <code>System.exit(status)</code> 时被执行，但就像 <a href="../../../../2021/06/18/uncaught-exception-handler/">Uncaught Exception Handling</a> 里描述的那样，主线程退出 VM 后虽然没有结束（在等待 shutdown hook 执行完毕），但它也不再消费分发过来的 input 事件导致出现 ANR 对话框，然后被用户杀死 app process，当然在进程被杀死前 shutdown hook 也有跟 uncaught exception handler 差不多长的生存时间</p>]]></content>
    
    
    
    <tags>
      
      <tag>kill</tag>
      
      <tag>exit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uncaught Exception Handling</title>
    <link href="/2021/06/18/uncaught-exception-handler/"/>
    <url>/2021/06/18/uncaught-exception-handler/</url>
    
    <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>根据 <code>Thread.setDefaultUncaughtExceptionHandler</code> 的方法文档</p><blockquote><p>Uncaught exception handling is controlled first by the thread, then by the thread’s ThreadGroup object and finally by the default uncaught exception handler. If the thread does not have an explicit uncaught exception handler set, and the thread’s thread group (including parent thread groups) does not specialize its uncaughtException method, then the default handler’s uncaughtException method will be invoked.</p></blockquote><p>当发生 <code>Uncaught Exception</code> 时，将会按照 <code>Thread.uncaughtExceptionHandler -&gt; ThreadGroup.uncaughtException -&gt; Thread.defaultUncaughtExceptionHandler</code> 的优先级次序去寻找异常处理器</p><p>而 <code>ThreadGroup.uncaughtException</code> 的默认实现仅仅是像事件冒泡那样把异常往上传递，跑到 root ThreadGroup 后中止冒泡并交由 <code>DefaultUncaughtExceptionHandler</code> 处理 or 打印至标准错误流，所以可以把 <code>ThreadGroup.uncaughtException</code> 当作透明的层忽略之</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;        parent.uncaughtException(t, e);    &#125; <span class="hljs-keyword">else</span> &#123;        Thread.<span class="hljs-type">UncaughtExceptionHandler</span> <span class="hljs-variable">ueh</span> <span class="hljs-operator">=</span>            Thread.getDefaultUncaughtExceptionHandler();        <span class="hljs-keyword">if</span> (ueh != <span class="hljs-literal">null</span>) &#123;            ueh.uncaughtException(t, e);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> ThreadDeath)) &#123;            System.err.print(<span class="hljs-string">&quot;Exception in thread \&quot;&quot;</span>                             + t.getName() + <span class="hljs-string">&quot;\&quot; &quot;</span>);            e.printStackTrace(System.err);        &#125;    &#125;&#125;</code></pre></div><p>下面仅考虑 <code>Thread.uncaughtExceptionHandler</code>、<code>DefaultUncaughtExceptionHandler</code> 和 <code>主线程</code> 三个因素</p><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>Thread.uncaughtExceptionHandler/DefaultUncaughtExceptionHandler 可以捕获异常，但无法改变 app 被 blocked 住，然后出现 ANR（即使点击 <code>等待</code> 依然被 blocked 住），点击 <code>确定</code> 后被 kill 的命运</p><div class="code-wrapper"><pre><code class="hljs log">2021-06-12 11:13:29.464 28055-28055/com.example.myapplication D/AndroidRuntime: Shutting down VM    --------- beginning of crash2021-06-12 11:13:29.465 28055-28055/com.example.myapplication E/AndroidRuntime: FATAL EXCEPTION: main    Process: com.example.myapplication, PID: 28055    java.lang.RuntimeException: Test Exception        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:58)        at com.example.myapplication.MainActivity.onCreate$lambda-2(MainActivity.kt:30)        at com.example.myapplication.MainActivity.lambda$hUPUYmntOngyO5ji3KzmjKQ19D4(Unknown Source:0)        at com.example.myapplication.-$$Lambda$MainActivity$hUPUYmntOngyO5ji3KzmjKQ19D4.onClick(Unknown Source:0)        at android.view.View.performClick(View.java:7509)        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)        at android.view.View.performClickInternal(View.java:7486)        at android.view.View.access$3600(View.java:841)        at android.view.View$PerformClick.run(View.java:28709)        at android.os.Handler.handleCallback(Handler.java:938)        at android.os.Handler.dispatchMessage(Handler.java:99)        at android.os.Looper.loop(Looper.java:236)        at android.app.ActivityThread.main(ActivityThread.java:8061)        at java.lang.reflect.Method.invoke(Native Method)        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)// 如果 Thread.uncaughtExceptionHandler != null or DefaultUncaughtExceptionHandler != null 则能够在自己的 UncaughtExceptionHandler 里捕获异常2021-06-12 11:13:29.471 28055-28055/com.example.myapplication E/cyrus: main-2 UncaughtExceptionHandler: Test Exception    java.lang.RuntimeException: Test Exception        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:58)        at com.example.myapplication.MainActivity.onCreate$lambda-2(MainActivity.kt:30)        at com.example.myapplication.MainActivity.lambda$hUPUYmntOngyO5ji3KzmjKQ19D4(Unknown Source:0)        at com.example.myapplication.-$$Lambda$MainActivity$hUPUYmntOngyO5ji3KzmjKQ19D4.onClick(Unknown Source:0)        at android.view.View.performClick(View.java:7509)        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1119)        at android.view.View.performClickInternal(View.java:7486)        at android.view.View.access$3600(View.java:841)        at android.view.View$PerformClick.run(View.java:28709)        at android.os.Handler.handleCallback(Handler.java:938)        at android.os.Handler.dispatchMessage(Handler.java:99)        at android.os.Looper.loop(Looper.java:236)        at android.app.ActivityThread.main(ActivityThread.java:8061)        at java.lang.reflect.Method.invoke(Native Method)        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)        // app 没有立刻崩溃，但是进入 blocked 状态，点击 app 没响应然后触发 ANR2021-06-12 11:17:10.449 1764-28190/? I/ActivityManager: Collecting stacks for pid 280552021-06-12 11:17:10.449 1764-28190/? I/system_server: libdebuggerd_client: started dumping process 280552021-06-12 11:17:10.450 697-697/? I/tombstoned: registered intercept for pid 28055 and type kDebuggerdJavaBacktrace2021-06-12 11:17:10.450 28055-28065/com.example.myapplication I/e.myapplicatio: Thread[6,tid=28065,WaitingInMainSignalCatcherLoop,Thread*=0xb400007271841000,peer=0x13780260,&quot;Signal Catcher&quot;]: reacting to signal 32021-06-12 11:17:10.528 697-697/? I/tombstoned: received crash request for pid 280552021-06-12 11:17:10.528 697-697/? I/tombstoned: found intercept fd 512 for pid 28055 and type kDebuggerdJavaBacktrace2021-06-12 11:17:10.528 28055-28065/com.example.myapplication I/e.myapplicatio: Wrote stack traces to tombstoned2021-06-12 11:17:10.529 1764-28190/? I/system_server: libdebuggerd_client: done dumping process 28055// 需要一段时间来 dump ANR 信息2021-06-12 11:17:15.839 1764-28190/? E/ActivityManager: ANR in com.example.myapplication (com.example.myapplication/.MainActivity)    PID: 28055    Reason: Input dispatching timed out (com.example.myapplication/com.example.myapplication.MainActivity, 7fc1f1 com.example.myapplication/com.example.myapplication.MainActivity (server) is not responding. Waited 8001ms for MotionEvent(action=DOWN))    Parent: com.example.myapplication/.MainActivity    Load: 0.13 / 0.47 / 0.83    ----- Output from /proc/pressure/memory -----    some avg10=0.00 avg60=0.00 avg300=0.00 total=15206960    full avg10=0.00 avg60=0.00 avg300=0.00 total=5127529    ----- End output from /proc/pressure/memory -----        CPU usage from 0ms to 5796ms later (2021-06-12 11:17:09.982 to 2021-06-12 11:17:15.778):      0.1% 1465/media.codec: 0% user + 0% kernel / faults: 38284 minor      18% 1764/system_server: 8.2% user + 10% kernel / faults: 4408 minor      0% 1509/media.swcodec: 0% user + 0% kernel / faults: 21804 minor      0% 899/media.hwcodec: 0% user + 0% kernel / faults: 7313 minor      0.1% 5899/com.sohu.inputmethod.sogou: 0.1% user + 0% kernel / faults: 1684 minor      2% 895/kworker/u16:16: 0% user + 2% kernel      2% 2930/com.android.phone: 1.2% user + 0.8% kernel / faults: 1835 minor      1.8% 1284/adbd: 0.5% user + 1.3% kernel      0% 1426/media.extractor: 0% user + 0% kernel / faults: 3197 minor      1.8% 25102/kworker/u16:5: 0% user + 1.8% kernel      1.5% 982/surfaceflinger: 0.1% user + 1.3% kernel / faults: 41 minor      0% 7493/kworker/u16:14: 0% user + 0% kernel      0% 28055/com.example.myapplication: 0% user + 0% kernel / faults: 1974 minor      1.2% 5242/com.android.nfc: 1% user + 0.1% kernel / faults: 796 minor      1% 18959/com.viomi.fridge.vertical: 0.8% user + 0.1% kernel / faults: 17 minor      1% 28105/kworker/u16:0: 0% user + 1% kernel      0.8% 584/logd: 0.3% user + 0.5% kernel      0.8% 836/android.hardware.sensors@1.0-service: 0.3% user + 0.5% kernel / faults: 115 minor      0.8% 1359/cnss_diag: 0.6% user + 0.1% kernel      0.8% 25780/com.xiaomi.market: 0.6% user + 0.1% kernel / faults: 736 minor 2 major      0.6% 806/android.hardware.graphics.composer@2.4-service: 0% user + 0.6% kernel / faults: 238 minor 2 major      0.6% 873/vendor.qti.hardware.perf@2.2-service: 0.3% user + 0.3% kernel / faults: 33 minor      0% 1443/mediaserver: 0% user + 0% kernel / faults: 70 minor      0.6% 16518/com.miui.player: 0.1% user + 0.5% kernel      0% 1/init: 0% user + 0% kernel      0% 697/tombstoned: 0% user + 0% kernel      0% 799/android.hardware.camera.provider@2.4-service_64: 0% user + 0% kernel / faults: 26 minor      0% 949/audioserver: 0% user + 0% kernel / faults: 56 minor      0.5% 20092/kworker/u17:0: 0% user + 0.5% kernel      0.5% 28100/logcat: 0% user + 0.5% kernel      0.3% 9/rcu_preempt: 0% user + 0.3% kernel      0.3% 495/crtc_commit:131: 0% user + 0.3% kernel      0.3% 534/irq/303-fts: 0% user + 0.3% kernel      0.3% 704/statsd: 0.1% user + 0.1% kernel / faults: 27 minor      0.3% 705/netd: 0.1% user + 0.1% kernel / faults: 62 minor      0% 1367/drmserver: 0% user + 0% kernel / faults: 16 minor      0.3% 2635/com.android.systemui: 0.3% user + 0% kernel / faults: 27 minor      0.3% 3547/irq/32-90b6400.: 0% user + 0.3% kernel      0.3% 6938/kworker/u17:2: 0% user + 0.3% kernel      0.3% 8546/com.tencent.mm:toolsmp: 0.1% user + 0.1% kernel / faults: 5 minor      0.3% 13715/com.tencent.mm: 0.1% user + 0.1% kernel / faults: 5 minor      0.1% 10/rcu_sched: 0% user + 0.1% kernel      0.1% 12/rcuop/0: 0% user + 0.1% kernel      0% 13/rcuos/0: 0% user + 0% kernel      0.1% 30/rcuop/2: 0% user + 0.1% kernel      0% 31/rcuos/2: 0% user + 0% kernel      0.1% 38/rcuop/3: 0% user + 0.1% kernel      0% 66/migration/7: 0% user + 0% kernel      0.1% 586/servicemanager: 0.1% user + 0% kernel      0.1% 598/android.hardware.keymaster@4.0-service-qti: 0% user + 0.1% kernel / faults: 11 minor      0.1% 628/vold: 0% user + 0.1% kernel / faults: 29 minor      0.1% 664/ipacm: 0% user + 0.1% kernel      0.1% 676/jbd2/sda31-8: 0% user + 0.1% kernel      0% 793/android.hardware.audio.service: 0% user + 0% kernel / faults: 39 minor      0% 798/android.hardware.bluetooth@1.0-service-qti: 0% user + 0% kernel / faults: 11 minor2021-06-12 11:17:15.839 1764-28190/? E/ActivityManager:   0.1% 807/android.hardware.health@2.1-service: 0% user + 0.1% kernel / faults: 9 minor      0% 828/android.hardware.neuralnetworks@1.3-service-qti: 0% user + 0% kernel / faults: 65 minor      0.1% 851/android.hardware.wifi@1.0-service: 0.1% user + 0% kernel      0% 1365/cameraserver: 0% user + 0% kernel / faults: 70 minor      0% 1440/media.metrics: 0% user + 0% kernel / faults: 36 minor 1 major      0% 1572/gatekeeperd: 0% user + 0% kernel / faults: 28 minor 7 major      0% 1605/android.hardware.biometrics.fingerprint@2.1-service: 0% user + 0% kernel / faults: 16 minor      0.1% 2251/cds_ol_rx_threa: 0% user + 0.1% kernel      0.1% 2884/com.qualcomm.qti.devicestatisticsservice: 0.1% user + 0% kernel / faults: 1 minor      0.1% 3549/irq/33-90cd000.: 0% user + 0.1% kernel      0.1% 6156/com.xiaomi.xmsf: 0.1% user + 0% kernel / faults: 27 minor      0.1% 8036/com.tencent.mm:appbrand0: 0.1% user + 0% kernel / faults: 6 minor      0.1% 8047/com.tencent.mm:appbrand1: 0% user + 0.1% kernel / faults: 6 minor      0.1% 8864/com.xiaomi.joyose: 0.1% user + 0% kernel      0.1% 14440/com.tencent.mm:push: 0% user + 0.1% kernel / faults: 8 minor      0.1% 15807/com.miui.personalassistant: 0% user + 0.1% kernel / faults: 9 minor      0.1% 27963/kworker/2:3: 0% user + 0.1% kernel      0.1% 28106/kworker/u16:3: 0% user + 0.1% kernel      0.1% 28171/kworker/0:1: 0% user + 0.1% kernel    14% TOTAL: 7.1% user + 6.5% kernel + 0.1% iowait + 0.5% irq + 0.2% softirq    CPU usage from 41ms to 439ms later (2021-06-12 11:17:10.023 to 2021-06-12 11:17:10.422) with 99% awake:      51% 1764/system_server: 18% user + 33% kernel / faults: 929 minor        39% 28190/AnrConsumer: 9% user + 30% kernel        6% 1789/android.ui: 3% user + 3% kernel        3% 2347/InputDispatcher: 3% user + 0% kernel      2.5% 66/migration/7: 0% user + 2.5% kernel      2.6% 534/irq/303-fts: 0% user + 2.6% kernel      2.6% 584/logd: 2.6% user + 0% kernel      2.7% 873/vendor.qti.hardware.perf@2.2-service: 0% user + 2.7% kernel / faults: 6 minor        2.7% 873/perf@2.2-servic: 0% user + 2.7% kernel       +0% 28191/POSIX timer 269: 0% user + 0% kernel       +0% 28192/POSIX timer 269: 0% user + 0% kernel      2.7% 895/kworker/u16:16: 0% user + 2.7% kernel      2.8% 982/surfaceflinger: 2.8% user + 0% kernel      2.8% 1284/adbd: 0% user + 2.8% kernel    8.9% TOTAL: 2.8% user + 5.7% kernel + 0.3% irq// 点击 ANR 对话框的确定按钮杀死 app2021-06-12 11:18:58.935 1764-1789/? I/ActivityManager: Killing 28055:com.example.myapplication/u0a161 (adj 0): user request after error2021-06-12 11:18:58.937 1764-1789/? I/Process: PerfMonitor : current process sending signal quiet. PID: 28055 SIG: 92021-06-12 11:18:58.938 1764-1802/? I/Process: PerfMonitor : current process killing process group. PID: 280552021-06-12 11:18:58.965 706-706/? I/Zygote: Process 28055 exited due to signal 9 (Killed)2021-06-12 11:18:58.966 1764-1802/? I/libprocessgroup: Successfully killed process cgroup uid 10161 pid 28055 in 28ms2021-06-12 11:18:58.970 882-882/? I/vendor.qti.hardware.servicetracker@1.2-service: killProcess is called for pid : 280552021-06-12 11:18:58.970 1764-5448/? W/ANRStateManager: clear state, but process isn&#x27;t exist. hash=92035998 uid=10161 pid=28055 state=16</code></pre></div><h3 id="子线程且-UEH-null"><a href="#子线程且-UEH-null" class="headerlink" title="子线程且 UEH != null"></a>子线程且 UEH != null</h3><p>app 没有发生 ANR 也没有崩溃，且无论 <code>DefaultUncaughtExceptionHandler</code> 是否为 null，<code>Thread.uncaughtExceptionHandler</code> 都能够有限捕获异常，说明线程的 UncaughtExceptionHandler 比默认的 UncaughtExceptionHandler 优先级要高</p><div class="code-wrapper"><pre><code class="hljs log">2021-06-12 17:20:41.503 20615-22015/com.example.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-10    Process: com.example.myapplication, PID: 20615    java.lang.RuntimeException: Test Exception        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:38)        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:36)        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)2021-06-12 17:20:41.509 20615-22015/com.example.myapplication E/cyrus: Thread-10-3890 UncaughtExceptionHandler: Test Exception    java.lang.RuntimeException: Test Exception        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:38)        at com.example.myapplication.MainActivity$onCreate$4$1.invoke(MainActivity.kt:36)        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</code></pre></div><h3 id="两个UEH都置空-or-DUEH-null"><a href="#两个UEH都置空-or-DUEH-null" class="headerlink" title="两个UEH都置空 or DUEH != null"></a>两个UEH都置空 or DUEH != null</h3><p>app 没有发生 ANR 也没有崩溃</p><div class="code-wrapper"><pre><code class="hljs log">    --------- beginning of crash2021-06-12 11:06:58.817 27816-27929/com.example.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-3    Process: com.example.myapplication, PID: 27816    java.lang.RuntimeException: Test Exception        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:58)        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:24)        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:22)        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)// DefaultUncaughtExceptionHandler != null 则能够捕获异常2021-06-12 17:03:51.701 20615-20884/com.example.myapplication E/cyrus: Thread-2-3882 DefaultUncaughtExceptionHandler: Test Exception    java.lang.RuntimeException: Test Exception        at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:24)        at com.example.myapplication.MainActivity$onCreate$2$1.invoke(MainActivity.kt:22)        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)        // 当 DefaultUncaughtExceptionHandler == null 时异常被输出到标准异常流2021-06-12 17:13:54.170 20615-21405/com.example.myapplication W/System.err: Exception in thread &quot;Thread-8&quot; java.lang.RuntimeException: Test Exception2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at com.example.myapplication.MainActivityKt.throwException(MainActivity.kt:75)2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at com.example.myapplication.MainActivity$onCreate$1$1.invoke(MainActivity.kt:17)2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at com.example.myapplication.MainActivity$onCreate$1$1.invoke(MainActivity.kt:15)2021-06-12 17:13:54.171 20615-21405/com.example.myapplication W/System.err:     at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</code></pre></div><h3 id="子线程且为默认-DUEH"><a href="#子线程且为默认-DUEH" class="headerlink" title="子线程且为默认 DUEH"></a>子线程且为默认 DUEH</h3><p>默认的 DefaultUncaughtExceptionHandler 是 KillApplicationHandler，它会杀死 app</p><div class="code-wrapper"><pre><code class="hljs log">// 除了有上一节的日志外，还会有以下日志并且 app 被 kill// app process 收到信号 SIGKILL(9) 被迫退出，app 立刻崩溃掉2021-06-12 11:06:58.870 27816-27929/com.example.myapplication I/Process: Sending signal. PID: 27816 SIG: 92021-06-12 11:06:58.910 1764-1802/? I/Process: PerfMonitor : current process killing process group. PID: 278162021-06-12 11:06:58.911 1764-2936/? I/ActivityManager: Process com.example.myapplication (pid 27816) has died: prcp CRE 2021-06-12 11:06:58.911 706-706/? I/Zygote: Process 27816 exited due to signal 9 (Killed)2021-06-12 11:06:58.912 1764-1802/? I/libprocessgroup: Successfully killed process cgroup uid 10161 pid 27816 in 0ms2021-06-12 11:06:58.917 1764-2936/? W/ANRStateManager: clear state, but process isn&#x27;t exist. hash=224220282 uid=10161 pid=27816 state=162021-06-12 11:06:58.919 882-8554/? I/vendor.qti.hardware.servicetracker@1.2-service: killProcess is called for pid : 27816</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>所在线程</th><th>子条件</th><th>结果</th></tr></thead><tbody><tr><td>主线程</td><td></td><td>始终会被 blocked 住，然后发生 ANR，最后被杀死</td></tr><tr><td>子线程</td><td>两个 UncaughtExceptionHandler 都置空 <br> 有任意一个自定义的 UncaughtExceptionHandler</td><td>app 没事</td></tr><tr><td></td><td>默认</td><td>KillApplicationHandler 捕获到异常并杀死 app</td></tr></tbody></table><h2 id="代码跟踪"><a href="#代码跟踪" class="headerlink" title="代码跟踪"></a>代码跟踪</h2><h3 id="抛出-UE-时发生了什么"><a href="#抛出-UE-时发生了什么" class="headerlink" title="抛出 UE 时发生了什么"></a>抛出 UE 时发生了什么</h3><p>有一个 API 可以抛出异常：<code>JNIEnv-&gt;Throw</code>，所以我猜当 java 层发生 uncaught exception 时相当于调用了它</p><p>这个方法的实现很简单，就是把 exception 记录在 Thread::tlsPtr_::exception</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/jni/jni_internal.cc</span><span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">Throw</span><span class="hljs-params">(JNIEnv* env, jthrowable java_exception)</span> </span>&#123;  <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;  ObjPtr&lt;mirror::Throwable&gt; exception = soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Throwable&gt;(java_exception);  <span class="hljs-keyword">if</span> (exception == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> JNI_ERR;  &#125;  soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">SetException</span>(exception);  <span class="hljs-keyword">return</span> JNI_OK;&#125;<span class="hljs-comment">// art/runtime/thread.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::SetException</span><span class="hljs-params">(ObjPtr&lt;mirror::Throwable&gt; new_exception)</span> </span>&#123;  <span class="hljs-built_in">CHECK</span>(new_exception != <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> DCHECK(!IsExceptionPending());</span>  tlsPtr_.exception = new_exception.<span class="hljs-built_in">Ptr</span>();&#125;<span class="hljs-comment">// art/runtime/thread.h</span>mirror::Throwable* exception;   <span class="hljs-comment">// The pending exception or null.</span></code></pre></div><p>接下来我猜想埋点在代码里的异常检查流程在发现 pending exception != null 后，会中断字节码的执行（<code>Thread.run()</code>）从而回到 native 代码</p><p>让我们从开启一个线程 <code>Thread.start()</code> 看看这个流程</p><div class="code-wrapper"><pre><code class="hljs cpp">Thread.<span class="hljs-built_in">start</span>()Thread.<span class="hljs-built_in">nativeCreate</span>()<span class="hljs-comment">// java_lang_Thread.cc</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Thread_nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass, jobject java_thread, jlong stack_size,</span></span><span class="hljs-params"><span class="hljs-function">                                jboolean daemon)</span> </span>&#123;  <span class="hljs-comment">// There are sections in the zygote that forbid thread creation.</span>  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();  <span class="hljs-keyword">if</span> (runtime-&gt;<span class="hljs-built_in">IsZygote</span>() &amp;&amp; runtime-&gt;<span class="hljs-built_in">IsZygoteNoThreadSection</span>()) &#123;    jclass internal_error = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/InternalError&quot;</span>);    <span class="hljs-built_in">CHECK</span>(internal_error != <span class="hljs-literal">nullptr</span>);    env-&gt;<span class="hljs-built_in">ThrowNew</span>(internal_error, <span class="hljs-string">&quot;Cannot create threads in zygote&quot;</span>);    <span class="hljs-keyword">return</span>;  &#125;  Thread::<span class="hljs-built_in">CreateNativeThread</span>(env, java_thread, stack_size, daemon == JNI_TRUE);&#125;<span class="hljs-comment">// art/runtime/thread.cc</span><span class="hljs-comment">// 最终调用 pthread_create 创建线程，新线程的入口是 Thread::CreateCallback</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::CreateNativeThread</span><span class="hljs-params">(JNIEnv* env, jobject java_peer, <span class="hljs-type">size_t</span> stack_size, <span class="hljs-type">bool</span> is_daemon)</span> </span>&#123;  <span class="hljs-built_in">CHECK</span>(java_peer != <span class="hljs-literal">nullptr</span>);  Thread* self = <span class="hljs-built_in">static_cast</span>&lt;JNIEnvExt*&gt;(env)-&gt;<span class="hljs-built_in">GetSelf</span>();  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VLOG_IS_ON</span>(threads)) &#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;    ArtField* f = jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_name);    ObjPtr&lt;mirror::String&gt; java_name =        f-&gt;<span class="hljs-built_in">GetObject</span>(soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Object&gt;(java_peer))-&gt;<span class="hljs-built_in">AsString</span>();    std::string thread_name;    <span class="hljs-keyword">if</span> (java_name != <span class="hljs-literal">nullptr</span>) &#123;      thread_name = java_name-&gt;<span class="hljs-built_in">ToModifiedUtf8</span>();    &#125; <span class="hljs-keyword">else</span> &#123;      thread_name = <span class="hljs-string">&quot;(Unnamed)&quot;</span>;    &#125;    <span class="hljs-built_in">VLOG</span>(threads) &lt;&lt; <span class="hljs-string">&quot;Creating native thread for &quot;</span> &lt;&lt; thread_name;    self-&gt;<span class="hljs-built_in">Dump</span>(<span class="hljs-built_in">LOG_STREAM</span>(INFO));  &#125;  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();  <span class="hljs-comment">// Atomically start the birth of the thread ensuring the runtime isn&#x27;t shutting down.</span>  <span class="hljs-type">bool</span> thread_start_during_shutdown = <span class="hljs-literal">false</span>;  &#123;    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::runtime_shutdown_lock_)</span></span>;    <span class="hljs-keyword">if</span> (runtime-&gt;<span class="hljs-built_in">IsShuttingDownLocked</span>()) &#123;      thread_start_during_shutdown = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      runtime-&gt;<span class="hljs-built_in">StartThreadBirth</span>();    &#125;  &#125;  <span class="hljs-keyword">if</span> (thread_start_during_shutdown) &#123;    <span class="hljs-function">ScopedLocalRef&lt;jclass&gt; <span class="hljs-title">error_class</span><span class="hljs-params">(env, env-&gt;FindClass(<span class="hljs-string">&quot;java/lang/InternalError&quot;</span>))</span></span>;    env-&gt;<span class="hljs-built_in">ThrowNew</span>(error_class.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;Thread starting during runtime shutdown&quot;</span>);    <span class="hljs-keyword">return</span>;  &#125;  Thread* child_thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(is_daemon);  <span class="hljs-comment">// Use global JNI ref to hold peer live while child thread starts.</span>  child_thread-&gt;tlsPtr_.jpeer = env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(java_peer);  stack_size = <span class="hljs-built_in">FixStackSize</span>(stack_size);  <span class="hljs-comment">// Thread.start is synchronized, so we know that nativePeer is 0, and know that we&#x27;re not racing</span>  <span class="hljs-comment">// to assign it.</span>  env-&gt;<span class="hljs-built_in">SetLongField</span>(java_peer, WellKnownClasses::java_lang_Thread_nativePeer,                    <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(child_thread));  <span class="hljs-comment">// Try to allocate a JNIEnvExt for the thread. We do this here as we might be out of memory and</span>  <span class="hljs-comment">// do not have a good way to report this on the child&#x27;s side.</span>  std::string error_msg;  <span class="hljs-function">std::unique_ptr&lt;JNIEnvExt&gt; <span class="hljs-title">child_jni_env_ext</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      JNIEnvExt::Create(child_thread, Runtime::Current()-&gt;GetJavaVM(), &amp;error_msg))</span></span>;  <span class="hljs-type">int</span> pthread_create_result = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (child_jni_env_ext.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-type">pthread_t</span> new_pthread;    <span class="hljs-type">pthread_attr_t</span> attr;    child_thread-&gt;tlsPtr_.tmp_jni_env = child_jni_env_ext.<span class="hljs-built_in">get</span>();    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_init, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setdetachstate, (&amp;attr, PTHREAD_CREATE_DETACHED),                       <span class="hljs-string">&quot;PTHREAD_CREATE_DETACHED&quot;</span>);    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setstacksize, (&amp;attr, stack_size), stack_size);    pthread_create_result = <span class="hljs-built_in">pthread_create</span>(&amp;new_pthread,                                           &amp;attr,                                           Thread::CreateCallback,                                           child_thread);    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_destroy, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);    <span class="hljs-keyword">if</span> (pthread_create_result == <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// pthread_create started the new thread. The child is now responsible for managing the</span>      <span class="hljs-comment">// JNIEnvExt we created.</span>      <span class="hljs-comment">// Note: we can&#x27;t check for tmp_jni_env == nullptr, as that would require synchronization</span>      <span class="hljs-comment">//       between the threads.</span>      child_jni_env_ext.<span class="hljs-built_in">release</span>();  <span class="hljs-comment">// NOLINT pthreads API.</span>      <span class="hljs-keyword">return</span>;    &#125;  &#125;  <span class="hljs-comment">// Either JNIEnvExt::Create or pthread_create(3) failed, so clean up.</span>  &#123;    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::runtime_shutdown_lock_)</span></span>;    runtime-&gt;<span class="hljs-built_in">EndThreadBirth</span>();  &#125;  <span class="hljs-comment">// Manually delete the global reference since Thread::Init will not have been run. Make sure</span>  <span class="hljs-comment">// nothing can observe both opeer and jpeer set at the same time.</span>  child_thread-&gt;<span class="hljs-built_in">DeleteJPeer</span>(env);  <span class="hljs-keyword">delete</span> child_thread;  child_thread = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> remove from thread group?</span>  env-&gt;<span class="hljs-built_in">SetLongField</span>(java_peer, WellKnownClasses::java_lang_Thread_nativePeer, <span class="hljs-number">0</span>);  &#123;    <span class="hljs-function">std::string <span class="hljs-title">msg</span><span class="hljs-params">(child_jni_env_ext.get() == <span class="hljs-literal">nullptr</span> ?</span></span><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;Could not allocate JNI Env: %s&quot;</span>, error_msg.c_str()) :</span></span><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;pthread_create (%s stack) failed: %s&quot;</span>,</span></span><span class="hljs-params"><span class="hljs-function">                                 PrettySize(stack_size).c_str(), strerror(pthread_create_result)))</span></span>;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;    soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(msg.<span class="hljs-built_in">c_str</span>());  &#125;&#125;<span class="hljs-comment">// art/runtime/thread.cc</span><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Thread::CreateCallback</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;  Thread* self = <span class="hljs-built_in">reinterpret_cast</span>&lt;Thread*&gt;(arg);  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();  <span class="hljs-keyword">if</span> (runtime == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Thread attaching to non-existent runtime: &quot;</span> &lt;&lt; *self;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  &#125;  &#123;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass self to MutexLock - requires self to equal Thread::Current(), which is only true</span>    <span class="hljs-comment">//       after self-&gt;Init().</span>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, *Locks::runtime_shutdown_lock_)</span></span>;    <span class="hljs-comment">// Check that if we got here we cannot be shutting down (as shutdown should never have started</span>    <span class="hljs-comment">// while threads are being born).</span>    <span class="hljs-built_in">CHECK</span>(!runtime-&gt;<span class="hljs-built_in">IsShuttingDownLocked</span>());    <span class="hljs-comment">// Note: given that the JNIEnv is created in the parent thread, the only failure point here is</span>    <span class="hljs-comment">//       a mess in InitStackHwm. We do not have a reasonable way to recover from that, so abort</span>    <span class="hljs-comment">//       the runtime in such a case. In case this ever changes, we need to make sure here to</span>    <span class="hljs-comment">//       delete the tmp_jni_env, as we own it at this point.</span>    <span class="hljs-built_in">CHECK</span>(self-&gt;<span class="hljs-built_in">Init</span>(runtime-&gt;<span class="hljs-built_in">GetThreadList</span>(), runtime-&gt;<span class="hljs-built_in">GetJavaVM</span>(), self-&gt;tlsPtr_.tmp_jni_env));    self-&gt;tlsPtr_.tmp_jni_env = <span class="hljs-literal">nullptr</span>;    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">EndThreadBirth</span>();  &#125;  &#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;    self-&gt;<span class="hljs-built_in">InitStringEntryPoints</span>();    <span class="hljs-comment">// Copy peer into self, deleting global reference when done.</span>    <span class="hljs-built_in">CHECK</span>(self-&gt;tlsPtr_.jpeer != <span class="hljs-literal">nullptr</span>);    self-&gt;tlsPtr_.opeer = soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Object&gt;(self-&gt;tlsPtr_.jpeer).<span class="hljs-built_in">Ptr</span>();    <span class="hljs-comment">// Make sure nothing can observe both opeer and jpeer set at the same time.</span>    self-&gt;<span class="hljs-built_in">DeleteJPeer</span>(self-&gt;<span class="hljs-built_in">GetJniEnv</span>());    self-&gt;<span class="hljs-built_in">SetThreadName</span>(self-&gt;<span class="hljs-built_in">GetThreadName</span>()-&gt;<span class="hljs-built_in">ToModifiedUtf8</span>().<span class="hljs-built_in">c_str</span>());    ArtField* priorityField = jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_priority);    self-&gt;<span class="hljs-built_in">SetNativePriority</span>(priorityField-&gt;<span class="hljs-built_in">GetInt</span>(self-&gt;tlsPtr_.opeer));    runtime-&gt;<span class="hljs-built_in">GetRuntimeCallbacks</span>()-&gt;<span class="hljs-built_in">ThreadStart</span>(self);    <span class="hljs-comment">// Unpark ourselves if the java peer was unparked before it started (see</span>    <span class="hljs-comment">// b/28845097#comment49 for more information)</span>    ArtField* unparkedField = jni::<span class="hljs-built_in">DecodeArtField</span>(        WellKnownClasses::java_lang_Thread_unparkedBeforeStart);    <span class="hljs-type">bool</span> should_unpark = <span class="hljs-literal">false</span>;    &#123;      <span class="hljs-comment">// Hold the lock here, so that if another thread calls unpark before the thread starts</span>      <span class="hljs-comment">// we don&#x27;t observe the unparkedBeforeStart field before the unparker writes to it,</span>      <span class="hljs-comment">// which could cause a lost unpark.</span>      <span class="hljs-function">art::MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(soa.Self(), *art::Locks::thread_list_lock_)</span></span>;      should_unpark = unparkedField-&gt;<span class="hljs-built_in">GetBoolean</span>(self-&gt;tlsPtr_.opeer) == JNI_TRUE;    &#125;    <span class="hljs-keyword">if</span> (should_unpark) &#123;      self-&gt;<span class="hljs-built_in">Unpark</span>();    &#125;    <span class="hljs-comment">// 重点在这里，执行 Thread.run()</span>    <span class="hljs-comment">// Invoke the &#x27;run&#x27; method of our java.lang.Thread.</span>    ObjPtr&lt;mirror::Object&gt; receiver = self-&gt;tlsPtr_.opeer;    jmethodID mid = WellKnownClasses::java_lang_Thread_run;    <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">ref</span><span class="hljs-params">(soa.Env(), soa.AddLocalReference&lt;jobject&gt;(receiver))</span></span>;    <span class="hljs-built_in">InvokeVirtualOrInterfaceWithJValues</span>(soa, ref.<span class="hljs-built_in">get</span>(), mid, <span class="hljs-literal">nullptr</span>);  &#125;  <span class="hljs-comment">// Thread.run() 返回后就销毁此线程</span>  <span class="hljs-comment">// Detach and delete self.</span>  Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetThreadList</span>()-&gt;<span class="hljs-built_in">Unregister</span>(self);  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-comment">// art/runtime/thread_list.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadList::Unregister</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK_EQ</span>(self, Thread::<span class="hljs-built_in">Current</span>());  <span class="hljs-built_in">CHECK_NE</span>(self-&gt;<span class="hljs-built_in">GetState</span>(), kRunnable);  Locks::mutator_lock_-&gt;<span class="hljs-built_in">AssertNotHeld</span>(self);  <span class="hljs-built_in">VLOG</span>(threads) &lt;&lt; <span class="hljs-string">&quot;ThreadList::Unregister() &quot;</span> &lt;&lt; *self;  &#123;    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;    ++unregistering_count_;  &#125;  <span class="hljs-comment">// Any time-consuming destruction, plus anything that can call back into managed code or</span>  <span class="hljs-comment">// suspend and so on, must happen at this point, and not in ~Thread. The self-&gt;Destroy is what</span>  <span class="hljs-comment">// causes the threads to join. It is important to do this after incrementing unregistering_count_</span>  <span class="hljs-comment">// since we want the runtime to wait for the daemon threads to exit before deleting the thread</span>  <span class="hljs-comment">// list.</span>  self-&gt;<span class="hljs-built_in">Destroy</span>();  <span class="hljs-comment">// If tracing, remember thread id and name before thread exits.</span>  Trace::<span class="hljs-built_in">StoreExitingThreadInfo</span>(self);  <span class="hljs-type">uint32_t</span> thin_lock_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">// Remove and delete the Thread* while holding the thread_list_lock_ and</span>    <span class="hljs-comment">// thread_suspend_count_lock_ so that the unregistering thread cannot be suspended.</span>    <span class="hljs-comment">// Note: deliberately not using MutexLock that could hold a stale self pointer.</span>    &#123;      <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Contains</span>(self)) &#123;        std::string thread_name;        self-&gt;<span class="hljs-built_in">GetThreadName</span>(thread_name);        std::ostringstream os;        <span class="hljs-built_in">DumpNativeStack</span>(os, <span class="hljs-built_in">GetTid</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;  native: &quot;</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Request to unregister unattached thread &quot;</span> &lt;&lt; thread_name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; os.<span class="hljs-built_in">str</span>();        <span class="hljs-keyword">break</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        MutexLock <span class="hljs-built_in">mu2</span>(self, *Locks::thread_suspend_count_lock_);        <span class="hljs-keyword">if</span> (!self-&gt;<span class="hljs-built_in">IsSuspended</span>()) &#123;          list_.<span class="hljs-built_in">remove</span>(self);          <span class="hljs-keyword">break</span>;        &#125;      &#125;    &#125;    <span class="hljs-comment">// In the case where we are not suspended yet, sleep to leave other threads time to execute.</span>    <span class="hljs-comment">// This is important if there are realtime threads. b/111277984</span>    <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// We failed to remove the thread due to a suspend request, loop and try again.</span>  &#125;  <span class="hljs-keyword">delete</span> self;  <span class="hljs-comment">// Release the thread ID after the thread is finished and deleted to avoid cases where we can</span>  <span class="hljs-comment">// temporarily have multiple threads with the same thread id. When this occurs, it causes</span>  <span class="hljs-comment">// problems in FindThreadByThreadId / SuspendThreadByThreadId.</span>  <span class="hljs-built_in">ReleaseThreadId</span>(<span class="hljs-literal">nullptr</span>, thin_lock_id);  <span class="hljs-comment">// Clear the TLS data, so that the underlying native thread is recognizably detached.</span>  <span class="hljs-comment">// (It may wish to reattach later.)</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __BIONIC__</span>  __get_tls()[TLS_SLOT_ART_THREAD_SELF] = <span class="hljs-literal">nullptr</span>;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_setspecific, (Thread::pthread_key_self_, <span class="hljs-literal">nullptr</span>), <span class="hljs-string">&quot;detach self&quot;</span>);  Thread::self_tls_ = <span class="hljs-literal">nullptr</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  <span class="hljs-comment">// Signal that a thread just detached.</span>  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, *Locks::thread_list_lock_)</span></span>;  --unregistering_count_;  Locks::thread_exit_cond_-&gt;<span class="hljs-built_in">Broadcast</span>(<span class="hljs-literal">nullptr</span>);&#125;<span class="hljs-comment">// art/runtime/thread.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::Destroy</span><span class="hljs-params">()</span> </span>&#123;  Thread* self = <span class="hljs-keyword">this</span>;  <span class="hljs-built_in">DCHECK_EQ</span>(self, Thread::<span class="hljs-built_in">Current</span>());  <span class="hljs-keyword">if</span> (tlsPtr_.jni_env != <span class="hljs-literal">nullptr</span>) &#123;    &#123;      <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;      <span class="hljs-function">MonitorExitVisitor <span class="hljs-title">visitor</span><span class="hljs-params">(self)</span></span>;      <span class="hljs-comment">// On thread detach, all monitors entered with JNI MonitorEnter are automatically exited.</span>      tlsPtr_.jni_env-&gt;monitors_.<span class="hljs-built_in">VisitRoots</span>(&amp;visitor, <span class="hljs-built_in">RootInfo</span>(kRootVMInternal));    &#125;    <span class="hljs-comment">// Release locally held global references which releasing may require the mutator lock.</span>    <span class="hljs-keyword">if</span> (tlsPtr_.jpeer != <span class="hljs-literal">nullptr</span>) &#123;      <span class="hljs-comment">// If pthread_create fails we don&#x27;t have a jni env here.</span>      tlsPtr_.jni_env-&gt;<span class="hljs-built_in">DeleteGlobalRef</span>(tlsPtr_.jpeer);      tlsPtr_.jpeer = <span class="hljs-literal">nullptr</span>;    &#125;    <span class="hljs-keyword">if</span> (tlsPtr_.class_loader_override != <span class="hljs-literal">nullptr</span>) &#123;      tlsPtr_.jni_env-&gt;<span class="hljs-built_in">DeleteGlobalRef</span>(tlsPtr_.class_loader_override);      tlsPtr_.class_loader_override = <span class="hljs-literal">nullptr</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (tlsPtr_.opeer != <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;    <span class="hljs-comment">// 销毁线程的时候会检查一下有没 pending exception，也就是此线程在执行代码过程中发生的 uncaught exception</span>    <span class="hljs-comment">// We may need to call user-supplied managed code, do this before final clean-up.</span>    <span class="hljs-built_in">HandleUncaughtExceptions</span>(soa);    <span class="hljs-built_in">RemoveFromThreadGroup</span>(soa);    Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();    <span class="hljs-keyword">if</span> (runtime != <span class="hljs-literal">nullptr</span>) &#123;      runtime-&gt;<span class="hljs-built_in">GetRuntimeCallbacks</span>()-&gt;<span class="hljs-built_in">ThreadDeath</span>(self);    &#125;    <span class="hljs-comment">// this.nativePeer = 0;</span>    <span class="hljs-keyword">if</span> (Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">IsActiveTransaction</span>()) &#123;      jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_nativePeer)          -&gt;<span class="hljs-built_in">SetLong</span>&lt;<span class="hljs-literal">true</span>&gt;(tlsPtr_.opeer, <span class="hljs-number">0</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_nativePeer)          -&gt;<span class="hljs-built_in">SetLong</span>&lt;<span class="hljs-literal">false</span>&gt;(tlsPtr_.opeer, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// Thread.join() is implemented as an Object.wait() on the Thread.lock object. Signal anyone</span>    <span class="hljs-comment">// who is waiting.</span>    ObjPtr&lt;mirror::Object&gt; lock =        jni::<span class="hljs-built_in">DecodeArtField</span>(WellKnownClasses::java_lang_Thread_lock)-&gt;<span class="hljs-built_in">GetObject</span>(tlsPtr_.opeer);    <span class="hljs-comment">// (This conditional is only needed for tests, where Thread.lock won&#x27;t have been set.)</span>    <span class="hljs-keyword">if</span> (lock != <span class="hljs-literal">nullptr</span>) &#123;      <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;      <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(lock))</span></span>;      <span class="hljs-function">ObjectLock&lt;mirror::Object&gt; <span class="hljs-title">locker</span><span class="hljs-params">(self, h_obj)</span></span>;      locker.<span class="hljs-built_in">NotifyAll</span>();    &#125;    tlsPtr_.opeer = <span class="hljs-literal">nullptr</span>;  &#125;  &#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(self)</span></span>;    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">RevokeThreadLocalBuffers</span>(<span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-comment">// Mark-stack revocation must be performed at the very end. No</span>  <span class="hljs-comment">// checkpoint/flip-function or read-barrier should be called after this.</span>  <span class="hljs-keyword">if</span> (kUseReadBarrier) &#123;    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">ConcurrentCopyingCollector</span>()-&gt;<span class="hljs-built_in">RevokeThreadLocalMarkStack</span>(<span class="hljs-keyword">this</span>);  &#125;&#125;<span class="hljs-comment">// art/runtime/thread.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::HandleUncaughtExceptions</span><span class="hljs-params">(ScopedObjectAccessAlreadyRunnable&amp; soa)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsExceptionPending</span>()) &#123;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">peer</span><span class="hljs-params">(tlsPtr_.jni_env, soa.AddLocalReference&lt;jobject&gt;(tlsPtr_.opeer))</span></span>;  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, kNative)</span></span>;  <span class="hljs-comment">// Get and clear the exception.</span>  <span class="hljs-function">ScopedLocalRef&lt;jthrowable&gt; <span class="hljs-title">exception</span><span class="hljs-params">(tlsPtr_.jni_env, tlsPtr_.jni_env-&gt;ExceptionOccurred())</span></span>;  tlsPtr_.jni_env-&gt;<span class="hljs-built_in">ExceptionClear</span>();  <span class="hljs-comment">// 如果存在 pending exception/uncaught exception，则执行 Thread.dispatchUncaughtException()</span>  <span class="hljs-comment">// Call the Thread instance&#x27;s dispatchUncaughtException(Throwable)</span>  tlsPtr_.jni_env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(peer.<span class="hljs-built_in">get</span>(),      WellKnownClasses::java_lang_Thread_dispatchUncaughtException,      exception.<span class="hljs-built_in">get</span>());  <span class="hljs-comment">// If the dispatchUncaughtException threw, clear that exception too.</span>  tlsPtr_.jni_env-&gt;<span class="hljs-built_in">ExceptionClear</span>();&#125;</code></pre></div><p>线程进入 VM 的入口点是 <code>Thread.run()</code>，执行完毕（或者发生 uncaught exception 被中断字节码的执行）退出 VM 回到 native 代码后，就执行销毁线程的流程：<code>ThreadList::Unregister</code> -&gt; <code>Thread::Destroy</code>，其中 <code>HandleUncaughtExceptions</code> 会检查是否有 uncaught exception/pending exception，有的话再次进入 VM 执行 <code>Thread.dispatchUncaughtException</code></p><h4 id="UEH-的入口点"><a href="#UEH-的入口点" class="headerlink" title="UEH 的入口点"></a>UEH 的入口点</h4><p>如果有 <code>Thread.uncaughtExceptionHandler</code> 则直接给它处理，否则事件冒泡给到 ThreadGroup，ThreadGroup 会把异常一直冒泡到 root ThreadGroup，然后交由 <code>DefaultUncaughtExceptionHandler</code> 处理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchUncaughtException</span><span class="hljs-params">(Throwable e)</span> &#123;        <span class="hljs-comment">// BEGIN Android-added: uncaughtExceptionPreHandler for use by platform.</span>        Thread.<span class="hljs-type">UncaughtExceptionHandler</span> <span class="hljs-variable">initialUeh</span> <span class="hljs-operator">=</span>                Thread.getUncaughtExceptionPreHandler();        <span class="hljs-keyword">if</span> (initialUeh != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                initialUeh.uncaughtException(<span class="hljs-built_in">this</span>, e);            &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error ignored) &#123;                <span class="hljs-comment">// Throwables thrown by the initial handler are ignored</span>            &#125;                <span class="hljs-comment">// END Android-added: uncaughtExceptionPreHandler for use by platform.</span>        getUncaughtExceptionHandler().uncaughtException(<span class="hljs-built_in">this</span>, e);    &#125;        <span class="hljs-keyword">public</span> UncaughtExceptionHandler <span class="hljs-title function_">getUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> uncaughtExceptionHandler != <span class="hljs-literal">null</span> ?            uncaughtExceptionHandler : group;    &#125;        &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroup</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;            parent.uncaughtException(t, e);        &#125; <span class="hljs-keyword">else</span> &#123;            Thread.<span class="hljs-type">UncaughtExceptionHandler</span> <span class="hljs-variable">ueh</span> <span class="hljs-operator">=</span>                Thread.getDefaultUncaughtExceptionHandler();            <span class="hljs-keyword">if</span> (ueh != <span class="hljs-literal">null</span>) &#123;                ueh.uncaughtException(t, e);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> ThreadDeath)) &#123;                System.err.print(<span class="hljs-string">&quot;Exception in thread \&quot;&quot;</span>                                 + t.getName() + <span class="hljs-string">&quot;\&quot; &quot;</span>);                e.printStackTrace(System.err);            &#125;        &#125;    &#125;    &#125;</code></pre></div><h2 id="谁打印了-FATAL-EXCEPTION"><a href="#谁打印了-FATAL-EXCEPTION" class="headerlink" title="谁打印了 FATAL EXCEPTION"></a>谁打印了 FATAL EXCEPTION</h2><p>在上面的代码块里 dispatchUncaughtException 还调用了 <code>Thread.uncaughtExceptionPreHandler</code>，这个 handler 是在 app 进程初始化时配置的，而且没有暴露给用户，就是它打印了 <code>AndroidRuntime: FATAL EXCEPTION</code> 的日志</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeInit</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commonInit</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">&quot;Entered RuntimeInit!&quot;</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * set handlers; these apply to all threads in the VM. Apps can replace</span><span class="hljs-comment">         * the default handler, but not the pre handler.</span><span class="hljs-comment">         */</span>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>();        RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KillApplicationHandler</span>(loggingHandler));        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Install a time zone supplier that uses the Android persistent time zone system property.</span><span class="hljs-comment">         */</span>        RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="hljs-string">&quot;persist.sys.timezone&quot;</span>));        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Sets handler for java.util.logging to use Android log facilities.</span><span class="hljs-comment">         * The odd &quot;new instance-and-then-throw-away&quot; is a mirror of how</span><span class="hljs-comment">         * the &quot;java.util.logging.config.class&quot; system property works. We</span><span class="hljs-comment">         * can&#x27;t use the system property here since the logger has almost</span><span class="hljs-comment">         * certainly already been initialized.</span><span class="hljs-comment">         */</span>        LogManager.getLogManager().reset();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndroidConfig</span>();        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Sets the default HTTP User-Agent used by HttpURLConnection.</span><span class="hljs-comment">         */</span>        <span class="hljs-type">String</span> <span class="hljs-variable">userAgent</span> <span class="hljs-operator">=</span> getDefaultUserAgent();        System.setProperty(<span class="hljs-string">&quot;http.agent&quot;</span>, userAgent);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Wire socket tagging to traffic stats.</span><span class="hljs-comment">         */</span>        NetworkManagementSocketTagger.install();        initialized = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">mTriggered</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;            mTriggered = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// Don&#x27;t re-enter if KillApplicationHandler has already run</span>            <span class="hljs-keyword">if</span> (mCrashing) <span class="hljs-keyword">return</span>;            <span class="hljs-comment">// mApplicationObject is null for non-zygote java programs (e.g. &quot;am&quot;)</span>            <span class="hljs-comment">// There are also apps running with the system UID. We don&#x27;t want the</span>            <span class="hljs-comment">// first clause in either of these two cases, only for system_server.</span>            <span class="hljs-keyword">if</span> (mApplicationObject == <span class="hljs-literal">null</span> &amp;&amp; (Process.SYSTEM_UID == Process.myUid())) &#123;                Clog_e(TAG, <span class="hljs-string">&quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot;</span> + t.getName(), e);            &#125; <span class="hljs-keyword">else</span> &#123;                logUncaught(t.getName(), ActivityThread.currentProcessName(), Process.myPid(), e);            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logUncaught</span><span class="hljs-params">(String threadName, String processName, <span class="hljs-type">int</span> pid, Throwable e)</span> &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-comment">// The &quot;FATAL EXCEPTION&quot; string is still used on Android even though</span>        <span class="hljs-comment">// apps can set a custom UncaughtExceptionHandler that renders uncaught</span>        <span class="hljs-comment">// exceptions non-fatal.</span>        message.append(<span class="hljs-string">&quot;FATAL EXCEPTION: &quot;</span>).append(threadName).append(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">if</span> (processName != <span class="hljs-literal">null</span>) &#123;            message.append(<span class="hljs-string">&quot;Process: &quot;</span>).append(processName).append(<span class="hljs-string">&quot;, &quot;</span>);        &#125;        message.append(<span class="hljs-string">&quot;PID: &quot;</span>).append(pid);        Clog_e(TAG, message.toString(), e);    &#125;    &#125;</code></pre></div><h2 id="KillApplicationHandler"><a href="#KillApplicationHandler" class="headerlink" title="KillApplicationHandler"></a>KillApplicationHandler</h2><p>如上面的代码所示，app 进程初始化时 <code>DefaultUncaughtExceptionHandler</code> 被设置为 <code>KillApplicationHandler</code>，如果新线程没有设置 UncaughtExceptionHandler 或者没有替换 DefaultUncaughtExceptionHandler，那么子线程的 Uncaught Exception 也会导致 app 被 killed</p><p>KillApplicationHandler 主要干了两件事：</p><ol><li>弹出 <code>异常退出</code> 对话框，可以让用户选择重启 app</li><li>退出 app 进程</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KillApplicationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoggingHandler mLoggingHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Create a new KillApplicationHandler that follows the given LoggingHandler.</span><span class="hljs-comment">     * If &#123;<span class="hljs-doctag">@link</span> #uncaughtException(Thread, Throwable) uncaughtException&#125; is called</span><span class="hljs-comment">     * on the created instance without &#123;<span class="hljs-doctag">@code</span> loggingHandler&#125; having been triggered,</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> LoggingHandler#uncaughtException(Thread, Throwable)</span><span class="hljs-comment">     * loggingHandler.uncaughtException&#125; will be called first.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loggingHandler the &#123;<span class="hljs-doctag">@link</span> LoggingHandler&#125; expected to have run before</span><span class="hljs-comment">     *     this instance&#x27;s &#123;<span class="hljs-doctag">@link</span> #uncaughtException(Thread, Throwable) uncaughtException&#125;</span><span class="hljs-comment">     *     is being called.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">KillApplicationHandler</span><span class="hljs-params">(LoggingHandler loggingHandler)</span> &#123;        <span class="hljs-built_in">this</span>.mLoggingHandler = Objects.requireNonNull(loggingHandler);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            ensureLogging(t, e);            <span class="hljs-comment">// Don&#x27;t re-enter -- avoid infinite loops if crash-reporting crashes.</span>            <span class="hljs-keyword">if</span> (mCrashing) <span class="hljs-keyword">return</span>;            mCrashing = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// Try to end profiling. If a profiler is running at this point, and we kill the</span>            <span class="hljs-comment">// process (below), the in-memory buffer will be lost. So try to stop, which will</span>            <span class="hljs-comment">// flush the buffer. (This makes method trace profiling useful to debug crashes.)</span>            <span class="hljs-keyword">if</span> (ActivityThread.currentActivityThread() != <span class="hljs-literal">null</span>) &#123;                ActivityThread.currentActivityThread().stopProfiling();            &#125;            <span class="hljs-comment">// Bring up crash dialog, wait for it to be dismissed</span>            ActivityManager.getService().handleApplicationCrash(                    mApplicationObject, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationErrorReport</span>.ParcelableCrashInfo(e));        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;            <span class="hljs-keyword">if</span> (t2 <span class="hljs-keyword">instanceof</span> DeadObjectException) &#123;                <span class="hljs-comment">// System process is dead; ignore</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    Clog_e(TAG, <span class="hljs-string">&quot;Error reporting crash&quot;</span>, t2);                &#125; <span class="hljs-keyword">catch</span> (Throwable t3) &#123;                    <span class="hljs-comment">// Even Clog_e() fails!  Oh well.</span>                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// Try everything to make sure this process goes away.</span>            Process.killProcess(Process.myPid());            System.exit(<span class="hljs-number">10</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Ensures that the logging handler has been triggered.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * See b/73380984. This reinstates the pre-O behavior of</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *   &#123;<span class="hljs-doctag">@code</span> thread.getUncaughtExceptionHandler().uncaughtException(thread, e);&#125;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * logging the exception (in addition to killing the app). This behavior</span><span class="hljs-comment">     * was never documented / guaranteed but helps in diagnostics of apps</span><span class="hljs-comment">     * using the pattern.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * If this KillApplicationHandler is invoked the &quot;regular&quot; way (by</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Thread#dispatchUncaughtException(Throwable)</span><span class="hljs-comment">     * Thread.dispatchUncaughtException&#125; in case of an uncaught exception)</span><span class="hljs-comment">     * then the pre-handler (expected to be &#123;<span class="hljs-doctag">@link</span> #mLoggingHandler&#125;) will already</span><span class="hljs-comment">     * have run. Otherwise, we manually invoke it here.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureLogging</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;        <span class="hljs-keyword">if</span> (!mLoggingHandler.mTriggered) &#123;            <span class="hljs-keyword">try</span> &#123;                mLoggingHandler.uncaughtException(t, e);            &#125; <span class="hljs-keyword">catch</span> (Throwable loggingThrowable) &#123;                <span class="hljs-comment">// Ignored.</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="主线程遇到-UE-时发生了什么"><a href="#主线程遇到-UE-时发生了什么" class="headerlink" title="主线程遇到 UE 时发生了什么"></a>主线程遇到 UE 时发生了什么</h2><p>上面在研究子线程时已经发现：Uncaught Exception 会中断字节码的执行流程从而回到 native 代码，主线程在回到 native 代码后选择依次执行 <code>DetachCurrentThread</code> 和 <code>DestroyJavaVM</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// zygote 进程的 native 层入口点，app 进程是由 zygote fork 出来的，所以这也算是 app 进程的入口点</span><span class="hljs-comment">// frameworks/base/cmds/app_process/app_main.cpp</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">// 启动 VM，首次进入 java 层，入口点是 ZygoteInit.main(args)</span></span><span class="hljs-function"><span class="hljs-comment">// frameworks/base/core/jni/AndroidRuntime.cpp </span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AndroidRuntime::start</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* className, <span class="hljs-type">const</span> Vector&lt;String8&gt;&amp; options, <span class="hljs-type">bool</span> zygote)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 启动 VM 后此线程就成为 VM 的主线程，直到 VM 退出后此线程才会结束生命</span>    <span class="hljs-comment">// Start VM.  This thread becomes the main thread of the VM, and will not return until the VM exits.</span>    JNIEnv* env;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// ZygoteInit.main(args)</span>    env-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// 还记得上面出现过的这行日志吗：D/AndroidRuntime: Shutting down VM</span>    <span class="hljs-comment">// 就是在这里打印出来的，此时主线程已经退出了 VM 并准备销毁 VM</span>    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;Shutting down VM\n&quot;</span>);    <span class="hljs-keyword">if</span> (mJavaVM-&gt;<span class="hljs-built_in">DetachCurrentThread</span>() != JNI_OK)        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Warning: unable to detach main thread\n&quot;</span>);    <span class="hljs-keyword">if</span> (mJavaVM-&gt;<span class="hljs-built_in">DestroyJavaVM</span>() != <span class="hljs-number">0</span>)        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);&#125;</code></pre></div><p>DetachCurrentThread 会调用 <code>HandleUncaughtExceptions</code>，这个方法也在上面介绍过了，它会检查是否有 uncaught exception/pending exception，有的话则再次进入 VM 执行 <code>Thread.dispatchUncaughtException()</code>，所以主线程的 uncaught exception 也是能够被捕获的</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/jni/java_vm_ext.cc</span><span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">DetachCurrentThread</span><span class="hljs-params">(JavaVM* vm)</span> </span>&#123;  <span class="hljs-keyword">if</span> (vm == <span class="hljs-literal">nullptr</span> || Thread::<span class="hljs-built_in">Current</span>() == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> JNI_ERR;  &#125;  JavaVMExt* raw_vm = <span class="hljs-built_in">reinterpret_cast</span>&lt;JavaVMExt*&gt;(vm);  Runtime* runtime = raw_vm-&gt;<span class="hljs-built_in">GetRuntime</span>();  runtime-&gt;<span class="hljs-built_in">DetachCurrentThread</span>();  <span class="hljs-keyword">return</span> JNI_OK;&#125;<span class="hljs-comment">// art/runtime/runtime.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::DetachCurrentThread</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-function">ScopedTrace <span class="hljs-title">trace</span><span class="hljs-params">(__FUNCTION__)</span></span>;  Thread* self = Thread::<span class="hljs-built_in">Current</span>();  <span class="hljs-keyword">if</span> (self == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;attempting to detach thread that is not attached&quot;</span>;  &#125;  <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">HasManagedStack</span>()) &#123;    <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; *Thread::<span class="hljs-built_in">Current</span>() &lt;&lt; <span class="hljs-string">&quot; attempting to detach while still running code&quot;</span>;  &#125;  thread_list_-&gt;<span class="hljs-built_in">Unregister</span>(self);&#125;ThreadList::UnregisterThread::DestroyHandleUncaughtExceptions</code></pre></div><p>然后主线程就会把 VM 销毁掉并结束自己的生命周期，但 app 进程并没有结束，还有其他 native thread 的存在，从系统申请的资源如 Surface 也没有释放，所以 app 页面依然存在并没有出现 <strong>崩溃/闪退</strong> 的现象</p><p>归属于 app 的窗口没有被回收，那么 input 事件依然会分发给 app，input 事件是需要主线程来消费的，但此时主线程已退出，很明显会阻塞住，所以会触发 ANR</p><p>如果用户选择继续等待，app 就变成一个没有 VM 没有主线程的僵尸进程但还没退出，选择确定会发送 SIGKILL 信号杀死 app 进程</p><h2 id="收集崩溃日志"><a href="#收集崩溃日志" class="headerlink" title="收集崩溃日志"></a>收集崩溃日志</h2><ul><li>DefaultUncaughtExceptionHandler 可以收集到 app 的崩溃日志，也就是主线程的 Uncaught Exception</li><li>当然它也可以收集到子线程的 Uncaught Exception</li><li>它可以提高 app 的稳定性，防止 KillApplicationHandler 粗暴地把 app 杀死</li><li>理论上来说，把崩溃日志写入文件，甚至于即刻上传至服务器都是可以做到的，因为触发 ANR 需要 5s，然后弹出 ANR 对话框直到用户选择杀死 app 也需要几秒钟的时间</li><li><a href="../../../../2021/06/20/kill-exit/">Shutdown Hook</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>uncaught exception</tag>
      
      <tag>exception</tag>
      
      <tag>崩溃</tag>
      
      <tag>崩溃日志</tag>
      
      <tag>crash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 IO 框架：Okio</title>
    <link href="/2021/06/12/okio/"/>
    <url>/2021/06/12/okio/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><table><thead><tr><th>Okio</th><th>java.io</th></tr></thead><tbody><tr><td>ByteString</td><td>String</td></tr><tr><td>Buffer</td><td>ByteArray</td></tr><tr><td>Source</td><td>InputStream</td></tr><tr><td>Sink</td><td>OutputStream</td></tr><tr><td>Segment</td><td></td></tr><tr><td>SegmentPool</td><td></td></tr></tbody></table><h3 id="ByteString"><a href="#ByteString" class="headerlink" title="ByteString"></a>ByteString</h3><p>虽然 <code>okio.ByteString</code> 对标的是 <code>java.lang.String</code>，但是它操作的对象却是 String 内部的 ByteArray，相较于 String 的 <strong>字符数据</strong> 更贴近于 <strong>字节数据</strong> 的概念</p><table><thead><tr><th>类别</th><th>API</th></tr></thead><tbody><tr><td>字符编码（charset）</td><td>utf8()</td></tr><tr><td></td><td>string(charset)</td></tr><tr><td>消息摘要（message digest）</td><td><code>md5()</code> 128-bit</td></tr><tr><td></td><td><code>hmacSha1(key)</code> 160-bit, <code>hmacSha256(key)</code> 256-bit, <code>hmacSha512(key)</code> 512-bit <br> hmac 是额外添加了一个秘钥作为影响因子的 sha</td></tr><tr><td></td><td><code>sha1()</code> 160-bit, <code>sha256()</code> 256-bit, <code>sha512()</code> 512-bit</td></tr><tr><td></td><td>digest(algorithm)</td></tr><tr><td>基于字节的匹配和查找（而不是字符）</td><td>rangeEquals(offset, other ByteString/ByteArray, otherOffset, byteCount)</td></tr><tr><td></td><td>startsWith(ByteString/ByteArray)</td></tr><tr><td></td><td>endsWith(ByteString/ByteArray)</td></tr><tr><td></td><td>indexOf(other ByteString/ByteArray, fromIndex)</td></tr><tr><td></td><td>lastIndexOf(other ByteString/ByteArray, fromIndex)</td></tr><tr><td>其他</td><td>hex()</td></tr><tr><td></td><td>toAsciiLowercase()</td></tr><tr><td></td><td>toAsciiUppercase()</td></tr></tbody></table><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul><li>Buffer 对其内部的内存（ByteArray）进行分段管理（Segment），就像内存分页一样</li><li>分段管理可以逐步回收已读的 Segment 而不必始终占用一大块的内存（Buffer 属于 <strong>流式</strong> API，不能重复读，那么已读的数据就可以及时释放掉）</li><li>分段管理还可以很方便地与另一个 Buffer 共享某一段数据（或是构造出共享数据的 clone，或是以共享替代传输的 copyTo，或是共享某几段的 ByteString），只需要让别的段（Segment）引用同一块内存（ByteArray）即可，别的 Buffer 不能往共享数据的 Segment 里写数据，只能自己往环里新插入一个段来写入</li><li>小块的段还很方便回收和复用，用一个池即可（<code>SegmentPool</code>），段太大容易造成内存浪费</li><li>Buffer 内部的 <code>Segment</code> 通过 <code>Segment.prev</code> 和 <code>Segment.next</code> 形成一个环（头尾相连的链表）</li><li><code>Segment.limit</code> 是下一次写操作写入的位置，<code>Segment.pos</code> 是下一次读操作读取的位置，正常情况下 <code>0 &lt;= pos &lt;= limit &lt;= max</code></li><li>写入（write）的节点总是 tail 节点（head.prev），如果当前的 tail 不满足写入条件（Segment 不够容量 or 是个共享的 Segment），会插入一个新的 Segment 到 head.prev 作为当前 tail 来使用</li><li>读操作（read）总是从 head 开始，读操作会使 pos 逐步增长（往前走），当 pos 与 limit 相遇时（pos == limit），说明此节点的数据已读完，会从环里删除此节点，并将 next 作为新的 head</li><li>初始环是空的（null），第一次写操作会初始化第一个节点 head，此时 head.prev 和 head.next 都指向它自己</li></ul><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>read/write</td><td>读写各种类型的数据类型</td></tr><tr><td>copy()/clone()</td><td>返回一个共享数据的 Buffer <br> 这个就比较有意思了，我们知道 Buffer 用 Segment 对数据进行分片管理（类似于内存的分页），这里并没有真正将数据拷贝一份到另一个 Buffer（要节约内存嘛），而是让另一个 Buffer 里的 Segment 与当前 Buffer 里的 Segment 共享用一个 ByteArray <br> 新的 Segment 可以有自己的 pos 和 limit，可以读但不能写（Segment.owner == false，写入的数据会放到新创建的/自己的 Segment 里去），不然会把别人的数据搞乱，当然 Segment 的持有者是可以写的（Segment.owner == true） <br> 共享了数据的 Segment 不能被 SegmentPool 回收（因为可能别人还在用，而且内部没有计算器指示被多少人持有），它的 Segment.share == true</td></tr><tr><td>copyTo(Buffer)</td><td>使另一个 Buffer 与当前 Buffer 共享某一段数据</td></tr><tr><td>peek()</td><td>返回一个可以重复读的 Source（一般的 Source 跟 InputStream 一样是单向/流式的，不能重复读），但是这个 Buffer 作为 Source 的 backend，已读的数据 Source 也是无法读取的</td></tr><tr><td>snapshot(byteCount)</td><td>返回一个 ByteString（上面说过 Okio ByteString 对标 java.lang.String），特别的是它与 Buffer 是共享底层 ByteArray 的（不是共享 Segment，但会使 Segment.shared 置真） <br> ByteString 是不可变的所以它不会修改共享的 ByteArray</td></tr><tr><td>skip(byteCount)</td><td>跳过 byteCount 字节的数据，使读指针 pos 前进 byteCount 位（已读完的 Segment 将被回收）</td></tr><tr><td>inputStream()</td><td>把 Buffer 作为输入流的源</td></tr><tr><td>outputStream()</td><td>把 Buffer 作为输出流的目的地</td></tr><tr><td>copyTo(OutputStream)</td><td>将 Buffer 里的数据拷贝一份到 OutputStream，不移动 Segment.pos（也即不会释放已读数据）</td></tr><tr><td>writeTo(OutputStream)</td><td>将 Buffer 里的数据写入到 OutputStream，会移动 Segment.pos</td></tr><tr><td>readFrom(InputStream)</td><td>将 InputStream 里的数据读到 Buffer 里</td></tr></tbody></table><h3 id="SegmentPool"><a href="#SegmentPool" class="headerlink" title="SegmentPool"></a>SegmentPool</h3><ul><li>当需要新的 Segment 时总是会从池里拿（<code>Segment.take()</code>），当一个 Segment 从环里移除不再需要时总是会放回到池里去（<code>Segment.recycle(Segment)</code>）</li><li><code>SegmentPool</code> 是全局的，内部结构类似于 HashMap（数组 + 链表），只不过数组容量是固定的，通过 tid 决定用哪个链表</li><li>回收时（recycle）插入链表头部，复用时（take）取链表头</li><li>为了适应多线程环境链表的节点是 <code>AtomicReference&lt;Segment?&gt;</code>，回收和复用都使用 CAS 操作整个 SegmentPool 使用 CAS 替代锁（lock-free），竞争失败则放弃相关操作</li></ul><h3 id="各种各样的装饰器（Decorators）"><a href="#各种各样的装饰器（Decorators）" class="headerlink" title="各种各样的装饰器（Decorators）"></a>各种各样的装饰器（Decorators）</h3><p>跟 <code>java.io</code> 一样，Okio 为 Source/Sink 提供了各种各样的装饰器</p><table><thead><tr><th>class</th><th>作用</th></tr></thead><tbody><tr><td>HashingSource/HashingSink</td><td>提供成员属性 <code>hash</code>，在 read/write 时实时更新</td></tr><tr><td>GzipSource/GzipSink</td><td>类似于 GzipInputStream/GzipOutputStream，对 write 进行压缩，对 read 进行解压缩</td></tr><tr><td>BufferSource/BufferSink</td><td>具有一段 buffer 的输入流/输出流，默认实现就是 Buffer</td></tr><tr><td>CipherSource/CipherSink</td><td>实时对输入流/输出流进行加解密</td></tr><tr><td>Throttler</td><td>给输入流/输出流装一个节流阀，模拟限流/弱网的情况</td></tr><tr><td>Pipe</td><td>顾名思义它是一段管道，管道两端连着 Source 和 Sink，流向 Sink 的数据即是 Source 的输出，管道及其 Source 和 Sink 是线程安全的</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>nio</tag>
      
      <tag>okio</tag>
      
      <tag>io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入探索 java.io 和 nio</title>
    <link href="/2021/06/05/io-and-nio/"/>
    <url>/2021/06/05/io-and-nio/</url>
    
    <content type="html"><![CDATA[<h3 id="FileInputStream-FileOutputStream"><a href="#FileInputStream-FileOutputStream" class="headerlink" title="FileInputStream/FileOutputStream"></a>FileInputStream/FileOutputStream</h3><p><code>FileInputStream</code> 和 <code>FileOutputStream</code> 都属于“流式” API，就像流水（<code>Stream</code>）一样只能朝着一个方向读写，不能后退</p><p><code>FileInputStream</code> 相当于以只读模式读文件：open(O_RDONLY) -&gt; read -&gt; close(fd)</p><p><code>FileOutputStream</code> 相当于以只写模式写文件：open(O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC)) -&gt; write -&gt; close(fd)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// open</span>FileInputStream(File file)IoBridge.open(name, O_RDONLY)Libcore.os.open(path, flags, <span class="hljs-number">0666</span>)Linux.open(String path, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> mode)Linux_open(JNIEnv* env, jobject, jstring javaPath, jint flags, jint mode)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><span class="hljs-comment">// 系统调用 open 的参数 flags 必须包含三个访问模式（access modes）其中之一：</span><span class="hljs-comment">// O_CREAT： 如果文件不存在则创建之</span><span class="hljs-comment">// O_APPEND：以 APPEND 的模式打开文件（附加）</span><span class="hljs-comment">// O_TRUNC： 如果文件存在且以写模式打开，则把文件长度置为 0</span>open(pathname, flags, modes)<span class="hljs-comment">// read</span>FileInputStream.read(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)IoBridge.read(FileDescriptor fd, <span class="hljs-type">byte</span>[] bytes, <span class="hljs-type">int</span> byteOffset, <span class="hljs-type">int</span> byteCount)Libcore.os.read(FileDescriptor fd, <span class="hljs-type">byte</span>[] bytes, <span class="hljs-type">int</span> byteOffset, <span class="hljs-type">int</span> byteCount)Linux.readBytes(FileDescriptor fd, <span class="hljs-type">byte</span>[] bytes, <span class="hljs-type">int</span> byteOffset, <span class="hljs-type">int</span> byteCount)Linux_readBytes(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><span class="hljs-comment">// 系统调用，fd 有个成员属性 offset，read 从 offset 开始读取 count 个字节的数据到 buf，offset 也会随着增长 count</span>read(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">void</span> *buf, size_t count)<span class="hljs-comment">// write</span>FileOutputStream.write(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)IoBridge.write(FileDescriptor fd, <span class="hljs-type">byte</span>[] bytes, <span class="hljs-type">int</span> byteOffset, <span class="hljs-type">int</span> byteCount)Libcore.os.write(FileDescriptor fd, <span class="hljs-type">byte</span>[] bytes, <span class="hljs-type">int</span> byteOffset, <span class="hljs-type">int</span> byteCount)Linux.writeBytes(FileDescriptor fd, Object buffer, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> byteCount)Linux_writeBytes(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount)    <span class="hljs-comment">// libcore_io_Linux.cpp</span>write(<span class="hljs-type">int</span> fd, const <span class="hljs-keyword">void</span>* buf, size_t count)    <span class="hljs-comment">// 系统调用</span><span class="hljs-comment">// close</span>FileInputStream.close()IoBridge.closeAndSignalBlockedThreads(fd)Libcore.os.close(fd)Linux.close(fd)Linux_close(JNIEnv* env, jobject, jobject javaFd)    <span class="hljs-comment">// libcore_io_Linux.cpp</span>close(fd)    <span class="hljs-comment">// 系统调用</span></code></pre></div><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p><code>RandomAccessFile</code> 提供了读写操作，相当于 <code>FileInputStream</code> 和 <code>FileOutputStream</code> 的组合</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// open，其中 mode 与 imode 之间的映射关系为 </span><span class="hljs-comment">// r  - O_RDONLY         - 只读</span><span class="hljs-comment">// rw - O_RDWR | O_CREAT - 读写</span>RandomAccessFile(File file, String mode)IoBridge.open(name, imode)Libcore.os.open(path, flags, <span class="hljs-number">0666</span>)Linux.open(String path, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> mode)Linux_open(JNIEnv* env, jobject, jstring javaPath, jint flags, jint mode)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><span class="hljs-comment">// 系统调用 open 的参数 flags 必须包含三个访问模式（access modes）其中之一：</span><span class="hljs-comment">// O_CREAT： 如果文件不存在则创建之</span><span class="hljs-comment">// O_APPEND：以 APPEND 的模式打开文件（附加）</span><span class="hljs-comment">// O_TRUNC： 如果文件存在且以写模式打开，则把文件长度置为 0</span>open(pathname, flags, modes)<span class="hljs-comment">// read &amp; write</span>read(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len) -&gt; 系统调用 read<span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span> b[], <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> -&gt; 系统调用 write<span class="hljs-comment">// seek</span>RandomAccessFile.seek(<span class="hljs-type">long</span> pos)Libcore.os.lseek(fd, pos, SEEK_SET)Linux.lseek(FileDescriptor fd, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)Linux_lseek(JNIEnv* env, jobject, jobject javaFd, jlong offset, jint whence)    <span class="hljs-comment">// libcore_io_Linux.cpp</span><span class="hljs-comment">// 系统调用，改变已打开的文件描述的文件偏移（fd.offset，指示下一次读写的位置），其中 whence 的取值有：</span><span class="hljs-comment">// SEEK_SET - fd.offset = offset</span><span class="hljs-comment">// SEEK_CUR - fd.offset += offset</span><span class="hljs-comment">// SEEK_END - fd.offset = fd.end + offset</span>lseek(<span class="hljs-type">int</span> fd, off_t offset, <span class="hljs-type">int</span> whence)</code></pre></div><p>总之，传统的 <code>java.io</code> 都是基于系统调用 <code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code> 和 <code>close</code></p><ul><li><code>FileInputStream</code> 包装了 <code>read</code></li><li><code>FileOutputStream</code> 包装了 <code>write</code></li><li><code>RandomAccessFile</code> 包装了 <code>read</code> 和 <code>write</code></li></ul><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p><code>FileChannel</code> 的读写操作最终是执行系统调用 <code>pread/pwrite</code>（区别于 <code>read/write</code> 的是它们不改变 <code>fd.offset</code>）</p><blockquote><p><code>pread()</code> reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buffer starting at buf.  The file offset is not changed.</p><p><code>pwrite()</code> writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset offset.  The file offset is not changed.</p><p><code>read()</code> attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On  files  that  support seeking, the read operation commences at the file offset, and the file offset is incremented by the number of bytes read.</p><p><code>read()</code> attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On  files  that  support seeking, the read operation commences at the file offset, and the file offset is incremented by the number of bytes read.</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// read</span>FileChannel.read(ByteBuffer dst, <span class="hljs-type">long</span> position)FileChannelImpl.read(ByteBuffer dst, <span class="hljs-type">long</span> position)IOUtil.read(FileDescriptor fd, ByteBuffer dst, <span class="hljs-type">long</span> position, NativeDispatcher nd)IOUtil.readIntoNativeBuffer(FileDescriptor fd, ByteBuffer bb, <span class="hljs-type">long</span> position, NativeDispatcher nd)FileDispatcherImpl.pread0(FileDescriptor fd, <span class="hljs-type">long</span> address, <span class="hljs-type">int</span> len, <span class="hljs-type">long</span> position)FileDispatcherImpl_pread0(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jlong offset)    <span class="hljs-comment">// FileDispatcherImpl.c</span>pread64(fd, buf, len, offset)    <span class="hljs-comment">// 系统调用</span><span class="hljs-comment">// write</span>FileChannel.write(ByteBuffer src, <span class="hljs-type">long</span> position)FileChannelImpl.write(ByteBuffer src, <span class="hljs-type">long</span> position)IOUtil.write(FileDescriptor fd, ByteBuffer src, <span class="hljs-type">long</span> position, NativeDispatcher nd)IOUtil.writeFromNativeBuffer(FileDescriptor fd, ByteBuffer bb, <span class="hljs-type">long</span> position, NativeDispatcher nd)FileDispatcherImpl.pwrite0(FileDescriptor fd, <span class="hljs-type">long</span> address, <span class="hljs-type">int</span> len, <span class="hljs-type">long</span> position)FileDispatcherImpl_pwrite0(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jlong offset)    <span class="hljs-comment">// FileDispatcherImpl.c</span>pwrite64(<span class="hljs-type">int</span> __fd, const <span class="hljs-keyword">void</span>* __buf, size_t __count, off64_t __offset)    <span class="hljs-comment">// 系统调用</span></code></pre></div><h3 id="数组的两次复制"><a href="#数组的两次复制" class="headerlink" title="数组的两次复制"></a>数组的两次复制</h3><p>咋一看，<code>FileInputStream/FileOutputStream</code> 和 <code>FileChannel</code> 最终都是通过系统调用 <code>read/write</code> 完成文件的读写操作，那 NIO 的优势体现在哪呢？</p><p>其实在 C 层的入口点就可以看出来了，看下面的读操作，<code>Byte[]</code> 是作为 java object 传给 C 层的，对它的读写操作需要包裹在 <code>GetByteArrayElements/ReleaseByteArrayElements</code> 之间（通过 <code>ScopedBytesRW</code> 的构造函数和析构函数），<code>GetByteArrayElements</code> 会从 <code>Byte[]</code> 复制一份数据出来，<code>ReleaseByteArrayElements</code> 会回写数据到 <code>Byte[]</code>，也就是说 <code>Byte[]</code> 在 C 层走一圈会有两次额外的复制操作，数组越大越耗资源</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">Linux_readBytes</span><span class="hljs-params">(JNIEnv* env, jobject, jobject javaFd, jobject javaBytes, jint byteOffset, jint byteCount)</span> </span>&#123;    <span class="hljs-function">ScopedBytesRW <span class="hljs-title">bytes</span><span class="hljs-params">(env, javaBytes)</span></span>;    <span class="hljs-keyword">if</span> (bytes.<span class="hljs-built_in">get</span>() == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IO_FAILURE_RETRY</span>(env, <span class="hljs-type">ssize_t</span>, read, javaFd, bytes.<span class="hljs-built_in">get</span>() + byteOffset, byteCount);&#125;<span class="hljs-comment">// 看下 ScopedBytesRW 是什么</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedBytesRW</span> : <span class="hljs-keyword">public</span> ScopedBytes&lt;<span class="hljs-literal">false</span>&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ScopedBytesRW</span>(JNIEnv* env, jobject object) : <span class="hljs-built_in">ScopedBytes</span>&lt;<span class="hljs-literal">false</span>&gt;(env, object) &#123;&#125;    <span class="hljs-function">jbyte* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mPtr;    &#125;&#125;;<span class="hljs-comment">// 貌似在 ScopedBytes 的构造函数和析构函数里做了些手脚</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> readOnly&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedBytes</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ScopedBytes</span>(JNIEnv* env, jobject object)    : <span class="hljs-built_in">mEnv</span>(env), <span class="hljs-built_in">mObject</span>(object), <span class="hljs-built_in">mByteArray</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">mPtr</span>(<span class="hljs-literal">nullptr</span>)    &#123;        <span class="hljs-keyword">if</span> (mObject == <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-built_in">jniThrowNullPointerException</span>(mEnv);        &#125; <span class="hljs-keyword">else</span> &#123;            jclass byteArrayClass = JniConstants::<span class="hljs-built_in">GetPrimitiveByteArrayClass</span>(env);            <span class="hljs-keyword">if</span> (mEnv-&gt;<span class="hljs-built_in">IsInstanceOf</span>(mObject, byteArrayClass)) &#123;                mByteArray = <span class="hljs-built_in">reinterpret_cast</span>&lt;jbyteArray&gt;(mObject);                mPtr = mEnv-&gt;<span class="hljs-built_in">GetByteArrayElements</span>(mByteArray, <span class="hljs-literal">nullptr</span>);                 <span class="hljs-comment">// 字节数组</span>            &#125; <span class="hljs-keyword">else</span> &#123;                mPtr = <span class="hljs-built_in">reinterpret_cast</span>&lt;jbyte*&gt;(mEnv-&gt;<span class="hljs-built_in">GetDirectBufferAddress</span>(mObject)); <span class="hljs-comment">// DirectBuffer</span>            &#125;        &#125;    &#125;    ~<span class="hljs-built_in">ScopedBytes</span>() &#123;        <span class="hljs-keyword">if</span> (mByteArray != <span class="hljs-literal">nullptr</span>) &#123;            mEnv-&gt;<span class="hljs-built_in">ReleaseByteArrayElements</span>(mByteArray, mPtr, readOnly ? JNI_ABORT : <span class="hljs-number">0</span>);        &#125;    &#125;&#125;;</code></pre></div><p><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html">JNI Functions</a></p><blockquote><p><code>Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy)</code></p><p>A family of functions that returns the body of the primitive array. The result is valid until the corresponding Release<PrimitiveType>ArrayElements() function is called. Since the returned array may be a copy of the Java array, changes made to the returned array will not necessarily be reflected in the original array until Release<PrimitiveType>ArrayElements() is called.</p><p>If isCopy is not NULL, then *isCopy is set to JNI_TRUE if a copy is made; or it is set to JNI_FALSE if no copy is made.</p></blockquote><blockquote><p><code>Release&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, NativeType *elems, jint mode)</code></p><p>A family of functions that informs the VM that the native code no longer needs access to elems. The elems argument is a pointer derived from array using the corresponding Get<PrimitiveType>ArrayElements() function. If necessary, this function copies back all changes made to elems to the original array.</p><p>The mode argument provides information on how the array buffer should be released. mode has no effect if elems is not a copy of the elements in array.</p><p>0 - copy back the content and free the elems buffer</p><p>JNI_COMMIT - copy back the content but do not free the elems buffer</p><p>JNI_ABORT - free the buffer without copying back the possible changes</p><p>In most cases, programmers pass “0” to the mode argument to ensure consistent behavior for both pinned and copied arrays. The other options give the programmer more control over memory management and should be used with extreme care.</p></blockquote><p><a href="https://stackoverflow.com/questions/21691356/ndk-does-getbytearrayelements-copy-data-from-java-to-c/21693632">NDK: Does GetByteArrayElements copy data from Java to C++?</a></p><blockquote><p>Get<Primitive>ArrayElements may or may not copy the data as it sees fit. The isCopy output parameter will tell you whether it has been copied. If data is not copied, then you have obtained a pointer to the data directly in the Dalvik heap. Read more here.</p><p>You always need to call the corresponding Release<Primitive>ArrayElements, regardless of whether a copy was made. Copying data back to the VM array isn’t the only cleanup that might need to be done, although (according to the JNI documentation already linked) it is feasible that changes can be seen on the Java side before Release… has been called (iff data has not been copied).</p><p>I don’t believe the VM is going to allow you to make the conversions that would be necessary to do what you are thinking. As I see it, either way you go, you will need to convert a byte array to a float or a float to a byte array in Java, which you cannot accomplish by type casting. The data is going to be copied at some point.</p></blockquote><p>为啥会有数组的复制和回写？参考 <a href="../../../../2021/05/28/dalvik-art-heap-gc/">老罗的 Android 之旅阅读笔记（Dalvik/ART 虚拟机篇）</a> 我猜有两个原因：</p><ol><li>GC 在标记阶段需要 <code>Stop The World</code> 以标记需要回收的对象，但很明显 VM 没法中断 native thread</li><li>还有 <code>Compacting GC</code> 会通过两个 <code>Bump Pointer Space</code> 来回捣鼓堆上的对象以实现内存的整理和压缩，释放小块的内存碎片，这会导致堆上对象的地址发生变动，VM 可以找到堆上所有对此对象的引用并修改它们的地址，但 VM 没法修改 native 代码对此对象的引用</li></ol><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>看 <code>FileChannel</code> 读操作的 C 层入口，不再是 <code>Byte[]</code> 对象而是 C 代码可以直接操作的虚拟地址 <code>address</code>，系统调用 <code>pread64</code> 可以直接把数据写到 <code>address</code> 上，省去了两次复制数据的操作</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">FileDispatcherImpl_pread0</span>(JNIEnv *env, jclass clazz, jobject fdo, jlong address, jint len, jlong offset)&#123;    jint fd = <span class="hljs-built_in">fdval</span>(env, fdo);    <span class="hljs-type">void</span> *buf = (<span class="hljs-type">void</span> *)<span class="hljs-built_in">jlong_to_ptr</span>(address);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">convertReturnVal</span>(env, <span class="hljs-built_in">pread64</span>(fd, buf, len, offset), JNI_TRUE);&#125;</code></pre></div><p>为啥 <code>FileChannel</code> 可以直接拿到并操作虚拟地址呢？那还得由 <code>ByteBuffer</code> 说起</p><p>ByteBuffer 有两种：</p><ol><li>ByteBuffer.allocateDirect           - <code>DirectByteBuffer</code></li><li>ByteBuffer.allocate/ByteBuffer.wrap - <code>HeapByteBuffer</code></li></ol><p><code>HeapByteBuffer</code> 就是对 <code>Byte[]</code> 的包装，主要看下 <code>DirectByteBuffer</code></p><p><code>DirectByteBuffer</code> 其实也持有一个字节数组 <code>DirectByteBuffer.MemoryRef.buffer</code>，不同于普通的 <code>Byte[]</code> 它是直接在 non_moving_space 上分配的，也就说它不会被 GC 整理和移动所以它的地址是固定不变的，native 代码可以直接在这块内存上进行读写操作</p><div class="code-wrapper"><pre><code class="hljs java">ByteBuffer.allocateDirect(<span class="hljs-type">int</span> capacity)DirectByteBuffer.MemoryRef(capacity)VMRuntime.newNonMovableArray(componentType, length)VMRuntime_newNonMovableArray(env, jobject, javaElementClass, length)Array::Alloc(Thread* self, ObjPtr&lt;Class&gt; array_class, int32_t component_count, size_t component_size_shift, gc::AllocatorType allocator_type)Heap::AllocObjectWithAllocator(Thread* self, ObjPtr&lt;mirror::Class&gt; klass, size_t byte_count, AllocatorType allocator, const PreFenceVisitor&amp; pre_fence_visitor)Heap::TryToAllocate(Thread* self, AllocatorType allocator_type, size_t alloc_size, size_t* bytes_allocated, size_t* usable_size, size_t* bytes_tl_bulk_allocated)Heap-&gt;non_moving_space-&gt;Alloc(Thread* self, size_t num_bytes, size_t* bytes_allocated, size_t* usable_size, size_t* bytes_tl_bulk_allocated)</code></pre></div><p>看下文档 <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html#nio_support">NIO Support</a> 是怎么说的</p><blockquote><p>The NIO-related entry points allow native code to access java.nio direct buffers. The contents of a direct buffer can, potentially, reside in native memory outside of the ordinary garbage-collected heap. </p><p><code>jobject NewDirectByteBuffer(JNIEnv* env, void* address, jlong capacity)</code></p><p>Allocates and returns a direct java.nio.ByteBuffer referring to the block of memory starting at the memory address address and extending capacity bytes.</p><p>Native code that calls this function and returns the resulting byte-buffer object to Java-level code should ensure that the buffer refers to a valid region of memory that is accessible for reading and, if appropriate, writing. An attempt to access an invalid memory location from Java code will either return an arbitrary value, have no visible effect, or cause an unspecified exception to be thrown.</p><p><code>void* GetDirectBufferAddress(JNIEnv* env, jobject buf)</code></p><p>Fetches and returns the starting address of the memory region referenced by the given direct java.nio.Buffer.</p><p>This function allows native code to access the same memory region that is accessible to Java code via the buffer object.</p></blockquote><p><code>FileChannel</code> 在进行读写操作时，也即 java 层和 native 层之间进行数据传递时，总是会使用 <code>DirectByteBuffer</code> 避免数组的两次拷贝</p><div class="code-wrapper"><pre><code class="hljs java">FileChannelImpl.read(FileDescriptor fd, ByteBuffer dst, <span class="hljs-type">long</span> position, NativeDispatcher nd) <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">if</span> (dst.isReadOnly())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Read-only buffer&quot;</span>);    <span class="hljs-keyword">if</span> (dst <span class="hljs-keyword">instanceof</span> DirectBuffer)        <span class="hljs-keyword">return</span> readIntoNativeBuffer(fd, dst, position, nd);    <span class="hljs-comment">// Substitute a native buffer</span>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> Util.getTemporaryDirectBuffer(dst.remaining());    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> readIntoNativeBuffer(fd, bb, position, nd);        bb.flip();        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)            dst.put(bb);        <span class="hljs-keyword">return</span> n;    &#125; <span class="hljs-keyword">finally</span> &#123;        Util.offerFirstTemporaryDirectBuffer(bb);    &#125;&#125;FileChannelImpl.write(FileDescriptor fd, ByteBuffer src, <span class="hljs-type">long</span> position, NativeDispatcher nd) <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">if</span> (src <span class="hljs-keyword">instanceof</span> DirectBuffer)        <span class="hljs-keyword">return</span> writeFromNativeBuffer(fd, src, position, nd);    <span class="hljs-comment">// Substitute a native buffer</span>    <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> src.position();    <span class="hljs-type">int</span> <span class="hljs-variable">lim</span> <span class="hljs-operator">=</span> src.limit();    <span class="hljs-keyword">assert</span> (pos &lt;= lim);    <span class="hljs-type">int</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> (pos &lt;= lim ? lim - pos : <span class="hljs-number">0</span>);    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> Util.getTemporaryDirectBuffer(rem);    <span class="hljs-keyword">try</span> &#123;        bb.put(src);        bb.flip();        <span class="hljs-comment">// Do not update src until we see how many bytes were written</span>        src.position(pos);        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> writeFromNativeBuffer(fd, bb, position, nd);        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// now update src</span>            src.position(pos + n);        &#125;        <span class="hljs-keyword">return</span> n;    &#125; <span class="hljs-keyword">finally</span> &#123;        Util.offerFirstTemporaryDirectBuffer(bb);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Returns a temporary buffer of at least the given size</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">getTemporaryDirectBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;    <span class="hljs-comment">// If a buffer of this size is too large for the cache, there</span>    <span class="hljs-comment">// should not be a buffer in the cache that is at least as</span>    <span class="hljs-comment">// large. So we&#x27;ll just create a new one. Also, we don&#x27;t have</span>    <span class="hljs-comment">// to remove the buffer from the cache (as this method does</span>    <span class="hljs-comment">// below) given that we won&#x27;t put the new buffer in the cache.</span>    <span class="hljs-keyword">if</span> (isBufferTooLarge(size)) &#123;        <span class="hljs-keyword">return</span> ByteBuffer.allocateDirect(size);    &#125;    <span class="hljs-type">BufferCache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> bufferCache.get();    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> cache.get(size);    <span class="hljs-keyword">if</span> (buf != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> buf;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// No suitable buffer in the cache so we need to allocate a new</span>        <span class="hljs-comment">// one. To avoid the cache growing then we remove the first</span>        <span class="hljs-comment">// buffer from the cache and free it.</span>        <span class="hljs-keyword">if</span> (!cache.isEmpty()) &#123;            buf = cache.removeFirst();            free(buf);        &#125;        <span class="hljs-keyword">return</span> ByteBuffer.allocateDirect(size);    &#125;&#125;</code></pre></div><h3 id="File-Lock-Supporting"><a href="#File-Lock-Supporting" class="headerlink" title="File Lock Supporting"></a>File Lock Supporting</h3><p><code>FileChannel.lock</code> 通过 <code>fcntl(F_SETLKW)</code> 获得一个文件锁（阻塞，<code>tryLock</code> 是 <code>fcntl(F_SETLK)</code> 非阻塞），<code>FileLock.release</code> 则通过 <code>F_UNLCK</code> 释放锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得锁</span>FileChannel.lock()FileChannel.lock(<span class="hljs-number">0</span>, Long.MAX_VALUE, <span class="hljs-literal">false</span>)FileChannelImpl.lock(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)FileDispatcherImpl.lock(FileDescriptor fd, <span class="hljs-type">boolean</span> blocking, <span class="hljs-type">long</span> pos, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)FileDispatcherImpl.lock0(FileDescriptor fd, <span class="hljs-type">boolean</span> blocking, <span class="hljs-type">long</span> pos, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)FileDispatcherImpl_lock0(JNIEnv *env, jobject <span class="hljs-built_in">this</span>, jobject fdo, jboolean block, jlong pos, jlong size, jboolean shared)fcntl(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )    <span class="hljs-comment">// 系统调用</span><span class="hljs-comment">// 释放锁</span>FileLock.release()FileLockImpl.release()FileChannelImpl.release(FileLockImpl fli)FileDispatcherImpl.release(FileDescriptor fd, <span class="hljs-type">long</span> pos, <span class="hljs-type">long</span> size)FileDispatcherImpl_release0(JNIEnv *env, jobject <span class="hljs-built_in">this</span>, jobject fdo, jlong pos, jlong size)fcntl(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __cmd, ...)    <span class="hljs-comment">// 系统调用</span></code></pre></div><blockquote><p>fcntl - manipulate file descriptor</p><p><code>int fcntl(int fd, int cmd, ... /* arg */ )</code></p><p>Linux implements traditional (“process-associated”) UNIX record locks, as standardized by POSIX.  For a Linux-specific alternative with better semantics, see the discussion of open file description locks below.</p><p>F_SETLK, F_SETLKW, and F_GETLK are used to acquire, release, and test for the existence of record locks (also known as byte-range, file-segment, or file-region locks).  The third argument, lock, is a pointer to a structure that has at least the following fields (in unspecified order).</p><div class="code-wrapper"><pre><code class="hljs">struct flock &#123;    ...    short l_type;    /* Type of lock: F_RDLCK,                        F_WRLCK, F_UNLCK */    short l_whence;  /* How to interpret l_start:                        SEEK_SET, SEEK_CUR, SEEK_END */    off_t l_start;   /* Starting offset for lock */    off_t l_len;     /* Number of bytes to lock */    pid_t l_pid;     /* PID of process blocking our lock                        (set by F_GETLK and F_OFD_GETLK) */    ...&#125;;</code></pre></div></blockquote><p>如果锁已被别的进程持有，<code>F_SETLK</code> 返回 -1 而 <code>F_SETLKW</code> 会阻塞直到锁被释放</p><ol><li><p>F_RDLCK 读锁，共享锁，可以被多个进程持有</p></li><li><p>F_WRLCK 写锁，排它锁（包括读锁），只能被一个进程持有</p></li><li><p>F_UNLCK 释放锁</p></li><li><p>SEEK_SET 锁的 offset 由 l_start 决定</p></li><li><p>SEEK_CUR 锁的 offset = fd.offset + l_start</p></li><li><p>SEEK_END 锁的 offset = fd.end + l_start</p></li></ol><h3 id="Buffer-的基本概念"><a href="#Buffer-的基本概念" class="headerlink" title="Buffer 的基本概念"></a>Buffer 的基本概念</h3><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>capacity</td><td>容量，固定不变的，在构造的时候就确定了</td></tr><tr><td>position</td><td>指示器的位置，指示下一次读/写的位置</td></tr><tr><td>limit</td><td>读模式表示 Buffer 里内容的大小（正常情况下 position &lt;= limit &lt;= capacity），写模式表示 Buffer 的容量（正常情况下 limit == capacity）</td></tr><tr><td>remaining</td><td>limit - position</td></tr><tr><td>read mode</td><td>position - 下一次读的位置，limit - Buffer 内的数据量，capacity - Buffer 容量</td></tr><tr><td>write mode</td><td>position - 下一次写的位置，limit/capacity - Buffer 容量</td></tr><tr><td>flip</td><td>limit, position = position, 0，用来把 Buffer 从写模式切换为读模式</td></tr><tr><td>rewind</td><td>position = 0</td></tr><tr><td>clear</td><td>position, limit = 0, capacity</td></tr><tr><td>compat</td><td>将 [position, limit] 这一块数据拷贝到 [0, limit - position]，然后 position, limit = limit - positon, capacity</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>ART</tag>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>老罗的 Android 之旅阅读笔记（Dalvik/ART 虚拟机篇）</title>
    <link href="/2021/05/28/dalvik-art-heap-gc/"/>
    <url>/2021/05/28/dalvik-art-heap-gc/</url>
    
    <content type="html"><![CDATA[<h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><h3 id="Dalvik-Heap"><a href="#Dalvik-Heap" class="headerlink" title="Dalvik Heap"></a>Dalvik Heap</h3><p>Dalvik 的堆空间分为 <code>Zygote Heap</code> 和 <code>Active Heap</code></p><p>Android 系统的第一个 Dalvik 虚拟机是由 Zygote 进程创建的。应用程序进程是由 Zygote 进程 <code>fork</code> 出来的。也就是说应用程序进程使用了一种 <strong>写时拷贝技术</strong>（<code>COW</code>）来复制了 Zygote 进程的地址空间。这意味着一开始的时候，应用程序进程和 Zygote 进程共享了同一个用来分配对象的堆。然而，当 Zygote 进程或者应用程序进程对该堆进行写操作时，内核就会执行真正的拷贝操作，使得 Zygote 进程和应用程序进程分别拥有自己的一份拷贝。</p><p>拷贝是一件费时费力的事情。因此，为了尽量地避免拷贝，Dalvik 虚拟机将自己的堆划分为两部分。事实上，Dalvik 虚拟机的堆最初是只有一个的。也就是 Zygote 进程在启动过程中创建 Dalvik 虚拟机的时候，只有一个堆。但是当 Zygote 进程在 <code>fork</code> 第一个应用程序进程之前，会将已经使用了的那部分堆内存划分为一部分，还没有使用的堆内存划分为另外一部分。前者就称为 <strong>Zygote 堆</strong>，后者就称为 <strong>Active 堆</strong>。以后无论是 Zygote 进程，还是应用程序进程，当它们需要分配对象的时候，都在 <code>Active 堆</code> 上进行。这样就可以使得 <code>Zygote 堆</code> 尽可能少地被执行写操作，因而就可以减少执行写时拷贝的操作。在 <code>Zygote 堆</code> 里面分配的对象其实主要就是 Zygote 进程在启动过程中预加载的类、资源和对象了。这意味着这些预加载的类、资源和对象可以在 Zygote 进程和应用程序进程中做到长期共享。这样既能减少拷贝操作，还能减少对内存的需求。</p><h3 id="堆的一些重要参数"><a href="#堆的一些重要参数" class="headerlink" title="堆的一些重要参数"></a>堆的一些重要参数</h3><table><thead><tr><th>中文名</th><th>英文名</th><th>VM 参数</th></tr></thead><tbody><tr><td>起始大小</td><td>Starting Size</td><td>-Xms</td></tr><tr><td>最大值</td><td>Maximum Size</td><td>-Xmx</td></tr><tr><td>增长上限值</td><td>Growth Limit</td><td>-XX:HeapGrowthLimit</td></tr><tr><td>最小空闲值</td><td>Min Free</td><td>-XX:HeapMinFree</td></tr><tr><td>最大空闲值</td><td>Max Free</td><td>-XX:HeapMaxFree</td></tr><tr><td>目标利用率</td><td>Target Utilization</td><td>-XX:HeapTargetUtilization</td></tr></tbody></table><p>堆 <strong>起始大小</strong> 指定了 Davlik 虚拟机在启动的时候向系统申请的物理内存的大小。后面再根据需要逐渐向系统申请更多的物理内存，直到达到 <strong>最大值</strong> 为止。这是一种按需要分配策略，可以避免内存浪费，厂商会通过 <code>dalvik.vm.heapstartsize</code> 和 <code>dalvik.vm.heapsize</code> 这两个属性将它们设置为合适设备的值的</p><p>注意，虽然堆使用的 <strong>物理内存</strong> 是按需要分配的，但是它使用的 <strong>虚拟内存</strong> 的总大小却是需要在 Dalvik 启动的时候就确定的。这个虚拟内存的大小就等于堆的最大值</p><p>想象一下，如果不这样做的话，会出现什么情况。假设开始时创建的虚拟内存小于堆的最大值，由于实际情况是允许虚拟内存达到堆的最大值的，因此当开始时创建的虚拟内存无法满足需求时，那么就需要重新创建另外一块更大的虚拟内存。这样就需要将之前的虚拟内存的内容拷贝到新创建的更大的虚拟内存去，并且还要相应地修改各种辅助数据结构。这样太麻烦了，而且效率也太低了。因此就在一开始的时候，就创建一块与堆的最大值相等的虚拟内存</p><p>但是 Dalvik 虚拟机又希望能够动态地调整堆的可用最大值，于是就出现了一个称为 <strong>增长上限</strong> 的值，我们可以认为它是堆大小的 <strong>软限制</strong>，而前面所描述的最大值是堆大小的 <strong>硬限制</strong>。它主要是用来限制 <code>Active Heap</code> 无节制地增长到最大值的，而是要根据预先设定的 <code>堆目标利用率</code> 来控制 <code>Active Heap</code> 有节奏地增长到最大值。这样可以更有效地使用堆内存。想象一下，如果我们一开始 <code>Active Heap</code> 的大小设置为最大值，那么就很有可能造成已分配的内存分布在一个很大的范围。这样随着 Dalvik 虚拟机不断地运行，<code>Active Heap</code> 的内存碎片就会越来越来重。相反，如果我们施加一个 <code>Soft Limit</code>，那可以尽量地控制已分配的内存都位于较紧凑的范围内，可以有效地减少碎片</p><p>后三个用来确保每次 GC 之后，堆已用内存和空闲内存有一个合适的比例，这样可以尽量地减少 GC 的次数。举个例子说，堆的利用率为 <code>U</code>，最小空闲值为 <code>MinFree</code> 字节，最大空闲值为 <code>MaxFree</code> 字节。假设在某一次 GC 之后，存活对象占用内存的大小为 <code>LiveSize</code>。那么这时候堆的理想大小应该为 <code>(LiveSize / U)</code>，且 <code>(LiveSize + MinFree)</code> &lt;= <code>(LiveSize / U)</code> &lt;= <code>(LiveSize + MaxFree)</code></p><h3 id="4-Type-Of-GC"><a href="#4-Type-Of-GC" class="headerlink" title="4 Type Of GC"></a>4 Type Of GC</h3><p>Davlik 虚拟机定义了四种类型的 GC</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* Not enough space for an &quot;ordinary&quot; Object to be allocated. */</span>  <span class="hljs-comment">/* 在堆上分配对象时内存不足 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> GcSpec *GC_FOR_MALLOC;    <span class="hljs-comment">/* Automatic GC triggered by exceeding a heap occupancy threshold. */</span>  <span class="hljs-comment">/* 在已分配内存达到一定量之后触发 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> GcSpec *GC_CONCURRENT;    <span class="hljs-comment">/* Explicit GC via Runtime.gc(), VMRuntime.gc(), or SIGUSR1. */</span>  <span class="hljs-comment">/* 应用程序调用 System.gc、VMRuntime.gc接口或者收到 SIGUSR1 信号时触发 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> GcSpec *GC_EXPLICIT;    <span class="hljs-comment">/* Final attempt to reclaim memory before throwing an OOM. */</span>  <span class="hljs-comment">/* 在准备抛 OOM 异常之前进行的最后努力而触发的 GC */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> GcSpec *GC_BEFORE_OOM;</code></pre></div><p>每种 GC 通过成员属性控制 GC 细节</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GcSpec</span> &#123;    <span class="hljs-comment">/* If true, only the application heap is threatened. */</span>    <span class="hljs-comment">/* true - 仅仅回收 Active Heap，false - 同时回收 Active Heap 和 Zygote Heap */</span>  <span class="hljs-type">bool</span> isPartial;    <span class="hljs-comment">/* If true, the trace is run concurrently with the mutator. */</span>    <span class="hljs-comment">/* true - 执行并行 GC，false - 执行非并行 GC */</span>  <span class="hljs-type">bool</span> isConcurrent;    <span class="hljs-comment">/* Toggles for the soft reference clearing policy. */</span>    <span class="hljs-comment">/* true - 不回收软引用，false - 回收软引用引 */</span>  <span class="hljs-type">bool</span> doPreserve;    <span class="hljs-comment">/* A name for this garbage collection mode. */</span>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *reason;  &#125;;</code></pre></div><p><code>GC_FOR_MALLOC</code>、<code>GC_CONCURRENT</code> 和 <code>GC_BEFORE_OOM</code> 三种类型的 GC 都是在分配对象的过程触发的：</p><ol><li>Dalvik 虚拟机在堆上分配对象的时候，如果分配失败会首先尝试 <code>GC_FOR_MALLOC</code></li><li>GC 后再次进行对象的分配，如果失败这时候就得考虑先将堆的当前大小设置为 Dalvik 虚拟机启动时指定的堆最大值，再进行内存分配了（不应该是逐步增长？）</li><li>如果上一步内存分配还是失败，这时候就得出狠招 <code>GC_BEFORE_OOM</code> 将 <strong>软引用</strong> 也回收掉</li><li>这是最后一次努力了，如果还是分配失败就抛出 <code>OOM</code></li><li>成功地在堆上分配到一个对象之后，就会检查 <code>Active Heap</code> 当前已经分配的内存，如果大于阀值就会唤醒 GC 线程进行 <code>GC_CONCURRENT</code>。这个阀值是一个比指定的 <strong>堆最小空闲内存</strong> 小 128K 的数值，也就是说当堆的 <strong>空闲内不足</strong> 时就会触发 <code>GC_CONCURRENT</code></li></ol><h3 id="Mark-Sweep（标记-清理-GC-算法）"><a href="#Mark-Sweep（标记-清理-GC-算法）" class="headerlink" title="Mark-Sweep（标记-清理 GC 算法）"></a>Mark-Sweep（标记-清理 GC 算法）</h3><p>顾名思义，<code>Mark-Sweep</code> （标记-回收）算法就是分为 <code>Mark</code> 和 <code>Sweep</code>两个阶段进行垃圾回收：</p><ol><li><code>Mark</code> 阶段从 <code>GC ROOT</code>开始递归地标记出当前所有被引用的对象</li><li><code>Sweep</code> 阶段负责回收那些没有被引用的对象</li></ol><p><img src="../../../../image/2021-05-28-dalvik-art-heap-gc/mark_sweep.jpg" alt="Mark - Sweep"></p><h4 id="挂起其他线程"><a href="#挂起其他线程" class="headerlink" title="挂起其他线程"></a>挂起其他线程</h4><p>函数 <code>lockThreadSuspend</code> 尝试获取 <code>gDvm._threadSuspendLock</code> 锁。如果获取失败，就表明有其它线程也正在请求挂起 Dalvik 虚拟机中的线程，包括当前线程。每一个 Dalvik 虚拟机线程都有一个 <code>Suspend Count</code> 计数，每当它们都挂起的时候，对应的 <code>Suspend Count</code> 计数就会加 <code>1</code>，而当被唤醒时，对应的 <code>Suspend Count</code> 计数就会减 <code>1</code>。在获取 <code>gDvm._threadSuspendLock</code> 锁失败的情况下，当前线程按照一定的时间间隔检查自己的 <code>Suspend Count</code>，直到自己的 <code>Suspend Count</code> 等于 <code>0</code>，并且能成功获取 <code>gDvm._threadSuspendLock</code> 锁为止。这样就可以保证每一个挂起 Dalvik 虚拟机线程的请求都能够得到顺序执行。</p><p>从函数 <code>lockThreadSuspend</code> 返回之后，就表明当前线程可以执行挂起其它线程的操作了。它首先要做的第一件事情是遍历 Dalvik 虚拟机线程列表，并且调用函数 <code>dvmAddToSuspendCounts</code> 将列表里面的每一个线程对应的 <code>Suspend Count</code> 都增加1，但是除了当前线程之外。注意，在增加被挂起线程的 <code>Suspend Count</code> 计数之前，必须要获取 <code>gDvm.threadSuspendCountLock</code> 锁。这个锁的获取和释放可以通过函数 <code>lockThreadSuspendCount</code> 和 <code>unlockThreadSuspendCount</code> 完成</p><p>将被挂起线程的 <code>Suspend Count</code> 计数都增加 <code>1</code> 之后，接下来就是等待被挂起线程自愿将自己挂起来了。这是通过函数 <code>waitForThreadSuspend</code> 来实现。当一个线程自愿将自己挂起来的时候，会将自己的状态设置为非运行状态（<code>THREAD_RUNNING</code>），这样函数 <code>waitForThreadSuspend</code> 通过不断地检查一个线程的状态是否处于非运行状态就可以知道它是否已经挂起来了</p><p>那么，一个线程在什么情况才会自愿将自己挂起来呢？一个线程在执行的过程中，会在合适的时候检查自己的 <code>Suspend Count</code> 计数。一旦该计数值不等于 <code>0</code>，那么它就知道有线程请求挂起自己，因此它就会很配合地将自己的状态设置为非运行的，并且将自己挂起来。例如，当一个线程通过解释器执行代码时，就会周期性地检查自己的 <code>Suspend Count</code> 是否等于 <code>0</code>。这里说的周期性，实际上就是碰到 <code>IF</code> 指令、<code>GOTO</code> 指令、<code>SWITCH</code> 指令、<code>RETURN</code> 指令和 <code>THROW</code> 指令等时。</p><h3 id="Heap-Bitmap"><a href="#Heap-Bitmap" class="headerlink" title="Heap Bitmap"></a>Heap Bitmap</h3><p>堆的起始地址为 <code>base</code>，大小为 <code>maxSize</code>，由此我们就知道在堆上创建的对象的地址范围为 <code>[base, maxSize)</code>。 但是通过 C 库提供的 <code>mspace_malloc</code> 在堆分配内存时，得到的内存地址是以 8 bits 对齐的。这意味着我们只需要 <code>(maxSize / 8)</code> bits 来描述堆对象。结构体 <code>HeapBitmap</code> 的成员变量 <code>bits</code> 是一个类型为 <code>unsigned long</code> 的数组，也就是说数组中的每一个元素都可以描述 <code>sizeof(unsigned long)</code> 个对象的存活。在 32 位设备上，一个 <code>unsigned long</code> 占用 32 bits，这意味着需要一个大小为 <code>(maxSize / 8 / 32)</code> 的 <code>unsigned long</code> 数组来描述堆对象的存活。如果换成字节数来描述的话，就是说我们需要一块大小为 <code>(maxSize / 8 / 32) × 4</code> 的内存块来描述一个大小为 <code>maxSize</code> 的堆对象。</p><p><code>Live Bitmap</code> 用来标记上一次 GC 时被引用的对象（也就是没有被回收的对象），<code>Mark Bitmap</code> 用来标记当前 GC Mark 阶段发现的被引用对象，那么在 <code>Live Bitmap</code> 标记为 1，但是在 <code>Mark Bitmap</code> 中标记为 0 的即为需要回收的对象</p><p>假设我们知道了一个对象的地址为 <code>ptr</code>，堆的起始地址为 <code>base</code>，那么就可以计算得到一个偏移值 <code>offset</code>。有了这个偏移值之后，可以计算得到用来描述该对象存活的 bit 位于 <code>HeapBitmap-&gt;bits</code> 的 <code>unsigned long</code> 数组的索引 <code>index</code>。有了这个 <code>index</code> 之后，我们就可以得到一个 <code>unsigned long</code> 值。接着再通过对象地址 <code>ptr</code> 的第 4 到第 8 位表示的数值为索引，在前面找到的 <code>unsigned long</code> 值取出相应的位，就可以得到该对象是否存活了。</p><p>相反，给出一个 <code>HeapBitmap-&gt;bits</code> 描述的 <code>unsigned long</code> 数组的索引 <code>index</code>，我们可以找到一个偏移值 <code>offset</code>，将这个偏移值加上堆的起始地址 <code>base</code>，就可以得到一个对象的地址 <code>ptr</code></p><h3 id="Mark-Stack"><a href="#Mark-Stack" class="headerlink" title="Mark Stack"></a>Mark Stack</h3><p>在 GC Mark 阶段，Dalvik 虚拟机能过 <strong>递归方式</strong> 来标记对象。但是这不是通过函数的递归调用来实现的，而是借助一个称为 <code>Mark Stack</code> 的栈来实现的。具体来说，当我们标记完 <code>GC ROOT</code> 之后，就按照它们的地址从小到大的顺序标记它们所引用的其它对象。</p><p>假设有 A、B、C 和 D 四个对象，它的地址大小关系为 A &lt; B &lt; C &lt; D，其中 B 和 D 是 <code>GC ROOT</code>，A 被 D 引用，C 没有被 B 和 D 引用。那么我们将依次遍历 B 和 D，当遍历到 B 的时候没有发现它引用其它对象，然后就继续向前遍历 D 对象，发现它引用了 A 对象。按照递归的算法，这时候除了标记 A 对象是正在使用之外，还应该去检查 A 对象有没有引用其它对象，然后又再检查它引用的对象有没有又引用其它的对象，一直这样遍历下去，这样就跟函数递归一样。（树的 <strong>深度优先</strong> 遍历算法）</p><p>更好的做法是将对象 A 记录在一个 <code>Mark Stack</code> 中，然后继续检查地址值比对象 D 大的其它对象。对于地址值比对象 D 大的其它对象，如果它们引用了一个地址值比它们小的其它对象，那么这些其它对象同样要记录在 <code>Mark Stack</code> 中。等到该轮检查结束之后，再回过头来检查记录在 <code>Mark Stack</code>里面的对象。然后又重复上述过程，直到 <code>Mark Stack</code>等于空为止。（树的 <strong>广度优先</strong> 遍历算法）</p><h3 id="Concurrent-GC"><a href="#Concurrent-GC" class="headerlink" title="Concurrent GC"></a>Concurrent GC</h3><p>在 GC Mark 阶段，要求除了 GC 线程之外其它的线程都停止，否则的话就会可能导致不能正确地标记每一个对象。这种现象在 GC 中称为 <code>Stop The World</code>，会导致程序中止执行，造成停顿的现象。为了尽可能地减少停顿，我们必须要允许在 Mark 阶段有条件地允许程序的其它线程执行。这种 GC 称为 <strong>并行垃圾收集算法</strong>（<code>Concurrent GC</code>）。</p><p>为了实现 <code>Concurrent GC</code>，Mark 阶段又划分两个子阶段：</p><ol><li>第一个子阶段只负责标记根集对象（<code>GC ROOT</code>）。所谓的根集对象，就是指在 GC 开始的瞬间，被全局变量、栈变量和寄存器等引用的对象</li><li>有了这些根集变量之后，我们就可以顺着它们找到其余的被引用变量。例如，一个栈变量引了一个对象，而这个对象又通过成员变量引用了另外一个对象，那该被引用的对象也会同时标记为正在使用。这个 <strong>标记被根集对象引用的对象</strong> 的过程就是第二个子阶段</li></ol><h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><h3 id="odex"><a href="#odex" class="headerlink" title="odex"></a>odex</h3><p>Davik 实现在 <code>libdvm.so</code> 中，ART 实现在 <code>libart.so</code> 中。Android 提供了一个系统属性 <code>persist.sys.dalvik.vm.lib</code>，如果等于 <code>libdvm.so</code> 就表示当前用的是 Dalvik，如果等于 <code>libart.so</code> 表示当前用的是 ART</p><p>Dalvik 执行的是 dex 字节码，ART 执行的是本地机器码</p><p>Dalvik 包含一个解释器用来执行 dex 字节码，而且从 Android 2.2 开始也包含有 <code>JIT</code>（Just-In-Time），用来在运行时动态地将执行频率很高的 dex 字节码翻译成本地机器码再执行。通过 <code>JIT</code> 就可以有效地提高 Dalvik 的执行效率。但是将 dex 字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候都要做重做这个翻译工作的。因此即使用采用了 <code>JIT</code>，Dalvik 的总体性能还是不能与直接执行本地机器码的 ART 相比（ART 是 <code>AOT</code>）</p><p><code>PackageManagerService</code> 在安装 APK 的过程中会通过 <code>Installer.dexopt</code> 对 dex 字节码进行优化，<code>Installer</code> 通过 socket 向守护进程 <code>installd</code> 发送一个 <code>dexopt</code> 请求，这个请求是由 <code>installd</code> 里面的函数 <code>dexopt</code> 来处理的</p><p><code>dexopt</code> 首先是读取系统属性 <code>persist.sys.dalvik.vm.lib</code>，接着在 <code>/data/dalvik-cache</code> 创建一个 <code>odex</code> 文件。这个 <code>odex</code> 文件就是作为 dex 优化后的输出文件。再接下来，函数 <code>dexopt</code> 通过 <code>fork</code> 来创建一个子进程：</p><ol><li>如果系统属性 <code>persist.sys.dalvik.vm.lib</code> 的值等于 <code>libdvm.so</code>，那么该子进程就会调用函数 <code>run_dexopt</code>（最终调用命令 <code>/system/bin/dexopt</code>）来将 dex 文件优化成 <code>odex</code> 文件</li><li>如果系统属性 <code>persist.sys.dalvik.vm.lib</code> 的值等于 <code>libart.so</code>，那么该子进程就会调用函数 <code>run_dex2oat</code>（最终调用命令 <code>/system/bin/dex2oat</code>）来将 dex 文件翻译成 <code>oat</code> 文件，实际上就是将 dex 字节码翻译成本地机器码，并且保存在一个 <code>oat</code> 文件中</li></ol><p>无论是对 dex 字节码进行优化，还是将 dex 字节码翻译成本地机器码，最终得到的结果都是保存在相同名称的一个 <code>odex</code> 文件里面的，但是前者对应的是一个 <code>dey</code> 文件（表示这是一个优化过的 dex），后者对应的是一个 <code>oat</code> 文件（实际上是一个自定义的 elf 文件，里面包含的都是本地机器指令）</p><h3 id="ART-Heap"><a href="#ART-Heap" class="headerlink" title="ART Heap"></a>ART Heap</h3><p><code>ART</code> 的堆分为四个部分：<code>Image Space</code>、<code>Zygote Space</code>、<code>Allocation Space</code> 和 <code>Large Object Space</code></p><p>其中 <code>Image Space</code>、<code>Zygote Space</code> 和 <code>Allocation Space</code> 是在地址上连续的空间，称为 <code>Continuous Space</code>，而 <code>Large Object Space</code> 是一些离散地址的集合，用来分配一些大对象，称为 <code>Discontinuous Space</code></p><p>Space 还可以划分为 <code>Allocable</code> 和 <code>Non-Allocable</code> 两种。例如，<code>Image Space</code> 是不能分配新对象的（它是 boot oat 的文件映射），而 <code>Zygote Space</code>、<code>Allocation Space</code> 和 <code>Large Object Space</code> 是可以分配对象</p><p><code>Continuous Space</code> 内部使用的内存块都是通过内存映射得到的，不过这块内存有可能是通过不同方式映射得到的。例如，<code>Image Space</code> 内部使用的内存块是通过内存映射 Image 文件得到的，而 <code>Zygote Space</code> 和 <code>Allocation Space</code> 内部使用的内存块是通过内存映射匿名共享内存得到</p><p><code>Image Space</code> 空间包含了那些需要预加载的系统类对象，是对 <code>/system/framework/boot.art</code> 或者 <code>/data/dalvik-cache/system@framework@boot.art@classes.dex</code> 的内存映射</p><p><code>Zygote Space</code> 和 <code>Allocation Space</code> 与 Dalvik 虚拟机垃圾收集机制中的 Zygote 堆和 Active 堆的作用是一样的。<code>Zygote Space</code> 在 Zygote 进程和应用程序进程之间共享的，而 <code>Allocation Space</code> 则是每个进程独占的。同样的，Zygote 进程一开始只有一个 <code>Image Space</code> 和一个 <code>Zygote Space</code>。在 Zygote 进程 <code>fork</code> 第一个子进程之前，就会把 <code>Zygote Space</code> 一分为二，原来的已经被使用的那部分堆还叫 <code>Zygote Space</code>，而未使用的那部分堆就叫 <code>Allocation Space</code>。以后的对象都在 <code>Allocation Space</code> 上分配。</p><p>只要满足以下三个条件，就在 <code>Large Object Space</code> 上分配，否则就在 <code>Zygote Space</code> 或者 <code>Allocation Space</code> 上分配：</p><ol><li>请求分配的内存大于等于 <code>Heap-&gt;large_object_threshold_</code>，它等于 <code>3 * kPageSize</code> 即 3 个页面的大小</li><li>已经从 <code>Zygote Space</code> 划分出 <code>Allocation Space</code>，即 <code>Heap-&gt;have_zygote_space_ == true</code></li><li>被分配的对象是一个原子类型数组，即 byte 数组、int 数组和 boolean 数组等</li></ol><p>ART 运行时的堆 <code>Heap</code> 有以下重要的成员变量</p><table><thead><tr><th>name</th><th>desc</th></tr></thead><tbody><tr><td>mark_sweep_collectors_</td><td>保存了六种 <code>Mark-Sweep</code> 垃圾收集器的向量</td></tr><tr><td>continuous_spaces_</td><td>保存了三个在地址空间上连续的 <code>Image Space</code>、<code>Zygote Space</code> 和 <code>Allocation Space</code></td></tr><tr><td>concurrent_gc_</td><td>bool，描述是否支持并行 GC，可以通过 <code>-Xgc</code> 来指定</td></tr><tr><td>parallel_gc_threads_</td><td>指定在 GC 暂停阶段用来同时执行 GC 任务的线程数，通过 <code>-XX:ParallelGCThreads</code>指定。默认 CPU 核心数减 1</td></tr><tr><td>conc_gc_threads_</td><td>非 GC 暂停阶段用来同时执行 GC 任务的线程数，通过 <code>-XX:ConcGCThreads</code> 指定</td></tr><tr><td>discontinuous_spaces_</td><td>向量，保存了在地址空间上不连续的 <code>Large Object Space</code></td></tr><tr><td>alloc_space_</td><td>指向 <code>Allocation Space</code></td></tr><tr><td>large_object_space_</td><td>指向 <code>Large Object Space</code></td></tr><tr><td>card_table_</td><td><code>Card Table</code></td></tr><tr><td>image_mod_union_table_</td><td>记录 GC 并行阶段在 <code>Image Space</code> 的对象对在 <code>Zygote Space</code> 和 <code>Allocation Space</code> 上分配的对象的引用</td></tr><tr><td>zygote_mod_union_table_</td><td>记录 GC 并行阶段在 <code>Zygote Space</code> 的对象对在 <code>Allocation Space</code> 上分配的对象的引用</td></tr><tr><td>mark_stack_</td><td><code>Mark Stack</code>，用来在 GC 过程中实现递归对象标记</td></tr><tr><td>allocation_stack_</td><td><code>Allocation Stack</code>，用来记录上一次 GC 后分配的对象，用来实现类型为 <code>Sticky</code> 的 <code>Mark Sweep Collector</code></td></tr><tr><td>live_stack_</td><td><code>Live Stack</code>，配合 <code>allocation_stack_</code> 一起使用，用来实现类型为 <code>Sticky</code> 的 <code>Mark Sweep Collector</code></td></tr><tr><td>mark_bitmap_</td><td>与 Dalvik Mark Bitmap 作用是一样的，用来标记当前 GC 之后还存活的对象</td></tr><tr><td>live_bitmap_</td><td>与 Dalvik Live Bitmap 作用是一样的，用来标记上一次 GC 之后还存活的对象</td></tr></tbody></table><p>Space 有以下三种回收策略</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// See Space::GetGcRetentionPolicy.  </span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">GcRetentionPolicy</span> &#123;    <span class="hljs-comment">// Objects are retained forever with this policy for a space.  </span>  <span class="hljs-comment">// 永远不会进行垃圾回收的 Space，例如 Image Space</span>  kGcRetentionPolicyNeverCollect,    <span class="hljs-comment">// Every GC cycle will attempt to collect objects in this space.  </span>  <span class="hljs-comment">// 每一次 GC 都会尝试回收垃圾的 Space，例如 Allocation Space</span>  kGcRetentionPolicyAlwaysCollect,    <span class="hljs-comment">// Objects will be considered for collection only in &quot;full&quot; GC cycles, ie faster partial  </span>  <span class="hljs-comment">// collections won&#x27;t scan these areas such as the Zygote.  </span>  <span class="hljs-comment">// 只有执行类型为 kGcTypeFull 的 GC 才会进行垃圾回收的 Space，例如 Zygote Space</span>  kGcRetentionPolicyFullCollect,  &#125;;</code></pre></div><h3 id="在堆上分配对象"><a href="#在堆上分配对象" class="headerlink" title="在堆上分配对象"></a>在堆上分配对象</h3><p>流程跟 Dalvik 差不多：</p><ol><li>Dalvik 虚拟机在堆上分配对象的时候，如果分配失败会首先尝试 <code>GC_FOR_MALLOC</code></li><li>GC 后再次进行对象的分配，如果失败这时候就得考虑先将堆的当前大小设置为 Dalvik 虚拟机启动时指定的堆最大值，再进行内存分配了（不应该是逐步增长？）</li><li>如果上一步内存分配还是失败，这时候就得出狠招 <code>GC_BEFORE_OOM</code> 将 <strong>软引用</strong> 也回收掉</li><li>这是最后一次努力了，如果还是分配失败就抛出 <code>OOM</code></li><li>成功地在堆上分配到一个对象之后，就会检查 <code>Active Heap</code> 当前已经分配的内存，如果大于阀值（<code>Heap-&gt;concurrent_start_bytes_</code>）就会唤醒 GC 线程进行 <code>GC_CONCURRENT</code>。这个阀值是一个比指定的 <strong>堆最小空闲内存</strong> 小 128K 的数值，也就是说当堆的 <strong>空闲内不足</strong> 时就会触发 <code>GC_CONCURRENT</code></li></ol><h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><p>ART 有以下三种 GC Collector </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// The type of collection to be performed. The ordering of the enum matters, it is used to  </span><span class="hljs-comment">// determine which GCs are run first.  </span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">GcType</span> &#123;    <span class="hljs-comment">// Placeholder for when no GC has been performed.  </span>  kGcTypeNone,    <span class="hljs-comment">// Sticky mark bits GC that attempts to only free objects allocated since the last GC.  </span>  <span class="hljs-comment">// StickyMarkSweep 类型的垃圾收集器，用来收集上次 GC 以来分配的对象</span>  kGcTypeSticky,    <span class="hljs-comment">// Partial GC that marks the application heap but not the Zygote.  </span>  <span class="hljs-comment">// PartialMarkSweep 类型的垃圾收集器，用来收集在 Allocation Space 上分配的对象</span>  kGcTypePartial,    <span class="hljs-comment">// Full GC that marks and frees in both the application and Zygote heap.  </span>  <span class="hljs-comment">// MarkSweep 类型的垃圾收集器，用来收集在 Zygote Space 和 Allocation Space 上分配的对象</span>  kGcTypeFull,    <span class="hljs-comment">// Number of different GC types.  </span>  kGcTypeMax,  &#125;;</code></pre></div><p>ART 比 Dalvik 多了一个称 <code>Mod Union Table</code> 的概念。<code>Mod Union Table</code> 是与 <code>Card Table</code> 配合使用的，用来记录在一次 GC 过程中，不会被回收的 Space 对象对会被回收的 Space 对象引用。例如，<code>Image Space</code> 对象对 <code>Zygote Space</code> 和 <code>Allocation Space</code> 对象的引用，以及 <code>Zygote Space</code> 对象对 <code>Allocation Space</code> 对象的引用。</p><h3 id="五个守护线程"><a href="#五个守护线程" class="headerlink" title="五个守护线程"></a>五个守护线程</h3><p><code>java.lang.Daemons</code> 类在加载的时候，会启动五个与堆或者 GC 相关的守护线程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Daemons</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;          ReferenceQueueDaemon.INSTANCE.start();          FinalizerDaemon.INSTANCE.start();          FinalizerWatchdogDaemon.INSTANCE.start();          HeapTrimmerDaemon.INSTANCE.start();          GCDaemon.INSTANCE.start();      &#125;&#125;</code></pre></div><table><thead><tr><th>英文</th><th>中文</th><th>描述</th></tr></thead><tbody><tr><td>ReferenceQueueDaemon</td><td>引用队列守护线程</td><td>在创建 <code>Reference</code> 时可以关联一个 <code>ReferenceQueue</code>，当引用对象被 GC 回收的时候，<code>Reference</code> 就会被加入到 <code>ReferenceQueue</code>。这个入队操作就是由 <code>ReferenceQueueDaemon</code> 来完成的。这样应用程序就可以知道那些被引用对象引用的对象已经被回收了</td></tr><tr><td>FinalizerDaemon</td><td>析构守护线程</td><td>对于重写了成员函数 <code>finalize</code> 的对象，它们被 GC 决定回收时并没有马上被回收，而是被放入到一个队列中，等待 <code>FinalizerDaemon</code> 守护线程去调用它们的成员函数 <code>finalize</code> 然后再被回收</td></tr><tr><td>FinalizerWatchdogDaemon</td><td>析构监护守护线程</td><td>用来监控 <code>FinalizerDaemon</code> 线程的执行。一旦检测到在执行成员函数 <code>finalize</code> 时超出一定的时间限制，那么就会退出 VM</td></tr><tr><td>HeapTrimmerDaemon</td><td>堆裁剪守护线程</td><td>用来执行裁剪堆的操作，也就是用来将那些空闲的堆内存归还给系统（<code>compacting</code>）</td></tr><tr><td>GCDaemon</td><td>并行 GC 线程</td><td>用来执行并行 GC</td></tr></tbody></table><h3 id="Compacting-GC"><a href="#Compacting-GC" class="headerlink" title="Compacting GC"></a>Compacting GC</h3><p>Android 4.4 支持 <code>Mark-Sweep GC</code>，到了 Android 5.0 增加了对 <code>Compacting GC</code> 的支持。所谓 <code>Compacting GC</code>，就是在进行 GC 的时候同时对堆空间进行 <strong>压缩</strong> 以消除碎片，因此它的堆空间利用率就更高。但是也正因为要对堆空间进行压缩，导致它的效率不如 <code>Mark-Sweep GC</code>，而且会导致对象的地址发生变化</p><p>在以往的 <code>Mark-Sweep GC</code> 时由于碎片而产生的内存不足问题是解决不了的，只能让应用程序 OOM。但是有了 <code>Compacting GC</code> 之后就可以在应用程序 OOM 之前再作一次努力，那就是对原来的堆空间进行压缩一下，再尝试进行分配，这样就可以提高成功分配内存的概率</p><p><code>Compacting GC</code> 增加了一些额外的参数：</p><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>-XX:NonMovingSpaceCapacity</td><td><code>Non-Moving Space</code> 的大小，默认大小为 <code>kDefaultNonMovingSpaceCapacity</code>（64MB）</td></tr><tr><td>-Xgc</td><td><code>Foreground GC</code> 的类型，可选：<code>Concurrent Mark-Sweep GC</code>、<code>Semi-Space GC</code> 或者 <code>Generational Semi-Space GC</code></td></tr><tr><td>-XX:BackgroundGC</td><td><code>Background GC</code> 的类型，比 <code>Foreground GC</code> 多了 <code>Homogeneous-Space-Compact</code>，默认就与 <code>Foreground GC</code> 一样</td></tr><tr><td>-XX:EnableHSpaceCompactForOOM / -XX:DisableHSpaceCompactForOOM</td><td>是否在 OOM 时执行 <code>Homogeneous-Space-Compact</code></td></tr></tbody></table><p><code>Compacting GC</code> 通过移动和整理对象以实现压缩：把散乱的对象逐个移动到一块空闲的内存空间，因为整块空间都是空闲的，所以可以紧凑地将它们放在一起，这个空间叫 <code>Bump Pointer Space</code></p><h4 id="Generational-Semi-Space-GC"><a href="#Generational-Semi-Space-GC" class="headerlink" title="(Generational) Semi-Space GC"></a>(Generational) Semi-Space GC</h4><p><code>Semi-Space GC</code> 由两个 <code>Bump Pointer Space</code> 组成，分别叫做 <code>From Space</code> 和 <code>To Space</code>，其中对象的分配发生在 <code>From Space</code>中。<code>Bump Pointer Space</code> 有一个指针 <code>end_</code> 始终指向下一次要分配的内存块的起始地址，因此在 <code>Bump Pointer Space</code> 上分配内存的逻辑是很简单的，只要指针 <code>end_</code> 向前移动指定的大小即可，这也是 <code>Bump Pointer</code> 的由来</p><p>当 <code>From Space</code> 不能满足内存分配要求时，就会触发一次 <code>Semi-Space GC</code>，结果就是 <code>From Space</code> 和 <code>To Space</code> 互换了位置，并且原来在 <code>From Space</code> 上的 Live Object 按地址值 <strong>从小到大</strong> 的顺序移动到了原来的<code>To Space</code>上去（这不就是 JVM Young Generation 里的 Survivor 嘛）</p><p><code>Generational Semi-Space GC</code> 涉及到三个 Space，其中两个是 <code>Bump Pointer Space</code>，另外一个是 <code>Promote Space</code></p><p><code>Generational Semi-Space GC</code> 与 <code>Semi-Space GC</code> 基本相同，只不过会考虑到 <strong>对象的年龄</strong>。如果一个对象在多次 GC 中都能存活下来，那么就会将它移动到一个 <code>Promote Space</code> 中去。这相当于是简单地将对象划分为 <strong>新生代</strong> 和 <strong>老生代</strong>，即在上一次 GC 之前分配的对象属于老生代，而在上一次 GC 之后分配的对象属于新生代。由于 <code>Promote Space</code> 是一个 <code>Non-Moving Space</code>，以后在这个 Space 上的对象不会再被移动。通过这种方式就可以有效地减少在 <code>Generational Semi-Space GC</code> 中要移动的对象的个数，从而提高 GC 效率（这不就是 JVM Old Generation）</p><p><code>Semi-Space GC</code> 和 <code>Generational Semi-Space GC</code> 使用的是同一个垃圾收集器，保存在 <code>Heap-&gt;semi_space_collector_</code>，From Space 和 To Space 分别是 <code>Heap-&gt;bump_pointer_space_</code> 和 <code>Heap-&gt;temp_space_</code>（它们都是 <code>Bump Pointer Space</code>），当 GC 执行完毕交换 From Space 和 To Space</p><p>只能执行类型为 <code>kGcTypeFull</code> 的 GC</p><h4 id="Mark-Compact-GC"><a href="#Mark-Compact-GC" class="headerlink" title="Mark-Compact GC"></a>Mark-Compact GC</h4><ol><li>只需一个 <code>Bump Pointer Space</code> 来压缩内存，当 GC 执行完成之后，原来位于 <code>Bump Pointer Space</code> 上的仍然存活的对象会被依次移动至左侧，并且按地址从小到大紧凑地排列在一起</li><li>执行过程分为 <strong>初始化</strong>、<strong>标记</strong>、<strong>回收</strong> 和 <strong>结束</strong> 四个阶段，对应的函数分别为 <code>MarkCompact</code> 的 <code>InitializePhase</code>、<code>MarkingPhase</code>、<code>ReclaimPhase</code> 和 <code>FinishPhase</code>，其中标记和回收阶段是在挂起其它线程的前提下进行的</li><li><code>Image Space</code> 和 <code>Zygote Space</code> 是不进行垃圾回收的，同时也意味着 <code>Non Moving Space</code>、<code>Bump Pointer Space</code> 和 <code>Large Object Space</code> 需要进行垃圾回收</li><li>标记阶段并没有对 <code>Bump Pointer Space</code> 的存活对象进行移动，而是在接下来的回收阶段再执行此操作</li><li>能够执行 <code>kGcTypeSticky</code>、<code>kGcTypePartial</code> 和 <code>kGcTypeFull</code> 三种类型的 GC</li></ol><h4 id="Homogeneous-Space-Compact"><a href="#Homogeneous-Space-Compact" class="headerlink" title="Homogeneous Space Compact"></a>Homogeneous Space Compact</h4><p>所谓的 <strong>同构空间压缩特性（Homogeneous Space Compact）</strong>，是针对 <code>Mark-Sweep GC</code> 而言的。一个 Space 需要有 Main 和 Backup 之分。执行同构空间压缩时，将 Main Space 的对象移动至 Backup Space 中去，再将 Main Space 和 Backup Space 进行交换，这样就达到压缩空间，即减少内存碎片的作用。</p><h4 id="Non-Moving-Space"><a href="#Non-Moving-Space" class="headerlink" title="Non-Moving Space"></a>Non-Moving Space</h4><p>在 <code>Compacting GC</code> 中涉及到对象的移动，但是有些对象例如类对象（Class）、类方法对象（ArtMethod）和类成员变量对象（ArtField），它们一经加载后基本上就会一直存在。因此频繁对此类对象进行移动是无益的，我们需要将它们分配在一个不能移动的 Space 中以减少在 <code>Compacting GC</code> 需要处理的对象的数量</p><h3 id="Foreground-GC-和-Background-GC"><a href="#Foreground-GC-和-Background-GC" class="headerlink" title="Foreground GC 和 Background GC"></a>Foreground GC 和 Background GC</h3><p>ART 既支持 <code>Mark-Sweep GC</code> 又支持 <code>Compacting GC</code>。其中 <code>Mark-Sweep GC</code> 执行效率更高但是存在内存碎片问题，而 <code>Compacting GC</code> 执行效率较低但是不存在内存碎片问题。ART 通过引入 <code>Foreground GC</code> 和 <code>Background GC</code> 的概念来对这两种 GC 进行扬长避短，分别用 <code>-Xgc</code> 和 <code>-XX:BackgroundGC</code> 指定</p><p>顾名思义，<code>Foreground GC</code> 就是应用程序在前台运行时执行的 GC，<code>Background GC</code> 就是应用程序在后台运行时执行的 GC。应用程序在前台运行时，响应性是最重要的，因此也要求执行的GC是高效的。相反，应用程序在后台运行时，响应性不是最重要的，这时候就适合用来解决堆的内存碎片问题。因此，<code>Mark-Sweep GC</code> 适合作为 <code>Foreground GC</code> 而 <code>Compacting GC</code> 适合作为 <code>Background GC</code></p><p><code>AMS</code> 清楚地知道应用程序当前是在前台运行还是后台运行，所以由它负责触发切换前后台 GC 的操作</p><div class="code-wrapper"><pre><code class="hljs java">ApplicationThread.scheduleLaunchActivityApplicationThread.updateProcessState(<span class="hljs-type">int</span> processState, <span class="hljs-type">boolean</span> fromIpc) &#123;      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;          <span class="hljs-keyword">if</span> (mLastProcessState != processState) &#123;              mLastProcessState = processState;              <span class="hljs-comment">// 用户可感知/用户不可感知</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DALVIK_PROCESS_STATE_JANK_PERCEPTIBLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;              <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DALVIK_PROCESS_STATE_JANK_IMPERCEPTIBLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;              <span class="hljs-type">int</span> <span class="hljs-variable">dalvikProcessState</span> <span class="hljs-operator">=</span> DALVIK_PROCESS_STATE_JANK_IMPERCEPTIBLE;                          <span class="hljs-comment">// &lt;= PROCESS_STATE_IMPORTANT_FOREGROUND 表示前台进程，用户可见可交互</span>            <span class="hljs-keyword">if</span> (processState &lt;= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123;                  dalvikProcessState = DALVIK_PROCESS_STATE_JANK_PERCEPTIBLE;              &#125;              VMRuntime.getRuntime().updateProcessState(dalvikProcessState);              ......          &#125;      &#125;  &#125; <span class="hljs-comment">// AMS 定义了 14 种进程的状态，越小越重要</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManager</span> &#123;      <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is a persistent system process. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_PERSISTENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is a persistent system process and is doing UI. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_PERSISTENT_UI</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is hosting the current top activities.  Note that this covers </span><span class="hljs-comment">     * all activities that are visible to the user. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_TOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is important to the user, and something they are aware of. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_IMPORTANT_FOREGROUND</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is important to the user, but not something they are aware of. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_IMPORTANT_BACKGROUND</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background running a backup/restore operation. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_BACKUP</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background, but it can&#x27;t restore its state so we want </span><span class="hljs-comment">     * to try to avoid killing it. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_HEAVY_WEIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background running a service.  Unlike oom_adj, this level </span><span class="hljs-comment">     * is used for both the normal running in background state and the executing </span><span class="hljs-comment">     * operations state. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_SERVICE</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background running a receiver.   Note that from the </span><span class="hljs-comment">     * perspective of oom_adj receivers run at a higher foreground level, but for our </span><span class="hljs-comment">     * prioritization here that is not necessary and putting them below services means </span><span class="hljs-comment">     * many fewer changes in some process states as they receive broadcasts. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_RECEIVER</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background but hosts the home activity. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_HOME</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is in the background but hosts the last shown activity. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_LAST_ACTIVITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is being cached for later use and contains activities. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_CACHED_ACTIVITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is being cached for later use and is a client of another cached </span><span class="hljs-comment">     * process that contains activities. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_CACHED_ACTIVITY_CLIENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;        <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> Process is being cached for later use and is empty. */</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROCESS_STATE_CACHED_EMPTY</span> <span class="hljs-operator">=</span> <span class="hljs-number">13</span>;  &#125;  VMRuntime.updateProcessState(<span class="hljs-type">int</span> state)VMRuntime_updateProcessState(JNIEnv* env, jobject, jint process_state)Heap::UpdateProcessState(ProcessState process_state)Heap::RequestCollectorTransition(CollectorType desired_collector_type, uint64_t delta_time)Heap::SignalHeapTrimDaemon(Thread* self)Daemons.requestHeapTrim()</code></pre></div><p>上面说过 ART 启动后加载 <code>java.lang.Daemons</code> 时，会启动五个守护线程，其中有一个是 <code>HeapTrimmerDaemon</code> 负责压缩堆内存，其实它也负责切换 GC，并且在过程中根据情况有可能在切换 GC 前执行一次 <code>compacting</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Daemons</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestHeapTrim</span><span class="hljs-params">()</span> &#123;          <span class="hljs-keyword">synchronized</span> (HeapTrimmerDaemon.INSTANCE) &#123;              HeapTrimmerDaemon.INSTANCE.notify();          &#125;      &#125;&#125;</code></pre></div><h4 id="切换至-Semi-Space-GC"><a href="#切换至-Semi-Space-GC" class="headerlink" title="切换至 Semi-Space GC"></a>切换至 Semi-Space GC</h4><p>这时候原来的 GC 只能为 <code>Mark-Sweep GC</code> 或者 <code>Concurrent Mark-Sweep GC</code>，此时 ART 堆由 <code>Image Space</code>、<code>Zygote Space</code>、<code>Non Moving Space</code>、<code>Main Space</code>、<code>Main Backup Space</code> 和 <code>Large Object Space</code> 组成。要做的是将 <code>Main Space</code> 上的存活对象移动至一个新创建的 <code>Bump Pointer Space</code> 上去，也就是说这时候的 Source Space 为 <code>Main Space</code>，而 Target Space 为 <code>Bump Pointer Space</code>。</p><p><code>Main Space</code> 就保存在 <code>Heap-&gt;main_space_</code>，因此就很容易可以获得。但是这时候是没有现成的 <code>Bump Pointer Space</code> 的，因此就需要创建一个。由于这时候的 <code>Main Backup Space</code> 是闲置的，并且当 GC 切换完毕它也用不上了，因此我们就可以将 <code>Main Backup Space</code> 底层使用的内存块获取回来，然后再封装成一个 <code>Bump Pointer Space</code>。注意这时候创建的 <code>Bump Pointer Space</code> 也是作为 GC 切换完成后的 From Space 使用的，因此除了要将它保存在 <code>Heap-&gt;bump_pointer_space_</code> 之外，还要将它添加到 ART 的 Space 列表中去</p><p>这时候 Source Space 和 Target Space 均已准备完毕，因此就可以执行 <code>Heap-&gt;Compact</code> 了。执行完毕还需要做一系列的清理工作，包括：</p><ol><li>删除 <code>Main Space</code></li><li>删除 <code>Main Backup Space</code></li><li>创建一个 <code>Bump Pointer Space</code> 保存在 <code>Heap-&gt;temp_space_</code>，作为 GC 切换完成后的 To Space 使用（注意这个 To Space 底层使用的内存块是来自于原来的 Main Space）</li></ol><p>这意味着将从 <code>(Concurrent)Mark-Sweep GC</code> 切换为 <code>Semi-Space GC</code> 之后，原来的 <code>Main Space</code> 和 <code>Main Backup Space</code> 就消失了，并且多了两个 <code>Bump Pointer Space</code>，其中一个作为 From Space，另外一个作为 To Space，并且 From Space 上的对象来自于原来的 <code>Main Space</code> 的存活对象</p><h4 id="切换至-Concurrent-Mark-Sweep-GC"><a href="#切换至-Concurrent-Mark-Sweep-GC" class="headerlink" title="切换至 (Concurrent)Mark-Sweep GC"></a>切换至 (Concurrent)Mark-Sweep GC</h4><p>这时候原来的 GC 只能为 <code>Semi-Space GC</code>、<code>Generational Semi-Space GC</code> 或者 <code>Mark-Compact GC</code>，ART 堆由 <code>Image Space</code>、<code>Zygote Space</code>、<code>Non Moving Space</code>、<code>Bump Pointer Space</code>、<code>Temp Space</code> 和 <code>Large Object Space</code> 组成。要做的是将 <code>Bump Pointer Space</code> 上的存活对象移动至一个新创建的 <code>Main Space</code> 上去，也就是说这时候的 Source Space 为 <code>Bump Pointer Space</code>，而 Target Space 为 <code>Main Space</code></p><p><code>Bump Pointer Space</code> 就保存在 <code>Heap-&gt;bump_pointer_space_</code>，因此就很容易可以获得。但是这时候是没有现成的 <code>Main Space</code> 的，因此就需要创建一个。由于这时候的 <code>Temp Space</code> 是闲置的，并且当 GC 切换完毕它也用不上了，因此我们就可以将 <code>Temp Space</code> 底层使用的内存块获取回来，然后再封装成一个 <code>Main Space</code>，这是通过调用 <code>Heap-&gt;CreateMainMallocSpace</code> 来实现的。注意，它在执行的过程中会将创建的 <code>Main Space</code> 保存在 <code>Heap-&gt;main_space_</code>，并且作为 GC 切换完成后 <code>(Concurrent)Mark-Sweep GC</code> 的 <code>Main Space</code>使用的，因此就还要将它添加到 ART 堆的 Space 列表中去</p><p>这时候 Source Space 和 Target Space 均已准备完毕，可以执行 <code>Heap-&gt;Compact</code>了。执行完毕还需要做一系列的清理工作，包括：</p><ol><li>删除 <code>Bump Pointer Space</code></li><li>删除 <code>Temp Space</code></li><li>创建一个 <code>Main Backup Space</code> 保存在 <code>Heap-&gt;main_space_backup_</code>，这是通过调用 <code>Heap-&gt;CreateMallocSpaceFromMemMap</code> 实现的，并且该 <code>Main Backup Space</code> 底层使用的内存块是来自于原来的 <code>Bump Pointer Space</code> 的</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/Luoshengyang/article/details/41338251">Dalvik虚拟机垃圾收集机制简要介绍和学习计划</a></li><li><a href="https://blog.csdn.net/luoshengyang/article/details/42072975">ART运行时垃圾收集机制简要介绍和学习计划</a></li><li><a href="https://www.kancloud.cn/alex_wsc/androids/472173">Dalvik虚拟机和ART虚拟机</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Dalvik</tag>
      
      <tag>ART</tag>
      
      <tag>JVM</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】mmap 和零拷贝</title>
    <link href="/2021/05/21/mmap/"/>
    <url>/2021/05/21/mmap/</url>
    
    <content type="html"><![CDATA[<p>平时在面试中你肯定会经常碰见的问题就是：<code>RocketMQ</code> 为什么快？<code>Kafka</code> 为什么快？什么是 <code>mmap</code>？</p><p>这一类的问题都逃不过的一个点就是 <strong>零拷贝</strong>，虽然还有一些其他的原因，但是今天我们的话题主要就是零拷贝。</p><h2 id="传统-IO"><a href="#传统-IO" class="headerlink" title="传统 IO"></a>传统 IO</h2><p>在开始谈零拷贝之前，首先要对传统的 IO 方式有一个概念。基于传统的 IO 方式，底层实际上通过调用 <code>read()</code> 和 <code>write()</code> 来实现。</p><p>通过 <code>read()</code> 把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过 <code>write()</code> 写入到 socket 缓冲区，最后写入网卡设备。</p><p><img src="../../../../image/2021-05-21-mmap/read_write.jpg" alt="read_write"></p><p>整个过程发生了 <strong>4</strong> 次用户态和内核态的上下文切换和 <strong>4</strong> 次拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>read()</code> 方法向操作系统发起调用，此时上下文从用户态转向内核态</li><li>DMA 控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU 把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，<code>read()</code> 返回</li><li>用户进程通过 <code>write()</code> 方法发起调用，上下文从用户态转为内核态</li><li>CPU 将应用缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code> 返回</li></ol><p><img src="../../../../image/2021-05-21-mmap/read_write_swimlane.jpg" alt="read_write_swimlane"></p><p>那么，这里指的 <strong>用户态</strong>、<strong>内核态</strong> 指的是什么？<strong>上下文切换</strong> 又是什么？</p><p>简单来说，<strong>用户空间</strong> 指的就是用户进程的运行空间，<strong>内核空间</strong> 就是内核的运行空间。如果进程运行在内核空间就是内核态，运行在用户空间就是用户态。为了安全起见，他们之间是互相隔离的，而在用户态和内核态之间的上下文切换也是比较耗时的。从上面我们可以看到，一次简单的 IO 过程产生了 4 次上下文切换，这个无疑在高并发场景下会对性能产生较大的影响。</p><p>那么什么又是 DMA 拷贝呢？</p><p>因为对于一个 IO 操作而言，都是通过 CPU 发出对应的指令来完成，但是相比 CPU 来说，IO 的速度太慢了，CPU 有大量的时间处于等待 IO 的状态。因此就产生了 DMA（Direct Memory Access）直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和 IO 设备的数据传输，从而减少 CPU 的等待时间。但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。</p><p><strong>零拷贝</strong> 是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省 CPU 周期和内存带宽。那么对于零拷贝而言，并非真的是完全没有数据拷贝的过程，只不过是减少用户态和内核态的切换次数以及 CPU 拷贝的次数。</p><p>这里，仅仅有针对性的来谈谈几种常见的零拷贝技术。</p><h2 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a><code>mmap</code> + <code>write</code></h2><p><code>mmap</code> + <code>write</code> 简单来说就是使用 <code>mmap</code> 替换了 <code>read</code> + <code>write</code> 中的 <code>read</code> 操作，减少了一次 CPU 的拷贝。</p><p><code>mmap</code> 主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次 CPU 拷贝。</p><p><img src="../../../../image/2021-05-21-mmap/mmap_write_swimlane.jpg" alt="mmap_write_swimlane"></p><p>整个过程发生了 <strong>4</strong> 次用户态和内核态的上下文切换和 <strong>3</strong> 次拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>mmap</code> 向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA 控制器把数据从硬盘中拷贝到读缓冲区</li><li>上下文从内核态转为用户态，<code>mmap</code> 调用返回</li><li>用户进程通过 <code>write()</code> 方法发起调用，上下文从用户态转为内核态</li><li>CPU 将读缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code> 返回</li></ol><p><code>mmap</code> 的方式节省了一次 CPU 拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</p><h2 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a><code>sendfile</code></h2><p>相比 <code>mmap</code> 来说，<code>sendfile</code> 同样减少了一次 CPU 拷贝，而且还减少了 <strong>2</strong> 次上下文切换。</p><p><img src="../../../../image/2021-05-21-mmap/sendfile.jpg" alt="sendfile"></p><p><code>sendfile</code> 是 Linux 2.1 内核版本后引入的一个系统调用函数，通过使用 <code>sendfile</code> 数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用 <code>sendfile</code> 替代了 <code>read</code> + <code>write</code> 从而节省了一次系统调用，也就是 <strong>2</strong> 次上下文切换。</p><p><img src="../../../../image/2021-05-21-mmap/sendfile_swimlane.jpg" alt="sendfile_swimlane"></p><p>整个过程发生了 <strong>2</strong> 次用户态和内核态的上下文切换和 <strong>3</strong> 次拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>sendfile()</code> 方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA 控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU 将读缓冲区中数据拷贝到 socket 缓冲区</li><li>DMA 控制器把数据从 socket 缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>sendfile</code> 调用返回</li><li><code>sendfile</code> 方法 IO 数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</li></ol><h2 id="sendfile-DMA-Scatter-Gather"><a href="#sendfile-DMA-Scatter-Gather" class="headerlink" title="sendfile + DMA Scatter/Gather"></a><code>sendfile</code> + DMA Scatter/Gather</h2><p>Linux 2.4 内核版本之后对 <code>sendfile</code> 做了进一步优化，通过引入新的硬件支持，这个方式叫做 DMA Scatter/Gather。它将读缓冲区中的数据描述信息（内存地址和偏移量）记录到 socket 缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次 CPU 拷贝的过程</p><p><img src="../../../../image/2021-05-21-mmap/gather_swimlane.jpg" alt="gather_swimlane"></p><p>整个过程发生了 <strong>2</strong> 次用户态和内核态的上下文切换和 <strong>2</strong> 次拷贝，其中更重要的是完全没有 CPU 拷贝，具体流程如下：</p><ol><li>用户进程通过 <code>sendfile()</code> 方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA 控制器利用 scatter 把数据从硬盘中拷贝到读缓冲区离散存储</li><li>CPU 把读缓冲区中的文件描述符和数据长度发送到 socket 缓冲区</li><li>DMA 控制器根据文件描述符和数据长度，使用 scatter/gather 把数据从内核缓冲区拷贝到网卡</li><li><code>sendfile()</code> 调用返回，上下文从内核态切换回用户态</li></ol><p>DMA gather 和 <code>sendfile</code> 一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有 CPU 拷贝过程，极大提升了性能。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>对于文章开头说的两个场景：<code>RocketMQ</code> 和 <code>Kafka</code> 都使用到了零拷贝的技术。</p><p>对于 <code>MQ</code> 而言，无非就是生产者发送数据到 <code>MQ</code> 然后持久化到磁盘，之后消费者从 <code>MQ</code> 读取数据。</p><p>对于 <code>RocketMQ</code> 来说这两个步骤使用的是 <code>mmap</code> + <code>write</code>，而 <code>Kafka</code> 则是使用 <code>mmap</code> + <code>write</code> 持久化数据，发送数据使用 <code>sendfile</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于 CPU 和 IO 速度的差异问题，产生了 DMA 技术，通过 DMA 搬运来减少 CPU 的等待时间。</p><p>传统的 IO <code>read</code> + <code>write</code> 方式会产生 <strong>2</strong> 次 DMA 拷贝 + <strong>2</strong> 次 CPU 拷贝，同时有 <strong>4</strong> 次上下文切换。</p><p>而通过 <code>mmap</code> + <code>write</code> 方式则产生 <strong>2</strong> 次 DMA 拷贝 + <strong>1</strong> 次 CPU 拷贝，<strong>4</strong> 次上下文切换，通过内存映射减少了一次 CPU 拷贝，可以减少内存使用，适合大文件的传输。</p><p><code>sendfile</code> 方式是新增的一个系统调用函数，产生 <strong>2</strong> 次 DMA 拷贝 + <strong>1</strong> 次 CPU 拷贝，但是只有 <strong>2</strong> 次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对 IO 数据不可见，适用于静态文件服务器。</p><p><code>sendfile</code> + DMA gather 方式产生 <strong>2</strong> 次 DMA 拷贝，没有 CPU 拷贝，而且也只有 <strong>2</strong> 次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.cn/post/6844903949359644680">深入剖析Linux IO原理和几种零拷贝机制的实现</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/p/13719610.html">原来 8 张图，就可以搞懂「零拷贝」了</a></li><li><a href="https://www.toutiao.com/i6898240850917114380/">腾讯游戏工程师：Linux Zero-copy技术全面揭秘</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mmap</tag>
      
      <tag>内存，虚拟地址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】网络 IO 演变发展过程和模型介绍</title>
    <link href="/2021/05/11/nonblocking-io/"/>
    <url>/2021/05/11/nonblocking-io/</url>
    
    <content type="html"><![CDATA[<p>在互联网中提起网络，我们都会避免不了讨论高并发、百万连接。而此处的百万连接的实现，脱离不了网络 IO 的选择，因此本文作为一篇个人学习的笔记，特此进行记录一下整个网络 IO 的发展演变过程。以及目前广泛使用的网络模型。</p><h2 id="网络-IO-的发展"><a href="#网络-IO-的发展" class="headerlink" title="网络 IO 的发展"></a>网络 IO 的发展</h2><p>在本节内容中，我们将一步一步介绍网络 IO 的演变发展过程。介绍完发展过程后，再对网络 IO 中几组容易混淆的概念进行对比、分析。</p><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/159e46c0950a4f2899729cb1ac78921b"></p><h3 id="网络-IO-的各个发展阶段"><a href="#网络-IO-的各个发展阶段" class="headerlink" title="网络 IO 的各个发展阶段"></a>网络 IO 的各个发展阶段</h3><p>通常，我们在此讨论的网络 IO 一般都是针对 linux 操作系统而言。网络 IO 的发展过程是随着 linux 的内核演变而变化，因此网络 IO 大致可以分为如下几个阶段：</p><ol><li>阻塞 IO(<code>BIO</code>)</li><li>非阻塞 IO(<code>NIO</code>)</li><li>IO 多路复用第一版(<code>select</code>/<code>poll</code>)</li><li>IO 多路复用第二版(<code>epoll</code>)</li><li>异步 IO(<code>AIO</code>)</li></ol><p>而每一个阶段，都是因为当前的网络有一些缺陷，因此又在不断改进该缺陷。这是网络 IO 一直演变过程中的本质。下面将对上述几个阶段进行介绍，并对每个阶段的网络 IO 解决了哪些问题、优点、缺点进行剖析。</p><h3 id="网络的两个阶段"><a href="#网络的两个阶段" class="headerlink" title="网络的两个阶段"></a>网络的两个阶段</h3><p>在网络中，我们通常可以将其广义上划分为以下两个阶段：</p><p>第一阶段：硬件接口到内核态<br>第二阶段：内核态到用户态</p><p>本人理解：我们通常上网，大部分数据都是通过网线传递的。因此对于两台计算机而言，要进行网络通信，其数据都是先从应用程序传递到传输层(TCP/UDP)到达内核态，然后再到网络层、数据链路层、物理层，接着数据传递到硬件网卡，最后通过网络传输介质传递到对端机器的网卡，然后再一步一步数据从网卡传递到内核态，最后再拷贝到用户态。</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/83594a2704d3449aa87f9a5d7cb07c16"></p><h3 id="阻塞-IO-和非阻塞-IO-的区别"><a href="#阻塞-IO-和非阻塞-IO-的区别" class="headerlink" title="阻塞 IO 和非阻塞 IO 的区别"></a>阻塞 IO 和非阻塞 IO 的区别</h3><p>根据 1.2 节的内容，我们可以知道，网络中的数据传输从网络传输介质到达目的机器，需要如上两个阶段。此处我们把从硬件到内核态这一阶段，是否发生阻塞等待，可以将网络分为阻塞 IO和非阻塞 IO。如果用户发起了读写请求，但内核态数据还未准备就绪，该阶段不会阻塞用户操作，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。</p><p>因此，区分阻塞 IO 和非阻塞 IO 主要看第一阶段是否阻塞用户操作。</p><h3 id="同步-IO-和异步-IO-的区别"><a href="#同步-IO-和异步-IO-的区别" class="headerlink" title="同步 IO 和异步 IO 的区别"></a>同步 IO 和异步 IO 的区别</h3><p>从前面我们知道了，数据的传递需要两个阶段，在此处只要任何一个阶段会阻塞用户请求，都将其称为同步 IO，两个阶段都不阻塞，则称为异步 IO。</p><p>在目前所有的操作系统中，linux 中的 <code>epoll</code>、mac 的 <code>kqueue</code> 都属于同步 IO，因为其在第二阶段(数据从内核态到用户态)都会发生拷贝阻塞。而只有 windows 中的 <code>IOCP</code> 才真正属于异步 IO，即 <code>AIO</code>。</p><h2 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h2><p>在本节，我们将介绍最初的阻塞 IO，阻塞 IO 英文为 <code>blocking IO</code>，又称为 <code>BIO</code>。根据前面的介绍，阻塞 IO 主要指的是第一阶段(硬件网卡到内核态)。</p><h3 id="阻塞-IO-的概念"><a href="#阻塞-IO-的概念" class="headerlink" title="阻塞 IO 的概念"></a>阻塞 IO 的概念</h3><p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。具体过程可以参考 2.2 的图示。</p><h3 id="阻塞-IO-的过程"><a href="#阻塞-IO-的过程" class="headerlink" title="阻塞 IO 的过程"></a>阻塞 IO 的过程</h3><p>​<img src="https://p6-tt.byteimg.com/origin/pgc-image/71c28eaee6a8417cbe636c7c883f6c02"></p><h3 id="阻塞-IO-的缺点"><a href="#阻塞-IO-的缺点" class="headerlink" title="阻塞 IO 的缺点"></a>阻塞 IO 的缺点</h3><p>在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是阻塞 IO + 多线程，每个连接一个单独的线程进行处理。</p><p>我们知道，一般一个程序可以开辟的线程是有限的，而且开辟线程的开销也是比较大的。也正是这种方式，会导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理。</p><p>既然发现了问题，分析了问题，那就得解决问题。既然阻塞 IO 有问题，本质是由于其阻塞导致的，因此自然而然引出了下面即将介绍的主角：非阻塞 IO</p><h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>非阻塞 IO 是为了解决前面提到的阻塞 IO 的缺陷而引出的，下面我们将介绍非阻塞 IO 的过程。</p><h3 id="非阻塞-IO-的概念"><a href="#非阻塞-IO-的概念" class="headerlink" title="非阻塞 IO 的概念"></a>非阻塞 IO 的概念</h3><p>非阻塞 IO：见名知意，就是在第一阶段(网卡-内核态)数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据好了没，好了没。</p><h3 id="非阻塞-IO-的过程"><a href="#非阻塞-IO-的过程" class="headerlink" title="非阻塞 IO 的过程"></a>非阻塞 IO 的过程</h3><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/12149fcdc97a493fa54248ad8da64bfa"></p><p>非阻塞 IO 是需要系统内核支持的，在创建了连接后，可以调用 <code>setsockop</code> 设置 <code>noblocking</code></p><h3 id="非阻塞-IO-的优点"><a href="#非阻塞-IO-的优点" class="headerlink" title="非阻塞 IO 的优点"></a>非阻塞 IO 的优点</h3><p>正如前面提到的，非阻塞 IO 解决了阻塞 IO 每个连接一个线程处理的问题，所以其最大的优点就是 一个线程可以处理多个连接，这也是其非阻塞决定的。</p><h3 id="非阻塞-IO-的缺点"><a href="#非阻塞-IO-的缺点" class="headerlink" title="非阻塞 IO 的缺点"></a>非阻塞 IO 的缺点</h3><p>但这种模式，也有一个问题，就是需要用户多次发起系统调用。频繁的系统调用是比较消耗系统资源的。</p><p>因此，既然存在这样的问题，那么自然而然我们就需要解决该问题：保留非阻塞 IO 的优点的前提下，减少系统调用</p><h2 id="IO-多路复用第一版"><a href="#IO-多路复用第一版" class="headerlink" title="IO 多路复用第一版"></a>IO 多路复用第一版</h2><p>为了解决非阻塞 IO 存在的频繁的系统调用这个问题，随着内核的发展，出现了 IO 多路复用模型。那么我们就需要搞懂几个问题：</p><ol><li>IO 多路复用到底复用什么？</li><li>IO 多路复用如何复用？</li></ol><p>IO 多路复用： 很多人都说，IO 多路复用是用一个线程来管理多个网络连接，但本人不太认可，因为在非阻塞 IO 时，就已经可以实现一个线程处理多个网络连接了，这个是由于其非阻塞而决定的。</p><p>在此处，个人观点，多路复用主要复用的是通过有限次的系统调用来实现管理多个网络连接。最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。因此，IO 多路复用，复用的是系统调用。通过有限次系统调用判断海量连接是否数据准备好了</p><p>无论下面的 <code>select</code>、<code>poll</code>、<code>epoll</code>，其都是这种思想实现的，不过在实现上，<code>select</code>/<code>poll</code> 可以看做是第一版，而 <code>epoll</code> 是第二版</p><h3 id="IO-多路复用第一版的概念"><a href="#IO-多路复用第一版的概念" class="headerlink" title="IO 多路复用第一版的概念"></a>IO 多路复用第一版的概念</h3><p>IO 多路复用第一版，这个概念是本人想出来的，主要是方便将 <code>select</code>/<code>poll</code> 和 <code>epoll</code> 进行区分</p><p>所以此处 IO 多路复用第一版，主要特指 <code>select</code> 和 <code>poll</code> 这两个。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;</code></pre></div><p><code>select</code> 函数监视的文件描述符分 3 类，分别是 <code>writefds</code>、<code>readfds</code> 和 <code>exceptfds</code>。调用后 <code>select</code> 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 <code>select</code> 函数返回后，可以通过遍历 <code>fdset</code>，来找到就绪的描述符。</p><p><code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<code>select</code> 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;    <span class="hljs-type">int</span> fd; <span class="hljs-comment">/* file descriptor */</span>    <span class="hljs-type">short</span> events; <span class="hljs-comment">/* requested events to watch */</span>    <span class="hljs-type">short</span> revents; <span class="hljs-comment">/* returned events witnessed */</span>&#125;;</code></pre></div><p><code>pollfd</code> 结构包含了要监视的 <code>event</code> 和发生的 <code>event</code>，不再使用 <code>select</code> “参数-值” 传递的方式。同时，<code>pollfd</code> 并没有最大数量限制（但是数量过大后性能也是会下降）。和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 <code>pollfd</code> 来获取就绪的描述符。</p><p>从上面看，<code>select</code> 和 <code>poll</code> 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><p>从本质来说：IO 多路复用中，<code>select()</code>/<code>poll()</code>/<code>epoll_wait()</code> 这几个函数对应第一阶段；<code>read()</code>/<code>recvfrom()</code> 对应第二阶段</p><h3 id="IO-多路复用第一版的过程"><a href="#IO-多路复用第一版的过程" class="headerlink" title="IO 多路复用第一版的过程"></a>IO 多路复用第一版的过程</h3><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/fce10fab6ff645e082796b8fa275527b"></p><h3 id="IO-多路复用第一版的优点"><a href="#IO-多路复用第一版的优点" class="headerlink" title="IO 多路复用第一版的优点"></a>IO 多路复用第一版的优点</h3><p>IO 多路复用，主要在于复用，通过 <code>select()</code> 或者 <code>poll()</code> 将多个 <code>socket fds</code> 批量通过系统调用传递给内核，由内核进行循环遍历判断哪些 <code>fd</code> 上数据就绪了，然后将就绪的 <code>readyfds</code> 返回给用户。再由用户进行挨个遍历就绪好的 <code>fd</code>，读取或者写入数据。</p><p>所以通过 IO 多路复用 + 非阻塞 IO，一方面降低了系统调用次数，另一方面可以用极少的线程来处理多个网络连接。</p><h3 id="IO-多路复用第一版的缺点"><a href="#IO-多路复用第一版的缺点" class="headerlink" title="IO 多路复用第一版的缺点"></a>IO 多路复用第一版的缺点</h3><p>虽然第一版 IO 多路复用解决了之前提到的频繁的系统调用次数，但同时引入了新的问题：用户需要每次将海量的 <code>socket fds</code> 集合从用户态传递到内核态，让内核态去检测哪些网络连接数据就绪了</p><p>但这个地方会出现频繁的将海量 <code>fd</code> 集合从用户态传递到内核态，再从内核态拷贝到用户态。所以，这个地方开销也挺大。</p><p>既然还有这个问题，那我们继续开始解决这个问题，因此就引出了第二版的 IO 多路复用。</p><p>其实思路也挺简单，既然需要拷贝，那就想办法，不拷贝。既然不拷贝，那就在内核开辟一段区域咯</p><h3 id="IO-多路复用第一版的区别"><a href="#IO-多路复用第一版的区别" class="headerlink" title="IO 多路复用第一版的区别"></a>IO 多路复用第一版的区别</h3><p><code>select</code> 和 <code>poll</code> 的区别</p><ol><li><code>select</code> 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 <code>poll</code> 理论上可以支持无限个</li><li><code>select</code> 和 <code>poll</code> 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源。</li></ol><h2 id="IO-多路复用第二版"><a href="#IO-多路复用第二版" class="headerlink" title="IO 多路复用第二版"></a>IO 多路复用第二版</h2><p>IO 多路复用第二版主要指 <code>epoll</code>，<code>epoll</code> 的出现也是随着内核版本迭代才诞生的，在网上到处看到，<code>epoll</code> 是内核 2.6 以后开始支持的</p><p><code>epoll</code> 的出现是为了解决前面提到的 IO 多路复用第一版的问题</p><h3 id="IO-多路复用第二版的概念"><a href="#IO-多路复用第二版的概念" class="headerlink" title="IO 多路复用第二版的概念"></a>IO 多路复用第二版的概念</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>；<span class="hljs-comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//往红黑树中增加、删除、更新管理的socket fd</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>；</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//这个api是用来在第一阶段阻塞，等待就绪的fd。</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;</code></pre></div><p><code>int epoll_create(int size);</code></p><p>创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select()</code> 中的第一个参数，给出最大监听的 fd+1 的值，参数 <code>size</code> 并不是限制了 <code>epoll</code> 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p><p>当创建好 <code>epoll</code> 句柄后，它就会占用一个 <code>fd</code> 值，在 linux 下如果查看 <code>/proc/进程id/fd/</code>，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></p><p>函数是对指定描述符 <code>fd</code> 执行 <code>op</code> 操作:</p><ul><li><code>epfd</code>：是 <code>epoll_create()</code> 的返回值。</li><li><code>op</code>：表示 <code>op</code> 操作，用三个宏来表示：添加 <code>EPOLL_CTL_ADD</code>，删除 <code>EPOLL_CTL_DEL</code>，修改 <code>EPOLL_CTL_MOD</code>。分别添加、删除和修改对 <code>fd</code> 的监听事件。</li><li><code>fd</code>：是需要监听的 <code>fd</code>（文件描述符）</li><li><code>epoll_event</code>：是告诉内核需要监听什么事，<code>struct epoll_event</code> 结构如下：</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> &#123;  <span class="hljs-type">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span>  <span class="hljs-type">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span>&#125;;<span class="hljs-comment">// events可以是以下几个宏的集合：</span><span class="hljs-comment">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><span class="hljs-comment">// EPOLLOUT：表示对应的文件描述符可以写；</span><span class="hljs-comment">// EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><span class="hljs-comment">// EPOLLERR：表示对应的文件描述符发生错误；</span><span class="hljs-comment">// EPOLLHUP：表示对应的文件描述符被挂断；</span><span class="hljs-comment">// EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><span class="hljs-comment">// EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span></code></pre></div><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code></p><p>等待 <code>epfd</code> 上的 <code>io</code> 事件，最多返回 <code>maxevents</code> 个事件。</p><p>参数 <code>events</code> 用来从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code>，参数 <code>timeout</code> 是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p><code>epoll</code> 对文件描述符的操作有两种模式：<code>LT（level trigger）</code> 和 <code>ET（edge trigger）</code>。<code>LT</code> 模式是默认模式，<code>LT</code> 模式与 <code>ET</code> 模式的区别如下：</p><ol><li><code>LT</code> 模式当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件。</li><li><code>ET</code> 模式当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li></ol><h4 id="LT-模式"><a href="#LT-模式" class="headerlink" title="LT 模式"></a>LT 模式</h4><p><code>LT(level triggered)</code> 是缺省的工作方式，并且同时支持 <code>block</code> 和 <code>no-block socket</code>.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 <code>fd</code> 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p><h4 id="ET-模式"><a href="#ET-模式" class="headerlink" title="ET 模式"></a>ET 模式</h4><p><code>ET(edge-triggered)</code> 是高速工作方式，只支持<code> no-block socket</code>。在这种模式下，当描述符从未就绪变为就绪时，内核通过 <code>epoll</code> 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 <code>EWOULDBLOCK</code> 错误）。但是请注意，如果一直不对这个 <code>fd</code> 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p><code>ET</code> 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 <code>LT</code> 模式高。<code>epoll</code> 工作在 <code>ET</code> 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h3 id="IO-多路复用第二版的过程"><a href="#IO-多路复用第二版的过程" class="headerlink" title="IO 多路复用第二版的过程"></a>IO 多路复用第二版的过程</h3><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/ddb4604a40fa4dd1a6cefc3f0799a03e"></p><p>当 <code>epoll_wait()</code> 调用后会阻塞，然后完了当返回时，会返回了哪些 <code>fd</code> 的数据就绪了，用户只需要遍历就绪的 <code>fd</code> 进行读写即可。</p><h3 id="IO-多路复用第二版的优点"><a href="#IO-多路复用第二版的优点" class="headerlink" title="IO 多路复用第二版的优点"></a>IO 多路复用第二版的优点</h3><p>IO 多路复用第二版 epoll 的优点在于一开始就在内核态分配了一段空间，来存放管理的 fd,所以在每次连接建立后，交给 <code>epoll</code> 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。所以现在的 IO 多路复用主要指 <code>epoll</code></p><h3 id="IO-多路复用第二版的缺点"><a href="#IO-多路复用第二版的缺点" class="headerlink" title="IO 多路复用第二版的缺点"></a>IO 多路复用第二版的缺点</h3><p>个人猜想： 如何降低占用的空间</p><h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><h3 id="异步-IO-的过程"><a href="#异步-IO-的过程" class="headerlink" title="异步 IO 的过程"></a>异步 IO 的过程</h3><p>​<img src="https://p3-tt.byteimg.com/origin/pgc-image/21afcdfdb3e145318cc3a771ea11f649"></p><p>前面介绍的所有网络 IO 都是同步 IO，因为当数据在内核态就绪时，在内核态拷贝用用户态的过程中，仍然会有短暂时间的阻塞等待。而异步 IO 指：内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成，目前只有 windows 系统的 <code>IOCP</code> 是属于异步 IO。</p><h2 id="网络-IO-各种模型"><a href="#网络-IO-各种模型" class="headerlink" title="网络 IO 各种模型"></a>网络 IO 各种模型</h2><h3 id="reactor-模型"><a href="#reactor-模型" class="headerlink" title="reactor 模型"></a>reactor 模型</h3><p>目前 <code>reactor</code> 模型有以下几种实现方案：</p><ol><li>单 <code>reactor</code> 单线程模型</li><li>单 <code>reactor</code> 多线程模型</li><li><code>multi-reactor</code> 多线程模型</li><li><code>multi-reactor</code> 多进程模型</li></ol><h4 id="单-reactor-单线程模型"><a href="#单-reactor-单线程模型" class="headerlink" title="单 reactor 单线程模型"></a>单 reactor 单线程模型</h4><p>此种模型，通常是只有一个 <code>epoll</code> 对象，所有的接收客户端连接、客户端读取、客户端写入操作都包含在一个线程内。该种模型也有一些中间件在用，比如 <code>redis</code></p><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/a4a057a00b5748d9b5146a9d4dc3ba2a"></p><p>但在目前的单线程 <code>Reactor</code> 模式中，不仅 I/O 操作在该 <code>Reactor</code> 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 <code>Reactor</code> 线程上卸载，以此来加速 <code>Reactor</code> 线程对 I/O 请求的响应。</p><h4 id="单-reactor-多线程模型"><a href="#单-reactor-多线程模型" class="headerlink" title="单 reactor 多线程模型"></a>单 <code>reactor</code> 多线程模型</h4><p>该模型主要是通过将，前面的模型进行改造，将读写的业务逻辑交给具体的线程池来实现，这样可以显示 <code>reactor</code> 线程对 IO 的响应，以此提升系统性能</p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/cd4d1c679c9e48a9846e65ad76363e7b"></p><p>在工作者线程池模式中，虽然非 I/O 操作交给了线程池来处理，但是所有的 I/O 操作依然由 <code>Reactor</code> 单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于 <code>Reactor</code> 的优化，又产生出下面的多线程模式。</p><h4 id="multi-reactor-多线程模型"><a href="#multi-reactor-多线程模型" class="headerlink" title="multi-reactor 多线程模型"></a>multi-reactor 多线程模型</h4><p>在这种模型中，主要分为两个部分：<code>mainReactor</code>、<code>subReactors</code>。<code>mainReactor</code> 主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给 <code>subReactors</code>，<code>subReactors</code> 来负责具体的每个连接的读写，对于非 IO 的操作，依然交给工作线程池去做，对逻辑进行解耦</p><p>​<img src="https://p1-tt.byteimg.com/origin/pgc-image/b092d02d992646b49468059f5c808036"></p><p><code>mainReactor</code> 对应 <code>Netty</code> 中配置的 <code>BossGroup</code> 线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，<code>BossGroup</code> 线程组一般一个线程工作即可 <code>subReactor</code> 对应 <code>Netty</code> 中配置的 <code>WorkerGroup</code> 线程组，<code>BossGroup</code> 线程组接受并建立完客户端的连接后，将网络 socket 转交给 <code>WorkerGroup</code> 线程组，然后在 <code>WorkerGroup</code> 线程组内选择一个线程，进行 I/O 的处理。<code>WorkerGroup</code> 线程组主要处理 I/O，一般设置 2*CPU 核数个线程</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>IO 模式和 IO 多路复用</li><li>Linux IO 模式及 select、poll、epoll 详解</li><li>Chapter 6. I/O Multiplexing: The select and poll Functions</li><li>高性能 IO 模型分析-Reactor 模式和 Proactor 模式（二）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>select</tag>
      
      <tag>poll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KOOM - 利用子进程 dump hprof</title>
    <link href="/2021/05/07/koom/"/>
    <url>/2021/05/07/koom/</url>
    
    <content type="html"><![CDATA[<h2 id="不冻结-APP-的-dump-hprof"><a href="#不冻结-APP-的-dump-hprof" class="headerlink" title="不冻结 APP 的 dump hprof"></a>不冻结 APP 的 dump hprof</h2><p>在 <a href="../../../../2021/04/12/leakcanary/">LeakCanary 浅析</a> 和 <a href="../../../../2021/04/23/matrix-resourcescanary/">Matrix - ResourcesCanary 浅析</a> 这两篇文章里，介绍了检测内存泄漏的两种相似的思路：</p><ol><li><code>WeakReference</code> + <code>ReferenceQueue</code> + 延迟 5s 检查是否被 GC</li><li><code>WeakReference</code> + <code>ConcurrentLinkedQueue</code>，子线程轮询的方式每隔 1m 检查队列里的对象是否被 GC</li></ol><p>但无论 <code>LeakCanary</code> 还是 <code>Matrix.ResourcesCanary</code> 都没有解决 dump hprof 时整个 APP 被「冻结」的问题，而一次 dump hprof 往往要持续 10s 甚至更多，这在线上环境下是不可接受的，所以在发生内存泄漏后只能上报类信息，开发者收到后人工检查涉及此类的相关代码找出泄漏点。但是这种方式是极其低效和不准确的，如果能在端侧找出泄漏对象的 GC ROOT PATH，就能极大地减少人工量，并且提高后续修复的准确度。</p><p>如果能够在不冻结 APP 的情况下 dump hprof，不仅仅能够上报内存泄漏问题，还能对 OOM 进行预警：比如监控 JVM 的内存使用率，当达到 90% 的时候将 hprof 上报分析</p><p><code>KOOM</code> 提出了一个在不冻结 APP 的情况下 dump hprof 的思路：<code>fork</code> 出子进程，总体流程是这样的：</p><ol><li>父进程 suspend JVM</li><li>父进程 fork 出子进程</li><li>父进程 resume JVM 后，线程等待子进程结束从而拿到 hprof</li><li>子进程调用 <code>Debug.dumpHprofData</code> 生成 hprof 后退出</li><li>父进程启动 <code>Service</code> 在另一个进程里解析 hprof 并构造 GC ROOT PATH</li></ol><p>整个过程 APP 只在 <code>fork</code> 前后冻结了一小会，这么短的时间是可以接受的，由于 <code>fork</code> 采用 <code>Copy-On-Write</code> 机制，子进程能够继承父进程的内存</p><h2 id="暂停和恢复-JVM"><a href="#暂停和恢复-JVM" class="headerlink" title="暂停和恢复 JVM"></a>暂停和恢复 JVM</h2><ol><li>&lt;= Android 10，使用函数 <code>SuspendVMEv</code> 和 <code>ResumeVMEv</code></li><li>&gt;= Android 11，使用类 <code>ScopedSuspendAll</code>（局部变量，构造函数暂停 JVM，析构函数恢复 JVM）</li><li>&lt;= Android 4，<code>KOOM</code> 不支持</li></ol><p>但是要从各个 Android 版本的 so 文件里准确找到这些函数（符号）是有难度的</p><p>寻找 <code>SuspendVMEv</code> 和 <code>ResumeVMEv</code> 的地址</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 自己实现 dlopen dlsym dlclose 以兼容各 Android 版本</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">initForkVMSymbols</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-type">void</span> *libHandle = kwai::linker::DlFcn::<span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, RTLD_NOW);  <span class="hljs-keyword">if</span> (libHandle == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  suspendVM = (<span class="hljs-built_in">void</span> (*)())kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(libHandle, <span class="hljs-string">&quot;_ZN3art3Dbg9SuspendVMEv&quot;</span>);  <span class="hljs-keyword">if</span> (suspendVM == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art3Dbg9SuspendVMEv unsupported!&quot;</span>);  &#125;  resumeVM = (<span class="hljs-built_in">void</span> (*)())kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(libHandle, <span class="hljs-string">&quot;_ZN3art3Dbg8ResumeVMEv&quot;</span>);  <span class="hljs-keyword">if</span> (resumeVM == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art3Dbg8ResumeVMEv unsupported!&quot;</span>);  &#125;  kwai::linker::DlFcn::<span class="hljs-built_in">dlclose</span>(libHandle);  <span class="hljs-keyword">return</span> suspendVM != <span class="hljs-literal">nullptr</span> &amp;&amp; resumeVM != <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> *<span class="hljs-title">DlFcn::dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *lib_name, <span class="hljs-type">int</span> flags)</span> </span>&#123;  <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;dlopen %s&quot;</span>, lib_name);  <span class="hljs-built_in">pthread_once</span>(&amp;once_control, init_api);  <span class="hljs-keyword">if</span> (android_api_ &lt; __ANDROID_API_N__) &#123;                         <span class="hljs-comment">// N 以下打开 libart.so 查找符号</span>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">dlopen</span>(lib_name, flags);  &#125;  <span class="hljs-keyword">if</span> (android_api_ &gt; __ANDROID_API_N__) &#123;    <span class="hljs-type">void</span> *handle = ::<span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libdl.so&quot;</span>, RTLD_NOW);    <span class="hljs-built_in">CHECKP</span>(handle)    <span class="hljs-keyword">auto</span> __loader_dlopen = <span class="hljs-built_in">reinterpret_cast</span>&lt;__loader_dlopen_fn&gt;(::<span class="hljs-built_in">dlsym</span>(handle, <span class="hljs-string">&quot;__loader_dlopen&quot;</span>));    <span class="hljs-built_in">CHECKP</span>(__loader_dlopen)    <span class="hljs-keyword">if</span> (android_api_ &lt; __ANDROID_API_Q__) &#123;                       <span class="hljs-comment">// Q 以下用 __loader_dlopen 查找符号</span>      <span class="hljs-keyword">return</span> __loader_dlopen(lib_name, flags, (<span class="hljs-type">void</span> *)dlerror);    &#125; <span class="hljs-keyword">else</span> &#123;      handle = __loader_dlopen(lib_name, flags, (<span class="hljs-type">void</span> *)dlerror); <span class="hljs-comment">// 其他情况，从 /proc/self/maps 拿到进程的内存布局，找到 mmap 进内存的 libart.so，根据 elf 文件结构解析里面的符号</span>      <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-comment">// Android Q added &quot;runtime&quot; namespace</span>        dl_iterate_data data&#123;&#125;;        data.info_.dlpi_name = lib_name;        <span class="hljs-built_in">dl_iterate_phdr_wrapper</span>(dl_iterate_callback, &amp;data);        <span class="hljs-built_in">CHECKP</span>(data.info_.dlpi_addr &gt; <span class="hljs-number">0</span>)        handle = __loader_dlopen(lib_name, flags, (<span class="hljs-type">void</span> *)data.info_.dlpi_addr);      &#125;      <span class="hljs-keyword">return</span> handle;    &#125;  &#125;  <span class="hljs-comment">// __ANDROID_API_N__</span>  <span class="hljs-keyword">auto</span> *data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">dl_iterate_data</span>();  data-&gt;info_.dlpi_name = lib_name;  <span class="hljs-built_in">dl_iterate_phdr_wrapper</span>(dl_iterate_callback, data);  <span class="hljs-keyword">return</span> data;&#125;<span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> *<span class="hljs-title">DlFcn::dlsym</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> </span>&#123;  <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;dlsym %s&quot;</span>, name);  <span class="hljs-built_in">CHECKP</span>(handle)  <span class="hljs-keyword">if</span> (android_api_ != __ANDROID_API_N__) &#123;                  <span class="hljs-comment">// 用 dlopen 打开则用 dlsym 查找符号</span>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">dlsym</span>(handle, name);  &#125;  <span class="hljs-comment">// __ANDROID_API_N__</span>  <span class="hljs-keyword">auto</span> *data = (dl_iterate_data *)handle;                   <span class="hljs-comment">// 否则遍历 elf 里的符号列表查找</span>  <span class="hljs-built_in">ElfW</span>(Addr) dlpi_addr = data-&gt;info_.dlpi_addr;  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Phdr)</span> *dlpi_phdr </span>= data-&gt;info_.dlpi_phdr;  <span class="hljs-built_in">ElfW</span>(Half) dlpi_phnum = data-&gt;info_.dlpi_phnum;  <span class="hljs-comment">// preserved for parse .symtab</span>  <span class="hljs-built_in">ElfW</span>(Addr) elf_base_addr;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dlpi_phnum; ++i) &#123;    <span class="hljs-keyword">if</span> (dlpi_phdr[i].p_type == PT_LOAD &amp;&amp; dlpi_phdr[i].p_offset == <span class="hljs-number">0</span>) &#123;      elf_base_addr = dlpi_addr + dlpi_phdr[i].p_vaddr;      <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;PT_LOAD dlpi_addr %p p_vaddr %p elf_base_addr %p&quot;</span>, dlpi_addr, dlpi_phdr[i].p_vaddr,            elf_base_addr);    &#125;    <span class="hljs-keyword">if</span> (dlpi_phdr[i].p_type == PT_DYNAMIC) &#123;      <span class="hljs-built_in">ElfW</span>(Dyn) *dyn = (<span class="hljs-built_in">ElfW</span>(Dyn) *)(dlpi_addr + dlpi_phdr[i].p_vaddr);      <span class="hljs-built_in">ElfW</span>(Dyn) *dyn_end = dyn + (dlpi_phdr[i].p_memsz / <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">ElfW</span>(Dyn)));      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *strtab;      <span class="hljs-built_in">ElfW</span>(Sym) * symtab;      <span class="hljs-type">bool</span> is_use_gnu_hash = <span class="hljs-literal">false</span>;      <span class="hljs-comment">// for ELF hash</span>      <span class="hljs-type">size_t</span> nbucket_;      <span class="hljs-type">size_t</span> nchain_;      <span class="hljs-type">uint32_t</span> *bucket_;      <span class="hljs-type">uint32_t</span> *chain_;      <span class="hljs-comment">// for GNU hash</span>      <span class="hljs-type">size_t</span> gnu_nbucket_;      <span class="hljs-type">uint32_t</span> *gnu_bucket_;      <span class="hljs-type">uint32_t</span> *gnu_chain_;      <span class="hljs-type">uint32_t</span> gnu_maskwords_;      <span class="hljs-type">uint32_t</span> gnu_shift2_;      <span class="hljs-built_in">ElfW</span>(Addr) * gnu_bloom_filter_;      <span class="hljs-comment">// ELF parse</span>      <span class="hljs-keyword">for</span> (; dyn &lt; dyn_end; dyn++) &#123;        <span class="hljs-keyword">switch</span> (dyn-&gt;d_tag) &#123;        <span class="hljs-keyword">case</span> DT_NULL:          <span class="hljs-comment">// the end of the dynamic-section</span>          dyn = dyn_end;          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> DT_STRTAB: &#123;          <span class="hljs-built_in">ElfW</span>(Addr) strtab_addr = dlpi_addr + dyn-&gt;d_un.d_ptr;          strtab = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(strtab_addr);          <span class="hljs-built_in">CHECKP</span>(strtab_addr &gt;= dlpi_addr)          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> DT_SYMTAB: &#123;          <span class="hljs-built_in">ElfW</span>(Addr) symtab_addr = dlpi_addr + dyn-&gt;d_un.d_ptr;          symtab = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-built_in">ElfW</span>(Sym) *&gt;(symtab_addr);          <span class="hljs-built_in">CHECKP</span>(symtab_addr &gt;= dlpi_addr)          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> DT_HASH: &#123;          <span class="hljs-comment">// ignore DT_HASH when ELF contains DT_GNU_HASH hash table</span>          <span class="hljs-keyword">if</span> (is_use_gnu_hash) &#123;            <span class="hljs-keyword">continue</span>;          &#125;          nbucket_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">0</span>];          nchain_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">1</span>];          bucket_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr + <span class="hljs-number">8</span>);          chain_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr + <span class="hljs-number">8</span> + nbucket_ * <span class="hljs-number">4</span>);          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> DT_GNU_HASH: &#123;          gnu_nbucket_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">0</span>];          <span class="hljs-comment">// skip symndx</span>          gnu_maskwords_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">2</span>];          gnu_shift2_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">3</span>];          gnu_bloom_filter_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-built_in">ElfW</span>(Addr) *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr + <span class="hljs-number">16</span>);          gnu_bucket_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(gnu_bloom_filter_ + gnu_maskwords_);          <span class="hljs-comment">// amend chain for symndx = header[1]</span>          gnu_chain_ = gnu_bucket_ + gnu_nbucket_ -                       <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint32_t</span> *&gt;(dlpi_addr + dyn-&gt;d_un.d_ptr)[<span class="hljs-number">1</span>];          --gnu_maskwords_;          is_use_gnu_hash = <span class="hljs-literal">true</span>;          <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">default</span>:          <span class="hljs-keyword">break</span>;        &#125;      &#125;      <span class="hljs-comment">// lookup symbol</span>      <span class="hljs-keyword">if</span> (is_use_gnu_hash) &#123;        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;lookup use gnu hash&quot;</span>);        <span class="hljs-type">uint32_t</span> hash = <span class="hljs-built_in">elf_gnu_hash</span>((<span class="hljs-type">uint8_t</span> *)name);        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint32_t</span> kBloomMaskBits = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">ElfW</span>(Addr)) * <span class="hljs-number">8</span>;        <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; gnu_maskwords_;        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span> bloom_word </span>= gnu_bloom_filter_[word_num];        <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> h1 = hash % kBloomMaskBits;        <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> h2 = (hash &gt;&gt; gnu_shift2_) % kBloomMaskBits;        <span class="hljs-comment">// test against bloom filter</span>        <span class="hljs-built_in">CHECKP</span>((<span class="hljs-number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) != <span class="hljs-number">0</span>)        <span class="hljs-comment">// bloom test says &quot;probably yes&quot;...</span>        <span class="hljs-type">uint32_t</span> n = gnu_bucket_[hash % gnu_nbucket_];        <span class="hljs-keyword">do</span> &#123;          <span class="hljs-built_in">ElfW</span>(Sym) *s = symtab + n;          <span class="hljs-keyword">if</span> (((gnu_chain_[n] ^ hash) &gt;&gt; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(strtab + s-&gt;st_name, name) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;find %s %p&quot;</span>, name, dlpi_addr + s-&gt;st_value);            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(dlpi_addr + s-&gt;st_value);          &#125;        &#125; <span class="hljs-keyword">while</span> ((gnu_chain_[n++] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;lookup use elf hash&quot;</span>);        <span class="hljs-type">uint32_t</span> hash = <span class="hljs-built_in">elf_hash</span>((<span class="hljs-type">uint8_t</span> *)name);        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> n = bucket_[hash % nbucket_]; n != <span class="hljs-number">0</span>; n = chain_[n]) &#123;          <span class="hljs-built_in">ElfW</span>(Sym) *s = symtab + n;          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(strtab + s-&gt;st_name, name) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;find %s %p&quot;</span>, name, dlpi_addr + s-&gt;st_value);            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(dlpi_addr + s-&gt;st_value);          &#125;        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;</code></pre></div><p>查找 <code>ScopedSuspendAll</code> 的构造函数和析构函数</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_dumpHprofDataNative</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jclass clazz, jstring file_name)</span> </span>&#123;  <span class="hljs-built_in">pthread_once</span>(&amp;once_control, initDumpHprofSymbols);  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// For above android 11</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">initDumpHprofSymbols</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Parse .dynsym(GLOBAL)</span>  <span class="hljs-type">void</span> *libHandle = kwai::linker::DlFcn::<span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, RTLD_NOW);  <span class="hljs-keyword">if</span> (libHandle == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span>;  &#125;  ScopedSuspendAllConstructor = (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">bool</span>))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(      libHandle, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllC1EPKcb&quot;</span>);  <span class="hljs-keyword">if</span> (ScopedSuspendAllConstructor == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllC1EPKcb unsupported!&quot;</span>);  &#125;  ScopedSuspendAllDestructor =      (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym</span>(libHandle, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllD1Ev&quot;</span>);  <span class="hljs-keyword">if</span> (ScopedSuspendAllDestructor == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art16ScopedSuspendAllD1Ev unsupported!&quot;</span>);  &#125;  kwai::linker::DlFcn::<span class="hljs-built_in">dlclose</span>(libHandle);  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>使用系统调用 <code>fork</code> 创建子进程</p><ol><li>子进程返回 0，dump hprof 后退出进程</li><li>父进程返回子进程 pid，首先恢复 JVM，然后利用 <code>waitpid</code> 阻塞直到子进程完成 dump hprof，然后处理 hprof</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJvmHeapDumper</span> &#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dump</span><span class="hljs-params">(String path)</span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">dumpRes</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> trySuspendVMThenFork();      <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;                       <span class="hljs-comment">// 子进程</span>        Debug.dumpHprofData(path);        KLog.i(TAG, <span class="hljs-string">&quot;notifyDumped:&quot;</span> + dumpRes);        <span class="hljs-comment">//System.exit(0);</span>        exitProcess();      &#125; <span class="hljs-keyword">else</span> &#123;                              <span class="hljs-comment">// 父进程</span>        resumeVM();        dumpRes = waitDumping(pid);        KLog.i(TAG, <span class="hljs-string">&quot;hprof pid:&quot;</span> + pid + <span class="hljs-string">&quot; dumped: &quot;</span> + path);      &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      e.printStackTrace();      KLog.e(TAG, <span class="hljs-string">&quot;dump failed caused by IOException!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> dumpRes;  &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_trySuspendVMThenFork</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jobject jObject)</span> </span>&#123;  <span class="hljs-keyword">if</span> (suspendVM == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-built_in">initForkVMSymbols</span>();  &#125;  <span class="hljs-keyword">if</span> (suspendVM != <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-built_in">suspendVM</span>();  &#125;  <span class="hljs-keyword">return</span> fork();    <span class="hljs-comment">// 用系统调用 fork 创建子进程</span>&#125;</code></pre></div><p>Android 11 的情况下也是利用系统调用 <code>fork</code> 出子进程</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_dumpHprofDataNative</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jclass clazz, jstring file_name)</span> </span>&#123;  <span class="hljs-built_in">pthread_once</span>(&amp;once_control, initDumpHprofSymbols);  <span class="hljs-keyword">if</span> (ScopedSuspendAllConstructor == <span class="hljs-literal">nullptr</span> || ScopedSuspendAllDestructor == <span class="hljs-literal">nullptr</span> ||      HprofConstructor == <span class="hljs-literal">nullptr</span> || HprofDestructor == <span class="hljs-literal">nullptr</span> || Dump == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> JNI_FALSE;  &#125;  <span class="hljs-built_in">ScopedSuspendAllConstructor</span>(gSSAHandle, LOG_TAG, <span class="hljs-literal">true</span>);  <span class="hljs-type">pid_t</span> pid = fork();  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-comment">// Fork error.</span>    __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, <span class="hljs-string">&quot;failed to fork!&quot;</span>);    <span class="hljs-keyword">return</span> JNI_FALSE;  &#125;  <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// Parent</span>    <span class="hljs-built_in">ScopedSuspendAllDestructor</span>(gSSAHandle);    <span class="hljs-type">int</span> stat_loc;    <span class="hljs-keyword">for</span> (;;) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">waitpid</span>(pid, &amp;stat_loc, <span class="hljs-number">0</span>) != <span class="hljs-number">-1</span> || errno != EINTR) &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> JNI_TRUE;  &#125;  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="处理-hprof"><a href="#处理-hprof" class="headerlink" title="处理 hprof"></a>处理 hprof</h2><p>子进程用 <code>Debug.dumpHprofData</code> 生成 hprof 文件后结束，父进程拿到 hprof 后开个新进程，在 <code>Service</code> 里用 <code>LeakCanary.Shark</code> 解析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJvmHeapDumper</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dump</span><span class="hljs-params">(String path)</span> &#123;    <span class="hljs-comment">//...</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">dumpRes</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> trySuspendVMThenFork();      <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;                   <span class="hljs-comment">// 子进程 dump hprof 后退出</span>        Debug.dumpHprofData(path);        KLog.i(TAG, <span class="hljs-string">&quot;notifyDumped:&quot;</span> + dumpRes);        exitProcess();      &#125; <span class="hljs-keyword">else</span> &#123;                          <span class="hljs-comment">// 父进程等待 dump hprof 完成</span>        resumeVM();        dumpRes = waitDumping(pid);        KLog.i(TAG, <span class="hljs-string">&quot;hprof pid:&quot;</span> + pid + <span class="hljs-string">&quot; dumped: &quot;</span> + path);      &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      e.printStackTrace();      KLog.e(TAG, <span class="hljs-string">&quot;dump failed caused by IOException!&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> dumpRes;  &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapAnalyzeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IntentService</span> &#123;     <span class="hljs-comment">// 在 HeapAnalyzeService 里解析 hprof</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runAnalysis</span><span class="hljs-params">(Application application,</span><span class="hljs-params">      HeapAnalysisListener heapAnalysisListener)</span> &#123;    KLog.i(TAG, <span class="hljs-string">&quot;runAnalysis startService&quot;</span>);    <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(application, HeapAnalyzeService.class);    <span class="hljs-type">IPCReceiver</span> <span class="hljs-variable">ipcReceiver</span> <span class="hljs-operator">=</span> buildAnalysisReceiver(heapAnalysisListener);    intent.putExtra(KConstants.ServiceIntent.RECEIVER, ipcReceiver);    <span class="hljs-type">KHeapFile</span> <span class="hljs-variable">heapFile</span> <span class="hljs-operator">=</span> KHeapFile.getKHeapFile();    intent.putExtra(KConstants.ServiceIntent.HEAP_FILE, heapFile);    application.startService(intent);  &#125;    &#125;<span class="hljs-comment">// HeapAnalyzeService 在另一个进程，防止解析 hprof 时 OOM 影响 APP</span><span class="hljs-comment">// &lt;service</span><span class="hljs-comment">//       android:name=&quot;.analysis.HeapAnalyzeService&quot;</span><span class="hljs-comment">//       android:process=&quot;:heap_analysis&quot; /&gt;</span></code></pre></div><p>Android 11 则是查找类 <code>Hprof</code> 的构造/析构函数和 <code>dump</code> 函数，在 native 层进行 dump hprof，后续依然是在 java 层开个新进程解析</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jboolean JNICALL <span class="hljs-title">Java_com_kwai_koom_javaoom_dump_ForkJvmHeapDumper_dumpHprofDataNative</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    JNIEnv *env, jclass clazz, jstring file_name)</span> </span>&#123;  <span class="hljs-comment">// ... 直接在 native 层 dump hprof</span>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file_name, <span class="hljs-literal">nullptr</span>);  <span class="hljs-built_in">HprofConstructor</span>(gHprofHandle, filename, <span class="hljs-number">-1</span>, <span class="hljs-literal">false</span>);  <span class="hljs-built_in">Dump</span>(gHprofHandle);  <span class="hljs-built_in">HprofDestructor</span>(gHprofHandle);  env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file_name, filename);  _exit(<span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">initDumpHprofSymbols</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 查找 Hprof 类的相关函数</span>  <span class="hljs-comment">//...</span>  libHandle = kwai::linker::DlFcn::<span class="hljs-built_in">dlopen_elf</span>(<span class="hljs-string">&quot;libart.so&quot;</span>, RTLD_NOW);  <span class="hljs-keyword">if</span> (libHandle == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span>;  &#125;  HprofConstructor = (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym_elf</span>(      libHandle, <span class="hljs-string">&quot;_ZN3art5hprof5HprofC2EPKcib&quot;</span>);  <span class="hljs-keyword">if</span> (HprofConstructor == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art5hprof5HprofC2EPKcib unsupported!&quot;</span>);  &#125;  HprofDestructor =      (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym_elf</span>(libHandle, <span class="hljs-string">&quot;_ZN3art5hprof5HprofD0Ev&quot;</span>);  <span class="hljs-keyword">if</span> (HprofDestructor == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art5hprof5HprofD0Ev unsupported!&quot;</span>);  &#125;  Dump = (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *))kwai::linker::DlFcn::<span class="hljs-built_in">dlsym_elf</span>(libHandle, <span class="hljs-string">&quot;_ZN3art5hprof5Hprof4DumpEv&quot;</span>);  <span class="hljs-keyword">if</span> (Dump == <span class="hljs-literal">nullptr</span>) &#123;    __android_log_print(ANDROID_LOG_WARN, LOG_TAG, <span class="hljs-string">&quot;_ZN3art5hprof5Hprof4DumpEv unsupported!&quot;</span>);  &#125;  kwai::linker::DlFcn::<span class="hljs-built_in">dlclose_elf</span>(libHandle);&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/KwaiAppTeam/KOOM">KOOM</a></li><li><a href="https://www.sunmoonblog.com/2019/06/04/fake-dlopen/">Android dlopen 方法的使用限制及解决方案</a></li><li><a href="https://tboox.org/cn/2020/07/04/byopen/">一个绕过移动端系统限制的dlopen库: byOpen</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>内存优化，OOM</tag>
      
      <tag>APM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matrix - TraceCanary 浅析</title>
    <link href="/2021/04/26/matrix-tracecanary/"/>
    <url>/2021/04/26/matrix-tracecanary/</url>
    
    <content type="html"><![CDATA[<h2 id="捕获掉帧-卡顿"><a href="#捕获掉帧-卡顿" class="headerlink" title="捕获掉帧/卡顿"></a>捕获掉帧/卡顿</h2><h3 id="什么是掉帧-卡顿"><a href="#什么是掉帧-卡顿" class="headerlink" title="什么是掉帧/卡顿"></a>什么是掉帧/卡顿</h3><blockquote><p>什么是卡顿，很多人能马上联系到的是帧率 FPS (每秒显示帧数)。那么多低的 FPS 才是卡顿呢？又或者低 FPS 真的就是卡顿吗？（以下 FPS 默认指平均帧率）</p><p>其实并非如此，举个例子，游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上，但我们平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得卡顿。 在人眼结构上看，当一组动作在 1 秒内有 12 次变化（即 12FPS），我们会认为这组动作是连贯的；而当大于 60FPS 时，人眼很难区分出来明显的变化，所以 60FPS 也一直作为业界衡量一个界面流畅程度的重要指标。一个稳定在 30FPS 的动画，我们不会认为是卡顿的，但一旦 FPS 很不稳定，人眼往往容易感知到。</p><p>FPS 低并不意味着卡顿发生，而卡顿发生 FPS 一定不高。 FPS 可以衡量一个界面的流程性，但往往不能很直观的衡量卡顿的发生，这里有另一个指标（掉帧程度）可以更直观地衡量卡顿。</p><p>什么是掉帧（跳帧）？ 按照理想帧率 60FPS 这个指标，计算出平均每一帧的准备时间有 1000ms/60 = 16.6667ms，如果一帧的准备时间超出这个值，则认为发生掉帧，超出的时间越长，掉帧程度越严重。假设每帧准备时间约 32ms，每次只掉一帧，那么 1 秒内实际只刷新 30 帧，即平均帧率只有 30FPS，但这时往往不会觉得是卡顿。反而如果出现某次严重掉帧（&gt;300ms），那么这一次的变化，通常很容易感知到。所以界面的掉帧程度，往往可以更直观的反映出卡顿。</p></blockquote><p>造成 <strong>掉帧</strong> 的直接原因通常是 <code>doFrame</code> 过于繁重执行超时，或者其他任务挤压了 <code>doFrame</code> 的执行时间，这些都会造成主线程不能在 <strong>帧间隔时间</strong> 内完成 ui 绘制</p><h3 id="计算-Message-耗时"><a href="#计算-Message-耗时" class="headerlink" title="计算 Message 耗时"></a>计算 <code>Message</code> 耗时</h3><p>我们知道主线程是「生产者 - 消费者」模型，任务（<code>Message</code>）都在消息队列（<code>MessageQueue</code>）里排队等待执行，如果能够度量出每个 <code>Message</code> 的耗时，然后与某个阈值进行比较，我们就能找出耗时任务做进一步的优化</p><p>从下面的代码可以看到，<code>Message</code> 执行前后都会有特定格式的日志输出，只要捕获这些日志，就能计算出每个 <code>Message</code> 的耗时</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Looper.loop() &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;        <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +                    msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);        &#125;        <span class="hljs-comment">// ...</span>        msg.target.dispatchMessage(msg);        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;            logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);        &#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p><code>LooperMonitor</code> 通过替换 <code>Looper.mLogging</code>，从而捕获到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code> 和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 的日志输出进而算出 <code>Message</code> 耗时，并提供 <code>dispatchStart</code> 和 <code>dispatchEnd</code> 两个钩子</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperMonitor</span> &#123;    <span class="hljs-comment">// 通过反射替换 Looper.mLogging</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetPrinter</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Printer</span> <span class="hljs-variable">originPrinter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (!isReflectLoggingError) &#123;                originPrinter = ReflectUtils.get(looper.getClass(), <span class="hljs-string">&quot;mLogging&quot;</span>, looper);                <span class="hljs-keyword">if</span> (originPrinter == printer &amp;&amp; <span class="hljs-literal">null</span> != printer) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            isReflectLoggingError = <span class="hljs-literal">true</span>;            Log.e(TAG, <span class="hljs-string">&quot;[resetPrinter] %s&quot;</span>, e);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != printer) &#123;            MatrixLog.w(TAG, <span class="hljs-string">&quot;maybe thread:%s printer[%s] was replace other[%s]!&quot;</span>,                    looper.getThread().getName(), printer, originPrinter);        &#125;        looper.setMessageLogging(printer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LooperPrinter</span>(originPrinter));        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != originPrinter) &#123;            MatrixLog.i(TAG, <span class="hljs-string">&quot;reset printer, originPrinter[%s] in %s&quot;</span>, originPrinter, looper.getThread().getName());        &#125;    &#125;    <span class="hljs-comment">// 捕获根据特定格式的日志输出</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printer</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(String x)</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != origin) &#123;                origin.println(x);                <span class="hljs-keyword">if</span> (origin == <span class="hljs-built_in">this</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(TAG + <span class="hljs-string">&quot; origin == this&quot;</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span> (!isHasChecked) &#123;                isValid = x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span> || x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&lt;&#x27;</span>;                isHasChecked = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span> (!isValid) &#123;                    MatrixLog.e(TAG, <span class="hljs-string">&quot;[println] Printer is inValid! x:%s&quot;</span>, x);                &#125;            &#125;            <span class="hljs-keyword">if</span> (isValid) &#123;                dispatch(x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span>, x);            &#125;        &#125;    &#125;    <span class="hljs-comment">// 分发 Dispatching to 和 Finished to 事件</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isBegin, String log)</span> &#123;        <span class="hljs-keyword">for</span> (LooperDispatchListener listener : listeners) &#123;            <span class="hljs-keyword">if</span> (listener.isValid()) &#123;                <span class="hljs-keyword">if</span> (isBegin) &#123;                    <span class="hljs-keyword">if</span> (!listener.isHasDispatchStart) &#123;                        listener.onDispatchStart(log);                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (listener.isHasDispatchStart) &#123;                        listener.onDispatchEnd(log);                    &#125;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isBegin &amp;&amp; listener.isHasDispatchStart) &#123;                listener.dispatchEnd();            &#125;        &#125;    &#125;    &#125;</code></pre></div><p>为了防止其他代码也替换 <code>Looper.mLogging</code>，<code>LooperMonitor</code> 还在主线程空闲的时候进行检查</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> LooperMonitor.queueIdle() &#123;    <span class="hljs-keyword">if</span> (SystemClock.uptimeMillis() - lastCheckPrinterTime &gt;= CHECK_TIME) &#123;        resetPrinter();        lastCheckPrinterTime = SystemClock.uptimeMillis();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="计算-doFrame-耗时"><a href="#计算-doFrame-耗时" class="headerlink" title="计算 doFrame 耗时"></a>计算 <code>doFrame</code> 耗时</h3><p>上面的方法可以统计主线程里每个 <code>Message</code> 的耗时，但并不是每个 <code>Message</code> 都在做 ui 绘制（<code>doFrame</code>），比如违规放入耗时的 IO 操作；为了更精确地捕获耗时的 <code>doFrame</code>，以及进行 FPS 统计，还需做更多的工作</p><p>参考 <a href="../../../../2020/12/02/vsync/">Android 图形栈（一）vsync</a> 我们知道，当 <code>APP_VSYNC</code> 到达时会走 <code>FrameDisplayEventReceiver.onVsync</code> -&gt; <code>Choreographer.doFrame</code> -&gt; <code>Choreographer.doCallbacks</code>，最后按 INPUT - ANIMATION - TRAVERSAL 的顺序执行 <code>Choreographer.mCallbackQueues</code> 里的 <code>Runnable</code></p><p>动态地往这三个队列的头部插入钩子，从而计算出每个阶段开始时间和结束时间，加上捕获 <code>Message</code> 的方法（<code>Choreographer.doFrame</code> 是由 <code>FrameDisplayEventReceiver.onVsync</code> 放入主线程任务队列的 <code>Message</code>），最终形成完整的闭环：</p><p><code>dispatchBegin</code> -&gt; <code>doFrameBegin</code> -&gt; <code>doQueueBegin(INPUT)</code> -&gt; <code>doQueueEnd(INPUT)</code> -&gt; <code>doQueueBegin(ANIMATION)</code> -&gt; <code>doQueueEnd(ANIMATION)</code> -&gt; <code>doQueueBegin(TRAVERSAL)</code> -&gt; <code>doQueueEnd(TRAVERSAL)</code> -&gt; <code>doFrameEnd</code> -&gt; <code>dispatchEnd</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIThreadMonitor</span> &#123;    <span class="hljs-comment">// 最开始先在 INPUT 头部插入钩子</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> UIThreadMonitor.onStart() &#123;        <span class="hljs-comment">// ...</span>        queueStatus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];        queueCost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];        addFrameCallback(CALLBACK_INPUT, <span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);    &#125;    <span class="hljs-comment">// 依次往 ANIMATION/TRAVERSAL 插入钩子</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();        <span class="hljs-keyword">try</span> &#123;            doFrameBegin(token);            doQueueBegin(CALLBACK_INPUT);            addFrameCallback(CALLBACK_ANIMATION, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                    doQueueEnd(CALLBACK_INPUT);                    doQueueBegin(CALLBACK_ANIMATION);                &#125;            &#125;, <span class="hljs-literal">true</span>);            addFrameCallback(CALLBACK_TRAVERSAL, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                    doQueueEnd(CALLBACK_ANIMATION);                    doQueueBegin(CALLBACK_TRAVERSAL);                &#125;            &#125;, <span class="hljs-literal">true</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;                MatrixLog.d(TAG, <span class="hljs-string">&quot;[UIThreadMonitor#run] inner cost:%sns&quot;</span>, System.nanoTime() - start);            &#125;        &#125;    &#125;    <span class="hljs-comment">// 主线程消息队列的任务结束钩子，也作为 TRAVERSAL 的结束标志</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">long</span> <span class="hljs-variable">startNs</span> <span class="hljs-operator">=</span> token;        <span class="hljs-type">long</span> <span class="hljs-variable">intendedFrameTimeNs</span> <span class="hljs-operator">=</span> startNs;        <span class="hljs-keyword">if</span> (isVsyncFrame) &#123;            doFrameEnd(token);            intendedFrameTimeNs = getIntendedFrameTimeNs(startNs);  <span class="hljs-comment">// FrameDisplayEventReceiver.mTimestampNanos</span>        &#125;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrameEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> token)</span> &#123;        doQueueEnd(CALLBACK_TRAVERSAL);        <span class="hljs-comment">// ...</span>        addFrameCallback(CALLBACK_INPUT, <span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);   <span class="hljs-comment">// 继续放入下一轮 doFrame 的钩子</span>    &#125;     &#125;</code></pre></div><h3 id="LooperObserver"><a href="#LooperObserver" class="headerlink" title="LooperObserver"></a><code>LooperObserver</code></h3><p>结合上面捕获到的信息，提供一个「观察者」</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperObserver</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDispatchBegin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Message 开始执行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginNs       开始时间（System.nanoTime）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuBeginNs    线程的开始时间（SystemClock.currentThreadTimeMillis）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token         等于 beginNs</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@CallSuper</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBegin</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginNs, <span class="hljs-type">long</span> token)</span> &#123;        isDispatchBegin = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Message 耗时统计</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> focusedActivity       当前页面（Activity）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startNs               Message 的开始时间（等于 beginNs）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endNs                 Message 的结束时间（等于 endNs）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isVsyncFrame          是否 ui 绘制任务（doFrame）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> intendedFrameTimeNs   收到 APP_VSYNC 信号的时间（FrameDisplayEventReceiver.onVsync）</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputCostNs           doFrame INPUT 阶段耗时</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> animationCostNs       doFrame ANIMATION 阶段耗时</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> traversalCostNs       doFrame TRAVERSAL 阶段耗时</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrame</span><span class="hljs-params">(String focusedActivity, <span class="hljs-type">long</span> startNs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">boolean</span> isVsyncFrame, <span class="hljs-type">long</span> intendedFrameTimeNs, <span class="hljs-type">long</span> inputCostNs, <span class="hljs-type">long</span> animationCostNs, <span class="hljs-type">long</span> traversalCostNs)</span> &#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Message 结束执行</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginNs       开始时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuBeginMs    线程的开始时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endNs         结束时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuEndMs      结束的线程时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token         等于 beginNs</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isVsyncFrame  此任务是否 ui 绘制任务（doFrame）</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@CallSuper</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isVsyncFrame)</span> &#123;        isDispatchBegin = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDispatchBegin</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> isDispatchBegin;    &#125;&#125;</code></pre></div><h3 id="计算-FPS"><a href="#计算-FPS" class="headerlink" title="计算 FPS"></a>计算 FPS</h3><blockquote><p>我们将掉帧数划分出几个区间进行定级，掉帧数小于 3 帧的情况属于最佳，依次类推，见下表：</p><table><thead><tr><th>Best</th><th>Normal</th><th>Middle</th><th>High</th><th>Frozen</th></tr></thead><tbody><tr><td>[0:3)</td><td>[3:9)</td><td>[9:24)</td><td>[24:42)</td><td>[42:∞)</td></tr></tbody></table><p>相比单看平均帧率，掉帧程度的分布可以明显的看出，界面卡顿（平均帧率低）的原因是因为连续轻微的掉帧，还是某次严重掉帧造成的。再通过 <code>Activity</code> 区分不同场景，计算每个界面在有效绘制的时间片内，掉帧程度的分布情况及平均帧率，从而来评估出一个界面的整体流畅程度。</p></blockquote><p>也就是说，一次掉帧可能掉了一帧、两帧或者更多帧（<strong>掉帧数</strong>），这里根据上表把一次掉帧划分为 <code>Best/Normal/Middle/High/Frozen</code> 五个级别，后续评价掉帧时就不再关注掉帧数而是 <strong>掉帧次数</strong> 及其严重级别</p><p>下图绿色的 <code>62.00 FPS</code> 指的是过去 200ms 内的平均帧率</p><p>灰色的 <code>sum: 3.0</code> 是 <strong>总掉帧次数</strong>，下面的彩虹从左到右分别代表 <code>Normal/Middle/High/Frozen</code> 这四个级别的掉帧占总掉帧的比例，往下是当前页面的掉帧数和掉帧比例</p><p>最底下的图表是过去 10s 内平均帧率（200ms 时间段）的横向柱状图，每 5s 就会有 25 条记录，50 FPS 差不多是 <code>Normal</code> 的帧率下限，30 FPS 差不多是 <code>Middle</code> 的帧率下限</p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/fps_board.jpg" alt="fps_board"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每帧的时间间隔，默认取 16ms（60 FPS）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIThreadMonitor</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">frameIntervalNanos</span> <span class="hljs-operator">=</span> <span class="hljs-number">16666666</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(TraceConfig config)</span> &#123;        frameIntervalNanos = ReflectUtils.reflectObject(choreographer, <span class="hljs-string">&quot;mFrameIntervalNanos&quot;</span>, Constants.DEFAULT_FRAME_DURATION);        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameTracer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> frameIntervalNs;     <span class="hljs-comment">// UIThreadMonitor.getMonitor().getFrameIntervalNanos()</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListener</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String focusedActivity, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> startNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> endNs, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isVsyncFrame,</span><span class="hljs-params">                                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> intendedFrameTimeNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> inputCostNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> animationCostNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> traversalCostNs)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">traceBegin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">jiter</span> <span class="hljs-operator">=</span> endNs - intendedFrameTimeNs;         <span class="hljs-comment">// 从收到 vsync 到完成 doFrame 的时间，也就是实际渲染一帧的耗时</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">dropFrame</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (jiter / frameIntervalNs);  <span class="hljs-comment">// 计算出渲染这一帧对比理论 FPS 有没掉帧，掉了多少帧</span>            <span class="hljs-comment">// ...</span>        &#125;    &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameDecorator</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrameAsync</span><span class="hljs-params">(String focusedActivity, <span class="hljs-type">long</span> startNs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">int</span> dropFrame, <span class="hljs-type">boolean</span> isVsyncFrame, <span class="hljs-type">long</span> intendedFrameTimeNs, <span class="hljs-type">long</span> inputCostNs, <span class="hljs-type">long</span> animationCostNs, <span class="hljs-type">long</span> traversalCostNs)</span> &#123;        <span class="hljs-built_in">super</span>.doFrameAsync(focusedActivity, startNs, endNs, dropFrame, isVsyncFrame, intendedFrameTimeNs, inputCostNs, animationCostNs, traversalCostNs);        <span class="hljs-keyword">if</span> (!Objects.equals(focusedActivity, lastVisibleScene)) &#123;        <span class="hljs-comment">// 切换页面时，重置页面的统计数据</span>            dropLevel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[FrameTracer.DropStatus.values().length];            lastVisibleScene = focusedActivity;            lastCost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            lastFrames[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 为什么不是用 endNs ？</span>        <span class="hljs-comment">// 1，因为 doFrame 执行完还要等 surfacefling 在下一帧的时间点进行合成和显示，而不是 doFrame 后立即显示，所以要用 frameIntervalMs 的倍数</span>        <span class="hljs-comment">// 2，其次考虑用户无操作/页面静止的情况，主线程的任务队列为空，没有刷新页面，如果用设备时间 endNs 会导致计算出极低的错误 FPS</span>        sumFrameCost += (dropFrame + <span class="hljs-number">1</span>) * frameIntervalMs;        sumFrames += <span class="hljs-number">1</span>;        <span class="hljs-type">float</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> sumFrameCost - lastCost[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 距离上一次刷新 FPS 的时间间隔</span>        <span class="hljs-keyword">if</span> (dropFrame &gt;= Constants.DEFAULT_DROPPED_FROZEN) &#123;    <span class="hljs-comment">// 根据掉帧数，给发生的掉帧事故分级别统计</span>            dropLevel[FrameTracer.DropStatus.DROPPED_FROZEN.index]++;            sumDropLevel[FrameTracer.DropStatus.DROPPED_FROZEN.index]++;            belongColor = frozenColor;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dropFrame &gt;= Constants.DEFAULT_DROPPED_HIGH) &#123;            dropLevel[FrameTracer.DropStatus.DROPPED_HIGH.index]++;            sumDropLevel[FrameTracer.DropStatus.DROPPED_HIGH.index]++;            <span class="hljs-keyword">if</span> (belongColor != frozenColor) &#123;                belongColor = highColor;            &#125;        &#125; <span class="hljs-comment">// ...</span>        <span class="hljs-type">long</span> <span class="hljs-variable">collectFrame</span> <span class="hljs-operator">=</span> sumFrames - lastFrames[<span class="hljs-number">0</span>];                              <span class="hljs-comment">// 200ms 内刷新了几帧</span>        <span class="hljs-keyword">if</span> (duration &gt;= <span class="hljs-number">200</span>) &#123;                                                      <span class="hljs-comment">// 每隔 200ms 刷新一次 FPS</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">fps</span> <span class="hljs-operator">=</span> Math.min(maxFps, <span class="hljs-number">1000.f</span> * collectFrame / duration);   <span class="hljs-comment">// 统计过去 200ms 的 FPS</span>            updateView(view, fps, belongColor, dropLevel[FrameTracer.DropStatus.DROPPED_NORMAL.index], dropLevel[FrameTracer.DropStatus.DROPPED_MIDDLE.index] ...);            lastCost[<span class="hljs-number">0</span>] = sumFrameCost;            lastFrames[<span class="hljs-number">0</span>] = sumFrames;            <span class="hljs-comment">// ...</span>        &#125;    &#125;    &#125;</code></pre></div><h3 id="统计耗时-Message"><a href="#统计耗时-Message" class="headerlink" title="统计耗时 Message"></a>统计耗时 <code>Message</code></h3><p><code>TraceCanary</code> 把耗时超过 700ms 的 <code>Message</code> 作为 <code>Evil Method</code> 上报</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilMethodTracer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isVsyncFrame)</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">dispatchCost</span> <span class="hljs-operator">=</span> (endNs - beginNs) / Constants.TIME_MILLIS_TO_NANO;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;                <span class="hljs-comment">// ...</span>            &#125;        &#125;    &#125;    &#125;</code></pre></div><h2 id="无埋点插桩收集函数耗时"><a href="#无埋点插桩收集函数耗时" class="headerlink" title="无埋点插桩收集函数耗时"></a>无埋点插桩收集函数耗时</h2><p>为了在捕捉到卡顿堆栈后，获取各个函数的执行耗时，需要对所有函数进行无埋点插桩，在函数执行前调用 <code>MethodBeat.i</code>，在函数执行后调用 <code>MethodBeat.o</code></p><blockquote><p>通过代理编译期间的任务 <code>transformClassesWithDexTask</code>，将全局 <code>class</code> 文件作为输入，利用 <code>ASM</code> 工具，高效地对所有 <code>class</code> 文件进行扫描及插桩</p><p>插桩过程有几个关键点：</p><ol><li>选择在该编译任务执行时插桩，是因为 <code>proguard</code> 操作是在该任务之前就完成的，意味着插桩时的 <code>class</code> 文件已经被混淆过的。而选择 <code>proguard</code> 之后去插桩，是因为如果提前插桩会造成部分方法不符合内联规则，没法在 <code>proguard</code> 时进行优化，最终导致程序方法数无法减少，从而引发方法数过大问题</li><li>为了减少插桩量及性能损耗，通过遍历 <code>class</code> 方法指令集，判断扫描的函数是否只含有 <code>PUT/READ FIELD</code> 等简单的指令，来过滤一些默认或匿名构造函数，以及 <code>get/set</code> 等简单不耗时函数</li><li>针对界面启动耗时，因为要统计从 <code>Activity.onCreate</code> 到 <code>Activity.onWindowFocusChange</code> 间的耗时，所以在插桩过程中需要收集应用内所有 <code>Activity</code> 的实现类，并覆盖 <code>onWindowFocusChange</code> 函数进行打点</li><li>为了方便及高效记录函数执行过程，我们为每个插桩的函数分配一个独立 ID，在插桩过程中，记录插桩的函数签名及分配的 ID，在插桩完成后输出一份 mapping，作为数据上报后的解析支持。</li></ol><p>归纳起来，编译期所做的工作如下图：</p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/build.png" alt="transform class"></p></blockquote><h3 id="Gradle-Transform"><a href="#Gradle-Transform" class="headerlink" title="Gradle Transform"></a>Gradle Transform</h3><p><code>ignoreMethodMapFilePath</code> 上面说过为了减少插桩量及性能损耗会忽略一些函数，这些被忽略的函数记录在此文件里（默认放在 <code>/app/build/outputs/mapping/&#123;var&#125;/ignoreMethodMapping.txt</code>），大概长这样：</p><div class="code-wrapper"><pre><code class="hljs kotlin">ignore methods:android.arch.core.executor.ArchTaskExecutor &lt;clinit&gt; ()Vandroid.arch.core.executor.ArchTaskExecutor &lt;<span class="hljs-keyword">init</span>&gt; ()Vandroid.arch.core.executor.ArchTaskExecutor$<span class="hljs-number">1</span> execute (Ljava.lang.Runnable;)Vandroid.arch.core.executor.DefaultTaskExecutor executeOnDiskIO (Ljava.lang.Runnable;)Vandroid.arch.core.<span class="hljs-keyword">internal</span>.FastSafeIterableMap &lt;<span class="hljs-keyword">init</span>&gt; ()Vandroid.arch.core.<span class="hljs-keyword">internal</span>.FastSafeIterableMap ceil (Ljava.lang.Object;)Ljava.util.Map$Entry;android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap size ()Iandroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap equals (Ljava.lang.Object;)Zandroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator backward (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator forward (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator &lt;<span class="hljs-keyword">init</span>&gt; (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)V</code></pre></div><p><code>methodMapFilePath</code> 函数签名和函数 ID 的映射（默认放在 <code>/app/build/outputs/mapping/&#123;var&#125;/methodMapping.txt</code>），大概长这样：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">6</span> run ()V<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,sample.tencent.matrix.MatrixApplication initSQLiteLintConfig ()Lcom.tencent.sqlitelint.config.SQLiteLintConfig;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">5</span> onClick (Landroid.view.View;)V<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">4</span> onClick (Landroid.view.View;)V<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,sample.tencent.matrix.MainActivity onResume ()V<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MatrixApplication onCreate ()V<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">3</span> onClick (Landroid.view.View;)V<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,sample.tencent.matrix.MainActivity onCreate (Landroid.os.Bundle;)V<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">2</span> onClick (Landroid.view.View;)V<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,org.apache.commons.io.comparator.DirectoryFileComparator compare (Ljava.io.File;Ljava.io.File;)I</code></pre></div><p><code>TraceCanary</code> 用 <code>Transform API</code> 处理并输出插桩后的 <code>class</code> </p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatrixTraceTransform</span>: <span class="hljs-type">Transform</span>() &#123;    <span class="hljs-comment">// Transform 的名称</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MatrixTraceTransform&quot;</span>    &#125;    <span class="hljs-comment">// Transform 接收 Input 处理并输出 Output</span>    <span class="hljs-comment">// 这里声明 MatrixTraceTransform 接收所有的 class，包括 class 文件和 jar 包中的 class</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: Set&lt;QualifiedContent.ContentType&gt; &#123;        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS    &#125;    <span class="hljs-comment">// 指定 class 的范围，限定项目内的所有 class</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt;? &#123;        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT    &#125;    <span class="hljs-comment">// 支持增量编译</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;        <span class="hljs-keyword">super</span>.transform(transformInvocation)        <span class="hljs-comment">// ...</span>        transforming(transformInvocation)    &#125;    <span class="hljs-comment">// 核心逻辑</span>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transforming</span><span class="hljs-params">(invocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()        <span class="hljs-keyword">val</span> outputProvider = invocation.outputProvider!!        <span class="hljs-keyword">val</span> isIncremental = invocation.isIncremental &amp;&amp; <span class="hljs-keyword">this</span>.isIncremental        <span class="hljs-keyword">if</span> (!isIncremental) &#123;            outputProvider.deleteAll()        &#125;        <span class="hljs-keyword">val</span> config = configure(invocation)        <span class="hljs-keyword">val</span> changedFiles = ConcurrentHashMap&lt;File, Status&gt;()    <span class="hljs-comment">// 需要进行插桩的 class/jar</span>        <span class="hljs-keyword">val</span> inputToOutput = ConcurrentHashMap&lt;File, File&gt;()     <span class="hljs-comment">// Input Dir -&gt; Output Dir，Input Jar -&gt; Output Jar</span>        <span class="hljs-keyword">val</span> inputFiles = ArrayList&lt;File&gt;()                      <span class="hljs-comment">// Input Dir &amp;&amp; Input Jar</span>        <span class="hljs-keyword">var</span> transformDirectory: File? = <span class="hljs-literal">null</span>        <span class="hljs-keyword">for</span> (input <span class="hljs-keyword">in</span> invocation.inputs) &#123;            <span class="hljs-comment">// 遍历并添加 class 文件</span>            <span class="hljs-keyword">for</span> (directoryInput <span class="hljs-keyword">in</span> input.directoryInputs) &#123;                changedFiles.putAll(directoryInput.changedFiles)                <span class="hljs-keyword">val</span> inputDir = directoryInput.file                inputFiles.add(inputDir)                <span class="hljs-keyword">val</span> outputDirectory = outputProvider.getContentLocation(                        directoryInput.name,                        directoryInput.contentTypes,                        directoryInput.scopes,                        Format.DIRECTORY)                inputToOutput[inputDir] = outputDirectory                <span class="hljs-keyword">if</span> (transformDirectory == <span class="hljs-literal">null</span>) transformDirectory = outputDirectory.parentFile            &#125;            <span class="hljs-comment">// 遍历并添加 jar 包</span>            <span class="hljs-keyword">for</span> (jarInput <span class="hljs-keyword">in</span> input.jarInputs) &#123;                <span class="hljs-keyword">val</span> inputFile = jarInput.file                changedFiles[inputFile] = jarInput.status                inputFiles.add(inputFile)                <span class="hljs-keyword">val</span> outputJar = outputProvider.getContentLocation(                        jarInput.name,                        jarInput.contentTypes,                        jarInput.scopes,                        Format.JAR)                inputToOutput[inputFile] = outputJar                <span class="hljs-keyword">if</span> (transformDirectory == <span class="hljs-literal">null</span>) transformDirectory = outputJar.parentFile            &#125;        &#125;        <span class="hljs-keyword">if</span> (inputFiles.size == <span class="hljs-number">0</span> || transformDirectory == <span class="hljs-literal">null</span>) &#123;            Log.i(TAG, <span class="hljs-string">&quot;Matrix trace do not find any input files&quot;</span>)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-comment">// 执行插桩</span>        <span class="hljs-keyword">val</span> outputDirectory = transformDirectory        MatrixTrace(                ignoreMethodMapFilePath = config.ignoreMethodMapFilePath,                methodMapFilePath = config.methodMapFilePath,                baseMethodMapPath = config.baseMethodMapPath,   <span class="hljs-comment">// 上一次插桩的 method mapping file，记录了已分配的 method id，插桩时要复用</span>                blockListFilePath = config.blockListFilePath,   <span class="hljs-comment">// 黑名单机制，忽略匹配的函数</span>                mappingDir = config.mappingDir                  <span class="hljs-comment">// Proguard mapping file</span>        ).doTransform(                classInputs = inputFiles,                changedFiles = changedFiles,                isIncremental = isIncremental,                traceClassDirectoryOutput = outputDirectory,                inputToOutput = inputToOutput,                legacyReplaceChangedFile = <span class="hljs-literal">null</span>,                legacyReplaceFile = <span class="hljs-literal">null</span>)        <span class="hljs-keyword">val</span> cost = System.currentTimeMillis() - start        Log.i(TAG, <span class="hljs-string">&quot; Insert matrix trace instrumentations cost time: %sms.&quot;</span>, cost)    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configure</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span>: Configuration &#123;        <span class="hljs-keyword">val</span> buildDir = project.buildDir.absolutePath        <span class="hljs-keyword">val</span> dirName = transformInvocation.context.variantName        <span class="hljs-keyword">val</span> mappingOut = Joiner.on(File.separatorChar).join(                buildDir,                FD_OUTPUTS,                <span class="hljs-string">&quot;mapping&quot;</span>,                dirName)        <span class="hljs-keyword">return</span> Configuration.Builder()                .setBaseMethodMap(extension.baseMethodMapFile)                .setBlockListFile(extension.blackListFile)                .setMethodMapFilePath(<span class="hljs-string">&quot;<span class="hljs-variable">$mappingOut</span>/methodMapping.txt&quot;</span>)                .setIgnoreMethodMapFilePath(<span class="hljs-string">&quot;<span class="hljs-variable">$mappingOut</span>/ignoreMethodMapping.txt&quot;</span>)                .setMappingPath(mappingOut)                .build()    &#125;&#125;</code></pre></div><h3 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;    <span class="hljs-keyword">val</span> executor: ExecutorService = Executors.newFixedThreadPool(<span class="hljs-number">16</span>)    <span class="hljs-keyword">val</span> config = Configuration.Builder()            .setIgnoreMethodMapFilePath(ignoreMethodMapFilePath)            .setMethodMapFilePath(methodMapFilePath)            .setBaseMethodMap(baseMethodMapPath)            .setBlockListFile(blockListFilePath)            .setMappingPath(mappingDir)            .build()    <span class="hljs-comment">/**</span><span class="hljs-comment">     * step 1</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">var</span> start = System.currentTimeMillis()    <span class="hljs-keyword">val</span> futures = LinkedList&lt;Future&lt;*&gt;&gt;()    <span class="hljs-keyword">val</span> mappingCollector = MappingCollector()    <span class="hljs-keyword">val</span> methodId = AtomicInteger(<span class="hljs-number">0</span>)    <span class="hljs-keyword">val</span> collectedMethodMap = ConcurrentHashMap&lt;String, TraceMethod&gt;()    <span class="hljs-comment">// 在线程池里解析各种 mapping file</span>    futures.add(executor.submit(ParseMappingTask(            mappingCollector, collectedMethodMap, methodId, config)))    <span class="hljs-comment">// 在线程池里扫描 class dir 和 jar，将 Input 和 Output 映射好放在下面的两个 map 里</span>    <span class="hljs-keyword">val</span> dirInputOutMap = ConcurrentHashMap&lt;File, File&gt;()    <span class="hljs-keyword">val</span> jarInputOutMap = ConcurrentHashMap&lt;File, File&gt;()    <span class="hljs-keyword">for</span> (file <span class="hljs-keyword">in</span> classInputs) &#123;        <span class="hljs-keyword">if</span> (file.isDirectory) &#123;            futures.add(executor.submit(CollectDirectoryInputTask(                    directoryInput = file,                    mapOfChangedFiles = changedFiles,                    mapOfInputToOutput = inputToOutput,                    isIncremental = isIncremental,                    traceClassDirectoryOutput = traceClassDirectoryOutput,                    legacyReplaceChangedFile = legacyReplaceChangedFile,                    legacyReplaceFile = legacyReplaceFile,                    resultOfDirInputToOut = dirInputOutMap            )))        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">val</span> status = Status.CHANGED            futures.add(executor.submit(CollectJarInputTask(                    inputJar = file,                    inputJarStatus = status,                    inputToOutput = inputToOutput,                    isIncremental = isIncremental,                    traceClassFileOutput = traceClassDirectoryOutput,                    legacyReplaceFile = legacyReplaceFile,                    resultOfDirInputToOut = dirInputOutMap,                    resultOfJarInputToOut = jarInputOutMap            )))        &#125;    &#125;    <span class="hljs-keyword">for</span> (future <span class="hljs-keyword">in</span> futures) &#123;        future.<span class="hljs-keyword">get</span>()    &#125;    futures.clear()    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(1)[Parse]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseMappingTask</span>(...) : Runnable &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()        <span class="hljs-keyword">val</span> mappingFile = File(config.mappingDir, <span class="hljs-string">&quot;mapping.txt&quot;</span>)    <span class="hljs-comment">// 解析 Proguard mapping file</span>        <span class="hljs-keyword">if</span> (mappingFile.isFile) &#123;            <span class="hljs-keyword">val</span> mappingReader = MappingReader(mappingFile)            mappingReader.read(mappingCollector)        &#125;        <span class="hljs-keyword">val</span> size = config.parseBlockFile(mappingCollector)          <span class="hljs-comment">// 解析黑名单</span>        <span class="hljs-keyword">val</span> baseMethodMapFile = File(config.baseMethodMapPath)      <span class="hljs-comment">// 加载已分配 method id 的函数列表</span>        getMethodFromBaseMethod(baseMethodMapFile, collectedMethodMap)        retraceMethodMap(mappingCollector, collectedMethodMap)        Log.i(TAG, <span class="hljs-string">&quot;[ParseMappingTask#run] cost:%sms, black size:%s, collect %s method from %s&quot;</span>,                System.currentTimeMillis() - start, size, collectedMethodMap.size, config.baseMethodMapPath)    &#125;&#125;</code></pre></div><h3 id="收集匹配的函数"><a href="#收集匹配的函数" class="headerlink" title="收集匹配的函数"></a>收集匹配的函数</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;    <span class="hljs-comment">// ... step 2 在线程池里用 ASM 解析 class 并收集匹配的函数</span>    start = System.currentTimeMillis()    <span class="hljs-keyword">val</span> methodCollector = MethodCollector(executor, mappingCollector, methodId, config, collectedMethodMap)    methodCollector.collect(dirInputOutMap.keys, jarInputOutMap.keys)    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(2)[Collection]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 搜集匹配的函数</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> MethodCollector.collect(Set&lt;File&gt; srcFolderList, Set&lt;File&gt; dependencyJarList) <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (File srcFile : srcFolderList) &#123;                    <span class="hljs-comment">// 在 class 里收集匹配的函数</span>        ArrayList&lt;File&gt; classFileList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">if</span> (srcFile.isDirectory()) &#123;            listClassFiles(classFileList, srcFile);        &#125; <span class="hljs-keyword">else</span> &#123;            classFileList.add(srcFile);        &#125;        <span class="hljs-keyword">for</span> (File classFile : classFileList) &#123;            futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectSrcTask</span>(classFile)));        &#125;    &#125;    <span class="hljs-keyword">for</span> (File jarFile : dependencyJarList) &#123;                <span class="hljs-comment">// 在 jar 包里收集匹配的函数</span>        futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectJarTask</span>(jarFile)));    &#125;    <span class="hljs-keyword">for</span> (Future future : futures) &#123;        future.get();    &#125;    futures.clear();    futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            saveIgnoreCollectedMethod(mappingCollector);    <span class="hljs-comment">// 写入 ignored methods 到文件里</span>        &#125;    &#125;));    futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            saveCollectedMethod(mappingCollector);          <span class="hljs-comment">// 将 method id -&gt; method 映射写入文件里</span>        &#125;    &#125;));    <span class="hljs-keyword">for</span> (Future future : futures) &#123;        future.get();    &#125;    futures.clear();&#125;<span class="hljs-comment">// 用 ASM Core API 解析并找到匹配的函数</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> CollectMethodNode.visitEnd() &#123;    <span class="hljs-built_in">super</span>.visitEnd();    <span class="hljs-type">TraceMethod</span> <span class="hljs-variable">traceMethod</span> <span class="hljs-operator">=</span> TraceMethod.create(<span class="hljs-number">0</span>, access, className, name, desc);    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>.equals(name)) &#123;        isConstructor = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">// 过滤掉空函数、getter/setter 等，加入 ignored method file 里</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isNeedTrace</span> <span class="hljs-operator">=</span> isNeedTrace(configuration, traceMethod.className, mappingCollector);    <span class="hljs-keyword">if</span> ((isEmptyMethod() || isGetSetMethod() || isSingleMethod())            &amp;&amp; isNeedTrace) &#123;        ignoreCount.incrementAndGet();        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 需要插桩的函数，如果没有 method id 则分配一个自增的 method id，加入 collectedMethodMap</span>    <span class="hljs-keyword">if</span> (isNeedTrace &amp;&amp; !collectedMethodMap.containsKey(traceMethod.getMethodName())) &#123;        traceMethod.id = methodId.incrementAndGet();        collectedMethodMap.put(traceMethod.getMethodName(), traceMethod);        incrementCount.incrementAndGet();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isNeedTrace &amp;&amp; !collectedIgnoreMethodMap.containsKey(traceMethod.className)) &#123;        ignoreCount.incrementAndGet();        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);    &#125;&#125;<span class="hljs-comment">// Jar 包则用 ZipFile API 遍历，依然用 ASM 解析</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectJarTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">ZipFile</span> <span class="hljs-variable">zipFile</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            zipFile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipFile</span>(fromJar);            Enumeration&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZipEntry</span>&gt; enumeration = zipFile.entries();            <span class="hljs-keyword">while</span> (enumeration.hasMoreElements()) &#123;                <span class="hljs-type">ZipEntry</span> <span class="hljs-variable">zipEntry</span> <span class="hljs-operator">=</span> enumeration.nextElement();                <span class="hljs-type">String</span> <span class="hljs-variable">zipEntryName</span> <span class="hljs-operator">=</span> zipEntry.getName();                <span class="hljs-keyword">if</span> (isNeedTraceFile(zipEntryName)) &#123;                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> zipFile.getInputStream(zipEntry);                    <span class="hljs-type">ClassReader</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(inputStream);                    <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);                    <span class="hljs-type">ClassVisitor</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceClassAdapter</span>(Opcodes.ASM5, classWriter);                    classReader.accept(visitor, <span class="hljs-number">0</span>);                &#125;            &#125;        &#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h3 id="执行插桩操作"><a href="#执行插桩操作" class="headerlink" title="执行插桩操作"></a>执行插桩操作</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;    <span class="hljs-comment">// ... step 3 执行插桩操作</span>    start = System.currentTimeMillis()    <span class="hljs-keyword">val</span> methodTracer = MethodTracer(executor, mappingCollector, config, methodCollector.collectedMethodMap, methodCollector.collectedClassExtendMap)    methodTracer.trace(dirInputOutMap, jarInputOutMap)    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(3)[Trace]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> MethodTracer.trace(Map&lt;File, File&gt; srcFolderList, Map&lt;File, File&gt; dependencyJarList) <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();    traceMethodFromSrc(srcFolderList, futures);     <span class="hljs-comment">// 处理 class</span>    traceMethodFromJar(dependencyJarList, futures); <span class="hljs-comment">// 处理 jar</span>    <span class="hljs-keyword">for</span> (Future future : futures) &#123;        future.get();    &#125;    futures.clear();&#125;<span class="hljs-comment">// 一个线程处理一个 class/dir </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceMethodFromSrc</span><span class="hljs-params">(Map&lt;File, File&gt; srcMap, List&lt;Future&gt; futures)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != srcMap) &#123;        <span class="hljs-keyword">for</span> (Map.Entry&lt;File, File&gt; entry : srcMap.entrySet()) &#123;            futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; innerTraceMethodFromSrc(entry.getKey(), entry.getValue()); &#125;            &#125;));        &#125;    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">innerTraceMethodFromSrc</span><span class="hljs-params">(File input, File output)</span> &#123;    <span class="hljs-comment">// ... 依然是 ASM 里 classReader，classWriter 和 classVisitor 的经典用法</span>    is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(classFile);    <span class="hljs-type">ClassReader</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(is);    <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);    <span class="hljs-type">ClassVisitor</span> <span class="hljs-variable">classVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceClassAdapter</span>(Opcodes.ASM5, classWriter);   <span class="hljs-comment">// 重要的类</span>    classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">public</span> MethodVisitor TraceClassAdapter.visitMethod(<span class="hljs-type">int</span> access, String name, String desc,                                 String signature, String[] exceptions) &#123;    <span class="hljs-keyword">if</span> (isABSClass) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (!hasWindowFocusMethod) &#123;    <span class="hljs-comment">// 匹配 Activity.onWindowFocusChanged，做页面打开速度统计</span>            hasWindowFocusMethod = MethodCollector.isWindowFocusChangeMethod(name, desc);        &#125;        <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">methodVisitor</span> <span class="hljs-operator">=</span> cv.visitMethod(access, name, desc, signature, exceptions);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceMethodAdapter</span>(api, methodVisitor, access, name, desc, <span class="hljs-built_in">this</span>.className,                hasWindowFocusMethod, isActivityOrSubClass, isNeedTrace);    &#125;&#125;<span class="hljs-comment">// 匹配 Activity.onWindowFocusChanged(boolean hasFocus)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;onWindowFocusChanged&quot;</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(Z)V&quot;</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isWindowFocusChangeMethod</span><span class="hljs-params">(String name, String desc)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> != name &amp;&amp; <span class="hljs-literal">null</span> != desc &amp;&amp; name.equals(TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD)         &amp;&amp; desc.equals(TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> TraceClassAdapter.visitEnd() &#123;    <span class="hljs-keyword">if</span> (!hasWindowFocusMethod &amp;&amp; isActivityOrSubClass &amp;&amp; isNeedTrace) &#123;        insertWindowFocusChangeMethod(cv, className);    &#125;    <span class="hljs-built_in">super</span>.visitEnd();&#125;<span class="hljs-comment">// 如果 Activity 没有覆盖 onWindowFocusChanged 则覆盖之（需要在里面插桩统计页面打开速度）</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertWindowFocusChangeMethod</span><span class="hljs-params">(ClassVisitor cv, String classname)</span> &#123;    <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">methodVisitor</span> <span class="hljs-operator">=</span> cv.visitMethod(Opcodes.ACC_PUBLIC, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD,            TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);    methodVisitor.visitCode();    methodVisitor.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number">0</span>);    methodVisitor.visitVarInsn(Opcodes.ILOAD, <span class="hljs-number">1</span>);    methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, TraceBuildConstants.MATRIX_TRACE_ACTIVITY_CLASS,         TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS, <span class="hljs-literal">false</span>);    traceWindowFocusChangeMethod(methodVisitor, classname);    methodVisitor.visitInsn(Opcodes.RETURN);    methodVisitor.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);    methodVisitor.visitEnd();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceMethodAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdviceAdapter</span> &#123;    <span class="hljs-comment">// 进入函数后先执行 MethodBeat.i</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodEnter</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">TraceMethod</span> <span class="hljs-variable">traceMethod</span> <span class="hljs-operator">=</span> collectedMethodMap.get(methodName);        <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-literal">null</span>) &#123;            traceMethodCount.incrementAndGet();            mv.visitLdcInsn(traceMethod.id);            mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-literal">false</span>);            <span class="hljs-comment">// 在 onWindowFocusChanged 插入 AppMethodBeat.at</span>            <span class="hljs-keyword">if</span> (checkNeedTraceWindowFocusChangeMethod(traceMethod)) &#123;                traceWindowFocusChangeMethod(mv, className);            &#125;        &#125;    &#125;        <span class="hljs-comment">// 退出函数前，执行 MethodBeat.o</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodExit</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode)</span> &#123;        <span class="hljs-type">TraceMethod</span> <span class="hljs-variable">traceMethod</span> <span class="hljs-operator">=</span> collectedMethodMap.get(methodName);        <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-literal">null</span>) &#123;            traceMethodCount.incrementAndGet();            mv.visitLdcInsn(traceMethod.id);            mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-literal">false</span>);        &#125;    &#125;&#125;<span class="hljs-comment">// jar 包一样的，只不过用的 ZipFile API 那套 ...</span></code></pre></div><h3 id="收集函数执行耗时"><a href="#收集函数执行耗时" class="headerlink" title="收集函数执行耗时"></a>收集函数执行耗时</h3><p>用一个 <code>long</code> 记录 <code>i/o</code> 函数调用，高位第一位表示是 <code>i</code> 函数还是 <code>o</code> 函数，后续 20 位存储 <code>method id</code>，低位 43 位存储 <em>相对时间戳</em>；运行时分配一个 100W 长度的 long 数组（占内存 7.6M）来存储，从索引 0 开始逐步递增到数组尾部，满了又从索引 0 开始，会覆盖旧数据，但因为 100W 足够大，用来收集栈帧执行时间足够了</p><blockquote><p>编译期已经对全局的函数进行插桩，在运行期间每个函数的执行前后都会调用 MethodBeat.i/o 的方法，如果是在主线程中执行，则在函数的执行前后获取当前距离 MethodBeat 模块初始化的时间 offset（为了压缩数据，存进一个long类型变量中），并将当前执行的是 MethodBeat i或者o、mehtod id 及时间 offset，存放到一个 long 类型变量中，记录到一个预先初始化好的数组 long[] 中 index 的位置（预先分配记录数据的 buffer 长度为 100w，内存占用约 7.6M）。</p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/run_store.jpg" alt="long buffer"></p><p><img src="../../../../image/2021-04-26-matrix-tracecanary/stack.jpg" alt="summary func cast"></p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录函数的开始时间</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.i(<span class="hljs-type">int</span> methodId) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (threadId == sMainThreadId) &#123;                <span class="hljs-comment">// 只关心主线程的慢函数，其他线程不记录</span>        <span class="hljs-keyword">if</span> (assertIn) &#123;                             <span class="hljs-comment">// 防止重入</span>            android.util.Log.e(TAG, <span class="hljs-string">&quot;ERROR!!! AppMethodBeat.i Recursive calls!!!&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        assertIn = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;       <span class="hljs-comment">// buffer 满了则重头开始，会覆盖掉旧数据</span>            mergeData(methodId, sIndex, <span class="hljs-literal">true</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            sIndex = <span class="hljs-number">0</span>;            mergeData(methodId, sIndex, <span class="hljs-literal">true</span>);        &#125;        ++sIndex;        assertIn = <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-comment">// 插入 buffer</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.mergeData(<span class="hljs-type">int</span> methodId, <span class="hljs-type">int</span> index, <span class="hljs-type">boolean</span> isIn) &#123;    <span class="hljs-keyword">if</span> (methodId == AppMethodBeat.METHOD_ID_DISPATCH) &#123;        sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;    &#125;    <span class="hljs-type">long</span> <span class="hljs-variable">trueId</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;                               <span class="hljs-comment">// 构造函数执行时间戳，第一位表示 i/o 操作</span>    <span class="hljs-keyword">if</span> (isIn) &#123;        trueId |= <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">63</span>;    &#125;    trueId |= (<span class="hljs-type">long</span>) methodId &lt;&lt; <span class="hljs-number">43</span>;                <span class="hljs-comment">// 后续 20 位存储 method id</span>    trueId |= sCurrentDiffTime &amp; <span class="hljs-number">0x7FFFFFFFFFFL</span>;    <span class="hljs-comment">// 低 43 位存储相对时间戳</span>    sBuffer[index] = trueId;    checkPileup(index);    sLastIndex = index;&#125;<span class="hljs-comment">// 记录函数的结束时间，跟上面是一样的</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.o(<span class="hljs-type">int</span> methodId) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (Thread.currentThread().getId() == sMainThreadId) &#123;        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;            mergeData(methodId, sIndex, <span class="hljs-literal">false</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            sIndex = <span class="hljs-number">0</span>;            mergeData(methodId, sIndex, <span class="hljs-literal">false</span>);        &#125;        ++sIndex;    &#125;&#125;</code></pre></div><p>值得注意的是，因为只有低 43 位存储时间戳，如果存储完整的时间戳那是不足的，而且在分析函数执行耗时用的是 duration = end - start，实际上不需要完整的时间戳，所以这里记录的是相对时间戳（<code>sCurrentDiffTime</code>）；而且为了性能，不在 <code>i/o</code> 函数里执行 <code>SystemClock.uptimeMillis()</code></p><p><code>sDiffTime</code> 记录加载类 <code>AppMethodBeat</code> 的时间戳，然后会起一个线程每隔 5ms 更新一次 <code>sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime</code></p><blockquote><p>另外，考虑到每个方法执行前后都获取系统时间（System.nanoTime）会对性能影响比较大，而实际上，单个函数执行耗时小于 5ms 的情况，对卡顿来说不是主要原因，可以忽略不计，如果是多次调用的情况，则在它的父级方法中可以反映出来，所以为了减少对性能的影响，通过另一条更新时间的线程每 5ms 去更新一个时间变量，而每个方法执行前后只读取该变量来减少性能损耗。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">sUpdateDiffTimeRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">while</span> (!isPauseUpdateTime &amp;&amp; status &gt; STATUS_STOPPED) &#123;                    sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;                    SystemClock.sleep(Constants.TIME_UPDATE_CYCLE_MS);                &#125;                <span class="hljs-keyword">synchronized</span> (updateTimeLock) &#123;                    updateTimeLock.wait();                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            MatrixLog.e(TAG, <span class="hljs-string">&quot;&quot;</span> + e.toString());        &#125;    &#125;&#125;;</code></pre></div><h2 id="上报耗时-Message"><a href="#上报耗时-Message" class="headerlink" title="上报耗时 Message"></a>上报耗时 <code>Message</code></h2><p>上面说过可以用一个 <code>long</code> 表示函数开始/结束的相对时间戳，然后存储在一个 100M 大小的数组里，插入索引会从 0 不断增长，到达 100M 后重置为 0</p><p>遇到耗时 <code>Message</code> 时，需要裁剪出有效的函数执行时间记录，所以在处理 <code>Message</code> 开始前先把索引记下来 <code>start</code>，处理完后从 <code>start</code> 到当前索引 <code>end</code> 之间就是这个 <code>Message</code> 的调用栈耗时记录</p><p>要注意的是索引到尾部后会重置为 0，所以要区分 <code>start</code> 和 <code>end</code> 大小关系；当 <code>start &lt; end</code> 取 <code>[start, end]</code>，当 <code>start &gt; end</code> 取 <code>[start,] + [0, end]</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilMethodTracer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBegin</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> token)</span> &#123;        <span class="hljs-built_in">super</span>.dispatchBegin(beginNs, cpuBeginMs, token);        indexRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;EvilMethodTracer#dispatchBegin&quot;</span>);  <span class="hljs-comment">// 把当前索引记下来</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isVsyncFrame)</span> &#123;        <span class="hljs-built_in">super</span>.dispatchEnd(beginNs, cpuBeginMs, endNs, cpuEndMs, token, isVsyncFrame);        <span class="hljs-type">long</span> <span class="hljs-variable">dispatchCost</span> <span class="hljs-operator">=</span> (endNs - beginNs) / Constants.TIME_MILLIS_TO_NANO;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;                <span class="hljs-type">long</span>[] data = AppMethodBeat.getInstance().copyData(indexRecord);    <span class="hljs-comment">// 裁剪出从开始索引到当前索引间的数据</span>                <span class="hljs-comment">// ...</span>            &#125;        &#125; ...    &#125;    &#125;<span class="hljs-comment">// 裁剪函数执行耗时，注意区分 start &lt; end 和 start &gt; end 两种情况</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppMethodBeat</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span>[] copyData(IndexRecord startRecord) &#123;        <span class="hljs-keyword">return</span> copyData(startRecord, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRecord</span>(sIndex - <span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] copyData(IndexRecord startRecord, IndexRecord endRecord) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">long</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">0</span>];        <span class="hljs-type">int</span> length;        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, startRecord.index);        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, endRecord.index);        <span class="hljs-keyword">if</span> (end &gt; start) &#123;            length = end - start + <span class="hljs-number">1</span>;            data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[length];            System.arraycopy(sBuffer, start, data, <span class="hljs-number">0</span>, length);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end &lt; start) &#123;            length = <span class="hljs-number">1</span> + end + (sBuffer.length - start);            data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[length];            System.arraycopy(sBuffer, start, data, <span class="hljs-number">0</span>, sBuffer.length - start);            System.arraycopy(sBuffer, <span class="hljs-number">0</span>, data, sBuffer.length - start, end + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// ...</span>    &#125;    &#125;</code></pre></div><h2 id="上报-ANR"><a href="#上报-ANR" class="headerlink" title="上报 ANR"></a>上报 ANR</h2><p>在 <a href="../../../../2020/10/20/anr/">阅读源码系列：ANR 是怎么产生的</a> 说过，ANR 是因为没有及时消费 <code>MotionEvent</code>，超过 5s 后由 AMS 弹出的对话框</p><p>弹出 ANR 对话框的 <code>Runnable</code> 是在分发 <code>MotionEvent</code> 时放下的一个延时炸弹（<code>Handler.postDelayed</code>），如果 <code>MotionEvent</code> 在 5s 内被消费则炸弹被移除（<code>Handler.removeCallbacks</code>）</p><p>我们在 <code>Message</code> 执行前有钩子函数 <code>dispatchBegin</code>，那也可以学习 ANR 放入报告函数（注意是放在子线程的消息队列里，不然在主线程里还没执行就被 ANR 对话框杀掉了），延时 5s，然后在 <code>dispatchEnd</code> 里移除，如果主线程的 <code>Message</code> 超过 5s 未执行完，那极有可能触发 ANR，于是收集调用堆栈及耗时信息上报给服务器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrTracer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBegin</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> token)</span> &#123;        <span class="hljs-built_in">super</span>.dispatchBegin(beginNs, cpuBeginMs, token);        anrTask.beginRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;AnrTracer#dispatchBegin&quot;</span>);     <span class="hljs-comment">// 记下调用堆栈的索引</span>        anrTask.token = token;        <span class="hljs-keyword">if</span> (traceConfig.isDevEnv()) &#123;            MatrixLog.v(TAG, <span class="hljs-string">&quot;* [dispatchBegin] token:%s index:%s&quot;</span>, token, anrTask.beginRecord.index);        &#125;        <span class="hljs-type">long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> (System.nanoTime() - token) / Constants.TIME_MILLIS_TO_NANO;        anrHandler.postDelayed(anrTask, Constants.DEFAULT_ANR - cost);                              <span class="hljs-comment">// 在子线程埋下延时 5s 的“炸弹”</span>        lagHandler.postDelayed(lagTask, Constants.DEFAULT_NORMAL_LAG - cost);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isBelongFrame)</span> &#123;        <span class="hljs-built_in">super</span>.dispatchEnd(beginNs, cpuBeginMs, endNs, cpuEndMs, token, isBelongFrame);        <span class="hljs-comment">// ... 及时移除“炸弹”</span>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != anrTask) &#123;            anrTask.getBeginRecord().release();            anrHandler.removeCallbacks(anrTask);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != lagTask) &#123;            lagHandler.removeCallbacks(lagTask);        &#125;    &#125;    &#125;<span class="hljs-comment">// 收集调用栈帧及其耗时、INPUUT/ANIMATION/TRAVERSAL 耗时、线程及进程信息等</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrHandleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">long</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();        <span class="hljs-type">boolean</span> <span class="hljs-variable">isForeground</span> <span class="hljs-operator">=</span> isForeground();        <span class="hljs-comment">// process</span>        <span class="hljs-type">int</span>[] processStat = Utils.getProcessPriority(Process.myPid());        <span class="hljs-type">long</span>[] data = AppMethodBeat.getInstance().copyData(beginRecord);        beginRecord.release();        <span class="hljs-type">String</span> <span class="hljs-variable">scene</span> <span class="hljs-operator">=</span> AppMethodBeat.getVisibleScene();        <span class="hljs-comment">// memory</span>        <span class="hljs-type">long</span>[] memoryInfo = dumpMemory();        <span class="hljs-comment">// Thread state</span>        Thread.<span class="hljs-type">State</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> Looper.getMainLooper().getThread().getState();        StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();        <span class="hljs-type">String</span> <span class="hljs-variable">dumpStack</span> <span class="hljs-operator">=</span> Utils.getStack(stackTrace, <span class="hljs-string">&quot;|*\t\t&quot;</span>, <span class="hljs-number">12</span>);        <span class="hljs-comment">// frame</span>        <span class="hljs-type">UIThreadMonitor</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> UIThreadMonitor.getMonitor();        <span class="hljs-type">long</span> <span class="hljs-variable">inputCost</span> <span class="hljs-operator">=</span> monitor.getQueueCost(UIThreadMonitor.CALLBACK_INPUT, token);        <span class="hljs-type">long</span> <span class="hljs-variable">animationCost</span> <span class="hljs-operator">=</span> monitor.getQueueCost(UIThreadMonitor.CALLBACK_ANIMATION, token);        <span class="hljs-type">long</span> <span class="hljs-variable">traversalCost</span> <span class="hljs-operator">=</span> monitor.getQueueCost(UIThreadMonitor.CALLBACK_TRAVERSAL, token);        <span class="hljs-comment">// trace</span>        LinkedList&lt;MethodItem&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();        <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span>) &#123;            TraceDataUtils.structuredDataToStack(data, stack, <span class="hljs-literal">true</span>, curTime);            TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceDataUtils</span>.IStructuredDataFilter() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFilter</span><span class="hljs-params">(<span class="hljs-type">long</span> during, <span class="hljs-type">int</span> filterCount)</span> &#123;                    <span class="hljs-keyword">return</span> during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS;                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFilterMaxCount</span><span class="hljs-params">()</span> &#123;                    <span class="hljs-keyword">return</span> Constants.FILTER_STACK_MAX_COUNT;                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-type">int</span> size)</span> &#123;                    MatrixLog.w(TAG, <span class="hljs-string">&quot;[fallback] size:%s targetSize:%s stack:%s&quot;</span>, size, Constants.TARGET_EVIL_METHOD_STACK, stack);                    <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK));                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                        iterator.next();                        iterator.remove();                    &#125;                &#125;            &#125;);        &#125;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">reportBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">logcatBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-type">long</span> <span class="hljs-variable">stackCost</span> <span class="hljs-operator">=</span> Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder));        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h2 id="统计-APP-amp-页面启动耗时"><a href="#统计-APP-amp-页面启动耗时" class="headerlink" title="统计 APP &amp; 页面启动耗时"></a>统计 APP &amp; 页面启动耗时</h2><p>包括 <code>Application</code> 执行耗时、首屏启动耗时、冷/热启动耗时、页面启动耗时，它们之间的关系如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * firstMethod.i       LAUNCH_ACTIVITY   onWindowFocusChange   LAUNCH_ACTIVITY    onWindowFocusChange</span><span class="hljs-comment"> * ^                         ^                   ^                     ^                  ^</span><span class="hljs-comment"> * |                         |                   |                     |                  |</span><span class="hljs-comment"> * |---------app---------|---|---firstActivity---|---------...---------|---careActivity---|</span><span class="hljs-comment"> * |&lt;--applicationCost--&gt;|</span><span class="hljs-comment"> * |&lt;--------------firstScreenCost--------------&gt;|</span><span class="hljs-comment"> * |&lt;---------------------------------------coldCost-------------------------------------&gt;|</span><span class="hljs-comment"> * .                         |&lt;-----warmCost----&gt;|</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="Application-执行耗时"><a href="#Application-执行耗时" class="headerlink" title="Application 执行耗时"></a><code>Application</code> 执行耗时</h3><p>有了上面的插桩，通过给 <code>Application.attachBaseContext</code> 插桩，也就是第一次执行 <code>AppMethodBeat.i</code> 的时候，可以拿到 <code>eggBrokenTime</code> 作为 APP 启动时间</p><p>这里解释下为什么不在 <code>Application</code> 构造函数里插桩并作为 APP 启动时间，那是因为 APP 有冷启动/热启动的概念，冷启动下 fork app process 并构造 <code>Application</code> 实例，此时算出的启动时间是正确的；但如果是热启动，<code>Application</code> 实例并没有销毁也不会执行构造函数，而是直接走 <code>onCreate</code> 函数，此时在构造函数里插桩就无法捕获到正确的启动时间了</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppMethodBeat</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">i</span><span class="hljs-params">(<span class="hljs-type">int</span> methodId)</span> &#123;        <span class="hljs-comment">// ... 第一次执行 AppMethodBeat.i 时</span>        <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;            <span class="hljs-keyword">synchronized</span> (statusLock) &#123;                <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;                    realExecute();                    status = STATUS_READY;                &#125;            &#125;        &#125;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">realExecute</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...</span>        ActivityThreadHacker.hackSysHandlerCallback();        <span class="hljs-comment">/// ...</span>    &#125;        &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityThreadHacker</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">sApplicationCreateBeginTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getEggBrokenTime</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ActivityThreadHacker.sApplicationCreateBeginTime;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hackSysHandlerCallback</span><span class="hljs-params">()</span> &#123;        sApplicationCreateBeginTime = SystemClock.uptimeMillis();   <span class="hljs-comment">// 记录 Application 的创建时间</span>        <span class="hljs-comment">// ...</span>    &#125;    &#125;</code></pre></div><p>初始化 <code>Application</code> 后启动第一个 <code>Activity</code>/<code>Service</code>/<code>BroadcastReceiver</code> 的时刻作为 <code>Application</code> 初始化的完结时间（为啥没有 <code>ContentProvider</code> 呢？因为它是在 <code>onCreate</code> 之前启动的，see <a href="../../../../2021/04/12/leakcanary/">LeakCanary 浅析</a>）</p><p>上述三大组件的启动会通过主线程的消息队列在 <code>ActivityThread.mH</code> 里执行</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CREATE_SERVICE</span>          <span class="hljs-operator">=</span> <span class="hljs-number">114</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RECEIVER</span>                <span class="hljs-operator">=</span> <span class="hljs-number">113</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RELAUNCH_ACTIVITY</span>       <span class="hljs-operator">=</span> <span class="hljs-number">160</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXECUTE_TRANSACTION</span>     <span class="hljs-operator">=</span> <span class="hljs-number">159</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));        <span class="hljs-keyword">switch</span> (msg.what) &#123;            <span class="hljs-comment">// ...</span>            <span class="hljs-keyword">case</span> CREATE_SERVICE:                <span class="hljs-keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,                            (<span class="hljs-string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));                &#125;                handleCreateService((CreateServiceData)msg.obj);                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> RECEIVER:                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;broadcastReceiveComp&quot;</span>);                handleReceiver((ReceiverData)msg.obj);                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> RELAUNCH_ACTIVITY:                handleRelaunchActivityLocally((IBinder) msg.obj);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:                <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> (ClientTransaction) msg.obj;                mTransactionExecutor.execute(transaction);                <span class="hljs-keyword">if</span> (isSystem()) &#123;                    <span class="hljs-comment">// Client transactions inside system process are recycled on the client side</span>                    <span class="hljs-comment">// instead of ClientLifecycleManager to avoid being cleared before this</span>                    <span class="hljs-comment">// message is handled.</span>                    transaction.recycle();                &#125;                <span class="hljs-comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-comment">// Activity 生命周期是通过 LaunchActivityItem/StartActivityItem/ResumeActivityItem/... 执行</span></code></pre></div><p>所以 <code>TraceCanary</code> 选择在第一次执行 <code>AppMethodBeat.i</code> 时，替换 <code>ActivityThread.sCurrentActivityThread.mH.mCallback</code>，在 <code>Handler.Callback.handleMessage(msg)</code> 里监听第一次启动 <code>Activity</code>/<code>Service</code>/<code>BroadcastReceiver</code> 的时刻作为 <code>Application</code> 初始化的结束点</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 第一次执行时</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.i(<span class="hljs-type">int</span> methodId) &#123;    <span class="hljs-keyword">if</span> (status &lt;= STATUS_STOPPED) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (methodId &gt;= METHOD_ID_MAX) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;        <span class="hljs-keyword">synchronized</span> (statusLock) &#123;            <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;                realExecute();                status = STATUS_READY;            &#125;        &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 替换 Handler.Callback</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.realExecute() &#123;    <span class="hljs-comment">// ...</span>    ActivityThreadHacker.hackSysHandlerCallback();    LooperMonitor.register(looperMonitorListener);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ActivityThreadHacker.hackSysHandlerCallback() &#123;    <span class="hljs-keyword">try</span> &#123;        sApplicationCreateBeginTime = SystemClock.uptimeMillis();        sApplicationCreateBeginMethodIndex = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;ApplicationCreateBeginMethodIndex&quot;</span>);        Class&lt;?&gt; forName = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> forName.getDeclaredField(<span class="hljs-string">&quot;sCurrentActivityThread&quot;</span>);        field.setAccessible(<span class="hljs-literal">true</span>);        <span class="hljs-type">Object</span> <span class="hljs-variable">activityThreadValue</span> <span class="hljs-operator">=</span> field.get(forName);        <span class="hljs-type">Field</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> forName.getDeclaredField(<span class="hljs-string">&quot;mH&quot;</span>);        mH.setAccessible(<span class="hljs-literal">true</span>);        <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> mH.get(activityThreadValue);        Class&lt;?&gt; handlerClass = handler.getClass().getSuperclass();        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != handlerClass) &#123;            <span class="hljs-type">Field</span> <span class="hljs-variable">callbackField</span> <span class="hljs-operator">=</span> handlerClass.getDeclaredField(<span class="hljs-string">&quot;mCallback&quot;</span>);            callbackField.setAccessible(<span class="hljs-literal">true</span>);            Handler.<span class="hljs-type">Callback</span> <span class="hljs-variable">originalCallback</span> <span class="hljs-operator">=</span> (Handler.Callback) callbackField.get(handler);            <span class="hljs-type">HackCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HackCallback</span>(originalCallback);            callbackField.set(handler, callback);        &#125;        MatrixLog.i(TAG, <span class="hljs-string">&quot;hook system handler completed. start:%s SDK_INT:%s&quot;</span>, sApplicationCreateBeginTime, Build.VERSION.SDK_INT);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        MatrixLog.e(TAG, <span class="hljs-string">&quot;hook system handler err! %s&quot;</span>, e.getCause().toString());    &#125;&#125;<span class="hljs-comment">// 记录时间点</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> HackCallback.handleMessage(Message msg) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLaunchActivity</span> <span class="hljs-operator">=</span> isLaunchActivity(msg);    <span class="hljs-keyword">if</span> (hasPrint &gt; <span class="hljs-number">0</span>) &#123;        MatrixLog.i(TAG, <span class="hljs-string">&quot;[handleMessage] msg.what:%s begin:%s isLaunchActivity:%s SDK_INT=%s&quot;</span>, msg.what, SystemClock.uptimeMillis()isLaunchActivity, Build.VERSION.SDK_INT);        hasPrint--;    &#125;    <span class="hljs-keyword">if</span> (!isCreated) &#123;        <span class="hljs-keyword">if</span> (isLaunchActivity || msg.what == CREATE_SERVICE                || msg.what == RECEIVER) &#123; <span class="hljs-comment">// todo for provider</span>            ActivityThreadHacker.sApplicationCreateEndTime = SystemClock.uptimeMillis();            ActivityThreadHacker.sApplicationCreateScene = msg.what;            isCreated = <span class="hljs-literal">true</span>;            sIsCreatedByLaunchActivity = isLaunchActivity;            MatrixLog.i(TAG, <span class="hljs-string">&quot;application create end, sApplicationCreateScene:%d, isLaunchActivity:%s&quot;</span>, msg.what, isLaunchActivity);            <span class="hljs-keyword">synchronized</span> (listeners) &#123;                <span class="hljs-keyword">for</span> (IApplicationCreateListener listener : listeners) &#123;                    listener.onApplicationCreateEnd();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg);&#125;</code></pre></div><h3 id="页面打开耗时"><a href="#页面打开耗时" class="headerlink" title="页面打开耗时"></a>页面打开耗时</h3><p>注册 <code>ActivityLifecycleCallbacks</code>，在 <code>onActivityCreated</code> 记录 <code>Activity</code> 的创建时间</p><p>在上面的插桩阶段，<code>AppMethodBeat.at(activity, isFocus)</code> 被添加到 <code>Activity.onWindowFocusChanged(hasFocus)</code> 的第一行代码，此时认为 <code>Activity</code> 获得焦点启动完毕（用户可见可交互），与 <code>Activity</code> 创建时间的差即为页面启动耗时</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartupTracer</span> &#123;    <span class="hljs-comment">// &quot;&#123;Activity全限定类名&#125;@&#123;activity.hashCode()&#125;&quot; -&gt; uptimeMillis</span>    <span class="hljs-keyword">private</span> HashMap&lt;String, Long&gt; createdTimeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAlive</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">super</span>.onAlive();        MatrixLog.i(TAG, <span class="hljs-string">&quot;[onAlive] isStartupEnable:%s&quot;</span>, isStartupEnable);        <span class="hljs-keyword">if</span> (isStartupEnable) &#123;            AppMethodBeat.getInstance().addListener(<span class="hljs-built_in">this</span>);                              <span class="hljs-comment">// 添加 onWindowFocusChanged(hasFocus) 监视器</span>            Matrix.with().getApplication().registerActivityLifecycleCallbacks(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">// 注册 ActivityLifecycleCallbacks</span>        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> &#123;        MatrixLog.i(TAG, <span class="hljs-string">&quot;activeActivityCount:%d, coldCost:%d&quot;</span>, activeActivityCount, coldCost);        <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;            lastCreateActivity = uptimeMillis();            MatrixLog.i(TAG, <span class="hljs-string">&quot;lastCreateActivity:%d, activity:%s&quot;</span>, lastCreateActivity, activity.getClass().getName());            isWarmStartUp = <span class="hljs-literal">true</span>;        &#125;        activeActivityCount++;        <span class="hljs-keyword">if</span> (isShouldRecordCreateTime) &#123;            createdTimeMap.put(activity.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode(), uptimeMillis());  <span class="hljs-comment">// 记录 Activity 创建时间</span>        &#125;    &#125;    <span class="hljs-comment">// 当 Activity.onWindowFocusChanged(hasFocus) hasFocus == true 时被调用</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityFocused</span><span class="hljs-params">(Activity activity)</span> &#123;        <span class="hljs-keyword">if</span> (ActivityThreadHacker.sApplicationCreateScene == Integer.MIN_VALUE) &#123;            Log.w(TAG, <span class="hljs-string">&quot;start up from unknown scene&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">activityName</span> <span class="hljs-operator">=</span> activity.getClass().getName();        <span class="hljs-keyword">if</span> (isColdStartup()) &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">isCreatedByLaunchActivity</span> <span class="hljs-operator">=</span> ActivityThreadHacker.isCreatedByLaunchActivity();            MatrixLog.i(TAG, <span class="hljs-string">&quot;#ColdStartup# activity:%s, splashActivities:%s, empty:%b, &quot;</span>                            + <span class="hljs-string">&quot;isCreatedByLaunchActivity:%b, hasShowSplashActivity:%b, &quot;</span>                            + <span class="hljs-string">&quot;firstScreenCost:%d, now:%d, application_create_begin_time:%d, app_cost:%d&quot;</span>,                    activityName, splashActivities, splashActivities.isEmpty(), isCreatedByLaunchActivity,                    hasShowSplashActivity, firstScreenCost, uptimeMillis(),                    ActivityThreadHacker.getEggBrokenTime(), ActivityThreadHacker.getApplicationCost());            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> activityName + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode();            <span class="hljs-type">Long</span> <span class="hljs-variable">createdTime</span> <span class="hljs-operator">=</span> createdTimeMap.get(key);            <span class="hljs-keyword">if</span> (createdTime == <span class="hljs-literal">null</span>) &#123;                createdTime = <span class="hljs-number">0L</span>;            &#125;            createdTimeMap.put(key, uptimeMillis() - createdTime);      <span class="hljs-comment">// 页面启动耗时</span>            <span class="hljs-comment">// ...</span>    &#125;    &#125;<span class="hljs-comment">// 当进入 Activity.onWindowFocusChanged(hasFocus) 函数时首先会执行此函数</span>AppMethodBeat.at(Activity activity, <span class="hljs-type">boolean</span> isFocus) &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">activityName</span> <span class="hljs-operator">=</span> activity.getClass().getName();    <span class="hljs-keyword">if</span> (isFocus) &#123;        <span class="hljs-keyword">if</span> (sFocusActivitySet.add(activityName)) &#123;            <span class="hljs-keyword">synchronized</span> (listeners) &#123;                <span class="hljs-keyword">for</span> (IAppMethodBeatListener listener : listeners) &#123;                    listener.onActivityFocused(activity);                &#125;            &#125;            MatrixLog.i(TAG, <span class="hljs-string">&quot;[at] visibleScene[%s] has %s focus!&quot;</span>, getVisibleScene(), <span class="hljs-string">&quot;attach&quot;</span>);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (sFocusActivitySet.remove(activityName)) &#123;            MatrixLog.i(TAG, <span class="hljs-string">&quot;[at] visibleScene[%s] has %s focus!&quot;</span>, getVisibleScene(), <span class="hljs-string">&quot;detach&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="首屏打开耗时"><a href="#首屏打开耗时" class="headerlink" title="首屏打开耗时"></a>首屏打开耗时</h3><p>首屏启动耗时（<code>firstScreenCost</code>） = 第一个页面（splash activity）接收到焦点的时间 - <code>eggBrokenTime</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartupTracer</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityFocused</span><span class="hljs-params">(Activity activity)</span> &#123;        <span class="hljs-comment">// ... 记录首屏启动耗时</span>        <span class="hljs-keyword">if</span> (firstScreenCost == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">this</span>.firstScreenCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();        &#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h3 id="冷启动和热启动耗时"><a href="#冷启动和热启动耗时" class="headerlink" title="冷启动和热启动耗时"></a>冷启动和热启动耗时</h3><p>当打开一个 <code>Activity</code> 时，如果 app process 不存在则需要通过 <code>zygote</code> 进程 <code>fork</code> 出 app process，实例化并执行 <code>Application.onCreate</code> 后再启动 <code>Activity</code>，这叫做 <strong>冷启动</strong>；APP 退出后，系统在内存充足的情况下并不会立刻销毁 app process，重新打开 APP 虽然会走 <code>Application.onCreate</code> 再打开 <code>Activity</code>，但这个 <code>Application</code> 实例并没有销毁（实际上是 JVM 没有被销毁），这叫 <strong>热启动</strong></p><p>怎么判断是冷启动还是热启动呢？既然 JVM 没有销毁，那么类的静态成员变量作为 <code>GC ROOT</code> 就会一直存在于内存中，判断它有没初始化即可知道是冷启动还是热启动，实际上 <code>Matrix</code> 就是这么做的，它的 <code>GC ROOT PATH</code> 是：</p><p><code>Matrix.sInstance</code> -&gt; <code>HashSet&lt;Plugin&gt; plugins</code> -&gt; <code>TracePlugin</code> -&gt; <code>StartupTracer</code> -&gt; <code>coldCost</code></p><p><code>StartupTracer.coldCost</code> 会在 <code>StartupTracer.onActivityFocused</code> 被初始化（&gt; 0），初始化时如果遇到 <code>StartupTracer.coldCost</code> == 0 则是冷启动；跟我想的不太一样的是，我认为冷启动耗时是从 <code>eggBrokenTime</code> 到第一个页面（splash activity）打开的时间，而 <code>TraceCanary</code> 计算的是到第二个页面（splash activity 之后的第一个页面）打开的时间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityFocused(Activity activity) &#123;    <span class="hljs-comment">// ... coldCost == 0 冷启动</span>    <span class="hljs-keyword">if</span> (isColdStartup()) &#123;                                                     <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">if</span> (hasShowSplashActivity) &#123;            coldCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (splashActivities.contains(activityName)) &#123;                hasShowSplashActivity = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (splashActivities.isEmpty()) &#123;            <span class="hljs-comment">// process which is has activity but not main UI process</span>                <span class="hljs-keyword">if</span> (isCreatedByLaunchActivity) &#123;                    coldCost = firstScreenCost;                &#125; <span class="hljs-keyword">else</span> &#123;                    firstScreenCost = <span class="hljs-number">0</span>;                    coldCost = ActivityThreadHacker.getApplicationCost();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (isCreatedByLaunchActivity) &#123;                    coldCost = firstScreenCost;                &#125; <span class="hljs-keyword">else</span> &#123;                    firstScreenCost = <span class="hljs-number">0</span>;                    coldCost = ActivityThreadHacker.getApplicationCost();                &#125;            &#125;        &#125;   <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>上面说过冷启动耗时是到第二个页面打开的时间，那如果在第一个页面打开时 <code>coldCost</code> &gt; 0 说明 JVM 没有销毁，是热启动（<code>isWarmStartUp</code>），热启动耗时相当于第一个页面的打开耗时</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartupTracer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastCreateActivity</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;   <span class="hljs-comment">// 当前/上一个 Activity.onCreate 的时间</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;        MatrixLog.i(TAG, <span class="hljs-string">&quot;activeActivityCount:%d, coldCost:%d&quot;</span>, activeActivityCount, coldCost);        <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;            lastCreateActivity = uptimeMillis();            MatrixLog.i(TAG, <span class="hljs-string">&quot;lastCreateActivity:%d, activity:%s&quot;</span>, lastCreateActivity, activity.getClass().getName());            isWarmStartUp = <span class="hljs-literal">true</span>;        &#125;        activeActivityCount++;        <span class="hljs-keyword">if</span> (isShouldRecordCreateTime) &#123;            createdTimeMap.put(activity.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode(), uptimeMillis());        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityFocused(Activity activity) &#123;        <span class="hljs-comment">// ...</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWarmStartUp()) &#123;            isWarmStartUp = <span class="hljs-literal">false</span>;            <span class="hljs-type">long</span> <span class="hljs-variable">warmCost</span> <span class="hljs-operator">=</span> uptimeMillis() - lastCreateActivity;            MatrixLog.i(TAG, <span class="hljs-string">&quot;#WarmStartup# activity:%s, warmCost:%d, now:%d, lastCreateActivity:%d&quot;</span>, activityName, warmCost, uptimeMillis(), lastCreateActivity);            <span class="hljs-keyword">if</span> (warmCost &gt; <span class="hljs-number">0</span>) &#123;                analyse(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, warmCost, <span class="hljs-literal">true</span>);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.wanandroid.com/blog/show/2937">ASM 入门</a></li><li><a href="https://github.com/dengshiwei/asm-module/blob/master/doc/blog/AOP%20%E5%88%A9%E5%99%A8%20ASM%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md">AOP 利器 ASM 基础入门</a></li><li><a href="https://su18.org/post/Nlwq9S-Ru/">字节码及ASM入门</a></li><li><a href="https://www.jianshu.com/p/031b62d02607">Gradle Transform API 的基本使用</a></li><li><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">Matrix Android TraceCanary</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>APM</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matrix - ResourcesCanary 浅析</title>
    <link href="/2021/04/23/matrix-resourcescanary/"/>
    <url>/2021/04/23/matrix-resourcescanary/</url>
    
    <content type="html"><![CDATA[<h2 id="Activity-的泄漏检测"><a href="#Activity-的泄漏检测" class="headerlink" title="Activity 的泄漏检测"></a><code>Activity</code> 的泄漏检测</h2><p>跟 <a href="https://github.com/square/leakcanary">LeakCanary</a> 一样，使用 <code>ActivityLifecycleCallbacks</code> 监听 <code>Activity.onDestroy()</code> 事件，从而收集到已销毁的 <code>Activity</code> 对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Plugin</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">super</span>.start();        <span class="hljs-keyword">if</span> (!isSupported()) &#123;            MatrixLog.e(TAG, <span class="hljs-string">&quot;ResourcePlugin start, ResourcePlugin is not supported, just return&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;        mWatcher.start();    &#125;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityRefWatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilePublisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Application.<span class="hljs-type">ActivityLifecycleCallbacks</span> <span class="hljs-variable">mRemovedActivityMonitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityLifeCycleCallbacksAdapter</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityDestroyed</span><span class="hljs-params">(Activity activity)</span> &#123;            pushDestroyedActivityInfo(activity);            mHandler.postDelayed(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                    triggerGc();                &#125;            &#125;, <span class="hljs-number">2000</span>);        &#125;    &#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;        stopDetect();        <span class="hljs-keyword">final</span> <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> mResourcePlugin.getApplication();        <span class="hljs-keyword">if</span> (app != <span class="hljs-literal">null</span>) &#123;            app.registerActivityLifecycleCallbacks(mRemovedActivityMonitor);            scheduleDetectProcedure();            MatrixLog.i(TAG, <span class="hljs-string">&quot;watcher is started.&quot;</span>);        &#125;    &#125;    &#125;</code></pre></div><p>跟 <code>LeakCanary</code> 不同的是，<code>ResourceCanary</code> 并没有采用 <code>WeakReference</code> + <code>ReferenceQueue</code> 的组合来监控 GC，而是用 <code>WeakReference</code> 软引用 <code>Activity</code> 并放在 <code>ConcurrentLinkedQueue</code> 里，然后专门开一个子线程监控并处理队列，开发者的解释是：</p><blockquote><p>可见其对 <code>Activity</code> 是否泄漏的判断依赖 VM 会将可回收的对象加入 <code>WeakReference</code> 关联的 <code>ReferenceQueue</code> 这一特性，在 Demo 的测试过程中我们发现这中做法在个别系统上可能存在误报，原因大致如下：</p><ol><li>VM 并没有提供强制触发 GC 的 API，通过 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 只能“建议”系统进行 GC，如果系统忽略了我们的 GC 请求，可回收的对象就不会被加入 <code>ReferenceQueue</code></li><li>将可回收对象加入 <code>ReferenceQueue</code> 需要等待一段时间，<code>LeakCanary</code>采用延时 100ms 的做法加以规避，但似乎并不绝对管用</li><li>监测逻辑是异步的，如果判断 <code>Activity</code> 是否可回收时某个 <code>Activity</code> 正好还被某个方法的局部变量持有，就会引起误判</li><li>若反复进入泄漏的 <code>Activity</code>，<code>LeakCanary</code> 会重复提示该Activity已泄漏</li></ol><p>对此我们做了以下改进：</p><ol><li>增加一个一定能被回收的“哨兵”对象，用来确认系统确实进行了 GC</li><li>直接通过 <code>WeakReference.get()</code> 来判断对象是否已被回收，避免因延迟导致误判</li><li>若发现某个 <code>Activity</code> 无法被回收，再重复判断 3 次，且要求从该 <code>Activity</code> 被记录起有2个以上的 <code>Activity</code> 被创建才认为是泄漏，以防在判断时该 <code>Activity</code> 被局部变量持有导致误判</li><li>对已判断为泄漏的 <code>Activity</code>，记录其类名，避免重复提示该 <code>Activity</code> 已泄漏</li></ol></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityRefWatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilePublisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;DestroyedActivityInfo&gt; mDestroyedActivityInfos;    <span class="hljs-comment">// 处理上面的队列</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RetryableTask</span> <span class="hljs-variable">mScanDestroyedActivitiesTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryableTask</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Status <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">// ...</span>        &#125;    &#125;;        <span class="hljs-comment">// 销毁的 Activity 被放到上面的队列里</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDestroyedActivityInfo</span><span class="hljs-params">(Activity activity)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">activityName</span> <span class="hljs-operator">=</span> activity.getClass().getName();        <span class="hljs-keyword">if</span> ((mDumpHprofMode == ResourceConfig.DumpMode.NO_DUMP || mDumpHprofMode == ResourceConfig.DumpMode.AUTO_DUMP)                &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()                &amp;&amp; isPublished(activityName)) &#123;            MatrixLog.i(TAG, <span class="hljs-string">&quot;activity leak with name %s had published, just ignore&quot;</span>, activityName);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-type">UUID</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID();        <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">keyBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        keyBuilder.append(ACTIVITY_REFKEY_PREFIX).append(activityName)                .append(<span class="hljs-string">&#x27;_&#x27;</span>).append(Long.toHexString(uuid.getMostSignificantBits())).append(Long.toHexString(uuid.getLeastSignificantBits()));        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyBuilder.toString();        <span class="hljs-keyword">final</span> <span class="hljs-type">DestroyedActivityInfo</span> <span class="hljs-variable">destroyedActivityInfo</span>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DestroyedActivityInfo</span>(key, activity, activityName);        mDestroyedActivityInfos.add(destroyedActivityInfo);        <span class="hljs-keyword">synchronized</span> (mDestroyedActivityInfos) &#123;            mDestroyedActivityInfos.notifyAll();        &#125;        MatrixLog.d(TAG, <span class="hljs-string">&quot;mDestroyedActivityInfos add %s&quot;</span>, activityName);    &#125;        <span class="hljs-comment">// 在子线程里处理 Activity 队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;        stopDetect();        <span class="hljs-keyword">final</span> <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> mResourcePlugin.getApplication();        <span class="hljs-keyword">if</span> (app != <span class="hljs-literal">null</span>) &#123;            app.registerActivityLifecycleCallbacks(mRemovedActivityMonitor);            scheduleDetectProcedure();            MatrixLog.i(TAG, <span class="hljs-string">&quot;watcher is started.&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleDetectProcedure</span><span class="hljs-params">()</span> &#123;        mDetectExecutor.executeInBackground(mScanDestroyedActivitiesTask);    &#125;&#125;</code></pre></div><p><code>LeakCanary</code> 每当一个 <code>Activity</code> 销毁时就放一个延时 5s 的检查任务，而 <code>ResourceCanary</code> 检测规则较为宽松：</p><ol><li>默认每隔 1min 检查一次 <code>mDestroyedActivityInfos</code></li><li>规定在检查次数 <code>mMaxRedetectTimes</code> 以下不判定为泄漏</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Status <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// If destroyed activity list is empty, just wait to save power.</span>    <span class="hljs-keyword">if</span> (mDestroyedActivityInfos.isEmpty()) &#123;        MatrixLog.i(TAG, <span class="hljs-string">&quot;DestroyedActivityInfo is empty! wait...&quot;</span>);        <span class="hljs-keyword">synchronized</span> (mDestroyedActivityInfos) &#123;            <span class="hljs-keyword">try</span> &#123;                mDestroyedActivityInfos.wait();            &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;                <span class="hljs-comment">// Ignored.</span>            &#125;        &#125;        MatrixLog.i(TAG, <span class="hljs-string">&quot;DestroyedActivityInfo is NOT empty! resume check&quot;</span>);        <span class="hljs-keyword">return</span> Status.RETRY;    &#125;    <span class="hljs-comment">// Fake leaks will be generated when debugger is attached.</span>    <span class="hljs-keyword">if</span> (Debug.isDebuggerConnected() &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()) &#123;        MatrixLog.w(TAG, <span class="hljs-string">&quot;debugger is connected, to avoid fake result, detection was delayed.&quot;</span>);        <span class="hljs-keyword">return</span> Status.RETRY;    &#125;<span class="hljs-comment">//          final WeakReference&lt;Object[]&gt; sentinelRef = new WeakReference&lt;&gt;(new Object[1024 * 1024]); // alloc big object</span>    triggerGc();    triggerGc();    triggerGc();<span class="hljs-comment">//          if (sentinelRef.get() != null) &#123;</span><span class="hljs-comment">//              // System ignored our gc request, we will retry later.</span><span class="hljs-comment">//              MatrixLog.d(TAG, &quot;system ignore our gc request, wait for next detection.&quot;);</span><span class="hljs-comment">//              return Status.RETRY;</span><span class="hljs-comment">//          &#125;</span>    <span class="hljs-keyword">final</span> Iterator&lt;DestroyedActivityInfo&gt; infoIt = mDestroyedActivityInfos.iterator();    <span class="hljs-keyword">while</span> (infoIt.hasNext()) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">DestroyedActivityInfo</span> <span class="hljs-variable">destroyedActivityInfo</span> <span class="hljs-operator">=</span> infoIt.next();        <span class="hljs-keyword">if</span> ((mDumpHprofMode == ResourceConfig.DumpMode.NO_DUMP || mDumpHprofMode == ResourceConfig.DumpMode.AUTO_DUMP)                &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()                &amp;&amp; isPublished(destroyedActivityInfo.mActivityName)) &#123;            MatrixLog.v(TAG, <span class="hljs-string">&quot;activity with key [%s] was already published.&quot;</span>, destroyedActivityInfo.mActivityName);            infoIt.remove();            <span class="hljs-keyword">continue</span>;        &#125;        triggerGc();        <span class="hljs-keyword">if</span> (destroyedActivityInfo.mActivityRef.get() == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// The activity was recycled by a gc triggered outside.</span>            MatrixLog.v(TAG, <span class="hljs-string">&quot;activity with key [%s] was already recycled.&quot;</span>, destroyedActivityInfo.mKey);            infoIt.remove();            <span class="hljs-keyword">continue</span>;        &#125;        ++destroyedActivityInfo.mDetectedCount;        <span class="hljs-keyword">if</span> (destroyedActivityInfo.mDetectedCount &lt; mMaxRedetectTimes                &amp;&amp; !mResourcePlugin.getConfig().getDetectDebugger()) &#123;            <span class="hljs-comment">// Although the sentinel tell us the activity should have been recycled,</span>            <span class="hljs-comment">// system may still ignore it, so try again until we reach max retry times.</span>            MatrixLog.i(TAG, <span class="hljs-string">&quot;activity with key [%s] should be recycled but actually still exists in %s times, wait for next detectiontoconfirm.&quot;</span>,                    destroyedActivityInfo.mKey, destroyedActivityInfo.mDetectedCount);            triggerGc();            <span class="hljs-keyword">continue</span>;        &#125;        MatrixLog.i(TAG, <span class="hljs-string">&quot;activity with key [%s] was suspected to be a leaked instance. mode[%s]&quot;</span>, destroyedActivityInfo.mKey,mDumpHprofMode;        <span class="hljs-keyword">if</span> (mLeakProcessor == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;LeakProcessor not found!!!&quot;</span>);        &#125;        triggerGc();        <span class="hljs-keyword">if</span> (mLeakProcessor.process(destroyedActivityInfo)) &#123;            MatrixLog.i(TAG, <span class="hljs-string">&quot;the leaked activity [%s] with key [%s] has been processed. stop polling&quot;</span>, destroyedActivityInfomActivityName,destroyedActivityInfo.mKey);            infoIt.remove();        &#125;    &#125;    triggerGc();    <span class="hljs-keyword">return</span> Status.RETRY;&#125;</code></pre></div><h2 id="heap-dump-并分析-hprof-文件"><a href="#heap-dump-并分析-hprof-文件" class="headerlink" title="heap dump 并分析 hprof 文件"></a>heap dump 并分析 hprof 文件</h2><p>这个阶段 <code>ResourcesCanary</code> 的逻辑跟 <code>LeakCanary</code> 几乎是一模一样的，估计是 copy 代码过来的，只不过 <code>ResourcesCanary</code> 用的还是 <a href="https://github.com/square/haha">haha</a> 而最新的 <code>LeakCanary</code> 已经使用 <code>Shark</code> 了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比 <code>LeakCanary</code>，<code>ResourcesCanary</code> 的优点是提出了子线程检查泄漏对象的思路，缺点是检测对象太单一，只有 <code>Activity</code>（重复 <code>Bitmap</code> 检测感觉并不可靠），而且没有抽象出通用的泄漏检测逻辑（<code>LeakCanary</code> 抽象出 <code>ObjectWatcher</code>）</p>]]></content>
    
    
    
    <tags>
      
      <tag>内存优化，OOM</tag>
      
      <tag>APM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 OOM</title>
    <link href="/2021/04/16/looking-into-oom/"/>
    <url>/2021/04/16/looking-into-oom/</url>
    
    <content type="html"><![CDATA[<h2 id="堆内存分配失败导致的-OOM"><a href="#堆内存分配失败导致的-OOM" class="headerlink" title="堆内存分配失败导致的 OOM"></a>堆内存分配失败导致的 OOM</h2><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>采用下述 API 来度量 APP 或系统的内存使用情况</p><table><thead><tr><th>类别</th><th>API</th><th>说明</th></tr></thead><tbody><tr><td>APP</td><td>Runtime.maxMemory()</td><td>JVM 可以从系统那申请到的内存的最大值，<code>ActivityManager.getMemoryClass()</code> 和 <code>ActivityManager.getLargeMemoryClass()</code> 其中之一，超过此阈值会发生 OOM</td></tr><tr><td></td><td>Runtime.totalMemory()</td><td>JVM 已申请到的内存大小，小于等于 <code>Runtime.maxMemory()</code> 且大于 <code>Runtime.freeMemory()</code>；当需要的内存（比如创建 1M 的字节数组）超过 <code>Runtime.freeMemory()</code> 时 JVM 会向系统申请内存，此时 <code>Runtime.totalMemory()</code> 会逐渐增大；直到等于 <code>Runtime.maxMemory()</code> 时，如果需要的内存超过 <code>Runtime.freeMemory()</code> 则抛出 OOM</td></tr><tr><td></td><td>Runtime.freeMemory()</td><td>JVM 已申请到但仍未使用的内存，当需要的内存超过此值时，JVM 会向系统申请内存</td></tr><tr><td></td><td>ActivityManager.getMemoryClass()</td><td>APP 可申请的内存上限</td></tr><tr><td></td><td>ActivityManager.getLargeMemoryClass()</td><td>设置 <code>android:largeHeap=&quot;true&quot;</code> 后 APP 可申请的内存上限，一般是 <code>ActivityManager.getLargeMemoryClass()</code> 的两倍</td></tr><tr><td>system</td><td>ActivityManager.MemoryInfo.availMem</td><td>当前系统可用内存大小，即设置里可用运存的值</td></tr><tr><td></td><td>ActivityManager.MemoryInfo.totalMem</td><td>系统总内存大小，即设置里运存总空间的值</td></tr><tr><td></td><td>ActivityManager.MemoryInfo.lowMemory</td><td>标识系统是否处于低内存状态</td></tr><tr><td></td><td>ActivityManager.MemoryInfo.threshold</td><td>当系统可用内存小于此阈值时，系统处于低内存状态</td></tr><tr><td>虚拟机配置项</td><td>dalvik.vm.heapgrowthlimit</td><td>默认情况下 App 可使用的 Heap 的最大值，比如 256m, 超过这个值就会产生 OOM</td></tr><tr><td></td><td>dalvik.vm.heapsize</td><td>如果配置了 largeHeap 则 App 可使用的 Heap 的最大值为此项设定值，比如 512m</td></tr><tr><td></td><td>dalvik.vm.heapstartsize</td><td>App 启动后系统分配给它的 Heap 初始大小，随着App使用可增加</td></tr><tr><td></td><td></td><td>以上配置项可以通过 <code>cat /system/build.prop</code> 或者 <code>adb shell getprop dalvik.vm.heapsize</code> 获取</td></tr></tbody></table><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用下面的测试代码在我的测试机（iQOO 3）上，循环申请 30M/5M/500K 的内存，每次间隔 1s 并打印内存统计情况</p><p>可以看到 JVM 使用内存上限 <code>max</code> 是 256M（刚好是 <code>memoryClass</code>，如果配置了 <code>largeHeap=&quot;true&quot;</code> 则是 <code>largeMemoryClass</code>），已申请内存 <code>total</code> 逐步上升直到 256M，<code>total</code> - <code>free</code> 等于申请内存的累计量；运行内存为 11.36GB，可用运存徘徊在 5GB 左右，当运存掉到 216M 时进入低内存状态，所以目前并不是低内存；APP 可申请内存上限为 256MB，设置 <code>largeHeap=&quot;true&quot;</code> 后翻倍到 512MB</p><p>抛出 OOM 时的信息为：<code>Failed to allocate a 512016 byte allocation with 22760 free bytes and 22KB until OOM, target footprint 268435456, growth limit 268435456</code></p><p>参考日志的最后一行，当时正在申请 500KB 的内存（<code>Failed to allocate a 512016 byte allocation</code>），还剩 14.95KB（<code>with 22760 free bytes and 22KB until OOM</code>），上限是 256MB（<code>target footprint 268435456, growth limit 268435456</code>）</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 循环申请内存直到 OOM</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mallocJVM</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> steps = arrayOf(<span class="hljs-number">1024L</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">30</span>, <span class="hljs-number">1024L</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>, <span class="hljs-number">1024L</span> * <span class="hljs-number">500</span>)    <span class="hljs-keyword">val</span> pool = mutableListOf&lt;ByteArray&gt;()    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">val</span> runtime = Runtime.getRuntime()        <span class="hljs-keyword">val</span> free = runtime.maxMemory() - runtime.totalMemory() + runtime.freeMemory()        <span class="hljs-keyword">val</span> size = <span class="hljs-keyword">if</span> (free &gt;= steps[<span class="hljs-number">0</span>]) steps[<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (free &gt;= steps[<span class="hljs-number">1</span>]) steps[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> steps[<span class="hljs-number">2</span>]        pool += ByteArray(size = size.toInt())        await()        printMemoryUsages()    &#125;&#125;<span class="hljs-comment">// 间隔 1s</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">(time: <span class="hljs-type">Long</span> = <span class="hljs-number">1000</span>)</span></span> &#123;    lock.lock()    <span class="hljs-keyword">try</span> &#123;        cond.await(time, TimeUnit.MILLISECONDS)    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock()    &#125;&#125;<span class="hljs-comment">// 打印内存统计情况</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMemoryUsages</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> runtime = Runtime.getRuntime()    am.getMemoryInfo(memInfo)    d(<span class="hljs-string">&quot;max:<span class="hljs-subst">$&#123;runtime.maxMemory&#125;</span> total:<span class="hljs-subst">$&#123;runtime.totalMemory&#125;</span> free:<span class="hljs-subst">$&#123;runtime.freeMemory&#125;</span> &quot;</span> +            <span class="hljs-string">&quot;availMem:<span class="hljs-subst">$&#123;memInfo.availMemReadable&#125;</span> totalMem:<span class="hljs-subst">$&#123;memInfo.totalMemReadable&#125;</span> &quot;</span> +            <span class="hljs-string">&quot;threshold:<span class="hljs-subst">$&#123;memInfo.thresholdReadable&#125;</span> lowMemory:<span class="hljs-subst">$&#123;memInfo.lowMemory&#125;</span> &quot;</span> +            <span class="hljs-string">&quot;memoryClass:<span class="hljs-subst">$&#123;am.memoryClassReadable&#125;</span> largeMemoryClass:<span class="hljs-subst">$&#123;am.largeMemoryClassReadable&#125;</span>&quot;</span>)&#125;</code></pre></div><p><img src="../../../../image/2021-04-16-looking-into-oom/oom_memory_log.png" alt="oom_memory_log.png"></p><p><img src="../../../../image/2021-04-16-looking-into-oom/oom_memory.png" alt="oom_memory.png"></p><h3 id="定位抛出-OOM-的位置"><a href="#定位抛出-OOM-的位置" class="headerlink" title="定位抛出 OOM 的位置"></a>定位抛出 OOM 的位置</h3><p>最终抛出 <code>OutOfMemoryError</code> 的代码 是 <code>Thread::ThrowOutOfMemoryError</code></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::ThrowOutOfMemoryError</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span> </span>&#123;  <span class="hljs-built_in">LOG</span>(WARNING) &lt;&lt; <span class="hljs-string">&quot;Throwing OutOfMemoryError &quot;</span>               &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&#x27;&quot;&#x27;</span>               &lt;&lt; <span class="hljs-string">&quot; (VmSize &quot;</span> &lt;&lt; <span class="hljs-built_in">GetProcessStatus</span>(<span class="hljs-string">&quot;VmSize&quot;</span>)               &lt;&lt; (tls32_.throwing_OutOfMemoryError ? <span class="hljs-string">&quot;, recursive case)&quot;</span> : <span class="hljs-string">&quot;)&quot;</span>);  <span class="hljs-keyword">if</span> (!tls32_.throwing_OutOfMemoryError) &#123;    tls32_.throwing_OutOfMemoryError = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">ThrowNewException</span>(<span class="hljs-string">&quot;Ljava/lang/OutOfMemoryError;&quot;</span>, msg);    tls32_.throwing_OutOfMemoryError = <span class="hljs-literal">false</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">Dump</span>(<span class="hljs-built_in">LOG_STREAM</span>(WARNING));  <span class="hljs-comment">// The pre-allocated OOME has no stack, so help out and log one.</span>    <span class="hljs-built_in">SetException</span>(Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetPreAllocatedOutOfMemoryErrorWhenThrowingOOME</span>());  &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::ThrowNewException</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* exception_class_descriptor,</span></span><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span> </span>&#123;  <span class="hljs-comment">// Callers should either clear or call ThrowNewWrappedException.</span>  <span class="hljs-built_in">AssertNoPendingExceptionForNewException</span>(msg);  <span class="hljs-built_in">ThrowNewWrappedException</span>(exception_class_descriptor, msg);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::ThrowNewWrappedException</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* exception_class_descriptor,</span></span><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span> </span>&#123;  <span class="hljs-comment">// ... 构造 Ljava/lang/OutOfMemoryError;</span>&#125;</code></pre></div><p>而因为堆内存分配失败抛出 OOM 的代码在 <code>Heap::ThrowOutOfMemoryError</code>，其中异常信息为：</p><p><code>&quot;Failed to allocate a (x) byte allocation with (x) free bytes and (x) until OOM, target footprint (x), growth limit (x)&quot;</code></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Heap::ThrowOutOfMemoryError</span><span class="hljs-params">(Thread* self, <span class="hljs-type">size_t</span> byte_count, AllocatorType allocator_type)</span> </span>&#123;  <span class="hljs-comment">// If we&#x27;re in a stack overflow, do not create a new exception. It would require running the</span>  <span class="hljs-comment">// constructor, which will of course still be in a stack overflow.</span>  <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">IsHandlingStackOverflow</span>()) &#123;    self-&gt;<span class="hljs-built_in">SetException</span>(        Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetPreAllocatedOutOfMemoryErrorWhenHandlingStackOverflow</span>());    <span class="hljs-keyword">return</span>;  &#125;  std::ostringstream oss;  <span class="hljs-type">size_t</span> total_bytes_free = <span class="hljs-built_in">GetFreeMemory</span>();  oss &lt;&lt; <span class="hljs-string">&quot;Failed to allocate a &quot;</span> &lt;&lt; byte_count &lt;&lt; <span class="hljs-string">&quot; byte allocation with &quot;</span> &lt;&lt; total_bytes_free      &lt;&lt; <span class="hljs-string">&quot; free bytes and &quot;</span> &lt;&lt; <span class="hljs-built_in">PrettySize</span>(<span class="hljs-built_in">GetFreeMemoryUntilOOME</span>()) &lt;&lt; <span class="hljs-string">&quot; until OOM,&quot;</span>      &lt;&lt; <span class="hljs-string">&quot; target footprint &quot;</span> &lt;&lt; target_footprint_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed)      &lt;&lt; <span class="hljs-string">&quot;, growth limit &quot;</span>      &lt;&lt; growth_limit_;  <span class="hljs-comment">// If the allocation failed due to fragmentation, print out the largest continuous allocation.</span>  <span class="hljs-keyword">if</span> (total_bytes_free &gt;= byte_count) &#123;    space::AllocSpace* space = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeNonMoving) &#123;      space = non_moving_space_;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeRosAlloc ||               allocator_type == kAllocatorTypeDlMalloc) &#123;      space = main_space_;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeBumpPointer ||               allocator_type == kAllocatorTypeTLAB) &#123;      space = bump_pointer_space_;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allocator_type == kAllocatorTypeRegion ||               allocator_type == kAllocatorTypeRegionTLAB) &#123;      space = region_space_;    &#125;    <span class="hljs-comment">// There is no fragmentation info to log for large-object space.</span>    <span class="hljs-keyword">if</span> (allocator_type != kAllocatorTypeLOS) &#123;      <span class="hljs-built_in">CHECK</span>(space != <span class="hljs-literal">nullptr</span>) &lt;&lt; <span class="hljs-string">&quot;allocator_type:&quot;</span> &lt;&lt; allocator_type                              &lt;&lt; <span class="hljs-string">&quot; byte_count:&quot;</span> &lt;&lt; byte_count                              &lt;&lt; <span class="hljs-string">&quot; total_bytes_free:&quot;</span> &lt;&lt; total_bytes_free;      space-&gt;<span class="hljs-built_in">LogFragmentationAllocFailure</span>(oss, byte_count);    &#125;  &#125;  self-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(oss.<span class="hljs-built_in">str</span>().<span class="hljs-built_in">c_str</span>());&#125;</code></pre></div><h2 id="创建线程时-Could-not-allocate-JNI-Env-导致的-OOM"><a href="#创建线程时-Could-not-allocate-JNI-Env-导致的-OOM" class="headerlink" title="创建线程时 Could not allocate JNI Env 导致的 OOM"></a>创建线程时 <code>Could not allocate JNI Env</code> 导致的 OOM</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>线程数量可以通过 <code>/proc/&#123;pid&#125;/status</code> 里 <code>Threads</code> 那行拿到</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Name</span>:m.<span class="hljs-property">myapplication</span><span class="hljs-title class_">State</span>:R (running)<span class="hljs-title class_">Tgid</span>:<span class="hljs-number">26939</span><span class="hljs-title class_">Ngid</span>:<span class="hljs-number">0</span><span class="hljs-title class_">Pid</span>:<span class="hljs-number">26939</span><span class="hljs-title class_">PPid</span>:<span class="hljs-number">1846</span><span class="hljs-title class_">TracerPid</span>:<span class="hljs-number">0</span><span class="hljs-title class_">Uid</span>:<span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-title class_">Gid</span>:<span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-number">10100</span><span class="hljs-title class_">FDSize</span>:<span class="hljs-number">64</span><span class="hljs-title class_">Groups</span>:<span class="hljs-number">3003</span> <span class="hljs-number">9997</span> <span class="hljs-number">20100</span> <span class="hljs-number">50100</span> ...<span class="hljs-title class_">Threads</span>:<span class="hljs-number">17</span>                  <span class="hljs-comment">// 线程数量</span>...</code></pre></div><p>不断地创建新线程，新线程啥也不干就阻塞住，从而使 APP 进程的线程数量持续上涨，模拟 APP 随意创建线程/线程池而没有做统一的管理，导致创建大量线程的情况，最后抛出 <code>Could not allocate JNI Env: Failed anonymous mmap(0x0, 8192, 0x3, 0x2, 53, 0): Permission denied. See process maps in the log.</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryKillerService</span> : <span class="hljs-type">IntentService</span>(<span class="hljs-string">&quot;MemoryKillerService&quot;</span>) &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;        <span class="hljs-comment">// 一个线程不断地创建测试线程（间隔 1ms）</span>        thread &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">val</span> thread = BlockingThread()                thread.start()                await(time = <span class="hljs-number">1</span>)            &#125;        &#125;        <span class="hljs-comment">// 一个线程不断地打印线程数</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            d(<span class="hljs-string">&quot;threadCount: <span class="hljs-subst">$&#123;getThreadCount()&#125;</span>&quot;</span>)            await(time = <span class="hljs-number">100</span>)        &#125;    &#125;&#125;<span class="hljs-comment">// 测试线程啥也不干，就阻塞住</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingThread</span>: <span class="hljs-type">Thread</span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = ReentrantLock()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cond = lock.newCondition()    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;        lock.lock()        <span class="hljs-keyword">try</span> &#123;            cond.await()        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock()        &#125;    &#125;&#125;<span class="hljs-comment">// 查询进程的线程数量</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getThreadCount</span><span class="hljs-params">()</span></span> = runCatching &#123;    regexGroupInFile(pattern = <span class="hljs-string">&quot;.*Threads:\\s+(\\d+).*&quot;</span>, path = <span class="hljs-string">&quot;/proc/<span class="hljs-subst">$&#123;myPid()&#125;</span>/status&quot;</span>)?.toInt()&#125;.getOrDefault(<span class="hljs-number">0</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.067</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1633</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.170</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1680</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.272</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1731</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.374</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1784</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.475</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1829</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.578</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1880</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.680</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1929</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.783</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">1972</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.886</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">2017</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10.988</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">2067</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.090</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">2113</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.193</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">2164</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.294</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29769</span>/com.<span class="hljs-property">myapplication</span> D/<span class="hljs-attr">memkiller</span>: <span class="hljs-attr">threadCount</span>: <span class="hljs-number">2208</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.368</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29771</span>/com.<span class="hljs-property">myapplication</span> W/m.<span class="hljs-property">myapplicatio</span>: <span class="hljs-title class_">Throwing</span> <span class="hljs-title class_">OutOfMemoryError</span> <span class="hljs-string">&quot;Could not allocate JNI Env: Failed anonymous mmap(0x0, 8192, 0x3, 0x2, 53, 0): Permission denied. See process maps in the log.&quot;</span>        --------- beginning <span class="hljs-keyword">of</span> crash<span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11.368</span> <span class="hljs-number">29743</span>-<span class="hljs-number">29771</span>/com.<span class="hljs-property">myapplication</span> E/<span class="hljs-title class_">AndroidRuntime</span>: <span class="hljs-variable constant_">FATAL</span> <span class="hljs-attr">EXCEPTION</span>: <span class="hljs-title class_">Thread</span>-<span class="hljs-number">2</span>    <span class="hljs-title class_">Process</span>: com.<span class="hljs-property">myapplication</span>, <span class="hljs-attr">PID</span>: <span class="hljs-number">29743</span>    java.<span class="hljs-property">lang</span>.<span class="hljs-property">OutOfMemoryError</span>: <span class="hljs-title class_">Could</span> not allocate <span class="hljs-variable constant_">JNI</span> <span class="hljs-title class_">Env</span>: <span class="hljs-title class_">Failed</span> anonymous <span class="hljs-title function_">mmap</span>(<span class="hljs-number">0x0</span>, <span class="hljs-number">8192</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">53</span>, <span class="hljs-number">0</span>): <span class="hljs-title class_">Permission</span> denied. <span class="hljs-title class_">See</span> process maps <span class="hljs-keyword">in</span> the log.        at java.<span class="hljs-property">lang</span>.<span class="hljs-property">Thread</span>.<span class="hljs-title function_">nativeCreate</span>(<span class="hljs-title class_">Native</span> <span class="hljs-title class_">Method</span>)        at java.<span class="hljs-property">lang</span>.<span class="hljs-property">Thread</span>.<span class="hljs-title function_">start</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-property">java</span>:<span class="hljs-number">733</span>)        at com.<span class="hljs-property">myapplication</span>.<span class="hljs-property">MemoryKillerService$onHandleIntent$1</span>.<span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">MemoryKillerService</span>.<span class="hljs-property">kt</span>:<span class="hljs-number">35</span>)        at com.<span class="hljs-property">myapplication</span>.<span class="hljs-property">MemoryKillerService$onHandleIntent$1</span>.<span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">MemoryKillerService</span>.<span class="hljs-property">kt</span>:<span class="hljs-number">22</span>)        at kotlin.<span class="hljs-property">concurrent</span>.<span class="hljs-property">ThreadsKt$thread$thread$1</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-property">kt</span>:<span class="hljs-number">30</span>)</code></pre></div><h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><div class="code-wrapper"><pre><code class="hljs cpp">Thread.<span class="hljs-built_in">start</span>()Thread.<span class="hljs-function">nativeCreate</span><span class="hljs-function">Thread_nativeCreate</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::CreateNativeThread</span><span class="hljs-params">(JNIEnv* env, jobject java_peer, <span class="hljs-type">size_t</span> stack_size, <span class="hljs-type">bool</span> is_daemon)</span> </span>&#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-comment">// Try to allocate a JNIEnvExt for the thread. We do this here as we might be out of memory and</span>  <span class="hljs-comment">// do not have a good way to report this on the child&#x27;s side.</span>  std::string error_msg;  <span class="hljs-function">std::unique_ptr&lt;JNIEnvExt&gt; <span class="hljs-title">child_jni_env_ext</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      JNIEnvExt::Create(child_thread, Runtime::Current()-&gt;GetJavaVM(), &amp;error_msg))</span></span>;  <span class="hljs-comment">// 成功创建 JNIEnvExt 后才会真正创建线程 pthread_create ...</span>  <span class="hljs-comment">// 找到了错误信息 Could not allocate JNI Env，它是由 child_jni_env_ext.get() == nullptr 触发的</span>  <span class="hljs-comment">// 也就是 JNIEnvExt::Create 返回 nullptr，JNIEnvExt 创建失败</span>  &#123;    <span class="hljs-function">std::string <span class="hljs-title">msg</span><span class="hljs-params">(child_jni_env_ext.get() == <span class="hljs-literal">nullptr</span> ?</span></span><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;Could not allocate JNI Env: %s&quot;</span>, error_msg.c_str()) :</span></span><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;pthread_create (%s stack) failed: %s&quot;</span>,</span></span><span class="hljs-params"><span class="hljs-function">                                 PrettySize(stack_size).c_str(), strerror(pthread_create_result)))</span></span>;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;    soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(msg.<span class="hljs-built_in">c_str</span>());  &#125;&#125;<span class="hljs-comment">// 发现 JNIEnvExt.locals_.table_mem_map_.IsValid 返回 false 导致 JNIEnvExt 创建失败</span>JNIEnvExt::CreateJNIEnvExt::CheckLocalsValidIndirectReferenceTable::IsValidMemMap.IsValid<span class="hljs-comment">// locals_ 是在 JNIEnvExt 的构造函数里初始化的</span>JNIEnvExt::<span class="hljs-built_in">JNIEnvExt</span>(Thread* self_in, JavaVMExt* vm_in, std::string* error_msg)    : <span class="hljs-built_in">self_</span>(self_in),      <span class="hljs-built_in">vm_</span>(vm_in),      <span class="hljs-built_in">local_ref_cookie_</span>(kIRTFirstSegment),      <span class="hljs-built_in">locals_</span>(kLocalsInitial, kLocal, IndirectReferenceTable::ResizableCapacity::kYes, error_msg),      <span class="hljs-built_in">monitors_</span>(<span class="hljs-string">&quot;monitors&quot;</span>, kMonitorsInitial, kMonitorsMax),      <span class="hljs-built_in">critical_</span>(<span class="hljs-number">0</span>),      <span class="hljs-built_in">check_jni_</span>(<span class="hljs-literal">false</span>),      <span class="hljs-built_in">runtime_deleted_</span>(<span class="hljs-literal">false</span>) &#123;  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(Thread::Current(), *Locks::jni_function_table_lock_)</span></span>;  check_jni_ = vm_in-&gt;<span class="hljs-built_in">IsCheckJniEnabled</span>();  functions = <span class="hljs-built_in">GetFunctionTable</span>(check_jni_);  unchecked_functions_ = <span class="hljs-built_in">GetJniNativeInterface</span>();&#125;<span class="hljs-comment">// table_mem_map_ 是由 MemMap::MapAnonymous 创建的</span>IndirectReferenceTable::<span class="hljs-built_in">IndirectReferenceTable</span>(<span class="hljs-type">size_t</span> max_count,                                               IndirectRefKind desired_kind,                                               ResizableCapacity resizable,                                               std::string* error_msg)    : <span class="hljs-built_in">segment_state_</span>(kIRTFirstSegment),      <span class="hljs-built_in">kind_</span>(desired_kind),      <span class="hljs-built_in">max_entries_</span>(max_count),      <span class="hljs-built_in">current_num_holes_</span>(<span class="hljs-number">0</span>),      <span class="hljs-built_in">resizable_</span>(resizable) &#123;  <span class="hljs-built_in">CHECK</span>(error_msg != <span class="hljs-literal">nullptr</span>);  <span class="hljs-built_in">CHECK_NE</span>(desired_kind, kJniTransitionOrInvalid);  <span class="hljs-comment">// Overflow and maximum check.</span>  <span class="hljs-built_in">CHECK_LE</span>(max_count, kMaxTableSizeInBytes / <span class="hljs-built_in">sizeof</span>(IrtEntry));  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> table_bytes = <span class="hljs-built_in">RoundUp</span>(max_count * <span class="hljs-built_in">sizeof</span>(IrtEntry), kPageSize);  table_mem_map_ = MemMap::<span class="hljs-built_in">MapAnonymous</span>(<span class="hljs-string">&quot;indirect ref table&quot;</span>,                                        table_bytes,                                        PROT_READ | PROT_WRITE,                                        <span class="hljs-comment">/*low_4gb=*/</span> <span class="hljs-literal">false</span>,                                        error_msg);  <span class="hljs-keyword">if</span> (!table_mem_map_.<span class="hljs-built_in">IsValid</span>() &amp;&amp; error_msg-&gt;<span class="hljs-built_in">empty</span>()) &#123;    *error_msg = <span class="hljs-string">&quot;Unable to map memory for indirect ref table&quot;</span>;  &#125;  <span class="hljs-keyword">if</span> (table_mem_map_.<span class="hljs-built_in">IsValid</span>()) &#123;    table_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;IrtEntry*&gt;(table_mem_map_.<span class="hljs-built_in">Begin</span>());  &#125; <span class="hljs-keyword">else</span> &#123;    table_ = <span class="hljs-literal">nullptr</span>;  &#125;  segment_state_ = kIRTFirstSegment;  last_known_previous_state_ = kIRTFirstSegment;  <span class="hljs-comment">// Take into account the actual length.</span>  max_entries_ = table_bytes / <span class="hljs-built_in">sizeof</span>(IrtEntry);&#125;<span class="hljs-comment">// 找到错误信息 Failed anonymous mmap 的出处了</span><span class="hljs-function">MemMap <span class="hljs-title">MemMap::MapAnonymous</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">uint8_t</span>* addr,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">size_t</span> byte_count,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">int</span> prot,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> low_4gb,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> reuse,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-comment">/*inout*/</span>MemMap* reservation,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-comment">/*out*/</span>std::string* error_msg,</span></span><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> use_debug_name)</span> </span>&#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-comment">// fd 没有指向任何有效文件，addr 也是 nullptr</span>  <span class="hljs-comment">// 也就是说这里只是开辟了容量是 byte_count 的一段内存空间</span>  <span class="hljs-type">void</span>* actual = <span class="hljs-built_in">MapInternal</span>(addr,                             page_aligned_byte_count,                             prot,                             flags,                             fd.<span class="hljs-built_in">get</span>(),                             <span class="hljs-number">0</span>,                             low_4gb);  saved_errno = errno;  <span class="hljs-keyword">if</span> (actual == MAP_FAILED) &#123;    <span class="hljs-keyword">if</span> (error_msg != <span class="hljs-literal">nullptr</span>) &#123;      <span class="hljs-keyword">if</span> (kIsDebugBuild || <span class="hljs-built_in">VLOG_IS_ON</span>(oat)) &#123;        <span class="hljs-built_in">PrintFileToLog</span>(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, LogSeverity::WARNING);      &#125;      *error_msg = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Failed anonymous mmap(%p, %zd, 0x%x, 0x%x, %d, 0): %s. &quot;</span>                                    <span class="hljs-string">&quot;See process maps in the log.&quot;</span>,                                addr,                                page_aligned_byte_count,                                prot,                                flags,                                fd.<span class="hljs-built_in">get</span>(),                                <span class="hljs-built_in">strerror</span>(saved_errno));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Invalid</span>();  &#125;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 看来是将 fd 映射进内存地址时失败了</span>MemMap::MapInternalMemMap::TargetMMapmmap</code></pre></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建线程时，需要构造 <code>JNIEnvExt</code> 这么一个对象，而 <code>JNIEnvExt</code> 需要 <code>mmap</code> 一块大小为 <code>RoundUp(max_count * sizeof(IrtEntry), kPageSize)</code> 的内存地址（内存页面大小的整数倍，比如上面 logcat 里，8192 = 4096 * 2），当虚拟内存地址空间耗尽时抛出 OOM</p><ol><li><code>Could not allocate JNI Env</code> 不能为 <code>JNIEnvExt</code> 分配内存</li><li><code>Failed anonymous mmap(0x0, 8192, 0x3, 0x2, 53, 0)</code> 不能分配 8192 大小的内存地址</li><li><code>Permission denied. See process maps in the log.</code> 我用的模拟器，可能是说超出内存限制后不能用其他方式获得内存？</li></ol><h2 id="创建线程时-pthread-create-failed-导致的-OOM"><a href="#创建线程时-pthread-create-failed-导致的-OOM" class="headerlink" title="创建线程时 pthread_create failed 导致的 OOM"></a>创建线程时 <code>pthread_create failed</code> 导致的 OOM</h2><p>用上面的测试代码还会出现另外一种 OOM 如下</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.488</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1702</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.590</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1747</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.692</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1796</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.794</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1848</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37.898</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1895</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.000</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1946</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.103</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">1997</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.205</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2045</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.307</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2096</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.410</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2139</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.513</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2175</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.615</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27431</span>/com.myapplication D/memkiller: threadCount: <span class="hljs-number">2220</span><span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">20</span> <span class="hljs-number">13</span>:<span class="hljs-number">55</span>:<span class="hljs-number">38.663</span> <span class="hljs-number">27404</span>-<span class="hljs-number">27433</span>/com.myapplication W/libc: pthread_create failed: couldn<span class="hljs-string">&#x27;t allocate TLS: Permission denied</span><span class="hljs-string">2021-04-20 13:55:38.663 27404-27433/com.myapplication W/m.myapplicatio: Throwing OutOfMemoryError &quot;pthread_create (1040KB stack) failed: Try again&quot;</span><span class="hljs-string">    </span><span class="hljs-string">    --------- beginning of crash</span><span class="hljs-string">2021-04-20 13:55:38.664 27404-27433/com.myapplication E/AndroidRuntime: FATAL EXCEPTION: Thread-2</span><span class="hljs-string">    Process: com.myapplication, PID: 27404</span><span class="hljs-string">    java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again</span><span class="hljs-string">        at java.lang.Thread.nativeCreate(Native Method)</span><span class="hljs-string">        at java.lang.Thread.start(Thread.java:733)</span><span class="hljs-string">        at com.myapplication.MemoryKillerService$onHandleIntent$1.invoke(MemoryKillerService.kt:35)</span><span class="hljs-string">        at com.myapplication.MemoryKillerService$onHandleIntent$1.invoke(MemoryKillerService.kt:22)</span><span class="hljs-string">        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span></code></pre></div><p>创建线程最终会执行系统调用 <code>pthread_create</code>，如果失败会抛出 <code>pthread_create (1040KB stack) failed</code>，1040KB 是线程的栈大小</p><p>上面 <code>pthread_create failed: couldn&#39;t allocate TLS: Permission denied</code> 表示为线程分配 Thread Local（TLS，THREAD LOCAL STORAGE）相关的内存时因为内存不足失败了</p><div class="code-wrapper"><pre><code class="hljs cpp">Thread.<span class="hljs-built_in">start</span>()Thread.<span class="hljs-function">nativeCreate</span><span class="hljs-function">Thread_nativeCreate</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::CreateNativeThread</span><span class="hljs-params">(JNIEnv* env, jobject java_peer, <span class="hljs-type">size_t</span> stack_size, <span class="hljs-type">bool</span> is_daemon)</span> </span>&#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-comment">// 不同于上面的情况，此时已为 JNIEnvExt 分配内存，但在执行 pthread_create 时出错了</span>  <span class="hljs-type">int</span> pthread_create_result = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (child_jni_env_ext.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-type">pthread_t</span> new_pthread;    <span class="hljs-type">pthread_attr_t</span> attr;    child_thread-&gt;tlsPtr_.tmp_jni_env = child_jni_env_ext.<span class="hljs-built_in">get</span>();    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_init, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setdetachstate, (&amp;attr, PTHREAD_CREATE_DETACHED),                       <span class="hljs-string">&quot;PTHREAD_CREATE_DETACHED&quot;</span>);    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_setstacksize, (&amp;attr, stack_size), stack_size);    pthread_create_result = <span class="hljs-built_in">pthread_create</span>(&amp;new_pthread,                                           &amp;attr,                                           Thread::CreateCallback,                                           child_thread);    <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_attr_destroy, (&amp;attr), <span class="hljs-string">&quot;new thread&quot;</span>);    <span class="hljs-keyword">if</span> (pthread_create_result == <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// pthread_create started the new thread. The child is now responsible for managing the</span>      <span class="hljs-comment">// JNIEnvExt we created.</span>      <span class="hljs-comment">// Note: we can&#x27;t check for tmp_jni_env == nullptr, as that would require synchronization</span>      <span class="hljs-comment">//       between the threads.</span>      child_jni_env_ext.<span class="hljs-built_in">release</span>();  <span class="hljs-comment">// NOLINT pthreads API.</span>      <span class="hljs-keyword">return</span>;    &#125;  &#125;  <span class="hljs-comment">// pthread_create 成功会在上面返回，跑到这里是因为其执行失败了</span>  &#123;    <span class="hljs-function">std::string <span class="hljs-title">msg</span><span class="hljs-params">(child_jni_env_ext.get() == <span class="hljs-literal">nullptr</span> ?</span></span><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;Could not allocate JNI Env: %s&quot;</span>, error_msg.c_str()) :</span></span><span class="hljs-params"><span class="hljs-function">        StringPrintf(<span class="hljs-string">&quot;pthread_create (%s stack) failed: %s&quot;</span>,</span></span><span class="hljs-params"><span class="hljs-function">                                 PrettySize(stack_size).c_str(), strerror(pthread_create_result)))</span></span>;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;    soa.<span class="hljs-built_in">Self</span>()-&gt;<span class="hljs-built_in">ThrowOutOfMemoryError</span>(msg.<span class="hljs-built_in">c_str</span>());  &#125;&#125;</code></pre></div><h3 id="更多的例子"><a href="#更多的例子" class="headerlink" title="更多的例子"></a>更多的例子</h3><p>线程数超出了限制</p><div class="code-wrapper"><pre><code class="hljs kotlin">W/libc: pthread_create failed: clone failed: Out of memoryW/art: Throwing OutOfMemoryError <span class="hljs-string">&quot;pthread_create (1040KB stack) failed: Out of memory&quot;</span></code></pre></div><p>内存不足</p><div class="code-wrapper"><pre><code class="hljs kotlin">W/libc: pthread_create failed: couldn<span class="hljs-string">&#x27;t allocate 1073152-bytes mapped space: Out of memory</span><span class="hljs-string">W/art: Throwing OutOfMemoryError with VmSize  4191668 kB &quot;pthread_create (1040KB stack) failed: Try again&quot;</span></code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html">Probe：Android线上OOM问题定位组件</a></li><li><a href="https://www.jianshu.com/p/e574f0ffdb42">不可思议的OOM</a></li><li><a href="https://github.com/CharonChui/AndroidNote/blob/master/AdavancedPart/OOM%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md">OOM问题分析</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尾递归及尾递归优化</title>
    <link href="/2021/04/15/tailrec/"/>
    <url>/2021/04/15/tailrec/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h2><blockquote><p>这里有一篇文章讲得很好，转载自 <a href="https://blog.csdn.net/qq_34639378/article/details/78397312">浅谈Java中的递归与尾递归</a></p></blockquote><h3 id="首先我们讲讲递归"><a href="#首先我们讲讲递归" class="headerlink" title="首先我们讲讲递归"></a>首先我们讲讲递归</h3><p>递归的本质是，某个方法中调用了自身。本质还是调用一个方法，只是这个方法正好是自身而已，递归因为是在自身中调用自身，所以会带来以下三个显著特点：</p><ol><li>调用的是同一个方法</li><li>因为 1，所以只需要写一个方法，就可以让你轻松调用无数次（不用一个个写，你定个 n 就能有 n 个方法），所以调用的方法数可能非常巨大</li><li>在自身中调用自身，是嵌套调用（栈帧无法回收，开销巨大）</li></ol><p>因为上面 2 和 3 两个特点，所以递归调用最大的诟病就是开销巨大，栈帧和堆一起爆掉，俗称内存溢出（一个误区，不是因为调用自身而开销巨大，而是嵌套加上轻易就能无数次调用，使得递归可以很容易开销巨大），既然会导致内存泄露那肯定要想办法了，方法很简单，那就是尾递归优化</p><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p>尾递归优化是利用上面的第一个特点 “调用同一个方法” 来进行优化的，包括两个东西：</p><h4 id="尾递归的形式"><a href="#尾递归的形式" class="headerlink" title="尾递归的形式"></a>尾递归的形式</h4><p>尾递归其实只是一种对递归的特殊写法，这种写法原本并不会带来跟递归不一样的影响，它只是写法不一样而已，写成这样不会有任何优化效果，该爆的栈和帧都还会爆；具体不一样在哪里，前面说了，递归的本质是某个方法调用了自身，尾递归这种形式就要求：某个方法调用自身这件事，一定是该方法做的 <strong>最后一件事</strong>（所以当有需要返回值的时候会是 <code>return f(n)</code>，没有返回的话就直接是 <code>f(n)</code>）</p><p>要求很简单，就一条，但是有一些常见的误区：</p><ol><li>这个 <code>f(n)</code> 外不能加其他东西，因为这就不是最后一件事了，值返回来后还要再干点其他的活，变量空间还需要保留</li><li>如果有返回值的，你不能：乘个常数 <code>return 3f(n)</code>，乘个 n <code>return n*f(n)</code>，甚至是 <code>f(n)+f(n-1)</code></li></ol><h4 id="编译器对尾递归的优化"><a href="#编译器对尾递归的优化" class="headerlink" title="编译器对尾递归的优化"></a>编译器对尾递归的优化</h4><p>上面说了，你光手动写成尾递归的形式，并没有什么卵用，要实现优化，还需要编译器中加入了对尾递归优化的机制，有了这个机制，编译的时候就会自动利用上面的特点一来进行优化，简单说就是重复利用同一个栈帧，不仅不用释放上一个，连下一个新的都不用开，效率非常高（有人做实验，这个比递推比迭代都要效率高）</p><p>为什么写成尾递归的形式，编译器就能优化了？</p><ol><li>因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了</li><li>正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间</li></ol><p>所以总结为了解决递归的开销大问题，使用尾递归优化，具体分两步：</p><ol><li>你把递归调用的形式写成尾递归的形式</li><li>编译器碰到尾递归，自动按照某种特定的方式进行优化编译</li></ol><p>举例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 没有使用尾递归的形式</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">recsum</span>(<span class="hljs-params">x</span>):  <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:    <span class="hljs-keyword">return</span> x  <span class="hljs-keyword">else</span>:    <span class="hljs-keyword">return</span> x + recsum(x - <span class="hljs-number">1</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用尾递归的形式）</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">tailrecsum</span>(<span class="hljs-params">x, running_total=<span class="hljs-number">0</span></span>):  <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:    <span class="hljs-keyword">return</span> running_total  <span class="hljs-keyword">else</span>:    <span class="hljs-keyword">return</span> tailrecsum(x - <span class="hljs-number">1</span>, running_total + x)</code></pre></div><p>但不是所有语言的编译器都做了尾递归优化。比如 C 实现了，JAVA 没有去实现，说到这里你很容易联想到 JAVA 中的自动垃圾回收机制，同是处理内存问题的机制，尾递归优化跟垃圾回收是不是有什么关系，这是不是就是 JAVA 不实现尾递归优化的原因？ </p><h3 id="所以下面要讲一下垃圾回收（GC）"><a href="#所以下面要讲一下垃圾回收（GC）" class="headerlink" title="所以下面要讲一下垃圾回收（GC）"></a>所以下面要讲一下垃圾回收（GC）</h3><p>首先我们需要谈一下内存机制，这里我们需要了解内存机制的两个部分：栈和堆。下面虽然是在说 JAVA，但是 C 也是差不多的</p><p>在 Java 中， JVM 中的栈记录了线程的方法调用，每个线程拥有一个栈，在某个线程的运行过程中如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈帧 (<code>frame</code>)。在 <code>frame</code> 中保存有该方法调用的参数、局部变量和返回地址；Java 的参数和局部变量只能是基本类型的变量(比如 <code>int</code>)，或者对象的引用(<code>reference</code>)，因此在栈中只保存有基本类型的变量和对象引用。而引用所指向的对象保存在堆中</p><p>然后由栈和堆的空间管理方式的不同，引出 <strong>垃圾回收</strong> 的概念，当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放，线程回到原方法继续执行，当所有的栈都清空时程序也随之运行结束</p><p>如上所述，栈(<code>stack</code>)可以自己照顾自己，但堆必须要小心对待。堆是 JVM 中一块可自由分配给对象的区域，当我们谈论垃圾回收 (garbage collection) 时，我们主要回收堆(<code>heap</code>)的空间</p><p>Java 的普通对象存活在堆中，与栈不同堆的空间不会随着方法调用结束而清空（即使它在栈上的引用已经被清空了），因此在某个方法中创建的对象，可以在方法调用结束之后继续存在于堆中，这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽</p><p>如果没有垃圾回收机制的话，你就需要手动地显式分配及释放内存，如果你忘了去释放内存，那么这块内存就无法重用了（不管是什么局部变量还是其他的什么）；这块内存被占有了却没被使用，这种场景被称之为 <strong>内存泄露</strong>，所以不管是 C 还是 JAVA，最原始的情况都是需要手动释放堆中的对象，C 到现在也是这样，所以你经常需要考虑对象的生存周期，但是 JAVA 则引入了一个自动垃圾回收的机制，它能智能地释放那些被判定已经没有用的对象 </p><h3 id="现在我们就可以比较一下尾递归优化和垃圾回收了"><a href="#现在我们就可以比较一下尾递归优化和垃圾回收了" class="headerlink" title="现在我们就可以比较一下尾递归优化和垃圾回收了"></a>现在我们就可以比较一下尾递归优化和垃圾回收了</h3><p>他们最本质的区别是：尾递归优化解决的是内存溢出的问题，而垃圾回收解决的是内存泄露的问题</p><ul><li>内存泄露指程序中动态分配内存给一些临时对象，但是对象不会被 GC 所回收，它始终占用内存，即被分配的对象可达但已无用</li><li>内存溢出指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于 Old 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况</li></ul><p>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。</p><p>自动垃圾回收机制的特点是：</p><ol><li>解决了所有情况下的内存泄露的问题，但还可以由于其他原因内存溢出</li><li>针对内存中的堆空间，正在运行的方法中的堆中的对象是不会被管理的，因为还有引用（栈帧没有被清空）</li><li>一般简单的自动垃圾回收机制是采用 <strong>引用计数</strong> 机制，每个对象包含一个计数器，当有新的指向该对象的引用时计数器加 1，当引用移除时计数器减 1，当计数器为 0 时认为该对象可以进行垃圾回收</li></ol><p>与之相对，尾递归优化的特点是：</p><ol><li>优化了递归调用时的内存溢出问题</li><li>针对内存中的堆空间和栈空间，正在运行的方法的堆和栈空间正是优化的目标</li><li>只在递归调用的时候使用，而且只能对于写成尾递归形式的递归进行优化</li></ol><h2 id="验证-Kotlin-的尾递归优化"><a href="#验证-Kotlin-的尾递归优化" class="headerlink" title="验证 Kotlin 的尾递归优化"></a>验证 Kotlin 的尾递归优化</h2><p>实现阶乘，<code>factorial</code> 是普通的递归版本，<code>factorialTail</code> 是尾递归版本（Kotlin 里除了要把递归函数写成尾递归的形式，还要添加 <code>tailrec</code> 关键字）</p><p>当计算 <code>5!</code> 时，通过控制台可以看到普通的递归会有 5 个栈帧（相当于从左至右计算：1 * 2 * 3 * 4 * 5）；而尾递归则只有一个栈帧，说明 Kotlin 确实通过尾递归优化减少了递归调用时的栈帧消耗（相当于从右至左计算：5 * 4 * 3 * 2 * 1）</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;        <span class="hljs-meta">@JvmStatic</span>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;            println(factorial(n = <span class="hljs-number">5</span>))            println(factorialTail(step = <span class="hljs-number">5</span>))        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阶乘的普通递归版本</span><span class="hljs-comment"> * 5! = 1 * 2 * 3 * 4 * 5</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorial</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (n) &#123;        <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; &#123;            printStack()            <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">else</span> -&gt; factorial(n - <span class="hljs-number">1</span>) * n    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阶乘的尾递归版本</span><span class="hljs-comment"> * 添加关键字 tailrec 看看 Kotlin 会不会对其进行优化</span><span class="hljs-comment"> */</span><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorialTail</span><span class="hljs-params">(step: <span class="hljs-type">Int</span>, value: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;    <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">1</span>) &#123;        printStack()        <span class="hljs-keyword">return</span> value    &#125;    <span class="hljs-keyword">return</span> factorialTail(step - <span class="hljs-number">1</span>, step * value)&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printStack</span><span class="hljs-params">()</span></span> &#123;    Exception().printStackTrace()&#125;</code></pre></div><p><img src="../../../../image/2021-04-15-tailrec/factorial_output.png" alt="factorial_output.png"></p><p>打开 class 文件可以看到，其实是把递归写法转换为 <code>while</code> 循环，从而实现「只使用一个栈帧」的目标 </p><p><img src="../../../../image/2021-04-15-tailrec/code.png" alt="code.png"></p><h2 id="验证-Java-的尾递归优化"><a href="#验证-Java-的尾递归优化" class="headerlink" title="验证 Java 的尾递归优化"></a>验证 Java 的尾递归优化</h2><p>从下面的控制台输出可以看到，无论是普通递归还是尾递归都产生了四个栈帧，说明 java 编译器并未实现对尾递归的优化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 阶乘的普通递归版本</span><span class="hljs-comment"> * 5! = 1 * 2 * 3 * 4 * 5</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-keyword">switch</span> (n) &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            printStack();            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> factorial(n - <span class="hljs-number">1</span>) * n;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阶乘的尾递归版本</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial_tail</span><span class="hljs-params">(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> value)</span> &#123;    <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">1</span>) &#123;        printStack();        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-keyword">return</span> factorial_tail(step - <span class="hljs-number">1</span>, step * value);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStack</span><span class="hljs-params">()</span> &#123;    Log.e(<span class="hljs-string">&quot;cyrus&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>());&#125;</code></pre></div><p><img src="../../../../image/2021-04-15-tailrec/java_output.png" alt="java_output.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>tailrec</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeakCanary 浅析</title>
    <link href="/2021/04/12/leakcanary/"/>
    <url>/2021/04/12/leakcanary/</url>
    
    <content type="html"><![CDATA[<h2 id="检测内存泄漏"><a href="#检测内存泄漏" class="headerlink" title="检测内存泄漏"></a>检测内存泄漏</h2><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><table><thead><tr><th>引用类型</th><th>GC 时机</th></tr></thead><tbody><tr><td>强引用</td><td>平时写代码最常用的引用类型，对象只要被强引用就不会被 GC</td></tr><tr><td>软引用 <code>SoftReference</code></td><td>只有当内存不足时才会被 GC</td></tr><tr><td>弱引用 <code>WeakReference</code></td><td>会被正常 GC</td></tr><tr><td>虚引用 <code>PhantomReference</code></td><td>会被正常 GC，因为 <code>get()</code> 总是返回 null，一般用来跟踪对象的生命周期</td></tr></tbody></table><p>所有的引用类型都可以在构造时与一个 <code>ReferenceQueue</code> 关联，当引用的对象被 GC 后，这个 <code>Reference</code> 将被入队到关联的引用队列里</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;T&gt; &#123;    <span class="hljs-comment">/* -- Constructors -- */</span>    Reference(T referent) &#123;        <span class="hljs-built_in">this</span>(referent, <span class="hljs-literal">null</span>);    &#125;    Reference(T referent, ReferenceQueue&lt;? <span class="hljs-built_in">super</span> T&gt; queue) &#123;        <span class="hljs-built_in">this</span>.referent = referent;        <span class="hljs-built_in">this</span>.queue = queue;    &#125;&#125;</code></pre></div><h3 id="如何检测泄漏对象"><a href="#如何检测泄漏对象" class="headerlink" title="如何检测泄漏对象"></a>如何检测泄漏对象</h3><p><code>ObjectWatcher</code> 实现了 <code>LeakCanary</code> 的泄漏检测机制：监控 - 等待 - 检查</p><p>用 <code>WeakReference</code> + <code>ReferenceQueue</code> 监控对象的 GC 状态，并用 <code>watchedObjects</code> 持有它的弱引用，key 是 UUID</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectWatcher</span> <span class="hljs-keyword">constructor</span>(  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;) : ReachabilityWatcher &#123;  <span class="hljs-comment">// 持有被监控对象的弱引用，以便后续的检查</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()  <span class="hljs-comment">// 引用队列，被 GC 的对象的引用会进入此队列</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()&#125;</code></pre></div><p>将指定对象交由 <code>ObjectWatcher</code> 进行监控</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 监控检测对象</span><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;  <span class="hljs-keyword">if</span> (!isEnabled()) &#123;    <span class="hljs-keyword">return</span>  &#125;  removeWeaklyReachableObjects()  <span class="hljs-comment">// 从 watchedObjects 移除已被 GC 的对象</span>  <span class="hljs-comment">// 弱引用监控对象并放入 watchedObjects</span>  <span class="hljs-keyword">val</span> key = UUID.randomUUID().toString()  <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()  <span class="hljs-keyword">val</span> reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)  SharkLog.d &#123;    <span class="hljs-string">&quot;Watching &quot;</span> +      (<span class="hljs-keyword">if</span> (watchedObject <span class="hljs-keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;instance of <span class="hljs-subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +      (<span class="hljs-keyword">if</span> (description.isNotEmpty()) <span class="hljs-string">&quot; (<span class="hljs-variable">$description</span>)&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>) +      <span class="hljs-string">&quot; with key <span class="hljs-variable">$key</span>&quot;</span>  &#125;  watchedObjects[key] = reference  <span class="hljs-comment">// 选机检查（默认 5s 后执行检查函数 moveToRetained）</span>  checkRetainedExecutor.execute &#123;    moveToRetained(key)  &#125;&#125;<span class="hljs-comment">// 出现在 queue 里的对象已被成功 GC 就不需要监控了</span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeWeaklyReachableObjects</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span>  <span class="hljs-comment">// reachable. This is before finalization or garbage collection has actually happened.</span>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?  <span class="hljs-keyword">do</span> &#123;    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;      watchedObjects.remove(ref.key)    &#125;  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)&#125;</code></pre></div><p>检查是否发生泄漏，默认情况是等待 5s，让 GC 线程有足够的机会去发现并回收这个对象，如果 5s 后仍然没有被 GC（没有出现在引用队列里），那么可以证明这个对象发生了内存泄漏，被强引用导致存活超过它的生命周期</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 上面说过检查操作将提交给 checkRetainedExecutor 执行</span><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;  <span class="hljs-comment">// ...</span>  checkRetainedExecutor.execute &#123;    moveToRetained(key)  &#125;&#125;<span class="hljs-comment">// 而 checkRetainedExecutor 是通过构造函数传入的</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectWatcher</span> <span class="hljs-keyword">constructor</span>(  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;)<span class="hljs-comment">// 默认是等待 5s 并在主线程执行检查操作</span><span class="hljs-keyword">object</span> AppWatcher &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> RETAINED_DELAY_NOT_SET = -<span class="hljs-number">1L</span>  <span class="hljs-meta">@Volatile</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retainedDelayMillis = RETAINED_DELAY_NOT_SET  <span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(    clock = &#123; SystemClock.uptimeMillis() &#125;,    checkRetainedExecutor = &#123;      check(isInstalled) &#123;        <span class="hljs-string">&quot;AppWatcher not installed&quot;</span>      &#125;      mainHandler.postDelayed(it, retainedDelayMillis)  <span class="hljs-comment">// 在主线程执行检查</span>    &#125;,    isEnabled = &#123; <span class="hljs-literal">true</span> &#125;  )  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    application: <span class="hljs-type">Application</span>,</span></span><span class="hljs-params"><span class="hljs-function">    retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,   <span class="hljs-comment">// 默认等待 5s</span>    watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)  ) &#123;    checkMainThread()    <span class="hljs-keyword">if</span> (isInstalled) &#123;      <span class="hljs-keyword">throw</span> IllegalStateException(        <span class="hljs-string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause      )    &#125;    check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;      <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span>    &#125;    installCause = RuntimeException(<span class="hljs-string">&quot;manualInstall() first called here&quot;</span>)    <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis    <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;      LogcatSharkLog.install()    &#125;    <span class="hljs-comment">// Requires AppWatcher.objectWatcher to be set</span>    LeakCanaryDelegate.loadLeakCanary(application)    watchersToInstall.forEach &#123;      it.install()    &#125;  &#125;&#125;<span class="hljs-comment">// 如果没有出现在引用队列里，说明此对象已发生泄漏，发出通知</span><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;  removeWeaklyReachableObjects()    <span class="hljs-comment">// 出现在引用队列里说明对象已被 GC，可以从 watchedObjects 移除</span>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;    retainedRef.retainedUptimeMillis = clock.uptimeMillis()    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;  &#125;&#125;</code></pre></div><h3 id="检测-Activity-泄漏"><a href="#检测-Activity-泄漏" class="headerlink" title="检测 Activity 泄漏"></a>检测 <code>Activity</code> 泄漏</h3><p>通过 <code>ActivityLifecycleCallbacks.onActivityDestroyed</code> 可以收集到 destoryed <code>Activity</code>，这些 <code>Activity</code> 已走完它的生命周期，应该被后续的 GC 回收掉</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 收集 destroyed Activity</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityWatcher</span>(  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;        reachabilityWatcher.expectWeaklyReachable(          activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span>        )      &#125;    &#125;&#125;</code></pre></div><h3 id="检测-Fragment-和-View-的泄漏"><a href="#检测-Fragment-和-View-的泄漏" class="headerlink" title="检测 Fragment 和 View 的泄漏"></a>检测 <code>Fragment</code> 和 <code>View</code> 的泄漏</h3><p>利用 <code>FragmentLifecycleCallbacks</code> 发现被 destroyed <code>Fragment</code> 和 <code>View</code>，然后用 <code>ObjectWatcher</code> 监控是否发生泄漏</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidXFragmentDestroyWatcher</span>(  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;    <span class="hljs-comment">// 发现 View</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;      <span class="hljs-keyword">val</span> view = fragment.view      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;        reachabilityWatcher.expectWeaklyReachable(          view, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +          <span class="hljs-string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span>        )      &#125;    &#125;    <span class="hljs-comment">// 发现 Fragment</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;      reachabilityWatcher.expectWeaklyReachable(        fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span>      )    &#125;  &#125;&#125;</code></pre></div><h3 id="检测-ViewModel-泄漏"><a href="#检测-ViewModel-泄漏" class="headerlink" title="检测 ViewModel 泄漏"></a>检测 <code>ViewModel</code> 泄漏</h3><p><code>Fragment</code> 里的 <code>ViewModel</code> 则是在 <code>FragmentLifecycleCallbacks.onFragmentCreated</code> 时，注入一个 <code>ViewModel</code>，通过反射拿到 <code>ViewModelStore.mMap</code>，这里有所有的 <code>ViewModel</code>，在 <code>ViewModel.onCleared</code> 时把它们加入 <code>ObjectWatcher</code> 进行泄漏检查</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModelClearedWatcher</span>(  storeOwner: ViewModelStoreOwner,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : ViewModel() &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;?  <span class="hljs-keyword">init</span> &#123;    <span class="hljs-comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span>    <span class="hljs-comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span>    <span class="hljs-comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span>    viewModelMap = <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">val</span> mMapField = ViewModelStore::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)      mMapField.isAccessible = <span class="hljs-literal">true</span>      <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span>      mMapField[storeOwner.viewModelStore] <span class="hljs-keyword">as</span> Map&lt;String, ViewModel&gt;    &#125; <span class="hljs-keyword">catch</span> (ignored: Exception) &#123;      <span class="hljs-literal">null</span>    &#125;  &#125;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> &#123;    viewModelMap?.values?.forEach &#123; viewModel -&gt;      reachabilityWatcher.expectWeaklyReachable(        viewModel, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span>      )    &#125;  &#125;  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">      storeOwner: <span class="hljs-type">ViewModelStoreOwner</span>,</span></span><span class="hljs-params"><span class="hljs-function">      reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span></span></span><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;      <span class="hljs-keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="hljs-keyword">object</span> : Factory &#123;        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel?&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T =          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="hljs-keyword">as</span> T      &#125;)      provider.<span class="hljs-keyword">get</span>(ViewModelClearedWatcher::<span class="hljs-keyword">class</span>.java)    &#125;  &#125;&#125;</code></pre></div><h3 id="检测更多类型的泄漏"><a href="#检测更多类型的泄漏" class="headerlink" title="检测更多类型的泄漏"></a>检测更多类型的泄漏</h3><p>对 <code>Service</code> 的检查就比较 hack 了，通过反射替换 <code>ActivityThread.mH.mCallback</code>，通过 <code>Message.waht == H.STOP_SERVICE</code> 定位到 <code>ActivityThread.handleStopService</code> 的调用时机，然后把这个被 stop 的 <code>Service</code> 记录下来；用动态代理实现 <code>IActivityManager</code> 并替换掉 <code>ActivityManager.IActivityManagerSinglteon.mInstance</code>，从而拦截方法 <code>serviceDoneExecuting</code>，此方法的调用表示 <code>Service</code> 生命周期已完结，可以把它交由 <code>ObjectWatcher</code> 进行监控</p><p>这给我启示，对于我们感兴趣的对象（需要警惕泄漏的对象，比如 <code>Bitmap</code>），都可以通过 <code>ObjectWatcher</code> 去检测泄漏问题</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> : <span class="hljs-type">Service</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">super</span>.onDestroy()    AppWatcher.objectWatcher.watch(      watchedObject = <span class="hljs-keyword">this</span>,      description = <span class="hljs-string">&quot;MyService received Service#onDestroy() callback&quot;</span>    )  &#125;&#125;</code></pre></div><h2 id="Heap-Dump"><a href="#Heap-Dump" class="headerlink" title="Heap Dump"></a>Heap Dump</h2><p>发现对象泄漏后触发 <code>OnObjectRetainedListener.onObjectRetained()</code>，最终调用 <code>Debug.dumpHprofData</code> 生成 hprof 文件</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onObjectRetained</span><span class="hljs-params">()</span></span> = scheduleRetainedObjectCheck()  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::heapDumpTrigger.isInitialized) &#123;      heapDumpTrigger.scheduleRetainedObjectCheck()    &#125;  &#125;  &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapDumpTrigger</span> &#123;  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L</span></span><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;    <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt    <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span>    &#125;    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis    backgroundHandler.postDelayed(&#123;      checkScheduledAt = <span class="hljs-number">0</span>      checkRetainedObjects()    &#125;, delayMillis)  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// ...</span>    dumpHeap(      retainedReferenceCount = retainedReferenceCount,      retry = <span class="hljs-literal">true</span>,      reason = <span class="hljs-string">&quot;<span class="hljs-variable">$retainedReferenceCount</span> retained objects, app is <span class="hljs-variable">$visibility</span>&quot;</span>    )  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">    retainedReferenceCount: <span class="hljs-type">Int</span>,</span></span><span class="hljs-params"><span class="hljs-function">    retry: <span class="hljs-type">Boolean</span>,</span></span><span class="hljs-params"><span class="hljs-function">    reason: <span class="hljs-type">String</span></span></span><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;    saveResourceIdNamesToMemory()    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapDumpResult = heapDumper.dumpHeap()) &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;    &#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidHeapDumper</span> &#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">()</span></span>: DumpHeapResult &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">val</span> durationMillis = measureDurationMillis &#123;      Debug.dumpHprofData(heapDumpFile.absolutePath)    &#125;    <span class="hljs-comment">// ...  </span>  &#125;&#125;</code></pre></div><h2 id="解析-hprof-文件"><a href="#解析-hprof-文件" class="headerlink" title="解析 hprof 文件"></a>解析 hprof 文件</h2><h3 id="hprof-文件格式"><a href="#hprof-文件格式" class="headerlink" title="hprof 文件格式"></a>hprof 文件格式</h3><p><img src="../../../../image/2021-04-12-leakcanary/java_hprof.png" alt="Java Hprof 格式"></p><p><img src="../../../../image/2021-04-12-leakcanary/android_hprof.png" alt="Android Hprof 格式"></p><p>hprof 是结构紧凑的二进制文件，整体上分为 <code>Header</code> 和 <code>Record</code> 数组两大部分</p><p><code>Header</code> 总共 18 + 4 + 4 + 4 = 32 字节，包括：</p><ol><li>格式名和版本号：JAVA PROFILE 1.0.3（18 字节）</li><li>标识符大小（4 字节）</li><li>高位时间戳（4 字节）</li><li>地位时间戳（4 字节）</li></ol><p><img src="../../../../image/2021-04-12-leakcanary/hprof_header.png" alt="Hprof Header 结构"></p><p><code>Record</code> 数组记录了内存中的各种数据</p><ol><li>TAG，<code>Record</code> 的类型（1 字节）</li><li>TIME，时间戳（4 字节）</li><li>LENGTH，<code>Record</code> BODY 的长度（4 字节）</li><li>BODY，不同的 <code>Record</code> 类型有不同的 BODY</li></ol><p><img src="../../../../image/2021-04-12-leakcanary/hprof_record.png" alt="Hprof Record 结构"></p><p>支持的 <code>TAG</code> 类型主要有：</p><ul><li>STRING_IN_UTF8             = 0x01</li><li>LOAD_CLASS                 = 0x02</li><li>STACK_FRAME                = 0x04</li><li>STACK_TRACE                = 0x05</li><li><strong>HEAP_DUMP</strong>              = 0x0c</li><li><strong>HEAP_DUMP_SEGMENT</strong>      = 0x1c<ul><li>ROOT_UNKNOWN             = 0xff</li><li>ROOT_JNI_GLOBAL          = 0x01</li><li>ROOT_JNI_LOCAL           = 0x02</li><li>ROOT_JAVA_FRAME          = 0x03</li><li><strong>CLASS_DUMP</strong>           = 0x20</li><li><strong>INSTANCE_DUMP</strong>        = 0x21</li><li><strong>OBJECT_ARRAY_DUMP</strong>    = 0x22</li><li><strong>PRIMITIVE_ARRAY_DUMP</strong> = 0x23</li></ul></li><li>HEAP_DUMP_END              = 0x2c</li></ul><p><code>CLASS_DUMP</code>、<code>INSTANCE_DUMP</code> 等重要结构可以看 <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF Agent</a></p><h3 id="解析-Header"><a href="#解析-Header" class="headerlink" title="解析 Header"></a>解析 Header</h3><p>拿到 hprof 文件后，从 <code>HeapAnalyzerService.runAnalysis</code> 开始解析流程</p><p><code>LeakCanary</code> 使用 <code>Shark</code> 解析 hprof 文件，首先解析出头部 <code>HprofHeader</code></p><div class="code-wrapper"><pre><code class="hljs kotlin">HeapAnalyzerService.runAnalysisHeapAnalyzerService.onHandleIntentInForegroundHeapAnalyzerService.analyzeHeapHeapAnalyzer.analyze<span class="hljs-function"><span class="hljs-keyword">fun</span> DualSourceProvider.<span class="hljs-title">openHeapGraph</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><span class="hljs-params"><span class="hljs-function">  indexedGcRootTypes: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = HprofIndex.defaultIndexedGcRootTags()</span></span>): CloseableHeapGraph &#123;  <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 解析出 HprofHeader</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseHeaderOf</span><span class="hljs-params">(source: <span class="hljs-type">BufferedSource</span>)</span></span>: HprofHeader &#123;  require(!source.exhausted()) &#123;    <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Source has no available bytes&quot;</span>)  &#125;  <span class="hljs-comment">// 开头是版本号 JAVA PROFILE 1.0.3，以 0 结尾</span>  <span class="hljs-keyword">val</span> endOfVersionString = source.indexOf(<span class="hljs-number">0</span>)  <span class="hljs-keyword">val</span> versionName = source.readUtf8(endOfVersionString)  <span class="hljs-keyword">val</span> version = supportedVersions[versionName]  checkNotNull(version) &#123;    <span class="hljs-string">&quot;Unsupported Hprof version [<span class="hljs-variable">$versionName</span>] not in supported list <span class="hljs-subst">$&#123;supportedVersions.keys&#125;</span>&quot;</span>  &#125;  <span class="hljs-comment">// Skip the 0 at the end of the version string.</span>  source.skip(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 然后是 ID 的长度</span>  <span class="hljs-keyword">val</span> identifierByteSize = source.readInt()  <span class="hljs-comment">// 时间戳</span>  <span class="hljs-keyword">val</span> heapDumpTimestamp = source.readLong()  <span class="hljs-keyword">return</span> HprofHeader(heapDumpTimestamp, version, identifierByteSize)&#125;</code></pre></div><h3 id="构造索引-HprofIndex"><a href="#构造索引-HprofIndex" class="headerlink" title="构造索引 HprofIndex"></a>构造索引 <code>HprofIndex</code></h3><p>从 <code>openHeapGraph</code> 里构造完 <code>HprofHeader</code> 后，开始解析 <code>HprofIndex</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> DualSourceProvider.<span class="hljs-title">openHeapGraph</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><span class="hljs-params"><span class="hljs-function">  indexedGcRootTypes: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = HprofIndex.defaultIndexedGcRootTags()</span></span>): CloseableHeapGraph &#123;  <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;  <span class="hljs-keyword">val</span> index = HprofIndex.indexRecordsOf(<span class="hljs-keyword">this</span>, header, proguardMapping, indexedGcRootTypes)  <span class="hljs-keyword">return</span> index.openHeapGraph()&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Creates an in memory index of an hprof source provided by [hprofSourceProvider].</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexRecordsOf</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  hprofSourceProvider: <span class="hljs-type">DualSourceProvider</span>,</span></span><span class="hljs-params"><span class="hljs-function">  hprofHeader: <span class="hljs-type">HprofHeader</span>,</span></span><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><span class="hljs-params"><span class="hljs-function">  indexedGcRootTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = defaultIndexedGcRootTags()</span></span>): HprofIndex &#123;  <span class="hljs-keyword">val</span> reader = StreamingHprofReader.readerFor(hprofSourceProvider, hprofHeader)  <span class="hljs-keyword">val</span> index = HprofInMemoryIndex.indexHprof(    reader = reader,    hprofHeader = hprofHeader,    proguardMapping = proguardMapping,    indexedGcRootTags = indexedGcRootTags  )  <span class="hljs-keyword">return</span> HprofIndex(hprofSourceProvider, hprofHeader, index)&#125;</code></pre></div><p>对象之所以会泄漏，是因为它被 GC ROOT 持有超过它的生命周期，所以分析 hprof 文件的首要目标是找出泄漏对象的 GC ROOT PATH；虽然 hprof 包含方方面面的信息，我们只关注需要的那几部分：<code>STRING_IN_UTF8</code>、<code>CLASS_DUMP</code>、<code>INSTANCE_DUMP</code>、<code>GC ROOT</code> 等等，其他的都不需要；而且 hprof 包含的数据非常多，全部加载到内存很容易发生 OOM</p><p>这个阶段的 <code>HprofInMemoryIndex</code> 主要包含以下信息</p><ul><li><code>hprofStringCache</code> 字符串池，string id -&gt; String，对应 TAG <code>STRING_IN_UTF8</code>，用来查找类名</li><li><code>classNames</code> 类名称池，class id -&gt; string id，对应 TAG <code>LOAD_CLASS</code>，通过类名 <code>leakcanary.KeyedWeakReference</code> 找到泄漏对象</li><li><code>gcRoots</code> GC ROOT 对象 id 数组</li></ul><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HprofInMemoryIndex</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> positionSize: <span class="hljs-built_in">Int</span>,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> hprofStringCache: LongObjectScatterMap&lt;String&gt;,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> classNames: LongLongScatterMap,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> classIndex: SortedBytesMap,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> instanceIndex: SortedBytesMap,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectArrayIndex: SortedBytesMap,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> primitiveArrayIndex: SortedBytesMap,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gcRoots: List&lt;GcRoot&gt;,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> proguardMapping: ProguardMapping?,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForClassSize: <span class="hljs-built_in">Int</span>,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForInstanceSize: <span class="hljs-built_in">Int</span>,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForObjectArraySize: <span class="hljs-built_in">Int</span>,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> bytesForPrimitiveArraySize: <span class="hljs-built_in">Int</span>,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> useForwardSlashClassPackageSeparator: <span class="hljs-built_in">Boolean</span>,  <span class="hljs-keyword">val</span> classFieldsReader: ClassFieldsReader,  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> classFieldsIndexSize: <span class="hljs-built_in">Int</span>)</code></pre></div><p>参照 <code>Record</code> 的结构读取需要的内容</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexHprof</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  reader: <span class="hljs-type">StreamingHprofReader</span>,</span></span><span class="hljs-params"><span class="hljs-function">  hprofHeader: <span class="hljs-type">HprofHeader</span>,</span></span><span class="hljs-params"><span class="hljs-function">  proguardMapping: <span class="hljs-type">ProguardMapping</span>?,</span></span><span class="hljs-params"><span class="hljs-function">  indexedGcRootTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt;</span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: HprofInMemoryIndex &#123;  <span class="hljs-comment">// 首先过一遍 hprof，计算出 class，instance，object array 和 primitive array 的数量</span>  <span class="hljs-comment">// First pass to count and correctly size arrays once and for all.</span>  <span class="hljs-keyword">var</span> maxClassSize = <span class="hljs-number">0L</span>  <span class="hljs-keyword">var</span> maxInstanceSize = <span class="hljs-number">0L</span>  <span class="hljs-keyword">var</span> maxObjectArraySize = <span class="hljs-number">0L</span>  <span class="hljs-keyword">var</span> maxPrimitiveArraySize = <span class="hljs-number">0L</span>  <span class="hljs-keyword">var</span> classCount = <span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> instanceCount = <span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> objectArrayCount = <span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> primitiveArrayCount = <span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> classFieldsTotalBytes = <span class="hljs-number">0</span>  <span class="hljs-keyword">val</span> bytesRead = reader.readRecords(    EnumSet.of(CLASS_DUMP, INSTANCE_DUMP, OBJECT_ARRAY_DUMP, PRIMITIVE_ARRAY_DUMP),    OnHprofRecordTagListener &#123; tag, _, reader -&gt;      <span class="hljs-keyword">val</span> bytesReadStart = reader.bytesRead      <span class="hljs-keyword">when</span> (tag) &#123;        CLASS_DUMP -&gt; &#123;          classCount++          reader.skipClassDumpHeader()          <span class="hljs-keyword">val</span> bytesReadStaticFieldStart = reader.bytesRead          reader.skipClassDumpStaticFields()          reader.skipClassDumpFields()          maxClassSize = max(maxClassSize, reader.bytesRead - bytesReadStart)          classFieldsTotalBytes += (reader.bytesRead - bytesReadStaticFieldStart).toInt()        &#125;        INSTANCE_DUMP -&gt; &#123;          instanceCount++          reader.skipInstanceDumpRecord()          maxInstanceSize = max(maxInstanceSize, reader.bytesRead - bytesReadStart)        &#125;        OBJECT_ARRAY_DUMP -&gt; &#123;          objectArrayCount++          reader.skipObjectArrayDumpRecord()          maxObjectArraySize = max(maxObjectArraySize, reader.bytesRead - bytesReadStart)        &#125;        PRIMITIVE_ARRAY_DUMP -&gt; &#123;          primitiveArrayCount++          reader.skipPrimitiveArrayDumpRecord()          maxPrimitiveArraySize = max(maxPrimitiveArraySize, reader.bytesRead - bytesReadStart)        &#125;      &#125;    &#125;)  <span class="hljs-comment">// 第二次才读取 string、class、instance 等结构信息  </span>  <span class="hljs-keyword">val</span> bytesForClassSize = byteSizeForUnsigned(maxClassSize)  <span class="hljs-keyword">val</span> bytesForInstanceSize = byteSizeForUnsigned(maxInstanceSize)  <span class="hljs-keyword">val</span> bytesForObjectArraySize = byteSizeForUnsigned(maxObjectArraySize)  <span class="hljs-keyword">val</span> bytesForPrimitiveArraySize = byteSizeForUnsigned(maxPrimitiveArraySize)  <span class="hljs-keyword">val</span> indexBuilderListener = Builder(    longIdentifiers = hprofHeader.identifierByteSize == <span class="hljs-number">8</span>,    maxPosition = bytesRead,    classCount = classCount,    instanceCount = instanceCount,    objectArrayCount = objectArrayCount,    primitiveArrayCount = primitiveArrayCount,    bytesForClassSize = bytesForClassSize,    bytesForInstanceSize = bytesForInstanceSize,    bytesForObjectArraySize = bytesForObjectArraySize,    bytesForPrimitiveArraySize = bytesForPrimitiveArraySize,    classFieldsTotalBytes = classFieldsTotalBytes  )  <span class="hljs-keyword">val</span> recordTypes = EnumSet.of(    STRING_IN_UTF8,    LOAD_CLASS,    CLASS_DUMP,    INSTANCE_DUMP,    OBJECT_ARRAY_DUMP,    PRIMITIVE_ARRAY_DUMP  ) + HprofRecordTag.rootTags.intersect(indexedGcRootTags)  reader.readRecords(recordTypes, indexBuilderListener)  <span class="hljs-keyword">return</span> indexBuilderListener.buildIndex(proguardMapping, hprofHeader)&#125;<span class="hljs-comment">// 类似 SAX 地流式读取各个 Record 结构，然后回调给 listener 处理</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readRecords</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  recordTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt;,</span></span><span class="hljs-params"><span class="hljs-function">  listener: <span class="hljs-type">OnHprofRecordTagListener</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Long</span> &#123;  <span class="hljs-keyword">return</span> sourceProvider.openStreamingSource().use &#123; source -&gt;    <span class="hljs-keyword">val</span> reader = HprofRecordReader(header, source)    reader.skip(header.recordsPosition)    <span class="hljs-comment">// Local ref optimizations</span>    <span class="hljs-keyword">val</span> intByteSize = INT.byteSize    <span class="hljs-keyword">val</span> identifierByteSize = reader.sizeOf(REFERENCE_HPROF_TYPE)    <span class="hljs-keyword">while</span> (!source.exhausted()) &#123;      <span class="hljs-comment">// type of the record</span>      <span class="hljs-keyword">val</span> tag = reader.readUnsignedByte()      <span class="hljs-comment">// number of microseconds since the time stamp in the header</span>      reader.skip(intByteSize)      <span class="hljs-comment">// number of bytes that follow and belong to this record</span>      <span class="hljs-keyword">val</span> length = reader.readUnsignedInt()      <span class="hljs-keyword">when</span> (tag) &#123;        STRING_IN_UTF8.tag -&gt; &#123;          <span class="hljs-keyword">if</span> (STRING_IN_UTF8 <span class="hljs-keyword">in</span> recordTags) &#123;            listener.onHprofRecord(STRING_IN_UTF8, length, reader)          &#125; <span class="hljs-keyword">else</span> &#123;            reader.skip(length)          &#125;        &#125;        LOAD_CLASS.tag -&gt; &#123;          <span class="hljs-keyword">if</span> (LOAD_CLASS <span class="hljs-keyword">in</span> recordTags) &#123;            listener.onHprofRecord(LOAD_CLASS, length, reader)          &#125; <span class="hljs-keyword">else</span> &#123;            reader.skip(length)          &#125;        &#125;        STACK_FRAME.tag -&gt; &#123;          <span class="hljs-keyword">if</span> (STACK_FRAME <span class="hljs-keyword">in</span> recordTags) &#123;            listener.onHprofRecord(STACK_FRAME, length, reader)          &#125; <span class="hljs-keyword">else</span> &#123;            reader.skip(length)          &#125;        &#125;        STACK_TRACE.tag -&gt; &#123;          <span class="hljs-keyword">if</span> (STACK_TRACE <span class="hljs-keyword">in</span> recordTags) &#123;            listener.onHprofRecord(STACK_TRACE, length, reader)          &#125; <span class="hljs-keyword">else</span> &#123;            reader.skip(length)          &#125;        &#125;        HEAP_DUMP.tag, HEAP_DUMP_SEGMENT.tag -&gt; &#123;          <span class="hljs-keyword">val</span> heapDumpStart = reader.bytesRead          <span class="hljs-keyword">var</span> previousTag = <span class="hljs-number">0</span>          <span class="hljs-keyword">var</span> previousTagPosition = <span class="hljs-number">0L</span>          <span class="hljs-keyword">while</span> (reader.bytesRead - heapDumpStart &lt; length) &#123;            <span class="hljs-keyword">val</span> heapDumpTagPosition = reader.bytesRead            <span class="hljs-keyword">val</span> heapDumpTag = reader.readUnsignedByte()            <span class="hljs-keyword">when</span> (heapDumpTag) &#123;              ROOT_UNKNOWN.tag -&gt; &#123;                <span class="hljs-keyword">if</span> (ROOT_UNKNOWN <span class="hljs-keyword">in</span> recordTags) &#123;                  listener.onHprofRecord(ROOT_UNKNOWN, -<span class="hljs-number">1</span>, reader)                &#125; <span class="hljs-keyword">else</span> &#123;                  reader.skip(identifierByteSize)                &#125;              &#125;              ROOT_JNI_GLOBAL.tag -&gt; &#123;                <span class="hljs-keyword">if</span> (ROOT_JNI_GLOBAL <span class="hljs-keyword">in</span> recordTags) &#123;                  listener.onHprofRecord(ROOT_JNI_GLOBAL, -<span class="hljs-number">1</span>, reader)                &#125; <span class="hljs-keyword">else</span> &#123;                  reader.skip(identifierByteSize + identifierByteSize)                &#125;              &#125;              ROOT_JNI_LOCAL.tag -&gt; &#123;                <span class="hljs-keyword">if</span> (ROOT_JNI_LOCAL <span class="hljs-keyword">in</span> recordTags) &#123;                  listener.onHprofRecord(ROOT_JNI_LOCAL, -<span class="hljs-number">1</span>, reader)                &#125; <span class="hljs-keyword">else</span> &#123;                  reader.skip(identifierByteSize + intByteSize + intByteSize)                &#125;              &#125;              ROOT_JAVA_FRAME.tag -&gt; &#123;                <span class="hljs-keyword">if</span> (ROOT_JAVA_FRAME <span class="hljs-keyword">in</span> recordTags) &#123;                  listener.onHprofRecord(ROOT_JAVA_FRAME, -<span class="hljs-number">1</span>, reader)                &#125; <span class="hljs-keyword">else</span> &#123;                  reader.skip(identifierByteSize + intByteSize + intByteSize)                &#125;              &#125;              <span class="hljs-comment">// ...</span>            &#125;            previousTag = heapDumpTag            previousTagPosition = heapDumpTagPosition          &#125;        &#125;        HEAP_DUMP_END.tag -&gt; &#123;          <span class="hljs-keyword">if</span> (HEAP_DUMP_END <span class="hljs-keyword">in</span> recordTags) &#123;            listener.onHprofRecord(HEAP_DUMP_END, length, reader)          &#125;        &#125;        <span class="hljs-keyword">else</span> -&gt; &#123;          reader.skip(length)        &#125;      &#125;    &#125;    reader.bytesRead  &#125;&#125;</code></pre></div><h3 id="查找泄漏对象"><a href="#查找泄漏对象" class="headerlink" title="查找泄漏对象"></a>查找泄漏对象</h3><p>泄漏对象被 <code>KeyedWeakReference</code> 弱引用并保存在 <code>ObjectWatcher.watchedObjects</code>，那么通过全限定类名 <code>leakcanary.KeyedWeakReference&quot;</code>/ <code>com.squareup.leakcanary.KeyedWeakReference</code> 找到 class id，通过 class id 找到 instance Record，在 instance Record 里找到名为 <code>referent</code> 的成员变量值，这个值就是泄漏对象的 instance id，最终会产生一个泄漏对象 instance id 数组 <code>leakingObjectIds</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> HeapAnalyzer.<span class="hljs-title">analyze</span><span class="hljs-params">(...)</span></span>: HeapAnalysis &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-keyword">val</span> sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))  sourceProvider.openHeapGraph(proguardMapping).use &#123; graph -&gt;    <span class="hljs-keyword">val</span> helpers =      FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)    <span class="hljs-keyword">val</span> result = helpers.analyzeGraph(      metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime    )    <span class="hljs-comment">// ...</span>  &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">analyzeGraph</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  metadataExtractor: <span class="hljs-type">MetadataExtractor</span>,</span></span><span class="hljs-params"><span class="hljs-function">  leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,</span></span><span class="hljs-params"><span class="hljs-function">  heapDumpFile: <span class="hljs-type">File</span>,</span></span><span class="hljs-params"><span class="hljs-function">  analysisStartNanoTime: <span class="hljs-type">Long</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: HeapAnalysisSuccess &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-keyword">val</span> leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks, unreachableObjects) = findLeaks(leakingObjectIds)  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">object</span> KeyedWeakReferenceFinder : LeakingObjectFinder &#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findLeakingObjectIds</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: Set&lt;<span class="hljs-built_in">Long</span>&gt; =    findKeyedWeakReferences(graph)      .filter &#123; it.hasReferent &amp;&amp; it.isRetained &#125;      .map &#123; it.referent.value &#125;      .toSet()  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findKeyedWeakReferences</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: List&lt;KeyedWeakReferenceMirror&gt; &#123;    <span class="hljs-keyword">return</span> graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) &#123;      <span class="hljs-keyword">val</span> keyedWeakReferenceClass = graph.findClassByName(<span class="hljs-string">&quot;leakcanary.KeyedWeakReference&quot;</span>)      <span class="hljs-keyword">val</span> keyedWeakReferenceClassId = keyedWeakReferenceClass?.objectId ?: <span class="hljs-number">0</span>      <span class="hljs-keyword">val</span> legacyKeyedWeakReferenceClassId =        graph.findClassByName(<span class="hljs-string">&quot;com.squareup.leakcanary.KeyedWeakReference&quot;</span>)?.objectId ?: <span class="hljs-number">0</span>      <span class="hljs-keyword">val</span> heapDumpUptimeMillis = heapDumpUptimeMillis(graph)      <span class="hljs-keyword">val</span> addedToContext: List&lt;KeyedWeakReferenceMirror&gt; = graph.instances        .filter &#123; instance -&gt;          instance.instanceClassId == keyedWeakReferenceClassId || instance.instanceClassId == legacyKeyedWeakReferenceClassId        &#125;        .map &#123;          KeyedWeakReferenceMirror.fromInstance(            it, heapDumpUptimeMillis          )        &#125;        .toList()      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext      addedToContext    &#125;  &#125;&#125;</code></pre></div><p>从逻辑上看引用关系是个图，图中的节点有个指向父节点的指针 <code>Node.parent</code>，而 GC ROOT 就是图中的根节点，它们没有 <code>parent</code>，GC ROOT 包括以下几类：</p><ol><li><code>ROOT UNKNOWN</code></li><li><code>ROOT JNI GLOBAL</code></li><li><code>ROOT JNI LOCAL</code></li><li><code>ROOT JAVA FRAME</code></li><li><code>ROOT NATIVE STACK</code></li><li><code>ROOT STICKY CLASS</code></li><li><code>ROOT THREAD BLOCK</code></li><li><code>ROOT MONITOR USED</code></li><li><code>ROOT THREAD OBJECT</code></li></ol><p>GC ROOT 的成员变量作为子节点，<code>parent</code> 指向 GC ROOT，成员变量还有成员变量作为子节点，这样就形成了一个很大的图</p><p>为了构造上面的引用图以及它们的引用关系，我们使用 <code>Stack</code> 来遍历找到的 <code>Record</code>，首先把 GC ROOT 都入栈，然后依次出栈执行：找到非空的成员变量并加入栈中（此时能够建立 parent - child 二级关系），如果 instance id == leakingObjectId 则记录起来，直到栈空或者已找完所有的泄漏对象；每一层二级关系的建立最终使所有关联的节点连接起来形成图，这样就可以沿着 <code>Node.parent</code> 一直往上走到 GC ROOT，这样泄漏对象的 GC ROOT PATH 就出来了</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: LeaksAndUnreachableObjects &#123;  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)  <span class="hljs-keyword">val</span> pathFindingResults =    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;,</span></span><span class="hljs-params"><span class="hljs-function">  computeRetainedHeapSize: <span class="hljs-type">Boolean</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: PathFindingResults &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-keyword">val</span> state = State(    leakingObjectIds = leakingObjectIds.toLongScatterSet(),    sizeOfObjectInstances = sizeOfObjectInstances,    computeRetainedHeapSize = computeRetainedHeapSize,    javaLangObjectId = javaLangObjectId,    estimatedVisitedObjects = estimatedVisitedObjects  )  <span class="hljs-keyword">return</span> state.findPathsFromGcRoots()&#125;<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> State.<span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">()</span></span>: PathFindingResults &#123;  <span class="hljs-comment">// 首先将 GC ROOT 入队</span>  enqueueGcRoots()  <span class="hljs-keyword">val</span> shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()  <span class="hljs-symbol">visitingQueue@</span> <span class="hljs-keyword">while</span> (queuesNotEmpty) &#123;    <span class="hljs-keyword">val</span> node = poll()    <span class="hljs-keyword">if</span> (leakingObjectIds.contains(node.objectId)) &#123;      shortestPathsToLeakingObjects.add(node)      <span class="hljs-comment">// Found all refs, stop searching (unless computing retained size)</span>      <span class="hljs-keyword">if</span> (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) &#123;        <span class="hljs-keyword">if</span> (computeRetainedHeapSize) &#123;          listener.onAnalysisProgress(FINDING_DOMINATORS)        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">break</span><span class="hljs-symbol">@visitingQueue</span>        &#125;      &#125;    &#125;    <span class="hljs-comment">// 找到子节点（类的静态成员变量、实例的成员变量等等）</span>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapObject = graph.findObjectById(node.objectId)) &#123;      <span class="hljs-keyword">is</span> HeapClass -&gt; visitClassRecord(heapObject, node)      <span class="hljs-keyword">is</span> HeapInstance -&gt; visitInstance(heapObject, node)      <span class="hljs-keyword">is</span> HeapObjectArray -&gt; visitObjectArray(heapObject, node)    &#125;  &#125;  <span class="hljs-keyword">return</span> PathFindingResults(    shortestPathsToLeakingObjects,    <span class="hljs-keyword">if</span> (visitTracker <span class="hljs-keyword">is</span> Dominated) visitTracker.dominatorTree <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>  )&#125;</code></pre></div><p>上面找到了所有泄漏对象的 GC ROOT PATH，但可能出现重复，这里利用前缀树删除重复路径；前缀树节点 <code>Node</code> 用 <code>Map&lt;Long, Node&gt;</code> 表示它引用了某个对象，叶子节点就是泄漏对象，最后广度优先遍历前缀树，将每个叶子节点及其路径记下来</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: LeaksAndUnreachableObjects &#123;  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)  <span class="hljs-keyword">val</span> pathFindingResults =    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)  <span class="hljs-keyword">val</span> unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)  <span class="hljs-keyword">val</span> shortestPaths =    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 利用前缀树删除重复路径</span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deduplicateShortestPaths</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">   inputPathResults: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferencePathNode</span>&gt;</span></span><span class="hljs-params"><span class="hljs-function"> )</span></span>: List&lt;ShortestPath&gt; &#123;   <span class="hljs-keyword">val</span> rootTrieNode = ParentNode(<span class="hljs-number">0</span>)   inputPathResults.forEach &#123; pathNode -&gt;     <span class="hljs-comment">// Go through the linked list of nodes and build the reverse list of instances from</span>     <span class="hljs-comment">// root to leaking.</span>     <span class="hljs-keyword">val</span> path = mutableListOf&lt;<span class="hljs-built_in">Long</span>&gt;()     <span class="hljs-keyword">var</span> leakNode: ReferencePathNode = pathNode     <span class="hljs-keyword">while</span> (leakNode <span class="hljs-keyword">is</span> ChildNode) &#123;       path.add(<span class="hljs-number">0</span>, leakNode.objectId)       leakNode = leakNode.parent     &#125;     path.add(<span class="hljs-number">0</span>, leakNode.objectId)     updateTrie(pathNode, path, <span class="hljs-number">0</span>, rootTrieNode)   &#125;   <span class="hljs-keyword">val</span> outputPathResults = mutableListOf&lt;ReferencePathNode&gt;()   findResultsInTrie(rootTrieNode, outputPathResults)   <span class="hljs-keyword">if</span> (outputPathResults.size != inputPathResults.size) &#123;     SharkLog.d &#123;       <span class="hljs-string">&quot;Found <span class="hljs-subst">$&#123;inputPathResults.size&#125;</span> paths to retained objects,&quot;</span> +         <span class="hljs-string">&quot; down to <span class="hljs-subst">$&#123;outputPathResults.size&#125;</span> after removing duplicated paths&quot;</span>     &#125;   &#125; <span class="hljs-keyword">else</span> &#123;     SharkLog.d &#123; <span class="hljs-string">&quot;Found <span class="hljs-subst">$&#123;outputPathResults.size&#125;</span> paths to retained objects&quot;</span> &#125;   &#125;   <span class="hljs-keyword">return</span> outputPathResults.map &#123; retainedObjectNode -&gt;     <span class="hljs-keyword">val</span> shortestChildPath = mutableListOf&lt;ChildNode&gt;()     <span class="hljs-keyword">var</span> node = retainedObjectNode     <span class="hljs-keyword">while</span> (node <span class="hljs-keyword">is</span> ChildNode) &#123;       shortestChildPath.add(<span class="hljs-number">0</span>, node)       node = node.parent     &#125;     <span class="hljs-keyword">val</span> rootNode = node <span class="hljs-keyword">as</span> RootNode     ShortestPath(rootNode, shortestChildPath)   &#125; &#125;<span class="hljs-comment">// 将一个 GC ROOT PATH 添加到前缀树</span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateTrie</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  pathNode: <span class="hljs-type">ReferencePathNode</span>,</span></span><span class="hljs-params"><span class="hljs-function">  path: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Long</span>&gt;,</span></span><span class="hljs-params"><span class="hljs-function">  pathIndex: <span class="hljs-type">Int</span>,</span></span><span class="hljs-params"><span class="hljs-function">  parentNode: <span class="hljs-type">ParentNode</span></span></span><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;  <span class="hljs-keyword">val</span> objectId = path[pathIndex]  <span class="hljs-keyword">if</span> (pathIndex == path.lastIndex) &#123;    parentNode.children[objectId] = LeafNode(objectId, pathNode)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">val</span> childNode = parentNode.children[objectId] ?: &#123;      <span class="hljs-keyword">val</span> newChildNode = ParentNode(objectId)      parentNode.children[objectId] = newChildNode      newChildNode    &#125;()    <span class="hljs-keyword">if</span> (childNode <span class="hljs-keyword">is</span> ParentNode) &#123;      updateTrie(pathNode, path, pathIndex + <span class="hljs-number">1</span>, childNode)    &#125;  &#125;&#125;</code></pre></div><p>到此 GC ROOT PATH 已找到，最后再封装为 <code>LeakTrace</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: LeaksAndUnreachableObjects &#123;  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)  <span class="hljs-keyword">val</span> pathFindingResults =    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)  <span class="hljs-keyword">val</span> unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)  <span class="hljs-keyword">val</span> shortestPaths =    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)  <span class="hljs-keyword">val</span> inspectedObjectsByPath = inspectObjects(shortestPaths)  <span class="hljs-keyword">val</span> retainedSizes =    <span class="hljs-keyword">if</span> (pathFindingResults.dominatorTree != <span class="hljs-literal">null</span>) &#123;      computeRetainedSizes(inspectedObjectsByPath, pathFindingResults.dominatorTree)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-literal">null</span>    &#125;  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks) = buildLeakTraces(    shortestPaths, inspectedObjectsByPath, retainedSizes  )  <span class="hljs-keyword">return</span> LeaksAndUnreachableObjects(applicationLeaks, libraryLeaks, unreachableObjects)&#125;<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">buildLeakTraces</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">  shortestPaths: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ShortestPath</span>&gt;,</span></span><span class="hljs-params"><span class="hljs-function">  inspectedObjectsByPath: <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">InspectedObject</span>&gt;&gt;,</span></span><span class="hljs-params"><span class="hljs-function">  retainedSizes: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Long</span>, Pair&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt;&gt;?</span></span><span class="hljs-params"><span class="hljs-function">)</span></span>: Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;  listener.onAnalysisProgress(BUILDING_LEAK_TRACES)  <span class="hljs-keyword">val</span> applicationLeaksMap = mutableMapOf&lt;String, MutableList&lt;LeakTrace&gt;&gt;()  <span class="hljs-keyword">val</span> libraryLeaksMap =    mutableMapOf&lt;String, Pair&lt;LibraryLeakReferenceMatcher, MutableList&lt;LeakTrace&gt;&gt;&gt;()  shortestPaths.forEachIndexed &#123; pathIndex, shortestPath -&gt;    <span class="hljs-keyword">val</span> inspectedObjects = inspectedObjectsByPath[pathIndex]    <span class="hljs-keyword">val</span> leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)    <span class="hljs-keyword">val</span> referencePath = buildReferencePath(shortestPath.childPath, leakTraceObjects)    <span class="hljs-keyword">val</span> leakTrace = LeakTrace(      gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot), <span class="hljs-comment">// 第一个元素是 GC ROOT</span>      referencePath = referencePath,                                <span class="hljs-comment">// GC ROOT PATH</span>      leakingObject = leakTraceObjects.last()                       <span class="hljs-comment">// leaking object</span>    )    <span class="hljs-keyword">val</span> firstLibraryLeakNode = <span class="hljs-keyword">if</span> (shortestPath.root <span class="hljs-keyword">is</span> LibraryLeakNode) &#123;      shortestPath.root    &#125; <span class="hljs-keyword">else</span> &#123;      shortestPath.childPath.firstOrNull &#123; it <span class="hljs-keyword">is</span> LibraryLeakNode &#125; <span class="hljs-keyword">as</span> LibraryLeakNode?    &#125;    <span class="hljs-keyword">if</span> (firstLibraryLeakNode != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">val</span> matcher = firstLibraryLeakNode.matcher      <span class="hljs-keyword">val</span> signature: String = matcher.pattern.toString()        .createSHA1Hash()      libraryLeaksMap.getOrPut(signature) &#123; matcher to mutableListOf() &#125;        .second += leakTrace    &#125; <span class="hljs-keyword">else</span> &#123;      applicationLeaksMap.getOrPut(leakTrace.signature) &#123; mutableListOf() &#125; += leakTrace    &#125;  &#125;  <span class="hljs-keyword">val</span> applicationLeaks = applicationLeaksMap.map &#123; (_, leakTraces) -&gt;    ApplicationLeak(leakTraces)  &#125;  <span class="hljs-keyword">val</span> libraryLeaks = libraryLeaksMap.map &#123; (_, pair) -&gt;    <span class="hljs-keyword">val</span> (matcher, leakTraces) = pair    LibraryLeak(leakTraces, matcher.pattern, matcher.description)  &#125;  <span class="hljs-keyword">return</span> applicationLeaks to libraryLeaks&#125;</code></pre></div><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="为什么不需要手动初始化？"><a href="#为什么不需要手动初始化？" class="headerlink" title="为什么不需要手动初始化？"></a>为什么不需要手动初始化？</h3><p><code>LeakCanary</code> 把初始化代码放在 <code>ContentProvider.onCreate()</code> 里（具体是 <code>AppWatcherInstaller</code>），而 <code>ContentProvider.onCreate()</code> 会早于 <code>Application.onCreate</code> 被调用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ContentProvider.onCreate 会早于 Application.onCreate</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ActivityThread.handleBindApplication(AppBindData data) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// If the app is being launched for full backup or restore, bring it up in</span>    <span class="hljs-comment">// a restricted environment with the base application class.</span>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// Propagate autofill compat state</span>    app.setAutofillOptions(data.autofillOptions);    <span class="hljs-comment">// Propagate Content Capture options</span>    app.setContentCaptureOptions(data.contentCaptureOptions);    mInitialApplication = app;    <span class="hljs-comment">// don&#x27;t bring up providers in restricted mode; they may depend on the</span>    <span class="hljs-comment">// app&#x27;s custom Application class</span>    <span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;        <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;            installContentProviders(app, data.providers);        &#125;    &#125;    <span class="hljs-comment">// Do this after providers, since instrumentation tests generally start their</span>    <span class="hljs-comment">// test thread at this point, and we don&#x27;t want that racing.</span>    <span class="hljs-keyword">try</span> &#123;        mInstrumentation.onCreate(data.instrumentationArgs);    &#125;    <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(            <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span>            + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);    &#125;    <span class="hljs-keyword">try</span> &#123;        mInstrumentation.callApplicationOnCreate(app);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(              <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()              + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);        &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installContentProviders</span><span class="hljs-params">(</span><span class="hljs-params">        Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;    <span class="hljs-keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (ProviderInfo cpi : providers) &#123;        <span class="hljs-type">ContentProviderHolder</span> <span class="hljs-variable">cph</span> <span class="hljs-operator">=</span> installProvider(context, <span class="hljs-literal">null</span>, cpi,                <span class="hljs-literal">false</span> <span class="hljs-comment">/*noisy*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*noReleaseNeeded*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*stable*/</span>);        <span class="hljs-keyword">if</span> (cph != <span class="hljs-literal">null</span>) &#123;            cph.noReleaseNeeded = <span class="hljs-literal">true</span>;            results.add(cph);        &#125;    &#125;&#125;<span class="hljs-comment">// 实例化 ContentProvider 并调用生命周期函数 onCreate</span><span class="hljs-keyword">private</span> ContentProviderHolder ActivityThread.installProvider(Context context,        ContentProviderHolder holder, ProviderInfo info,        <span class="hljs-type">boolean</span> noisy, <span class="hljs-type">boolean</span> noReleaseNeeded, <span class="hljs-type">boolean</span> stable) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> c.getClassLoader();    <span class="hljs-type">LoadedApk</span> <span class="hljs-variable">packageInfo</span> <span class="hljs-operator">=</span> peekPackageInfo(ai.packageName, <span class="hljs-literal">true</span>);    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// System startup case.</span>        packageInfo = getSystemContext().mPackageInfo;    &#125;    localProvider = packageInfo.getAppFactory()            .instantiateProvider(cl, info.name);    provider = localProvider.getIContentProvider();    <span class="hljs-keyword">if</span> (provider == <span class="hljs-literal">null</span>) &#123;        Slog.e(TAG, <span class="hljs-string">&quot;Failed to instantiate class &quot;</span> +              info.name + <span class="hljs-string">&quot; from sourceDir &quot;</span> +              info.applicationInfo.sourceDir);        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(        TAG, <span class="hljs-string">&quot;Instantiating local provider &quot;</span> + info.name);    <span class="hljs-comment">// XXX Need to create the correct context for this provider.</span>    localProvider.attachInfo(c, info);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ContentProvider.attachInfo(Context context, ProviderInfo info) &#123;    attachInfo(context, info, <span class="hljs-literal">false</span>);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ContentProvider.attachInfo(Context context, ProviderInfo info, <span class="hljs-type">boolean</span> testing) &#123;    <span class="hljs-comment">// ...</span>    ContentProvider.<span class="hljs-built_in">this</span>.onCreate();&#125;</code></pre></div><h3 id="有什么缺点"><a href="#有什么缺点" class="headerlink" title="有什么缺点"></a>有什么缺点</h3><ol><li><code>LeakCanary</code> 是在 app process 内 heap dump 的，期间进程内的其他线程会被挂起直到 heap dump 完成，这会导致 app 无响应，生产环境下是不可接受的</li><li>hprof 文件往往达到 400M / 500M 这个量级，客户端存储是个问题</li><li>hprof 文件要回传给服务器分析，但是文件太大网络消耗也有很大问题</li><li>如果是在客户端分析 hprof 文件，由于文件太大导致分析进程在很多情况下自己也 OOM 了</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://leo-wxy.github.io/2020/12/14/Hprof%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">Hprof文件解析</a></li><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF Agent</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>LeakCanary</tag>
      
      <tag>内存优化，OOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 的一些知识点</title>
    <link href="/2021/04/05/hashmap/"/>
    <url>/2021/04/05/hashmap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap-的桶由链表变为红黑树（树化）的过程"><a href="#HashMap-的桶由链表变为红黑树（树化）的过程" class="headerlink" title="HashMap 的桶由链表变为红黑树（树化）的过程"></a>HashMap 的桶由链表变为红黑树（树化）的过程</h2><h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><ol><li>节点为红色或者黑色</li><li>根节点必须是黑的</li><li>红色节点的左右子节点必须为黑色</li><li>一个节点到叶子节点的每条路径必须包含相同数目的黑色节点</li></ol><h3 id="颜色变换和两种选择"><a href="#颜色变换和两种选择" class="headerlink" title="颜色变换和两种选择"></a>颜色变换和两种选择</h3><p>添加新节点后，因为新节点总是红色的，那么会有几种情况出现：</p><ol><li>新节点是根节点，也就是说树是空的，根据规则二，把新节点设为黑色即可</li><li>新节点的父节点是黑色，或者父节点是根，满足规则</li><li>父节点是红色，违反规则三，需要进行 <strong>平衡</strong> 操作</li></ol><p>平衡操作主要是根据情况组合使用下面三种转换（方块表示一棵满足红黑树规则的子树）：</p><p><img src="../../../../image/2021-04-05-hashmap/op_1.png" alt="单旋"></p><p><img src="../../../../image/2021-04-05-hashmap/op_2.png" alt="双旋"></p><p><img src="../../../../image/2021-04-05-hashmap/op_3.png" alt="颜色变换"></p><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><h4 id="为什么要进行旋转？"><a href="#为什么要进行旋转？" class="headerlink" title="为什么要进行旋转？"></a>为什么要进行旋转？</h4><p>由于 P（父节点 和 X（新节点）都为红色，违反规则三</p><h4 id="为什么新节点总是红色？"><a href="#为什么新节点总是红色？" class="headerlink" title="为什么新节点总是红色？"></a>为什么新节点总是红色？</h4><p>因为添加新节点前的树结构是构建好的，一但我们添加黑色节点，无论添加在哪里都会破坏原有路径上的黑色节点的数量平等关系，所以插入红色节点是正确的选择</p><h4 id="为什么要进行颜色变换？"><a href="#为什么要进行颜色变换？" class="headerlink" title="为什么要进行颜色变换？"></a>为什么要进行颜色变换？</h4><p>如果叶子节点是红色的，那么我们在添加的时候只能添加黑色节点，然而添加任何黑色叶子节点都会违反规则四，所以要对其进行变换。进行变换后叶子节点是黑色的，而且我们默认添加的叶子节点是红色的，添加到红色的新节点后并不会违反规则四，所以这种变换很有用</p><h4 id="第二种双变换中在树的内部怎么出现的红色的节点？"><a href="#第二种双变换中在树的内部怎么出现的红色的节点？" class="headerlink" title="第二种双变换中在树的内部怎么出现的红色的节点？"></a>第二种双变换中在树的内部怎么出现的红色的节点？</h4><p>正是由于上面的颜色变换导致颜色变换后的节点与他的父节点产生了颜色冲突</p><h3 id="HashMap-树化的过程"><a href="#HashMap-树化的过程" class="headerlink" title="HashMap 树化的过程"></a>HashMap 树化的过程</h3><p>当满足下述条件时才将链表树化为红黑树</p><ul><li>桶内元素超过 <code>TREEIFY_THRESHOLD = 8</code>（当桶内元素小于 <code>UNTREEIFY_THRESHOLD = 6</code> 时，红黑树会降级为链表）</li><li>桶的数量超过 <code>MIN_TREEIFY_CAPACITY</code>（小于这个数量只是进行扩容操作）；无论是链表还是红黑树，都是为了解决哈希冲突，如果桶太少则应该首先增加桶的数量降低哈希冲突出现的概率，其次才是用红黑树增加查找效率</li></ul><p>首先将 <code>Node</code> 转变为 <code>TreeNode</code>，此时还是链表结构；第一个节点即为根，后面的节点作为新节点，按规则依次添加到树里：比父节点小则添加到左子树，比父节点大则添加到右子树，从上往下搜索直到要添加的子树为空即为新节点的位置；每次插入新节点后都需要进行 <strong>平衡</strong> 操作</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;    <span class="hljs-comment">// ... 将新元素添加至链表尾部（桶），如果桶的大小超过 TREEIFY_THRESHOLD，准备树化</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;            p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                treeifyBin(tab, hash);            <span class="hljs-keyword">break</span>;        &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;    <span class="hljs-comment">// 如果桶的数量 &lt; MIN_TREEIFY_CAPACITY，只是扩容</span>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();        <span class="hljs-comment">// 桶多于 MIN_TREEIFY_CAPACITY 才树化</span>    <span class="hljs-comment">// 将桶 tab[index] 里的节点转变为 TreeNode，但 此时还是链表</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">do</span> &#123;            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)                hd = p;            <span class="hljs-keyword">else</span> &#123;                p.prev = tl;                tl.next = p;            &#125;            tl = p;        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)            <span class="hljs-comment">// hd 是链表头，从它开始树化</span>            hd.treeify(tab);    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将还是链表的桶树化，当前是链表头</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeify</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab)</span> &#123;    <span class="hljs-comment">// 链表里第一个元素作为红黑树初始的根</span>    <span class="hljs-comment">// 遍历链表，逐个添加到红黑树中</span>    TreeNode&lt;K,V&gt; root = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="hljs-built_in">this</span>, next; x != <span class="hljs-literal">null</span>; x = next) &#123;        next = (TreeNode&lt;K,V&gt;)x.next;        x.left = x.right = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;            x.parent = <span class="hljs-literal">null</span>;            x.red = <span class="hljs-literal">false</span>;            root = x;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">K</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> x.key;            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> x.hash;            Class&lt;?&gt; kc = <span class="hljs-literal">null</span>;            <span class="hljs-comment">// 从根开始，自上而下找位置</span>            <span class="hljs-comment">// 比父节点小则插入到左子树，比父节点大则插入到右子树，直到所插入的位置为 null</span>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;                <span class="hljs-comment">// x - 新节点，p - 父节点，h - 新节点 hash，ph - parent hash</span>                <span class="hljs-comment">// dir == -1，新节点比父节点小，添加到左子树；dir == 1，新节点比父节点大，添加到右子树</span>                <span class="hljs-type">int</span> dir, ph;                <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key;                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)                    dir = -<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)                    dir = <span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-literal">null</span> &amp;&amp;                          (kc = comparableClassFor(k)) == <span class="hljs-literal">null</span>) ||                         (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)                    dir = tieBreakOrder(k, pk);                <span class="hljs-comment">// xp - 新节点的父节点</span>                <span class="hljs-comment">// 一直找，直到新节点需要插入的位置是为 null，那么就把新节点放在那</span>                TreeNode&lt;K,V&gt; xp = p;                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-literal">null</span>) &#123;                    x.parent = xp;                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)                        xp.left = x;                    <span class="hljs-keyword">else</span>                        xp.right = x;                    <span class="hljs-comment">// 插入新节点后可能会破坏红黑树的平衡，每次插入后都要执行平衡操作</span>                    root = balanceInsertion(root, x);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;    &#125;    moveRootToFront(tab, root);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 插入新节点后需要平衡红黑树</span><span class="hljs-keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="hljs-title function_">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> &#123;    x.red = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 新节点总是红色的</span>    <span class="hljs-comment">// xp - 新节点的 parent，xpp - 新节点的祖父，xppl - 祖父的左孩子，xppr - 祖父的右孩子</span>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;        <span class="hljs-comment">// 新节点没有父节点，说明它是根节点，根节点必须是黑色</span>        <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-literal">null</span>) &#123;            x.red = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-comment">// 1，不是根节点且父节点是黑色，满足红黑树的条件，返回即可</span>        <span class="hljs-comment">// 2，祖父为 null 说明父节点为根，根一定是黑色，新节点为红色，满足条件</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">// 父节点是红色且有祖父节点，那就比较麻烦了，必须要进行旋转和颜色变换操作，此时父节点是祖父的左孩子    </span>        <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;            <span class="hljs-comment">// 新节点是红色，父节点也是红色，父节点旁边的兄弟节点也是红色（由于当前红黑树除新节点外是平衡的，所以祖父肯定是黑色）</span>            <span class="hljs-comment">// 那么进行颜色变换：将父节点和它的兄弟节点变为黑色，祖父变为红色，对应图三</span>            <span class="hljs-comment">// 祖父变色后，可能引起祖父上面不平衡，所以下次循环要操作祖父</span>            <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-literal">null</span> &amp;&amp; xppr.red) &#123;                xppr.red = <span class="hljs-literal">false</span>;                xp.red = <span class="hljs-literal">false</span>;                xpp.red = <span class="hljs-literal">true</span>;                x = xpp;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 父节点的兄弟为黑色 or 为空，那么就要通过旋转解决两个红色节点相连的问题</span>                <span class="hljs-comment">// 新节点是右孩子，对应图二的双旋，这里是第一次的左旋</span>                <span class="hljs-keyword">if</span> (x == xp.right) &#123;                    root = rotateLeft(root, x = xp);                    xpp = (xp = x.parent) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : xp.parent;                &#125;                <span class="hljs-comment">// 继续上面的（左旋）后的第二次右旋</span>                <span class="hljs-comment">// 或者对应图一的单旋（右旋）</span>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-literal">null</span>) &#123;                    xp.red = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-literal">null</span>) &#123;                        xpp.red = <span class="hljs-literal">true</span>;                        root = rotateRight(root, xpp);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 同样是旋转和颜色变换操作，只不过父节点现在是祖父的右孩子，流程跟上面差不多的</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (xppl != <span class="hljs-literal">null</span> &amp;&amp; xppl.red) &#123;                xppl.red = <span class="hljs-literal">false</span>;                xp.red = <span class="hljs-literal">false</span>;                xpp.red = <span class="hljs-literal">true</span>;                x = xpp;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (x == xp.left) &#123;                    root = rotateRight(root, x = xp);                    xpp = (xp = x.parent) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : xp.parent;                &#125;                <span class="hljs-keyword">if</span> (xp != <span class="hljs-literal">null</span>) &#123;                    xp.red = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-literal">null</span>) &#123;                        xpp.red = <span class="hljs-literal">true</span>;                        root = rotateLeft(root, xpp);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="扩容的过程"><a href="#扩容的过程" class="headerlink" title="扩容的过程"></a>扩容的过程</h2><h3 id="计算扩容大小和下一次扩容阈值"><a href="#计算扩容大小和下一次扩容阈值" class="headerlink" title="计算扩容大小和下一次扩容阈值"></a>计算扩容大小和下一次扩容阈值</h3><p>扩容时，容量翻倍，下一次扩容阈值 <code>threshold</code> 也翻倍；特殊情况是当前容量小于默认初始容量 <code>DEFAULT_INITIAL_CAPACITY = 16</code> 时，<code>threshold</code> 不翻倍而是取扩容后的负载因子倍数</p><p>第一次扩容时 <code>table</code> 尚未初始化，当前容量为零，如果构造函数有设置 <code>initialCapacity</code>，则扩容后的大小为 <code>initialCapacity</code>，下一次扩容阈值为 <code>initialCapacity * loadFactor</code>；否则扩容后大小和负载因子都取默认值</p><p>第一次扩容时，<code>threshold</code> 取 <code>initialCapacity * loadFactor</code>，而 <code>loadFactor</code> 总是小于等于 1 的，所以 <code>threshold</code> 总是小于等于 <code>capacity</code>，后续即使翻倍 <code>threshold</code> 也是小于等于 <code>capacity</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">// table 已被初始化的情况（table != null）</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 限制最大容量（MAXIMUM_CAPACITY = 1 &lt;&lt; 30）</span>        <span class="hljs-comment">// 因为容量是个 int 值，要限制下不至于溢出</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">// 最常见的情况：capacity 和 threshold 翻一倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">// 第一次扩容，table 还未被初始化但是 threshold 有值，那么把它作为扩容后的容量</span>    <span class="hljs-comment">// 对应 HashMap(initialCapacity, loadFactor)，HashMap(initialCapacity) 和 HashMap(Map&lt;? extends K, ? extends V&gt; m) 这三种情况</span>    <span class="hljs-comment">// 前两种情况 threshold 可以通过 initialCapacity 算出来，后一种情况可以通过 Map 大小算出来</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        newCap = oldThr;    <span class="hljs-comment">// table 还未被初始化并且 threshold 也没有值，对应 HashMap()</span>    <span class="hljs-comment">// 没有传入 initialCapacity，threshold 没有参考值所以为零，那么使用默认值</span>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    <span class="hljs-comment">// 1，当 table 尚未初始化且 threshold/initialCapacity 有值</span>    <span class="hljs-comment">// 2，当 table 已初始化但扩容前的容量 &lt; DEFAULT_INITIAL_CAPACITY</span>    <span class="hljs-comment">// 下一次扩容大小 newThr 为扩容后到达负载因子的水平</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h3 id="重新-hash"><a href="#重新-hash" class="headerlink" title="重新 hash"></a>重新 hash</h3><ol><li>只有一个元素，重新 hash 算出新位置即可</li><li>链表的情况，因为 <code>capacity</code> 总是 2 的次方，<code>capacity</code> 形如 <code>100000</code> 而 <code>capacity - 1</code> 形如 <code>011111</code>，通过 <code>e.hash &amp; oldCap) == 0</code> 把链表拆分为两个链表 low（高位为 0）和 high（高位为 1），low 留在原位 <code>newTab[j]</code>，high 迁移到 <code>newTab[j + oldCap]</code></li><li>如果是红黑树，跟链表一样先拆分和迁移，如果链表里元素数量小于等于 <code>UNTREEIFY_THRESHOLD = 6</code> 则转化为链表，否则重新构建红黑树</li></ol><p>为什么拆分链表是可行的？假设当前容量 4 扩容后为 8，那么 hash 的右值为 <code>0011</code> 和 <code>0111</code>（object.hash() * (capacity - 1)，扩容的翻倍操作实际上是左移一位），可以看到区别就是高位对应的 object.hash() 值，高位 hash 为零即使扩容了位置也不变，高位 hash 为 1 则迁移到 oldCap + j 的位置上（obj 相当于高位对应的部分，j 则是低位对应的部分）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    <span class="hljs-comment">// ...</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];    table = newTab;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;  <span class="hljs-comment">// 遍历旧 table</span>            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-comment">// 如果桶中只有一个元素，重新计算位置并迁移</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                <span class="hljs-comment">// 红黑树，拆分并重建红黑树    </span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);                <span class="hljs-comment">// 桶里是链表，根据高位是 0 还是 1 把链表拆分为两个链表（low 和 high）</span>                <span class="hljs-comment">// low 留在原来的位置，hihg 迁移到新位置</span>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;<span class="hljs-comment">// 红黑树重新 hash 的过程</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> bit)</span> &#123;    <span class="hljs-comment">// 跟链表一样根据高位拆分为 low（0）和 high（1）两个链表</span>    TreeNode&lt;K,V&gt; b = <span class="hljs-built_in">this</span>;    TreeNode&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;    TreeNode&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-literal">null</span>; e = next) &#123;        next = (TreeNode&lt;K,V&gt;)e.next;        e.next = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-literal">null</span>)                loHead = e;            <span class="hljs-keyword">else</span>                loTail.next = e;            loTail = e;            ++lc;        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-literal">null</span>)                hiHead = e;            <span class="hljs-keyword">else</span>                hiTail.next = e;            hiTail = e;            ++hc;        &#125;    &#125;    <span class="hljs-comment">// 拆分后，如果 &lt; UNTREEIFY_THRESHOLD 则转为链表，否则重新构建红黑树</span>    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)            tab[index] = loHead.untreeify(map);        <span class="hljs-keyword">else</span> &#123;            tab[index] = loHead;            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>) <span class="hljs-comment">// (else is already treeified)</span>                loHead.treeify(tab);        &#125;    &#125;    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)            tab[index + bit] = hiHead.untreeify(map);        <span class="hljs-keyword">else</span> &#123;            tab[index + bit] = hiHead;            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>)                hiHead.treeify(tab);        &#125;    &#125;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC 下一些线程安全的容器</title>
    <link href="/2021/03/31/juc-collection/"/>
    <url>/2021/03/31/juc-collection/</url>
    
    <content type="html"><![CDATA[<h2 id="写时复制（Copy-On-Write）"><a href="#写时复制（Copy-On-Write）" class="headerlink" title="写时复制（Copy On Write）"></a>写时复制（Copy On Write）</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h3><p>使用 <strong>写时复制</strong> 实现的线程安全版 <code>ArrayList</code>，当发生修改操作时（add、set、remove）才加锁，将原数组复制一份并在上面修改成为新数组，最后用新数组替换原数组</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;    <span class="hljs-keyword">synchronized</span> (lock) &#123;        Object[] elements = getArray();        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        newElements[len] = e;        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><p>也就是说所有的修改操作都不会修改原数组，这样所有的读操作（get、iterate）都可以不加锁，从而实现高效的读（虽然有可能会读到旧数据）；因为它的写操作是很昂贵的（复制一份出来），但同时它的读操作和迭代很高效（不上锁），所以它适用于读操作远大于写操作的情况；<code>CopyOnWriteArraySet</code> 内部是通过 <code>CopyOnWriteArrayList</code> 实现的</p><h2 id="分段加锁"><a href="#分段加锁" class="headerlink" title="分段加锁"></a>分段加锁</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p>跟 <code>HashMap</code> 一样采用数组 + 链表的实现，链表又叫做桶 or 箱子（bin）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;&#125;</code></pre></div><p>写时采用 <strong>分段加锁</strong>，不对整个写操作 or <code>table</code> 加锁，而只对所在的桶加锁，其他线程依然可以进行读操作 or 对其他桶进行写操作</p><p>整个 <code>ConcurrentHashMap</code> 都没有使用 <code>Lock</code> 进行阻塞，而是尽可能采用自旋 + CAS（乐观锁，是实现无锁操作的重要函数），最后才用 <code>synchronized</code>（参考文章，它的锁膨胀过程中掺杂自旋和阻塞）对桶上锁</p><p><code>tabAt</code>、<code>setTabAt</code> 和 <code>casTabAt</code> 使对 <code>table</code> 的操作具有可见性和原子性，避免了对 <code>table</code> 上锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;    <span class="hljs-comment">// 没有对整个写操作加锁，也没有对 table 加锁</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// CAS 失败会自旋，是乐观锁</span>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;        <span class="hljs-comment">// 如果 table == null，则进行初始化；初始化后每个桶是 null</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            tab = initTable();                <span class="hljs-comment">// 所在的桶为 null，不加锁直接用 CAS 操作添加新桶头，失败的话自旋</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 找到所在的不为 null 的桶，对单个桶上锁</span>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-comment">// 沿着链表从头开始走，如果找到 key 值相等的节点则覆盖旧的 value</span>                    <span class="hljs-comment">// 否则作为新节点添加到链表尾部</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                    e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,                                                          value, <span class="hljs-literal">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">// ... 链表被树化为红黑树的情况参考 HashMap 的文章</span>                &#125;            &#125;            <span class="hljs-comment">// ...</span>        &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 初始化 table，自旋 + CAS</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];                    table = tab = nt;                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                sizeCtl = sc;            &#125;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> tab;&#125;<span class="hljs-comment">// 使数组的读/写操作像 volatile 成员变量一样具有线程可见性</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE);&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;    U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);&#125;<span class="hljs-comment">// 在数组上实现 CAS 操作</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><span class="hljs-params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;</code></pre></div><p>虽然都是线程安全的 map，但 <code>ConcurrentHashMap</code> 的分段加锁对比 <code>HashTable</code> 的整个方法加锁优势就体现出来了，高并发下优势会愈加明显</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// HashTable 对整个写操作加锁</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;    <span class="hljs-comment">// Make sure the value is not null</span>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();    &#125;    <span class="hljs-comment">// Makes sure the key is not already in the hashtable.</span>    HashtableEntry&lt;?,?&gt; tab[] = table;    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];    <span class="hljs-keyword">for</span>(; entry != <span class="hljs-literal">null</span> ; entry = entry.next) &#123;        <span class="hljs-keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;            <span class="hljs-type">V</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> entry.value;            entry.value = value;            <span class="hljs-keyword">return</span> old;        &#125;    &#125;    addEntry(hash, key, value, index);    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>读操作完全不加锁，但是 <code>Node.val</code> 和 <code>Node.next</code> 是 <code>volatile</code> 修饰的，所以 <code>Node</code> 的线程可见性是有保证的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))                <span class="hljs-keyword">return</span> e.val;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))                <span class="hljs-keyword">return</span> e.val;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-keyword">volatile</span> V val;    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;&#125;</code></pre></div><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><code>BlockingQueue</code></h2><p>它提供的阻塞操作包括：</p><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td><code>put(e)</code></td><td>入队</td></tr><tr><td><code>offer(e, timeout, unit)</code></td><td>设置超时的入队</td></tr><tr><td><code>take()</code></td><td>出队</td></tr><tr><td><code>poll(timeout, unit)</code></td><td>设置超时的出队</td></tr><tr><td><code>drainTo(collection, maxElements)</code></td><td>批量出队并添加到另一个集合中</td></tr></tbody></table><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h3><p>基于数组、容量有限的阻塞队列，通过构造函数指定队列的容量</p><p>用两个指针 <code>takeIndex</code>(队头，指向下一次出队的位置) 和 <code>putIndex</code>（队尾，指向下一次入队的位置） 模拟队列，它们初始为 0（最左边），随着元素的入队 <code>putIndex</code> 往右移动，随着元素的出队 <code>takeIndex</code> 也往右移动，当它们越过数组最后边时会重置到最左边，<code>count</code> 确保 <code>takeIndex</code> 不会违规越过 <code>putIndex</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;    <span class="hljs-comment">/** The queued items */</span>    <span class="hljs-keyword">final</span> Object[] items;    <span class="hljs-comment">/** items index for next take, poll, peek or remove */</span>    <span class="hljs-type">int</span> takeIndex;    <span class="hljs-comment">/** items index for next put, offer, or add */</span>    <span class="hljs-type">int</span> putIndex;    <span class="hljs-comment">/** Number of elements in the queue */</span>    <span class="hljs-type">int</span> count;&#125;</code></pre></div><p>出队/入队时用了 <code>Lock</code> 和 <code>Condition</code> 实现阻塞和唤醒，出队时如果为空则阻塞在 <code>notEmpty</code> 上，入队时如果满了则阻塞在 <code>notFull</code>，入队后唤醒阻塞在 <code>notEmpty</code> 上的线程，出队后唤醒阻塞在 <code>notFull</code> 上的线程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;    <span class="hljs-comment">/** Main lock guarding all access */</span>    <span class="hljs-keyword">final</span> ReentrantLock lock;    <span class="hljs-comment">/** Condition for waiting takes */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;    <span class="hljs-comment">/** Condition for waiting puts */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Inserts element at current put position, advances, and signals.</span><span class="hljs-comment">     * Call only when holding lock.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E x)</span> &#123;        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span>        <span class="hljs-comment">// assert items[putIndex] == null;</span>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;        items[putIndex] = x;        <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;        count++;        notEmpty.signal();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Extracts element at current take position, advances, and signals.</span><span class="hljs-comment">     * Call only when holding lock.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span>        <span class="hljs-comment">// assert items[takeIndex] != null;</span>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>        <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) items[takeIndex];        items[takeIndex] = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;        count--;        <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)            itrs.elementDequeued();        notFull.signal();        <span class="hljs-keyword">return</span> x;    &#125;  &#125;</code></pre></div><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><code>LinkedBlockingQueue</code></h3><p>基于链表、无限容量（当然也可以通过构造函数设置最大容量）的阻塞队列，链表是单向的，<code>head</code> 指向队头也就是出队的位置，<code>last</code> 指向队尾也就是出队的位置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Linked list node class.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;        E item;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * One of:</span><span class="hljs-comment">         * - the real successor Node</span><span class="hljs-comment">         * - this Node, meaning the successor is head.next</span><span class="hljs-comment">         * - null, meaning there is no successor (this is the last node)</span><span class="hljs-comment">         */</span>        Node&lt;E&gt; next;        Node(E x) &#123; item = x; &#125;    &#125;    <span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;    <span class="hljs-comment">/** Current number of elements */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Head of linked list.</span><span class="hljs-comment">     * Invariant: head.item == null</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; head;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Tail of linked list.</span><span class="hljs-comment">     * Invariant: last.next == null</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;        <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span>        <span class="hljs-comment">// assert last.next == null;</span>        last = last.next = node;    &#125;    <span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span>        <span class="hljs-comment">// assert head.item == null;</span>        Node&lt;E&gt; h = head;        Node&lt;E&gt; first = h.next;        h.next = h; <span class="hljs-comment">// help GC</span>        head = first;        <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;        first.item = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre></div><p>跟 <code>ArrayBlockingQueue</code> 一样用了两个条件变量：<code>notEmpty</code> 和 <code>notFull</code> 来阻塞/唤醒生产者和消费者；为啥会有 <code>notFull</code> 的情况呢，不是无限容量吗？因为它可以设置一个最大容量</p><p>不同的是 <code>LinkedBlockingQueue</code> 用了两个锁，<code>takeLock</code> 给出队加锁，<code>putLock</code> 给入队加锁，出队和入队之所以可以并行是有 <code>count</code> 在确保数量正确</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;    <span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;    <span class="hljs-comment">/** Current number of elements */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();    <span class="hljs-comment">/** Lock held by take, poll, etc */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();    <span class="hljs-comment">/** Wait queue for waiting takes */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();    <span class="hljs-comment">/** Lock held by put, offer, etc */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();    <span class="hljs-comment">/** Wait queue for waiting puts */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();&#125;</code></pre></div><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><code>PriorityBlockingQueue</code></h3><p>上面两个阻塞队列是 <code>FIFO</code> 排序的，而这个可以用 <code>Comparator</code> 和 <code>Comparable</code> 自定义优先级</p><p>底层用 <strong>小顶堆</strong> 实现的优先队列，小顶堆是用数组实现的二叉树（左右节点要大于父节点）；入队元素添加到叶子那层的最左边，然后自下往上跟父节点比较，如果小则交换，这个操作叫 <code>siftUp</code>；出队元素固定是树的根节点，出队后把最后一个节点作为根节点，从上往下跟左右节点比较，如果大则交换，这个操作叫 <code>siftDown</code>（参考 <a href="../../../../2021/02/19/threadpool/">这篇文章</a> 里堆的介绍）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Priority queue represented as a balanced binary heap: the two</span><span class="hljs-comment">     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span><span class="hljs-comment">     * priority queue is ordered by comparator, or by the elements&#x27;</span><span class="hljs-comment">     * natural ordering, if comparator is null: For each node n in the</span><span class="hljs-comment">     * heap and each descendant d of n, n &lt;= d.  The element with the</span><span class="hljs-comment">     * lowest value is in queue[0], assuming the queue is nonempty.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] queue;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] array,</span><span class="hljs-params">                                       Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; cmp)</span> &#123;        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[parent];            <span class="hljs-keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;            array[k] = e;            k = parent;        &#125;        array[k] = x;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] array,</span><span class="hljs-params">                                                    <span class="hljs-type">int</span> n,</span><span class="hljs-params">                                                    Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; cmp)</span> &#123;        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> n &gt;&gt;&gt; <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (k &lt; half) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;                <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> array[child];                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="hljs-number">0</span>)                    c = array[child = right];                <span class="hljs-keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;                array[k] = c;                k = child;            &#125;            array[k] = x;        &#125;    &#125;&#125;</code></pre></div><p>虽然底层是数组但可以扩容，也即无限容量；扩容操作也很细致地分为两步：</p><ul><li>分配一块新内存，用 int 和 CAS 操作实现自旋（也许是认为分配新内存很快，所以用乐观锁？）</li><li>复制数组用 <code>Lock</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryGrow</span><span class="hljs-params">(Object[] array, <span class="hljs-type">int</span> oldCap)</span> &#123;    <span class="hljs-comment">// 分配内存，自旋</span>    lock.unlock(); <span class="hljs-comment">// must release and then re-acquire main lock</span>    Object[] newArray = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (allocationSpinLock == <span class="hljs-number">0</span> &amp;&amp;        U.compareAndSwapInt(<span class="hljs-built_in">this</span>, ALLOCATIONSPINLOCK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">newCap</span> <span class="hljs-operator">=</span> oldCap + ((oldCap &lt; <span class="hljs-number">64</span>) ?                                   (oldCap + <span class="hljs-number">2</span>) : <span class="hljs-comment">// grow faster if small</span>                                   (oldCap &gt;&gt; <span class="hljs-number">1</span>));            <span class="hljs-keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// possible overflow</span>                <span class="hljs-type">int</span> <span class="hljs-variable">minCap</span> <span class="hljs-operator">=</span> oldCap + <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (minCap &lt; <span class="hljs-number">0</span> || minCap &gt; MAX_ARRAY_SIZE)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();                newCap = MAX_ARRAY_SIZE;            &#125;            <span class="hljs-keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)                newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCap];        &#125; <span class="hljs-keyword">finally</span> &#123;            allocationSpinLock = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (newArray == <span class="hljs-literal">null</span>) <span class="hljs-comment">// back off if another thread is allocating</span>        Thread.<span class="hljs-keyword">yield</span>();    <span class="hljs-comment">// 复制数组才上悲观锁</span>    lock.lock();    <span class="hljs-keyword">if</span> (newArray != <span class="hljs-literal">null</span> &amp;&amp; queue == array) &#123;        queue = newArray;        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, oldCap);    &#125;&#125;</code></pre></div><p>跟 <code>ArrayBlockingQueue</code> 一样，入队/出队用同一把锁，因为无容量限制所以只需一个条件变量 <code>notEmpty</code>（<code>notFull</code> 的情况不会出现）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Lock used for all public operations.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Condition for blocking when empty.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;&#125;</code></pre></div><h3 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h3><ul><li>需要自定义优先级用 <code>PriorityBlockingQueue</code>，需要无限容量用 <code>LinkedBlockingQueue</code></li><li><code>LinkedBlockingQueue</code> 入队出队分别使用两把锁，也就是说入队出队可以并行，在高并发下会比使用同一把锁的 <code>ArrayBlockingQueue</code> 性能要好</li><li><code>ArrayBlockingQueue</code> 在内存利用率上会比 <code>LinkedBlockingQueue</code> 要好（<code>Node</code> 需要额外的空间），而且底层数组在构造函数时就已预先分配内存，使用时无需动态申请内存，内存波动较小；而动态申请内存的 <code>LinkedBlockingQueue</code> 可能会增加 JVM GC 的负担</li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a><code>ConcurrentLinkedQueue</code></h2><p>用链表实现的线程安全的队列，没有使用 <code>Lock</code> 和 <code>synchronized</code>，而是采用 <code>CAS</code> 操作和自旋的乐观锁，所以 <code>ConcurrentLinkedQueue</code> 是乐观的容器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;E&gt; &#123;    <span class="hljs-comment">// 因为没使用锁，为了确保可见性，节点的成员变量都是 volatile</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;        <span class="hljs-keyword">volatile</span> E item;        <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;    &#125;    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;            <span class="hljs-comment">// 头节点，出队时从头结点出队</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;    <span class="hljs-comment">// 尾结点，入队时从尾结点入队</span>&#125;<span class="hljs-comment">// 出队操作，不移除 Node 只是将 Node.item 置空，下一次操作才会将 Node.item == null 的空节点移除</span><span class="hljs-comment">// 使用 for + cas</span><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;    restartFromHead:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;            <span class="hljs-type">E</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> p.item;            <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span> &amp;&amp; casItem(p, item, <span class="hljs-literal">null</span>)) &#123;                <span class="hljs-comment">// Successful CAS is the linearization point</span>                <span class="hljs-comment">// for item to be removed from this queue.</span>                <span class="hljs-keyword">if</span> (p != h) <span class="hljs-comment">// hop two nodes at a time</span>                    updateHead(h, ((q = p.next) != <span class="hljs-literal">null</span>) ? q : p);                <span class="hljs-keyword">return</span> item;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-literal">null</span>) &#123;                updateHead(h, p);                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)                <span class="hljs-keyword">continue</span> restartFromHead;            <span class="hljs-keyword">else</span>                p = q;        &#125;    &#125;&#125;<span class="hljs-comment">// 入队，依然用的是 for + cas</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = newNode(Objects.requireNonNull(e));    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;        Node&lt;E&gt; q = p.next;        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// p is last node</span>            <span class="hljs-keyword">if</span> (casNext(p, <span class="hljs-literal">null</span>, newNode)) &#123;                <span class="hljs-comment">// Successful CAS is the linearization point</span>                <span class="hljs-comment">// for e to become an element of this queue,</span>                <span class="hljs-comment">// and for newNode to become &quot;live&quot;.</span>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span>                    casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-comment">// Lost CAS race to another thread; re-read next</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)            <span class="hljs-comment">// We have fallen off list.  If tail is unchanged, it</span>            <span class="hljs-comment">// will also be off-list, in which case we need to</span>            <span class="hljs-comment">// jump to head, from which all live nodes are always</span>            <span class="hljs-comment">// reachable.  Else the new tail is a better bet.</span>            p = (t != (t = tail)) ? t : head;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// Check for tail updates after two hops.</span>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是 https ？</title>
    <link href="/2021/03/30/https/"/>
    <url>/2021/03/30/https/</url>
    
    <content type="html"><![CDATA[<p><code>https = http + tls</code></p><p><code>tcp</code> 三次握手建立连接后，再进行 <code>tls</code> 握手/协商得到一个秘钥，然后双方使用这个秘钥加密（对称加密）明文的 http 为密文后再发送，同样双方收到密文后也用这个秘钥解密得到明文</p><p><strong>对称加密</strong> 使用同一秘钥加密和解密，性能高，http 明文就是通过对称加密后才进行传输的，对称加密算法有：<code>DES</code>、<code>3DES</code>、<code>AES</code> 等；但秘钥交换是个问题，所以需要非对称加密的帮助</p><p><strong>非对称加密</strong> 公钥加密则私钥解密，私钥加密则公钥解密，性能比对称加密要差，不适合加解密大量的数据，但很适合于解决秘钥交换的问题，常用的有：<code>RSA</code>、<code>DSA</code> 等</p><h1 id="tls-协商-握手"><a href="#tls-协商-握手" class="headerlink" title="tls 协商/握手"></a>tls 协商/握手</h1><ol><li>Client Hello</li></ol><p>客户端发送：<strong>客户端随机数</strong>（client random）和客户端支持的 <strong>加密套件列表</strong></p><ol start="2"><li>Server Hello</li></ol><p>服务端从客户端支持的加密套件中选择一个，然后发送：<strong>服务端随机数</strong>（server random）和 <strong>选用的套件</strong>，比如 <code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code> 就是：</p><ul><li>密钥协商使用 <code>ECDHE</code></li><li>签名算法使用 <code>RSA</code></li><li>加密 http 明文所使用的对称加密算法是 <code>AES</code>，密钥长度 256，分组模式 <code>GCM</code></li><li>摘要算法使用 <code>SHA384</code></li></ul><ol start="3"><li>Server Certificate</li></ol><p>服务端发送 <strong>CA 证书</strong></p><ol start="4"><li>Server Key Exchange</li></ol><p>服务端生成一个随机数作为 <strong>服务端椭圆曲线私钥</strong>，选择一个 <strong>椭圆曲线</strong>（比如 named_curve）和 <strong>椭圆曲线基点 G</strong>，根据 G 和服务端椭圆曲线私钥生成 <strong>服务端椭圆曲线公钥</strong></p><p>为了确保服务端椭圆曲线公钥不被篡改，服务端用 RSA + 服务端 CA 私钥给服务端椭圆曲线公钥做个签名 <strong>signature</strong></p><p>最后发送椭圆曲线、G、服务端椭圆曲线公钥和 signature 给客户端</p><ol start="5"><li>Server Hello Done</li></ol><p>服务端告诉客户端我这边的信息已经发送完毕</p><ol start="6"><li>Client Key Exchange</li></ol><p>客户端进行 CA 证书校验；同样生成一个随机数作为 <strong>客户端椭圆曲线私钥</strong>，根据服务端给的 G 和客户端椭圆曲线私钥生成 <strong>客户端椭圆曲线公钥</strong> 发给服务端（服务端 CA 公钥加密签名防篡改）</p><p>此时客户端算出椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端也算出椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)</p><p>而两端算出的 <strong>椭圆曲线秘钥</strong> 是一致的，但这还没有结束，对 http 明文进行加密的 <strong>主秘钥</strong> = server random + client random + 椭圆曲线秘钥</p><ol start="7"><li>Change Cipher Spec</li></ol><p>服务端和客户端都通知对方，后续的数据传输将使用 RSA + 主秘钥加密了</p><ol start="8"><li>Finish</li></ol><p>第一个由 tls 记录层协议进行加密保护的信息，双方需要验证对方发送的 Finished 信息，保证协商的密钥是可用的，保证协商过程中，没有被篡改</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>https 使用对称加密（比如 <code>RSA</code>）对 http 明文进行加密传输，这个秘钥叫主秘钥，但要确保秘钥交换过程是安全的；那怎样的交换过程是安全的呢？当然不交换，服务端和客户端各自按照一定的规则生成相同秘钥最安全！这个规则就是 <code>密钥协商协议</code></p><blockquote><p>DH（Diffie-Hellman）算法是 Whitfield Diffie 和 Martin Hellman 在 1976 年公布的一种密钥交换算法，它是一种建立密钥的方法而不是加密方法，所以密钥必须和其他一种加密算法结合使用。这种密钥交换技术的目的在于使两个用户安全的协商一个会话密码。Diffie-Hellman 密钥交换算法的有效性依赖于计算离散对数的难度。</p></blockquote><p>总的来说 <code>DH</code> 靠本地计算替代网络传输保证了秘钥的安全</p><p><img src="/image/2021-03-30-https/dh.png" alt="秘钥协商协议"></p><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>SSL 证书包括 <strong>CA 证书</strong> 和 <strong>用户证书</strong> 两种</p><p>CA 全称 <code>Certification Authority</code>（证书颁发机构），顾名思义是专门给别人颁发证书的机构，它的证书叫做 CA 证书，大部分 CA 证书会被内置到 Android、iOS、Chrome、Firefox 等软件里面并受到信任</p><p>CA 颁发的证书包括 <strong>根证书</strong> 和 <strong>中间证书</strong> 两种：</p><ul><li><p>根证书是根 CA 的证书，是公开密钥基础建设中信任链的起点，一般客户端会内置</p></li><li><p>中间证书，因为根证书太宝贵了，直接颁发风险太大，为了保护根证书，CA 通常会颁发所谓的中间证书。CA 使用它的私钥对中间证书签名使它受到信任。然后 CA 使用中间证书的私钥签署和颁发终端用户 SSL 证书。这个过程可以执行多次，其中一个中间根对另一个中间根进行签名，这样就形成了证书链：根证书 - 中间证书… - 用户证书</p></li></ul><p>用户证书是由 CA 中间证书签发给用户的证书，包含服务器证书和客户端证书</p><ul><li><p>服务器证书，组成 Web 服务器的 SSL 安全功能的唯一的数字标识，通过 CA 签发并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息如：服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件</p></li><li><p>客户端证书，在双向 https 验证中必须有客户端证书，生成方式同服务器证书一样，单向认证则不需要用到</p></li></ul><p><img src="/image/2021-03-30-https/cert_chain.png" alt="证书链"></p><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><ul><li><p>key：密钥文件，SSL 证书的私钥就包含在其中</p></li><li><p>csr：这个文件里面包含着证书的公钥和其他一些公司信息，通过请求签名之后就可以直接生出证书</p></li><li><p>crt / cert：该文件中也包含了证书的公钥、签名信息以及根据不同类型证书携带不同的认证信息如 IP、域名等</p></li><li><p>pem：该文件相对比较少见，里面包含着证书的私钥以及部分证书信息</p></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>Issuer</code> 是颁发机构也即 CA，<code>Subject</code> 是主体也即 CA 认证的对象，一般是域名：mail.google.com、*.cnblogs.com，它们有几个描述字段：</p><ul><li>CN，公用名称（Common Name），一般为域名、ip 地址、单位/组织/公司名</li><li>O，单位名称（Organization Name）</li><li>C，所在国家（Country）</li><li>L，所在城市（Locality）</li><li>S，所在省份（State/Provice）</li><li>E，电子邮件（Email）</li><li>…</li></ul><p><code>Validity</code> 是证书有效期：<code>[Not Before, Not After]</code></p><p>证书中还包含主体的公钥信息 <code>Subject Public Key Info</code>，包括公钥算法和公钥，这样服务器下发证书给客户端时，客户端也就拿到了服务端的公钥</p><p>还有非常重要的、确保证书未被篡改的签名信息 <code>Signature Algorithm</code>，包括签名算法和签名，这是由颁发机构用它的私钥签发的，客户端可以通过 CA 证书里的公钥校验</p><div class="code-wrapper"><pre><code class="hljs shell">// 谷歌邮箱的证书<span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="hljs-keyword">in</span> ./mail.google.com -noout -text</span>Certificate:    Data:        Version: 3 (0x2)        Serial Number:            5c:48:a5:bd:db:83:49:69:12:a9:54:9f:08:5d:b1:d5        Signature Algorithm: sha256WithRSAEncryption        Issuer: C = US, O = Google Trust Services LLC, CN = GTS CA 1C3        Validity            Not Before: Nov  2 13:45:40 2022 GMT            Not After : Jan 25 13:45:39 2023 GMT        Subject: CN = mail.google.com        Subject Public Key Info:            Public Key Algorithm: id-ecPublicKey                Public-Key: (256 bit)                pub:                    04:48:6e:8d:70:27:fd:14:77:98:20:c4:71:c2:18:                    83:fe:f7:fe:3d:20:2e:b7:5b:87:31:5d:69:ca:2f:                    07:3a:cb:cc:5a:2a:9b:18:26:43:a1:76:5f:92:42:                    5e:4e:bf:2e:8c:89:3e:6e:cf:6e:21:74:38:94:d0:                    5e:08:bc:ad:0f                ASN1 OID: prime256v1                NIST CURVE: P-256        X509v3 extensions:            X509v3 Key Usage: critical                Digital Signature            X509v3 Extended Key Usage:                TLS Web Server Authentication            X509v3 Basic Constraints: critical                CA:FALSE            X509v3 Subject Key Identifier:                E1:AF:FF:77:26:9C:2D:37:42:00:C5:30:3A:81:A2:01:90:A8:2C:1F            X509v3 Authority Key Identifier:                keyid:8A:74:7F:AF:85:CD:EE:95:CD:3D:9C:D0:E2:46:14:F3:71:35:1D:27            Authority Information Access:                OCSP - URI:http://ocsp.pki.goog/gts1c3                CA Issuers - URI:http://pki.goog/repo/certs/gts1c3.der            X509v3 Subject Alternative Name:                DNS:mail.google.com, DNS:inbox.google.com            X509v3 Certificate Policies:                Policy: 2.23.140.1.2.1                Policy: 1.3.6.1.4.1.11129.2.5.3            X509v3 CRL Distribution Points:                Full Name:                  URI:http://crls.pki.goog/gts1c3/QOvJ0N1sT2A.crl            CT Precertificate SCTs:                Signed Certificate Timestamp:                    Version   : v1 (0x0)                    Log ID    : E8:3E:D0:DA:3E:F5:06:35:32:E7:57:28:BC:89:6B:C9:                                03:D3:CB:D1:11:6B:EC:EB:69:E1:77:7D:6D:06:BD:6E                    Timestamp : Nov  2 14:45:42.034 2022 GMT                    Extensions: none                    Signature : ecdsa-with-SHA256                                30:45:02:20:55:B9:3F:3A:67:2C:6D:51:09:80:E1:BB:                                8D:5B:EF:19:7C:37:B8:4A:A9:D3:A8:D0:0C:07:A5:AE:                                F7:15:F3:D2:02:21:00:FB:4E:96:FE:38:FE:27:AF:7E:                                63:41:F6:30:9B:66:4E:43:D0:D6:6B:4F:C1:43:68:14:                                5D:B6:58:B8:37:28:B4                Signed Certificate Timestamp:                    Version   : v1 (0x0)                    Log ID    : B3:73:77:07:E1:84:50:F8:63:86:D6:05:A9:DC:11:09:                                4A:79:2D:B1:67:0C:0B:87:DC:F0:03:0E:79:36:A5:9A                    Timestamp : Nov  2 14:45:42.195 2022 GMT                    Extensions: none                    Signature : ecdsa-with-SHA256                                30:46:02:21:00:ED:AB:D5:12:61:88:24:CF:40:C6:45:                                9B:C0:29:4D:50:CE:E3:54:4D:05:63:06:CE:46:38:A9:                                03:17:5C:11:44:02:21:00:9E:57:54:CE:BC:25:CA:8B:                                6C:26:98:52:DF:03:0C:CE:43:46:E9:AA:9B:83:20:F2:                                1B:94:FD:52:EB:E1:C1:4B    Signature Algorithm: sha256WithRSAEncryption         9d:04:e6:b9:2c:a9:77:0a:11:54:28:3e:6f:83:50:a5:87:14:         03:ba:cc:85:0f:cb:c8:1f:a9:e8:d0:44:b7:a9:c8:86:98:6c:         9a:8e:89:2f:cd:bb:36:82:52:29:2e:28:a8:d3:76:31:5a:71:         e5:91:6d:4c:b6:ad:79:d7:a8:c8:a6:ed:ec:09:4b:e0:a4:e4:         07:b5:5e:d0:c4:a8:50:92:01:df:53:4d:fd:e5:d0:ac:5f:43:         b5:64:d2:a8:f9:1c:2c:aa:f1:0a:d3:69:d4:6d:03:60:63:b0:         f2:0b:5a:74:35:73:72:b6:86:2c:93:08:e9:92:69:68:78:90:         16:b7:fe:b7:ab:72:46:f8:30:21:8b:6d:86:a1:99:6a:fa:be:         0e:c6:f4:d3:c7:d6:80:4f:b1:36:d3:b5:34:cd:f6:12:d6:55:         c5:a7:7d:bb:84:81:f0:34:87:17:11:a9:42:a9:d0:8b:cf:05:         28:3b:fb:89:f9:0f:af:c4:32:3f:31:60:19:70:b9:10:6e:6a:         64:40:28:5f:ba:d5:6e:8d:8c:40:b7:a0:d7:2c:68:41:50:af:         f7:bf:e9:f1:a0:03:98:c1:66:ee:31:97:54:66:e8:ed:4f:67:         c0:70:f7:12:32:9f:c3:50:b6:4a:7e:0b:f9:73:86:de:34:df:         94:e5:bb:9b// Charles 代理软件的自签名证书<span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl x509 -<span class="hljs-keyword">in</span> ./charles.pem -noout -text</span>Certificate:    Data:        Version: 3 (0x2)        Serial Number: 1648018041505 (0x17fb587aaa1)        Signature Algorithm: sha256WithRSAEncryption        Issuer: CN = &quot;Charles Proxy CA (23 Mar 2022, \E4\BA\92\E8\81\94\E7\BD\91\E5\BC\80\E5\8F\91\E9\83\A8-\E6\9E\97\E5\A8\81)&quot;, OU = https://charlesproxy.com/ssl, O = XK72 Ltd, L = Auckland, ST = Auckland, C = NZ        Validity            Not Before: Mar 22 06:47:21 2022 GMT            Not After : Mar 22 06:47:21 2023 GMT        Subject: CN = &quot;Charles Proxy CA (23 Mar 2022, \E4\BA\92\E8\81\94\E7\BD\91\E5\BC\80\E5\8F\91\E9\83\A8-\E6\9E\97\E5\A8\81)&quot;, OU = https://charlesproxy.com/ssl, O = XK72 Ltd, L = Auckland, ST = Auckland, C = NZ        Subject Public Key Info:            Public Key Algorithm: rsaEncryption                RSA Public-Key: (2048 bit)                Modulus:                    00:b8:ca:61:56:ee:b3:ae:94:0d:2b:5d:da:c0:a1:                    cb:e3:3e:d2:19:22:03:88:57:0d:a6:96:7e:4f:2e:                    11:9e:8d:45:c6:ef:e8:d7:86:dc:eb:a6:94:56:d9:                    25:0e:63:4a:1d:37:22:1d:e5:83:19:c7:1b:a3:c8:                    d7:69:29:82:dc:e7:a7:04:66:73:f1:1e:1c:16:6f:                    fd:e5:79:97:c5:b5:29:d3:a9:27:3a:f3:88:c0:6a:                    ef:e9:e4:5f:c4:5d:68:80:f2:bf:65:75:25:24:c3:                    e6:44:74:1c:e8:5d:c3:06:45:13:cc:7c:fd:b2:70:                    ed:d1:41:9c:ae:33:b7:5e:84:c6:4b:67:86:41:d1:                    75:2b:79:6c:52:e5:8b:58:05:68:3b:42:1b:a0:35:                    85:bf:3f:25:05:b4:a5:60:68:d0:6d:42:63:37:e1:                    67:82:e3:3d:2e:d6:9f:9a:8a:ff:2f:14:df:df:cc:                    cf:67:a9:4f:68:19:18:a2:f6:6d:95:46:79:e7:4d:                    93:58:25:f5:fb:21:f0:40:59:38:0b:4c:a3:c8:7f:                    9d:2f:12:87:fc:0a:20:08:75:e8:29:a7:d0:44:48:                    d1:d8:36:f5:6a:53:eb:e0:6f:5a:41:ce:f8:1b:f2:                    e3:35:d3:c1:03:86:30:17:0c:0b:d5:f4:59:90:81:                    6c:79                Exponent: 65537 (0x10001)        X509v3 extensions:            X509v3 Basic Constraints: critical                CA:TRUE            Netscape Comment:                ....This Root certificate was generated by Charles Proxy for SSL Proxying. If this certificate is part of a certificate chain, this means that you&#x27;re browsing through Charles Proxy with SSL Proxying enabled for this website. Please see http://charlesproxy.com/ssl for more information.            X509v3 Key Usage: critical                Certificate Sign            X509v3 Subject Key Identifier:                4D:45:D9:BF:C6:09:B5:13:ED:13:C0:39:AF:21:8A:FF:48:F2:F8:D0    Signature Algorithm: sha256WithRSAEncryption         8c:7b:ed:c6:f9:1b:ed:ba:e9:ed:6c:07:a8:0d:ff:7b:05:30:         1c:cd:cf:78:17:21:14:74:f7:f3:91:ba:12:2d:ef:98:91:94:         a3:d8:13:62:0f:05:31:57:86:54:48:02:7f:96:91:5a:d5:95:         10:78:ab:ba:f5:9f:18:1f:d1:23:b2:74:01:87:d7:d2:9b:ec:         94:b6:c7:4b:d6:28:d0:b7:07:17:65:e2:8a:5e:36:cd:93:5a:         cd:e9:bc:8e:00:ca:5d:f6:14:2a:ac:b8:de:38:91:3c:8d:14:         27:32:0b:5b:72:de:ee:7c:a6:81:bf:d8:b5:ba:67:e2:f6:9e:         35:5d:ef:c8:77:f1:ef:8d:b2:54:b7:70:12:29:39:3d:b8:12:         a0:22:4a:b1:d5:62:ba:35:a2:9d:4d:54:5d:c5:e7:ab:0a:54:         28:f9:b0:8d:8f:ec:48:ef:27:38:a6:6e:ba:62:28:ba:ca:60:         92:09:f2:cd:2b:23:85:1c:c5:93:2d:96:e6:30:69:f8:d0:cf:         6d:3f:e3:6e:52:c2:b1:af:be:75:d3:ba:35:58:b6:de:21:a3:         33:ea:fc:11:ed:08:87:a2:95:e8:3b:06:d4:c0:5f:a5:7e:a4:         39:52:d1:40:18:6a:38:22:07:fc:c9:78:8f:a7:dc:9b:7b:13:         71:a9:6c:53</code></pre></div><p><img src="/image/2021-03-30-https/cert_structure.awebp" alt="证书结构"></p><h2 id="校验流程"><a href="#校验流程" class="headerlink" title="校验流程"></a>校验流程</h2><ol><li><p>证书的下发与校验发生在 SSL 握手期间，服务端在第三步下发证书给客户端，客户端在第六步进行证书的校验</p></li><li><p>校验证书链</p></li></ol><p>CA 会给颁发的证书签名，所谓签名就是用 CA 私钥对证书摘要进行加密操作得到输出：<code>encrypt(digest(cert), privKey) = signature</code>，那么校验签名就是：<code>digest(cert) == decrypt(signature, pubKey)</code></p><p>客户端可以通过服务端证书的 <code>Issuer</code> 字段得知 CA，然后在内置/配置的受信任 CA 列表里找到对应的 CA 证书，从 CA 证书的 <code>Subject Public Key Info</code> 找到 CA 公钥 <code>pubKey</code></p><p>用服务端证书签名字段 <code>Signature Algorithm</code> 里的加密算法 <code>decrypt</code>，和上面找到的 CA 公钥 <code>pubKey</code>，解密签名得到正确的证书摘要 <code>signed digest = decrypt(signature, pubKey)</code>，这个摘要是受到 CA 私钥加密保护的所以无法被篡改</p><p>客户端计算服务端证书的摘要 <code>digest = digest(cert)</code>，如果与 <code>signed digest</code> 一致说明证书未篡改</p><p>重复以上过程直到最终构建出一条完整的证书链，这个证书链的顶端必须是受信任的根 CA，这条证书链才算校验通过</p><p><img src="/image/2021-03-30-https/ssl_handshake.awebp" alt="SSL握手"></p><ol start="3"><li>是否在上级证书的吊销列表里</li></ol><p>有两种方式：</p><ul><li><p>证书吊销列表校验：CRL（Certificate Revocation List），它是一个单独的文件，该文件包含了 CA 已经吊销的证书序列号与吊销日期；证书中一般会包含一个 URL 地址（CRL Distribution Point），通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，这期间可能已经造成了极大损失</p></li><li><p>证书状态在线查询：OCSP（Online Certificate Status Protocol），一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。部分 CA 或大部分的自签 CA 都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情</p></li></ul><ol start="4"><li>证书是否过期</li></ol><p><code>Validity</code> 字段，证书有效期在 <code>[Not Before, Not After]</code> 之间</p><ol start="5"><li>服务器域名是否与证书主体匹配</li></ol><p>比如访问谷歌邮箱 <code>https://mail.google.com/mail/u/0/#inbox</code>，服务端下发的证书里的主体是 <code>Subject: CN = mail.google.com</code></p><p>主体名还可以用通配符，比如博客园 <code>https://www.cnblogs.com/blogs-of-lxl/p/10136582.html</code> 里证书主体是 <code>Subject: CN = *.cnblogs.com</code></p><h2 id="自定义-CA"><a href="#自定义-CA" class="headerlink" title="自定义 CA"></a>自定义 CA</h2><p>然而现实情况往往来得更加复杂：</p><ul><li><p>终端设备没有及时更新 CA 列表，导致某些 CA 在此设备上失效了</p></li><li><p>终端设备不可信，导入了一些不可信/失效的 CA 证书，导致 app 流量被捕获（比如 Charles 等各种代理工具）</p></li><li><p>证书链上的某些中间 CA 证书是不公开的，只在公司网络/产品内使用</p></li><li><p>测试环境需要信任自签 CA 证书以捕获流量</p></li><li><p>…</p></li></ul><p>所以 android 有两种自定义 CA 的基于配置文件的方式（都有对应的代码方式）：</p><ol><li>只信任指定 CA 而不是系统默认 CA</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">network-security-config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">domain-config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">includeSubdomains</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>secure.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">includeSubdomains</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>cdn.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">trust-anchors</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">certificates</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;@raw/trusted_roots&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">certificates</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;@raw/my_ca&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">trust-anchors</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">domain-config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">network-security-config</span>&gt;</span></code></pre></div><ol start="2"><li>信任所有公钥哈希匹配的证书</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">network-security-config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">domain-config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">domain</span> <span class="hljs-attr">includeSubdomains</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>example.com<span class="hljs-tag">&lt;/<span class="hljs-name">domain</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">pin-set</span> <span class="hljs-attr">expiration</span>=<span class="hljs-string">&quot;2018-01-01&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pin</span> <span class="hljs-attr">digest</span>=<span class="hljs-string">&quot;SHA-256&quot;</span>&gt;</span>7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=<span class="hljs-tag">&lt;/<span class="hljs-name">pin</span>&gt;</span>            <span class="hljs-comment">&lt;!-- backup pin --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pin</span> <span class="hljs-attr">digest</span>=<span class="hljs-string">&quot;SHA-256&quot;</span>&gt;</span>fwza0LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM1oE=<span class="hljs-tag">&lt;/<span class="hljs-name">pin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">pin-set</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">domain-config</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">network-security-config</span>&gt;</span></code></pre></div><h1 id="提问时间"><a href="#提问时间" class="headerlink" title="提问时间"></a>提问时间</h1><ol><li>怎么证明CA机构的公钥是可信的</li></ol><p>CA 证书是从上到下一级一级地签发下来的（证书链），操作系统内置根 CA 证书（证书里包含 CA 公钥），可以从下到上逐级确认</p><ol start="2"><li>如何防范中间人攻击</li></ol><p>这个可以采用从下至上的方式递推：</p><ul><li><p>client 与 server 之间传输数据经过对称加密，中间人不知道秘钥 primaryKey 所以无法偷听和篡改</p></li><li><p>主密钥 primaryKey 是通过秘钥协商协议在 client 和 server 各自的本地计算出来的：<code>primaryKey = f(clientLocal, serverPublics) = f(serverLocal, clientPublics)</code>，local 都各自存在于 client 和 server 本地，只有 publics 才需要传输，中间人只能拿到 publics 缺失 local 是不能计算出 primaryKey 的</p></li><li><p>server 把 serverPublics 用 server 私钥加密发送给 client，client 从证书里拿到 server 公钥解密，并用 server 公钥加密 clientPublics 发送给 server，server 通过自己私钥解密</p></li><li><p>中间人可以从 server 证书拿到 server 公钥，从而偷听到 serverPublics，但它没有 server 私钥，也无法篡改 server 证书里的 server 公钥，所以无法篡改 serverPublics</p></li><li><p>同样中间人没有 server 私钥所以无法篡改经过 server 公钥加密发送给 server 的 clientPublics</p></li><li><p>server 证书由受信任的 CA 签发（用 CA 私钥加密证书摘要），server 没有 CA 私钥所以无法篡改 server 证书，同时受信任 CA 证书列表内置于 client，证书内包含 CA 公钥，于是中间人也无法用假的 CA 密钥对伪造 server 证书</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.cn/post/7186837003026038843">货拉拉SSL证书踩坑之旅 - 货拉拉技术 - 掘金</a></li><li><a href="https://developer.android.com/training/articles/security-config">Network security configuration</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <link href="/2021/03/13/tcp-handshake-goodbye/"/>
    <url>/2021/03/13/tcp-handshake-goodbye/</url>
    
    <content type="html"><![CDATA[<p><img src="../../../../image/2021-03-23-tcp-handshake-goodbye/tcp_header.jpeg" alt="tpc_header.jpeg"></p><h2 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h2><ul><li>从 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号，这个序号称为 <strong>字节序号</strong></li><li>如果一个 TCP 报文的 <strong>报文序号</strong> 为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文携带的第一个字节序号是 301，最后一个字节序号是 400</li><li>每传送一个 TCP 报文都要等待对方回复一个确认，但这种方式效率太低，在 TCP 协议中，一般采用累积确认的方式，即每次传送多个连续 TCP 报文，可以只对最后一个 TCP 报文进行确认。对方通过回复一个 <strong>确认号</strong> 来表示已经接收到了哪个 TCP 报文。比如发送方发送了一个序号为 301 的 TCP 报文，这个报文携带了 100 字节数据，则接收方应当回复的确认号是 401，它表示接收方已经收到了字节序号为 [300, 400] 的数据，现在期望你发送字节序号为 401 以及以后的数据</li></ul><h2 id="SYN、ACK-和-FIN"><a href="#SYN、ACK-和-FIN" class="headerlink" title="SYN、ACK 和 FIN"></a>SYN、ACK 和 FIN</h2><ul><li><code>ACK</code>：TCP 协议规定，只有 <code>ACK=1</code> 时有效，也规定连接建立后所有发送的报文的 <code>ACK</code> 必须为 1</li><li><code>SYN</code>：在连接建立时用来同步序号。当 <code>SYN=1</code> 而 <code>ACK=0</code> 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 <code>SYN=1</code> 和 <code>ACK=1</code>。因此 <code>SYN</code> 置 1 就表示这是一个连接请求或连接接受报文</li><li><code>FIN</code>：用来释放一个连接。当 <code>FIN=1</code> 表明此发送方的数据已经发送完毕并要求释放连接</li></ul><h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2><p><img src="../../../../image/2021-03-23-tcp-handshake-goodbye/tcp_sequence.jpeg"></p><p>TCP 需要建立一条可靠的连接，那么对于一条可靠的连接来说，最起码的是发出去的请求能收到对方的确认。所以 Client 发送 <code>SYN</code> 并受到 <code>ACK</code> 后，才能确认连接建立，同样 Server 也需要发送 <code>SYN</code> 并受到 <code>ACK</code> 才能确认建立连接，这样最少需要三次请求，也就是 <strong>三次握手</strong></p><p>TCP 是全双工模式，也就是双方可以同时发送和接收消息。Client 发送 <code>FIN</code> 并收到 <code>ACK</code> 只是确认了 Client 没有更多数据需要传输，此时 Client 不能关闭连接，因为 Server 可能还会有数据传输过来。而当 Server 发送 <code>FIN</code> 并收到 <code>ACK</code> 后，双方都确认没有更多的消息需要传递，于是关闭连接。这样最少需要 <strong>四次挥手</strong></p><p>四次挥手之所以比三次握手多一次是因为：</p><ol><li>TCP 需要建立连接后才能传输数据，于是乎在建立连接的过程中肯定没有数据报文，可以把 <code>SYN</code> 和 <code>ACK</code> 合并为一个报文节省流量</li><li>而断开连接时，Server 回复 <code>ACK</code> 响应 Client 的 <code>FIN</code> 后，Server 依然可以继续发送报文，此时 Client 进入等待状态继续接收 Server 报文直到 Server 发送完毕并发送 <code>FIN</code>，<code>FIN</code> 和 <code>ACK</code> 并不能合并为一个报文</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析 Tinker 是如何实现热修复的</title>
    <link href="/2021/03/12/how-tinker-work/"/>
    <url>/2021/03/12/how-tinker-work/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tinker 是微信团队开源的一款 android 热修复框架，它的使用流程大体是：</p><ul><li>client 安装 V1.apk</li><li>提交了一些 hotfix，打包出 V2.apk</li><li>利用 Tinker 提供的差分工具，在 server 计算出补丁包 patch1.apk，并下发给 client</li><li>client 收到补丁包后，在后台给 V1.apk 打上 patch1.apk 得到 V2.apk（V1.apk + patch1.apk = V2.apk）</li><li>app 在下次启动时，将加载 V2.apk</li></ul><p>它的工作目录大概是这样的：</p><div class="code-wrapper"><pre><code class="hljs xml">- /data/user/0/tinker.sample.android/tinker    - info.lock    - patch.info    - patch-d1ec6aa9        - patch-d1ec6aa9.apk        - dex            - tinker_classN.apk            - oat                - tinker_classN.apk.cur.prof                - x86                    - tinker_classN.vdex                    - tinker_classN.odex        - res            - resources.apk        - lib            - lib                - armeabi                    - libmmkv.so                - ...        - odex</code></pre></div><p>注入代码和资源的时序图如下</p><p><img src="../../../../image/2021-03-12-how-tinker-work/inject.jpg" alt="inject.jpg"></p><h2 id="代码的热更新"><a href="#代码的热更新" class="headerlink" title="代码的热更新"></a>代码的热更新</h2><h3 id="使用-TinkerClassLoader"><a href="#使用-TinkerClassLoader" class="headerlink" title="使用 TinkerClassLoader"></a>使用 <code>TinkerClassLoader</code></h3><p>Tinker 代码热更新的原理是用 <code>TinkerClassLoader</code> 替代原有的 <code>ClassLoader</code>，这样 V2 版本的类就会被优先加载，从而实现「覆盖」旧代码的功能</p><p><code>TinkerClassLoader</code> 打破了传统的双亲委派模式，其内部相当于有两个 <code>ClassLoader</code></p><ul><li><code>TinkerClassLoader</code>，包含 V2 版本的代码</li><li><code>mOriginAppClassLoader</code>，android app 的类加载器，包含 V1 版本的代码</li></ul><p>加载类的时候，首先从自身加载（也就是优先加载 V2 版本的代码），然后再从 app 的类加载器中加载（V1 版本的代码就会被 V2 所覆盖）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TinkerClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PathClassLoader</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader mOriginAppClassLoader;    TinkerClassLoader(String dexPath, File optimizedDir, String libraryPath, ClassLoader originAppClassLoader) &#123;        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;&quot;</span>, libraryPath, ClassLoader.getSystemClassLoader());        mOriginAppClassLoader = originAppClassLoader;        injectDexPath(<span class="hljs-built_in">this</span>, dexPath, optimizedDir);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        Class&lt;?&gt; cl = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            cl = <span class="hljs-built_in">super</span>.findClass(name);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;            cl = <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">if</span> (cl != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> cl;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> mOriginAppClassLoader.loadClass(name);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">injectDexPath</span><span class="hljs-params">(ClassLoader cl, String dexPath, File optimizedDir)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> List&lt;File&gt; dexFiles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">16</span>);            <span class="hljs-keyword">for</span> (String oneDexPath : dexPath.split(<span class="hljs-string">&quot;:&quot;</span>)) &#123;                <span class="hljs-keyword">if</span> (oneDexPath.isEmpty()) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                dexFiles.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(oneDexPath));            &#125;            <span class="hljs-keyword">if</span> (!dexFiles.isEmpty()) &#123;                SystemClassLoaderAdder.injectDexesInternal(cl, dexFiles, optimizedDir);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable thr) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TinkerRuntimeException</span>(<span class="hljs-string">&quot;Fail to create TinkerClassLoader.&quot;</span>, thr);        &#125;    &#125;&#125;</code></pre></div><p>创建 <code>TinkerClassLoader</code></p><div class="code-wrapper"><pre><code class="hljs java">ClassLoader NewClassLoaderInjector.inject(Application app, ClassLoader oldClassLoader,  File dexOptDir, <span class="hljs-type">boolean</span> useDLC, List&lt;File&gt; patchedDexes) <span class="hljs-keyword">throws</span> Throwable &#123;    <span class="hljs-keyword">final</span> String[] patchedDexPaths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[patchedDexes.size()];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; patchedDexPaths.length; ++i) &#123;        patchedDexPaths[i] = patchedDexes.get(i).getAbsolutePath();    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">newClassLoader</span> <span class="hljs-operator">=</span> createNewClassLoader(oldClassLoader, dexOptDir, useDLC, patchedDexPaths);    doInject(app, newClassLoader);    <span class="hljs-keyword">return</span> newClassLoader;&#125;ClassLoader NewClassLoaderInjector.createNewClassLoader(ClassLoader oldClassLoader, File dexOptDir, <span class="hljs-type">boolean</span> useDLC, String... patchDexPaths) <span class="hljs-keyword">throws</span> Throwable &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">Field</span> <span class="hljs-variable">pathListField</span> <span class="hljs-operator">=</span> findField(Class.forName(<span class="hljs-string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, <span class="hljs-literal">false</span>, oldClassLoader), <span class="hljs-string">&quot;pathList&quot;</span>);    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">oldPathList</span> <span class="hljs-operator">=</span> pathListField.get(oldClassLoader);    <span class="hljs-comment">// V2 版本的 dex 列表（apk 包），组合为字符串</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">dexPathBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasPatchDexPaths</span> <span class="hljs-operator">=</span> patchDexPaths != <span class="hljs-literal">null</span> &amp;&amp; patchDexPaths.length &gt; <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (hasPatchDexPaths) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; patchDexPaths.length; ++i) &#123;            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;                dexPathBuilder.append(File.pathSeparator);            &#125;            dexPathBuilder.append(patchDexPaths[i]);        &#125;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">combinedDexPath</span> <span class="hljs-operator">=</span> dexPathBuilder.toString();    <span class="hljs-comment">// 把 V1 版本的 so 文件目录组合为字符串</span>    <span class="hljs-comment">// so 文件目录其实一直是固定的，比如上面提到的 /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/lib/x86</span>    <span class="hljs-comment">// 这是因为 V2 版本的 so 文件被释放到这个目录，把 V1 版本的文件给覆盖掉了（在合成新版本的章节会介绍）</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">Field</span> <span class="hljs-variable">nativeLibraryDirectoriesField</span> <span class="hljs-operator">=</span> findField(oldPathList.getClass(), <span class="hljs-string">&quot;nativeLibraryDirectories&quot;</span>);    List&lt;File&gt; oldNativeLibraryDirectories = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (nativeLibraryDirectoriesField.getType().isArray()) &#123;        oldNativeLibraryDirectories = Arrays.asList((File[]) nativeLibraryDirectoriesField.get(oldPathList));    &#125; <span class="hljs-keyword">else</span> &#123;        oldNativeLibraryDirectories = (List&lt;File&gt;) nativeLibraryDirectoriesField.get(oldPathList);    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">libraryPathBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    <span class="hljs-type">boolean</span> <span class="hljs-variable">isFirstItem</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span> (File libDir : oldNativeLibraryDirectories) &#123;        <span class="hljs-keyword">if</span> (libDir == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (isFirstItem) &#123;            isFirstItem = <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            libraryPathBuilder.append(File.pathSeparator);        &#125;        libraryPathBuilder.append(libDir.getAbsolutePath());    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">combinedLibraryPath</span> <span class="hljs-operator">=</span> libraryPathBuilder.toString();    <span class="hljs-comment">// 构造 TinkerClassLoader</span>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (useDLC &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="hljs-number">27</span>) &#123;        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegateLastClassLoader</span>(combinedDexPath, combinedLibraryPath, ClassLoader.getSystemClassLoader());        <span class="hljs-keyword">final</span> <span class="hljs-type">Field</span> <span class="hljs-variable">parentField</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredField(<span class="hljs-string">&quot;parent&quot;</span>);        parentField.setAccessible(<span class="hljs-literal">true</span>);        parentField.set(result, oldClassLoader);    &#125; <span class="hljs-keyword">else</span> &#123;        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TinkerClassLoader</span>(combinedDexPath, dexOptDir, combinedLibraryPath, oldClassLoader);    &#125;    <span class="hljs-comment">// &#x27;EnsureSameClassLoader&#x27; mechanism which is first introduced in Android O</span>    <span class="hljs-comment">// may cause exception if we replace definingContext of old classloader.</span>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">26</span>) &#123;        findField(oldPathList.getClass(), <span class="hljs-string">&quot;definingContext&quot;</span>).set(oldPathList, result);    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h3 id="替代-PathClassLoader"><a href="#替代-PathClassLoader" class="headerlink" title="替代 PathClassLoader"></a>替代 <code>PathClassLoader</code></h3><p><code>PathClassLoader</code> 结构如下，因为没有公开方法设置 <code>optimizeDir</code>（odex 文件目录，后续会讲到 Tinker 触发 dex 优化时把文件输出目录设置在 patch dir 内），需要通过反射重新构造 <code>dexElements</code></p><div class="code-wrapper"><pre><code class="hljs html">- dalvik.system.PathClassLoader（继承自 BaseDexClassLoader）    - pathList: DexPathList        - nativeLibraryDirectories: File[]            - 0                - /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/lib/x86        - dexElements: Element[]            - 0                - path: File = /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/base.apk                - dexFile: DexFile = /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/base.apk                - initialized: Boolean = false                - urlHandler: ClassPathURLStreamHandler = null</code></pre></div><p>不同 android 版本里 app class loader 的实现和结构可能是不同的，需要分开处理；Tinker 整理出了 V23、V19、V14 和 V4 四个版本</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SystemClassLoaderAdder.injectDexesInternal(ClassLoader cl, List&lt;File&gt; dexFiles, File optimizeDir) <span class="hljs-keyword">throws</span> Throwable &#123;    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">23</span>) &#123;        V23.install(cl, dexFiles, optimizeDir);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">19</span>) &#123;        V19.install(cl, dexFiles, optimizeDir);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">14</span>) &#123;        V14.install(cl, dexFiles, optimizeDir);    &#125; <span class="hljs-keyword">else</span> &#123;        V4.install(cl, dexFiles, optimizeDir);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">V23</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">install</span><span class="hljs-params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory)</span>        <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException,        NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123;        <span class="hljs-comment">/* The patched class loader is expected to be a descendant of</span><span class="hljs-comment">         * dalvik.system.BaseDexClassLoader. We modify its</span><span class="hljs-comment">         * dalvik.system.DexPathList pathList field to append additional DEX</span><span class="hljs-comment">         * file entries.</span><span class="hljs-comment">         */</span>        <span class="hljs-type">Field</span> <span class="hljs-variable">pathListField</span> <span class="hljs-operator">=</span> ShareReflectUtil.findField(loader, <span class="hljs-string">&quot;pathList&quot;</span>);        <span class="hljs-type">Object</span> <span class="hljs-variable">dexPathList</span> <span class="hljs-operator">=</span> pathListField.get(loader);        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IOException&gt;();        ShareReflectUtil.expandFieldArray(dexPathList, <span class="hljs-string">&quot;dexElements&quot;</span>, makePathElements(dexPathList,            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,            suppressedExceptions));        <span class="hljs-keyword">if</span> (suppressedExceptions.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (IOException e : suppressedExceptions) &#123;                ShareTinkerLog.w(TAG, <span class="hljs-string">&quot;Exception in makePathElement&quot;</span>, e);                <span class="hljs-keyword">throw</span> e;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * A wrapper around</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> private static final dalvik.system.DexPathList#makePathElements&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object[] makePathElements(        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,        ArrayList&lt;IOException&gt; suppressedExceptions)        <span class="hljs-keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;        Method makePathElements;        <span class="hljs-keyword">try</span> &#123;            makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="hljs-string">&quot;makePathElements&quot;</span>, List.class, File.class, List.class);        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;            ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makePathElements(List,File,List) failure&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="hljs-string">&quot;makePathElements&quot;</span>, ArrayList.class, File.class, ArrayList.class);            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e1) &#123;                ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: try use v19 instead&quot;</span>);                    <span class="hljs-keyword">return</span> V19.makeDexElements(dexPathList, files, optimizedDirectory, suppressedExceptions);                &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e2) &#123;                    ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makeDexElements(List,File,List) failure&quot;</span>);                    <span class="hljs-keyword">throw</span> e2;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> (Object[]) makePathElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);    &#125;&#125;</code></pre></div><h3 id="注入-TinkerClassLoader"><a href="#注入-TinkerClassLoader" class="headerlink" title="注入 TinkerClassLoader"></a>注入 <code>TinkerClassLoader</code></h3><p>注入 <code>TinkerClassLoader</code>，有这么几个地方：</p><ul><li><code>Thread.getContextClassLoader()</code></li><li><code>Application.mBase(ContextImpl).mClassLoader</code></li><li><code>Application.mBase(ContextImpl).mPackageInfo(LoadedApk).mClassLoader</code></li><li><code>Resources.mClassLoader</code></li><li><code>Resources.mDrawableInflater(DrawableInflater).mClassLoader</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> NewClassLoaderInjector.doInject(Application app, ClassLoader classLoader) <span class="hljs-keyword">throws</span> Throwable &#123;    Thread.currentThread().setContextClassLoader(classLoader);    <span class="hljs-keyword">final</span> <span class="hljs-type">Context</span> <span class="hljs-variable">baseContext</span> <span class="hljs-operator">=</span> (Context) findField(app.getClass(), <span class="hljs-string">&quot;mBase&quot;</span>).get(app);    <span class="hljs-keyword">try</span> &#123;        findField(baseContext.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(baseContext, classLoader);    &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;        <span class="hljs-comment">// There&#x27;s no mClassLoader field in ContextImpl before Android O.</span>        <span class="hljs-comment">// However we should try our best to replace this field in case some</span>        <span class="hljs-comment">// customized system has one.</span>    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">basePackageInfo</span> <span class="hljs-operator">=</span> findField(baseContext.getClass(), <span class="hljs-string">&quot;mPackageInfo&quot;</span>).get(baseContext);    findField(basePackageInfo.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(basePackageInfo, classLoader);    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Resources</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> app.getResources();        <span class="hljs-keyword">try</span> &#123;            findField(res.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(res, classLoader);            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">drawableInflater</span> <span class="hljs-operator">=</span> findField(res.getClass(), <span class="hljs-string">&quot;mDrawableInflater&quot;</span>).get(res);            <span class="hljs-keyword">if</span> (drawableInflater != <span class="hljs-literal">null</span>) &#123;                findField(drawableInflater.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(drawableInflater, classLoader);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;            <span class="hljs-comment">// Ignored.</span>        &#125;    &#125;&#125;</code></pre></div><p>上面列出的几个 <code>ClassLoader</code>，其中有两个是比较重要的</p><p><code>Application.mBase(ContextImpl).mClassLoader</code> 是在实例化 <code>ApplicationLike</code> 时用到；为了能够加载到 V2 版本的代码，app application 必须设置为 <code>TinkerApplication</code>（它是 Tinker 库的类，只要不更新 Tinker 版本，业务的迭代更新一般不会改动到它，所以它是比较稳定不变的）；在注入 <code>TinkerClassLoader</code> 后，通过反射调用业务方的 <code>ApplicationLike</code>（业务代码较常变动）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> TinkerApplication.attachBaseContext(Context base)<span class="hljs-keyword">void</span> TinkerApplication.onBaseContextAttached(Context base, <span class="hljs-type">long</span> applicationStartElapsedTime, <span class="hljs-type">long</span> applicationStartMillisTime) &#123;    loadTinker();  <span class="hljs-comment">// 先注入 TinkerClassLoader</span>    mCurrentClassLoader = base.getClassLoader();  <span class="hljs-comment">// Application.mBase(ContextImpl).mClassLoader</span>    mInlineFence = createInlineFence(<span class="hljs-built_in">this</span>, tinkerFlags, delegateClassName, tinkerLoadVerifyFlag,         applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);&#125;Handler TinkerApplication.createInlineFence(Application app, <span class="hljs-type">int</span> tinkerFlags, String delegateClassName, <span class="hljs-type">boolean</span> tinkerLoadVerifyFlag,     <span class="hljs-type">long</span> applicationStartElapsedTime, <span class="hljs-type">long</span> applicationStartMillisTime, Intent resultIntent) &#123;    <span class="hljs-comment">// delegateClassName 比如 tinker.sample.android.app.SampleApplicationLike</span>    <span class="hljs-comment">// 此时 mCurrentClassLoader 是 TinkerClassLoader</span>    <span class="hljs-keyword">final</span> Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="hljs-literal">false</span>, mCurrentClassLoader);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p><code>Application.mBase(ContextImpl).mPackageInfo(LoadedApk).mClassLoader</code> 在实例化 <code>Activity</code> 时会用到，在<a href="../../../../2020/11/03/launch-activity-sequence/">这篇文章</a>里可以找到入口点：</p><div class="code-wrapper"><pre><code class="hljs java">ActivityThread.handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)=ActivityThread.performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> createBaseContextForActivity(r);    <span class="hljs-type">Activity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 用这个 cl 加载目标 Activity 类；而这个 cl 是上面 ContextImpl 的</span>        java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> appContext.getClassLoader();        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);        <span class="hljs-comment">// ...</span>&#125;Instrumentation.newActivity(ClassLoader cl, String className, Intent intent)     <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> intent != <span class="hljs-literal">null</span> &amp;&amp; intent.getComponent() != <span class="hljs-literal">null</span> ? intent.getComponent().getPackageName() : <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);&#125;AppComponentFactory.instantiateActivity(ClassLoader cl, String className, Intent intent)    <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;    <span class="hljs-keyword">return</span> (Activity) cl.loadClass(className).newInstance();&#125;ActivityThread.createBaseContextForActivity(ActivityClientRecord r) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> displayId;    <span class="hljs-keyword">try</span> &#123;        displayId = ActivityTaskManager.getService().getDisplayId(r.token);    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;        <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();    &#125;    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createActivityContext(<span class="hljs-built_in">this</span>, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);    <span class="hljs-comment">// ...</span>&#125;ContextImpl.createActivityContext(ActivityThread mainThread, LoadedApk packageInfo, ActivityInfo activityInfo,     IBinder activityToken, <span class="hljs-type">int</span> displayId, Configuration overrideConfiguration) &#123;    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;packageInfo&quot;</span>);    String[] splitDirs = packageInfo.getSplitResDirs();    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> packageInfo.getClassLoader();  <span class="hljs-comment">// ContextImpl.getClassLoader() 来自于 LoadedApk.mClassLoader</span>    <span class="hljs-comment">// ...</span>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextImpl</span>(<span class="hljs-literal">null</span>, mainThread, packageInfo, <span class="hljs-literal">null</span>, activityInfo.splitName, activityToken, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, classLoader, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="资源的热更新"><a href="#资源的热更新" class="headerlink" title="资源的热更新"></a>资源的热更新</h2><h3 id="app-resources"><a href="#app-resources" class="headerlink" title="app resources"></a>app resources</h3><p>对于资源的热更新 Tinker 做了两块</p><p>一块是针对 app context 的，Tinker 用新的资源包（比如上面说到的 <code>/data/user/0/tinker.sample.android/tinker/patch-d1ec6aa9/res/resources.apk</code>）构造出一个新的 <code>AssetManager</code>，替换掉 <code>Resources</code> 里旧的 <code>Resource.mResourcesImpl(ResourcesImpl).mAssets</code></p><div class="code-wrapper"><pre><code class="hljs java">TinkerResourceLoader.loadTinkerResources(TinkerApplication application, String directory, Intent intentResult)<span class="hljs-comment">// 资源热更新的逻辑在这里</span>TinkerResourcePatcher.monkeyPatchExistingResources(Context context, String externalResourceFile) <span class="hljs-keyword">throws</span> Throwable &#123;    <span class="hljs-comment">// ... 创建一个新的 AssetManager，它指向新的资源包</span>    <span class="hljs-keyword">if</span> (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Could not create new AssetManager&quot;</span>);    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Resources</span> <span class="hljs-variable">resources</span> <span class="hljs-operator">=</span> wr.get();        <span class="hljs-keyword">if</span> (resources == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 替换 Resources 里的 AssetManager</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//pre-N</span>            assetsFiled.set(resources, newAssetManager);        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;            <span class="hljs-comment">// N</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resourceImpl</span> <span class="hljs-operator">=</span> resourcesImplFiled.get(resources);            <span class="hljs-comment">// for Huawei HwResourcesImpl</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Field</span> <span class="hljs-variable">implAssets</span> <span class="hljs-operator">=</span> findField(resourceImpl, <span class="hljs-string">&quot;mAssets&quot;</span>);            implAssets.set(resourceImpl, newAssetManager);        &#125;        <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>app context 里的 <code>Resources</code> 是在构造 app context 的同时通过 <code>ResourcesManager.getResources</code> 创建的，而且 <code>ResourcesManager.mResourceReferences</code> 会持有一个它的弱引用</p><div class="code-wrapper"><pre><code class="hljs java">ActivityThread.handleBindApplication(AppBindData data) &#123;    <span class="hljs-comment">// ... 实例化 ContextImpl 和 Application</span>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 构造 app context（ContextImpl）和 Application</span>Application LoadedApk.makeApplication(<span class="hljs-type">boolean</span> forceDefaultAppClass, Instrumentation instrumentation) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(mActivityThread, <span class="hljs-built_in">this</span>);    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 在构造 ContextImpl 时候会创建 Resources</span>ContextImpl LoadedApk.createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123;    <span class="hljs-keyword">return</span> createAppContext(mainThread, packageInfo, <span class="hljs-literal">null</span>);&#125;ContextImpl LoadedApk.createAppContext(ActivityThread mainThread, LoadedApk packageInfo, String opPackageName) &#123;    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;packageInfo&quot;</span>);    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextImpl</span>(<span class="hljs-literal">null</span>, mainThread, packageInfo, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, opPackageName);    context.setResources(packageInfo.getResources());    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);    <span class="hljs-keyword">return</span> context;&#125;<span class="hljs-comment">// 通过 ResourcesManager.getResources() 创建 Resources 实例时，ResourcesManager.mResourceReferences 会持有一个它的弱引用</span>Resources LoadedApk.getResources() &#123;    <span class="hljs-keyword">if</span> (mResources == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">final</span> String[] splitPaths;        <span class="hljs-keyword">try</span> &#123;            splitPaths = getSplitPaths(<span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">catch</span> (NameNotFoundException e) &#123;            <span class="hljs-comment">// This should never fail.</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;null split not found&quot;</span>);        &#125;        mResources = ResourcesManager.getInstance().getResources(<span class="hljs-literal">null</span>, mResDir,                splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,                Display.DEFAULT_DISPLAY, <span class="hljs-literal">null</span>, getCompatibilityInfo(),                getClassLoader(), <span class="hljs-literal">null</span>);    &#125;    <span class="hljs-keyword">return</span> mResources;&#125;ResourcesManager.getResources(...) &#123;    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, <span class="hljs-string">&quot;ResourcesManager#getResources&quot;</span>);    <span class="hljs-keyword">final</span> <span class="hljs-type">ResourcesKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcesKey</span>(...);    classLoader = classLoader != <span class="hljs-literal">null</span> ? classLoader : ClassLoader.getSystemClassLoader();    <span class="hljs-keyword">if</span> (activityToken != <span class="hljs-literal">null</span>) &#123;        rebaseKeyForActivity(activityToken, key);    &#125;    <span class="hljs-comment">// Preload the ApkAssets required by the key to prevent performing heavy I/O while the</span>    <span class="hljs-comment">// ResourcesManager lock is held.</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">ApkAssetsSupplier</span> <span class="hljs-variable">assetsSupplier</span> <span class="hljs-operator">=</span> createApkAssetsSupplierNotLocked(key);    <span class="hljs-keyword">return</span> createResources(activityToken, key, classLoader, assetsSupplier);    &#125;ResourcesManager.createResources(...) &#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;        <span class="hljs-type">ResourcesImpl</span> <span class="hljs-variable">resourcesImpl</span> <span class="hljs-operator">=</span> findOrCreateResourcesImplForKeyLocked(key, apkSupplier);        <span class="hljs-keyword">if</span> (resourcesImpl == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">if</span> (activityToken != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> createResourcesForActivityLocked(activityToken, classLoader, resourcesImpl, key.mCompatInfo);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> createResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);        &#125;    &#125;&#125;ResourcesManager.createResourcesLocked(...) &#123;    cleanupReferences(mResourceReferences, mResourcesReferencesQueue);    <span class="hljs-type">Resources</span> <span class="hljs-variable">resources</span> <span class="hljs-operator">=</span> compatInfo.needsCompatResources() ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompatResources</span>(classLoader) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resources</span>(classLoader);    resources.setImpl(impl);    resources.setCallbacks(mUpdateCallbacks);    mResourceReferences.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(resources, mResourcesReferencesQueue));    <span class="hljs-keyword">return</span> resources;&#125;</code></pre></div><p><code>Application</code> 创建后会调用 <code>Application.attach</code>，后续会触发 <code>TinkerResourcePatcher.isResourceCanPatch</code> 和 <code>TinkerResourcePatcher.monkeyPatchExistingResources</code>，从而把 <code>ResourcesManager.mResourceReferences</code> 里的 <code>Resources</code> 都修改掉</p><div class="code-wrapper"><pre><code class="hljs java">Instrumentation.newApplication(ClassLoader cl, String className, Context context) <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> getFactory(context.getPackageName()).instantiateApplication(cl, className);    app.attach(context);    <span class="hljs-keyword">return</span> app;&#125;Application.attach(Context context) &#123;    attachBaseContext(context);    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125;TinkerLoader.tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent)TinkerResourceLoader.checkComplete(Context context, String directory, ShareSecurityCheck securityCheck, Intent intentResult)<span class="hljs-comment">// 通过反射拿到 ResourcesManager.mResourceReferences</span>TinkerResourceLoader.isResourceCanPatch(Context context) <span class="hljs-keyword">throws</span> Throwable &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// Iterate over all known Resources objects</span>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= KITKAT) &#123;        <span class="hljs-comment">//pre-N</span>        <span class="hljs-comment">// Find the singleton instance of ResourcesManager</span>        <span class="hljs-keyword">final</span> Class&lt;?&gt; resourcesManagerClass = Class.forName(<span class="hljs-string">&quot;android.app.ResourcesManager&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">Method</span> <span class="hljs-variable">mGetInstance</span> <span class="hljs-operator">=</span> findMethod(resourcesManagerClass, <span class="hljs-string">&quot;getInstance&quot;</span>);        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resourcesManager</span> <span class="hljs-operator">=</span> mGetInstance.invoke(<span class="hljs-literal">null</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Field</span> <span class="hljs-variable">fMActiveResources</span> <span class="hljs-operator">=</span> findField(resourcesManagerClass, <span class="hljs-string">&quot;mActiveResources&quot;</span>);            <span class="hljs-keyword">final</span> ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt; activeResources19 =                    (ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(resourcesManager);            references = activeResources19.values();        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException ignore) &#123;            <span class="hljs-comment">// N moved the resources to mResourceReferences</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Field</span> <span class="hljs-variable">mResourceReferences</span> <span class="hljs-operator">=</span> findField(resourcesManagerClass, <span class="hljs-string">&quot;mResourceReferences&quot;</span>);            references = (Collection&lt;WeakReference&lt;Resources&gt;&gt;) mResourceReferences.get(resourcesManager);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Field</span> <span class="hljs-variable">fMActiveResources</span> <span class="hljs-operator">=</span> findField(activityThread, <span class="hljs-string">&quot;mActiveResources&quot;</span>);        <span class="hljs-keyword">final</span> HashMap&lt;?, WeakReference&lt;Resources&gt;&gt; activeResources7 =                (HashMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(currentActivityThread);        references = activeResources7.values();    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h3 id="local-resources"><a href="#local-resources" class="headerlink" title="local resources"></a>local resources</h3><p>另一块是针对局部 <code>Context</code> 的，比如 <code>Activity</code>，从<a href="../../../../2020/11/03/launch-activity-sequence/">Activity 启动流程时序图</a>可以找到创建 <code>Activity</code> 的入口点</p><p>创建 <code>Activity</code> 的时候会创建并使用它自己的 <code>Context</code>，而且把 <code>Context.getResources</code> 指向从 <code>ActivityThread.mPackages</code> 里找到的资源目录，所以 Tinker 会在 <code>monkeyPatchExistingResources</code> 修改 <code>ActivityThread.mPackages</code> 指向新资源包</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建 Activity</span>ActivityThread.handleLaunchActivity ...ActivityThread.performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;        <span class="hljs-type">ActivityInfo</span> <span class="hljs-variable">aInfo</span> <span class="hljs-operator">=</span> r.activityInfo;    <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-literal">null</span>) &#123;        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> createBaseContextForActivity(r);    <span class="hljs-comment">// ...</span>    activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);    <span class="hljs-comment">// ...</span>    activity.attach(appContext, <span class="hljs-built_in">this</span>, getInstrumentation(), r.token,            r.ident, app, r.intent, r.activityInfo, title, r.parent,            r.embeddedID, r.lastNonConfigurationInstances, config,            r.referrer, r.voiceInteractor, window, r.configCallback,            r.assistToken);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 创建 Activity ContextImpl，可以看到它的 Resources 是指向 ActivityClientRecord.packageInfo.getResDir() 的</span><span class="hljs-comment">// 而 ActivityClientRecord.packageInfo 在上面被赋值了</span>ContextImpl.createBaseContextForActivity(ActivityClientRecord r) ContextImpl.createActivityContext(ActivityThread mainThread,        LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, <span class="hljs-type">int</span> displayId,        Configuration overrideConfiguration) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextImpl</span>(<span class="hljs-literal">null</span>, mainThread, packageInfo, <span class="hljs-literal">null</span>,            activityInfo.splitName, activityToken, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, classLoader, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// ...</span>    context.setResources(resourcesManager.createBaseTokenResources(activityToken,            packageInfo.getResDir(),            splitDirs,            packageInfo.getOverlayDirs(),            packageInfo.getApplicationInfo().sharedLibraryFiles,            displayId,            overrideConfiguration,            compatInfo,            classLoader,            packageInfo.getApplication() == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : packageInfo.getApplication().getResources().getLoaders()));    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// ActivityClientRecord.packageInfo 是从 ActivityThread.mPackages 里取的</span>ActivityThread.getPackageInfo(String packageName, CompatibilityInfo compatInfo, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> userId) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">differentUser</span> <span class="hljs-operator">=</span> (UserHandle.myUserId() != userId);    <span class="hljs-type">ApplicationInfo</span> <span class="hljs-variable">ai</span> <span class="hljs-operator">=</span> PackageManager.getApplicationInfoAsUserCached(            packageName,            PackageManager.GET_SHARED_LIBRARY_FILES            | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,            (userId &lt; <span class="hljs-number">0</span>) ? UserHandle.myUserId() : userId);    <span class="hljs-keyword">synchronized</span> (mResourcesManager) &#123;        WeakReference&lt;LoadedApk&gt; ref;        <span class="hljs-keyword">if</span> (differentUser) &#123;            <span class="hljs-comment">// Caching not supported across users</span>            ref = <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((flags &amp; Context.CONTEXT_INCLUDE_CODE) != <span class="hljs-number">0</span>) &#123;            ref = mPackages.get(packageName);        &#125; <span class="hljs-keyword">else</span> &#123;            ref = mResourcePackages.get(packageName);        &#125;        <span class="hljs-type">LoadedApk</span> <span class="hljs-variable">packageInfo</span> <span class="hljs-operator">=</span> ref != <span class="hljs-literal">null</span> ? ref.get() : <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (ai != <span class="hljs-literal">null</span> &amp;&amp; packageInfo != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (!isLoadedApkResourceDirsUpToDate(packageInfo, ai)) &#123;                List&lt;String&gt; oldPaths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();                LoadedApk.makePaths(<span class="hljs-built_in">this</span>, ai, oldPaths);                packageInfo.updateApplicationInfo(ai, oldPaths);            &#125;            <span class="hljs-keyword">if</span> (packageInfo.isSecurityViolation() &amp;&amp; (flags&amp;Context.CONTEXT_IGNORE_SECURITY) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(                        <span class="hljs-string">&quot;Requesting code from &quot;</span> + packageName                        + <span class="hljs-string">&quot; to be run in process &quot;</span>                        + mBoundApplication.processName                        + <span class="hljs-string">&quot;/&quot;</span> + mBoundApplication.appInfo.uid);            &#125;            <span class="hljs-keyword">return</span> packageInfo;        &#125;    &#125;    <span class="hljs-keyword">if</span> (ai != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> getPackageInfo(ai, compatInfo, flags);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// Tinker 将 ActivityThread.mPackages 里的 LoadedApk.mResDir 改为新的资源包</span>TinkerResourcePatcher.isResourceCanPatch(Context context) <span class="hljs-keyword">throws</span> Throwable &#123;    Class&lt;?&gt; activityThread = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);    <span class="hljs-comment">// ...</span>    packagesFiled = findField(activityThread, <span class="hljs-string">&quot;mPackages&quot;</span>);    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;        resourcePackagesFiled = findField(activityThread, <span class="hljs-string">&quot;mResourcePackages&quot;</span>);    &#125;    <span class="hljs-comment">// ...</span>&#125;TinkerResourcePatcher.monkeyPatchExistingResources(Context context, String externalResourceFile) <span class="hljs-keyword">throws</span> Throwable &#123;    <span class="hljs-keyword">if</span> (externalResourceFile == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">ApplicationInfo</span> <span class="hljs-variable">appInfo</span> <span class="hljs-operator">=</span> context.getApplicationInfo();    <span class="hljs-keyword">final</span> Field[] packagesFields;    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;        packagesFields = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>[]&#123;packagesFiled, resourcePackagesFiled&#125;;    &#125; <span class="hljs-keyword">else</span> &#123;        packagesFields = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>[]&#123;packagesFiled&#125;;    &#125;    <span class="hljs-keyword">for</span> (Field field : packagesFields) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(currentActivityThread);        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">loadedApk</span> <span class="hljs-operator">=</span> entry.getValue().get();            <span class="hljs-keyword">if</span> (loadedApk == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">resDirPath</span> <span class="hljs-operator">=</span> (String) resDir.get(loadedApk);            <span class="hljs-keyword">if</span> (appInfo.sourceDir.equals(resDirPath)) &#123;                resDir.set(loadedApk, externalResourceFile);            &#125;        &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>hotfix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Application 是如何被创建和初始化的？</title>
    <link href="/2021/03/02/how-application-being-created-and-init/"/>
    <url>/2021/03/02/how-application-being-created-and-init/</url>
    
    <content type="html"><![CDATA[<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>从 <code>startActivity</code> 开始，比如打开一个 app 的首页，当 app 未启动时就会走创建 <code>Application</code> 这条路</p><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/from_startActivity_to_zygote.png" alt="from_startActivity_to_zygote.png"></p><h2 id="AMS-承担的工作"><a href="#AMS-承担的工作" class="headerlink" title="AMS 承担的工作"></a>AMS 承担的工作</h2><p>其中的转折点在 <code>resumeTopActivityInnerLocked</code>，发现 app process 不存在，走启动 app process 的流程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> ActivityStack.resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;    <span class="hljs-comment">// ... Launching this app&#x27;s activity, make sure the app is no longer considered stopped. 下面是启动 Activity 的逻辑</span>    <span class="hljs-keyword">if</span> (next.attachedToProcess()) &#123;        <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 此时 app process 还没有起来，走下面一段逻辑</span>        <span class="hljs-comment">// Whoops, need to restart this activity!</span>        <span class="hljs-keyword">if</span> (!next.hasBeenLaunched) &#123;            next.hasBeenLaunched = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;                next.showStartingWindow(<span class="hljs-literal">null</span> <span class="hljs-comment">/* prev */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* newTask */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* taskSwich */</span>);            &#125;            <span class="hljs-keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="hljs-string">&quot;Restarting: &quot;</span> + next);        &#125;        <span class="hljs-keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="hljs-string">&quot;resumeTopActivityLocked: Restarting &quot;</span> + next);        mStackSupervisor.startSpecificActivity(next, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);    &#125;&#125;</code></pre></div><p>最后走到 <code>attemptZygoteSendArgsAndGetResult</code>，AMS 将 app 的相关参数通过 socket 发送给 zygote 进程，由 zygote 负责 fork 出一个 app process，这一段路程就算完结了</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.ProcessStartResult <span class="hljs-title function_">attemptZygoteSendArgsAndGetResult</span><span class="hljs-params">(ZygoteState zygoteState, String msgStr)</span> <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">zygoteWriter</span> <span class="hljs-operator">=</span> zygoteState.mZygoteOutputWriter;        <span class="hljs-keyword">final</span> <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">zygoteInputStream</span> <span class="hljs-operator">=</span> zygoteState.mZygoteInputStream;        zygoteWriter.write(msgStr);        zygoteWriter.flush();        Process.<span class="hljs-type">ProcessStartResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Process</span>.ProcessStartResult();        result.pid = zygoteInputStream.readInt();        result.usingWrapper = zygoteInputStream.readBoolean();        <span class="hljs-keyword">if</span> (result.pid &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;fork() failed&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;        zygoteState.close();        Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with Zygote - &quot;</span> + ex.toString());        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(ex);    &#125;&#125;</code></pre></div><p>值得注意的是，AMS 是通过 <code>LocalSocket</code> 与 zygote 交互的，它们建立连接的过程如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.ProcessStartResult ZygoteProcess.startViaZygote(...) &#123;    ArrayList&lt;String&gt; argsForZygote = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    argsForZygote.add(<span class="hljs-string">&quot;--runtime-args&quot;</span>);    <span class="hljs-comment">// 拼接字符串参数 ...</span>    <span class="hljs-keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), zygotePolicyFlags, argsForZygote);&#125;<span class="hljs-keyword">private</span> ZygoteState ZygoteProcess.openZygoteSocketIfNeeded(String abi) <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;    <span class="hljs-keyword">try</span> &#123;        attemptConnectionToPrimaryZygote();        <span class="hljs-keyword">if</span> (primaryZygoteState.matches(abi)) &#123;            <span class="hljs-keyword">return</span> primaryZygoteState;        &#125;        <span class="hljs-keyword">if</span> (mZygoteSecondarySocketAddress != <span class="hljs-literal">null</span>) &#123;            attemptConnectionToSecondaryZygote();            <span class="hljs-keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;                <span class="hljs-keyword">return</span> secondaryZygoteState;            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;Error connecting to zygote&quot;</span>, ioe);    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteStartFailedEx</span>(<span class="hljs-string">&quot;Unsupported zygote ABI: &quot;</span> + abi);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ZygoteProcess.attemptConnectionToPrimaryZygote() <span class="hljs-keyword">throws</span> IOException &#123;    <span class="hljs-keyword">if</span> (primaryZygoteState == <span class="hljs-literal">null</span> || primaryZygoteState.isClosed()) &#123;        primaryZygoteState = ZygoteState.connect(mZygoteSocketAddress, mUsapPoolSocketAddress);        maybeSetApiDenylistExemptions(primaryZygoteState, <span class="hljs-literal">false</span>);        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);    &#125;&#125;<span class="hljs-keyword">static</span> ZygoteState ZygoteState.connect(LocalSocketAddress zygoteSocketAddress, LocalSocketAddress usapSocketAddress) <span class="hljs-keyword">throws</span> IOException &#123;     DataInputStream zygoteInputStream;    BufferedWriter zygoteOutputWriter;    <span class="hljs-keyword">final</span> <span class="hljs-type">LocalSocket</span> <span class="hljs-variable">zygoteSessionSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalSocket</span>()    <span class="hljs-keyword">if</span> (zygoteSocketAddress == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;zygoteSocketAddress can&#x27;t be null&quot;</span>);    &#125;        <span class="hljs-keyword">try</span> &#123;        zygoteSessionSocket.connect(zygoteSocketAddress);        zygoteInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(zygoteSessionSocket.getInputStream());        zygoteOutputWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(zygoteSessionSocket.getOutputStream()), Zygote.SOCKET_BUFFER_SIZE);    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;        <span class="hljs-keyword">try</span> &#123;            zygoteSessionSocket.close();        &#125; <span class="hljs-keyword">catch</span> (IOException ignore) &#123;&#125;         <span class="hljs-keyword">throw</span> ex;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteState</span>(zygoteSocketAddress, usapSocketAddress, zygoteSessionSocket, zygoteInputStream, zygoteOutputWriter, getAbiList(zygoteOutputWriter, zygoteInputStream));&#125;</code></pre></div><h2 id="走入-zygote"><a href="#走入-zygote" class="headerlink" title="走入 zygote"></a>走入 zygote</h2><h3 id="从-zygote-开始"><a href="#从-zygote-开始" class="headerlink" title="从 zygote 开始"></a>从 zygote 开始</h3><p>下面就轮到 zygote 出场了，zygote 进程是 system server 和 app 进程的父进程，它在 java 的入口点是 <code>ZygoteInit.main</code>；zygote 启动后会加载各个进程共享的资源，然后启动 system server，最后工作在主循环 <code>runSelectLoop</code> 上；在 <code>runSelectLoop</code> 里，zygote 通过 <code>epoll</code> 监听 zygote server socket 并根据请求参数 fork 出 app 进程（上面也说到过 AMS 是通过 <code>LocalSocket</code> 请求让 zygote fork app process）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * zygote 的入口点</span><span class="hljs-comment"> * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,</span><span class="hljs-comment"> * and handles other tasks related to preparing the process for forking into applications.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ZygoteInit.main(String[] argv) &#123;    <span class="hljs-type">ZygoteServer</span> <span class="hljs-variable">zygoteServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">// ...</span>    zygoteServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZygoteServer</span>(isPrimaryZygote);    <span class="hljs-comment">// ...</span>    caller = zygoteServer.runSelectLoop(abiList);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>zygote server socket 实际上是个挂载在 <code>/dev/sockets/</code> 目录下的 FD，它是由脚本 <code>init.rc</code> 创建的，这个 FD 可以通过环境变量 <code>ANDROID_SOCKET_&lt;socketName&gt;</code> 获得</p><div class="code-wrapper"><pre><code class="hljs java">ZygoteServer(<span class="hljs-type">boolean</span> isPrimaryZygote) &#123;    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();    <span class="hljs-keyword">if</span> (isPrimaryZygote) &#123;        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);  <span class="hljs-comment">// PRIMARY_SOCKET_NAME = &quot;zygote&quot;</span>        mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);    &#125; <span class="hljs-keyword">else</span> &#123;        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);        mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);    &#125;    mUsapPoolSupported = <span class="hljs-literal">true</span>;    fetchUsapPoolPolicyProps();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Creates a managed LocalServerSocket object using a file descriptor</span><span class="hljs-comment"> * created by an init.rc script.  The init scripts that specify the</span><span class="hljs-comment"> * sockets name can be found in system/core/rootdir.  The socket is bound</span><span class="hljs-comment"> * to the file system in the /dev/sockets/ directory, and the file</span><span class="hljs-comment"> * descriptor is shared via the ANDROID_SOCKET_&lt;socketName&gt; environment</span><span class="hljs-comment"> * variable.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> LocalServerSocket Zygote.createManagedSocketFromInitSocket(String socketName) &#123;    <span class="hljs-type">int</span> fileDesc;    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">fullSocketName</span> <span class="hljs-operator">=</span> ANDROID_SOCKET_PREFIX + socketName;  <span class="hljs-comment">// ANDROID_SOCKET_PREFIX = &quot;ANDROID_SOCKET_&quot;</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> System.getenv(fullSocketName);        fileDesc = Integer.parseInt(env);    &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Socket unset or invalid: &quot;</span> + fullSocketName, ex);    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">FileDescriptor</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileDescriptor</span>();        fd.setInt$(fileDesc);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalServerSocket</span>(fd);    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(            <span class="hljs-string">&quot;Error building socket from file descriptor: &quot;</span> + fileDesc, ex);    &#125;&#125;</code></pre></div><p>而 zygote 主循环的整个代码就是 epoll 多路复用的模型</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Runs the zygote process&#x27;s select loop. Accepts new connections as</span><span class="hljs-comment"> * they happen, and reads commands from connections one spawn-request&#x27;s</span><span class="hljs-comment"> * worth at a time.</span><span class="hljs-comment"> */</span>Runnable ZygoteServer.runSelectLoop(String abiList) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-comment">// epoll 可以同时监听多个 FD：pollFDs，当 epoll 返回时要逐个处理</span>        StructPollfd[] pollFDs;        pollFDs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructPollfd</span>[socketFDs.size()];        <span class="hljs-type">int</span> <span class="hljs-variable">pollIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (FileDescriptor socketFD : socketFDs) &#123;            pollFDs[pollIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructPollfd</span>();            pollFDs[pollIndex].fd = socketFD;            pollFDs[pollIndex].events = (<span class="hljs-type">short</span>) POLLIN;            ++pollIndex;        &#125;        <span class="hljs-comment">// ... 阻塞直到 pollFDs 里有消息输入</span>        <span class="hljs-type">int</span> pollReturnValue;        <span class="hljs-keyword">try</span> &#123;            pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);        &#125; <span class="hljs-keyword">catch</span> (ErrnoException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;poll failed&quot;</span>, ex);        &#125;        <span class="hljs-comment">// ... 第一个 PD 总是 Zygote server socket，它接收 fork 请求并创建一个新的 FD 与对方交互</span>        <span class="hljs-keyword">while</span> (--pollIndex &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (pollIndex == <span class="hljs-number">0</span>) &#123;                <span class="hljs-type">ZygoteConnection</span> <span class="hljs-variable">newPeer</span> <span class="hljs-operator">=</span> acceptCommandPeer(abiList);                peers.add(newPeer);                socketFDs.add(newPeer.getFileDescriptor());            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;                <span class="hljs-comment">// 从 FD 里解析请求参数并处理</span>                <span class="hljs-type">ZygoteConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> peers.get(pollIndex);                <span class="hljs-type">boolean</span> <span class="hljs-variable">multipleForksOK</span> <span class="hljs-operator">=</span> !isUsapPoolEnabled() &amp;&amp; ZygoteHooks.indefiniteThreadSuspensionOK();                <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> connection.processCommand(<span class="hljs-built_in">this</span>, multipleForksOK);  <span class="hljs-comment">// commands alaways null in zygote server</span>                <span class="hljs-comment">// ...</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="fork-app-process"><a href="#fork-app-process" class="headerlink" title="fork app process"></a>fork app process</h3><p>下面看看 zygote 是怎么 fork 出 app process 的</p><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/fork_by_zygote.png" alt="fork_by_zygote.png"></p><p>在 <code>fork()</code> 系统调用后，返回 0 表示当前处于子进程，&gt; 0 处于父进程（也就是 zygote）</p><p>zygote 进程会继续它的主循环 <code>runSelectLoop</code>，而子进程会跳出主循环，执行 <code>ZygoteConnection.processCommand</code> 返回的 <code>Runnable</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ZygoteInit.main(String[] argv) &#123;    <span class="hljs-comment">// ...</span>    Runnable caller;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// ...</span>        Log.i(TAG, <span class="hljs-string">&quot;Accepting command socket connections&quot;</span>);        <span class="hljs-comment">// The select loop returns early in the child process after a fork and</span>        <span class="hljs-comment">// loops forever in the zygote.</span>        caller = zygoteServer.runSelectLoop(abiList);    &#125; ...    <span class="hljs-comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span>    <span class="hljs-comment">// command.</span>    <span class="hljs-keyword">if</span> (caller != <span class="hljs-literal">null</span>) &#123;        caller.run();    &#125;&#125;</code></pre></div><p>这个 <code>Runnable</code> 实际上是通过反射调用 <code>ActivityThread.main</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// app 进程的 entry point 被设置为 android.app.ActivityThread</span><span class="hljs-type">boolean</span> <span class="hljs-title function_">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, HostingRecord hostingRecord,</span><span class="hljs-params">        <span class="hljs-type">int</span> zygotePolicyFlags, <span class="hljs-type">boolean</span> disableHiddenApiChecks, <span class="hljs-type">boolean</span> disableTestApiChecks,</span><span class="hljs-params">        <span class="hljs-type">boolean</span> mountExtStorageFull, String abiOverride)</span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// Start the process.  It will either succeed and return a result containing</span>    <span class="hljs-comment">// the PID of the new process, or else throw a RuntimeException.</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">entryPoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;    <span class="hljs-keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime);&#125;<span class="hljs-comment">// 寻找方法 main(String[] args)</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">findStaticMain</span><span class="hljs-params">(String className, String[] argv, ClassLoader classLoader)</span> &#123;    Class&lt;?&gt; cl;    <span class="hljs-keyword">try</span> &#123;        cl = Class.forName(className, <span class="hljs-literal">true</span>, classLoader);    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Missing class when invoking static main &quot;</span> + className, ex);    &#125;    Method m;    <span class="hljs-keyword">try</span> &#123;        m = cl.getMethod(<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String[].class &#125;);    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Missing static main on &quot;</span> + className, ex);    &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Problem getting static main on &quot;</span> + className, ex);    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> m.getModifiers();    <span class="hljs-keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main method is not public and static on &quot;</span> + className);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAndArgsCaller</span>(m, argv);&#125;<span class="hljs-comment">// 通过反射调用 main 方法</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAndArgsCaller</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-comment">/** method to call */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method mMethod;    <span class="hljs-comment">/** argument array */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] mArgs;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MethodAndArgsCaller</span><span class="hljs-params">(Method method, String[] args)</span> &#123;        mMethod = method;        mArgs = args;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            mMethod.invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; mArgs &#125;);        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;            <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> ex.getCause();            <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;                <span class="hljs-keyword">throw</span> (RuntimeException) cause;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> Error) &#123;                <span class="hljs-keyword">throw</span> (Error) cause;            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);        &#125;    &#125;&#125;</code></pre></div><h2 id="Application-实例的创建和初始化"><a href="#Application-实例的创建和初始化" class="headerlink" title="Application 实例的创建和初始化"></a>Application 实例的创建和初始化</h2><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/create_application.png" alt="create_application.png"></p><p>app process 的起始点是 <code>ActivityThread.main</code>，做完所有准备龚州工作后进入 loop 循环，后续的任务通过 <code>Handler</code> 执行</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-comment">// ...</span>    Looper.prepareMainLooper();    <span class="hljs-comment">// ...</span>    Looper.loop();    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);&#125;</code></pre></div><p><code>ActivityThread.handleBindApplication</code> 是 <code>Application</code> 实例创建和初始化的地方</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ActivityThread.handleBindApplication(AppBindData data) &#123;    <span class="hljs-comment">// ...</span>    Application app;    <span class="hljs-keyword">final</span> StrictMode.<span class="hljs-type">ThreadPolicy</span> <span class="hljs-variable">savedPolicy</span> <span class="hljs-operator">=</span> StrictMode.allowThreadDiskWrites();    <span class="hljs-keyword">final</span> StrictMode.<span class="hljs-type">ThreadPolicy</span> <span class="hljs-variable">writesAllowedPolicy</span> <span class="hljs-operator">=</span> StrictMode.getThreadPolicy();    <span class="hljs-keyword">try</span> &#123;        app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);        <span class="hljs-comment">// ...</span>    &#125; ...&#125;<span class="hljs-keyword">public</span> Application LoadedApk.makeApplication(<span class="hljs-type">boolean</span> forceDefaultAppClass, Instrumentation instrumentation) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">String</span> <span class="hljs-variable">appClass</span> <span class="hljs-operator">=</span> mApplicationInfo.className;    <span class="hljs-keyword">if</span> (forceDefaultAppClass || (appClass == <span class="hljs-literal">null</span>)) &#123;        appClass = <span class="hljs-string">&quot;android.app.Application&quot;</span>;    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> getClassLoader();        <span class="hljs-keyword">if</span> (!mPackageName.equals(<span class="hljs-string">&quot;android&quot;</span>)) &#123;            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;initializeJavaContextClassLoader&quot;</span>);            initializeJavaContextClassLoader();            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        &#125;        <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(mActivityThread, <span class="hljs-built_in">this</span>);        <span class="hljs-comment">// ... 创建 Application 实例</span>        app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);        appContext.setOuterContext(app);    &#125; ...    mActivityThread.mAllApplications.add(app);    mApplication = app;    <span class="hljs-keyword">if</span> (instrumentation != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            instrumentation.callApplicationOnCreate(app);  <span class="hljs-comment">// 这里会调用生命周期函数 onCreate</span>        &#125; ...    &#125;    <span class="hljs-keyword">return</span> app;&#125;<span class="hljs-keyword">public</span> Instrumentation.Application <span class="hljs-title function_">newApplication</span><span class="hljs-params">(ClassLoader cl, String className, Context context)</span>        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> getFactory(context.getPackageName()).instantiateApplication(cl, className);    app.attach(context);  <span class="hljs-comment">// 在这里会调用 attachBaseContext</span>    <span class="hljs-keyword">return</span> app;&#125;<span class="hljs-comment">// 最终调用 loadClass 加载 app Application 类</span>Application AppComponentFactory.instantiateApplication(ClassLoader cl, String className)        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;    <span class="hljs-keyword">return</span> (Application) cl.loadClass(className).newInstance();&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Application</tag>
      
      <tag>AMS</tag>
      
      <tag>Zygote</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池 ThreadPool 的实现</title>
    <link href="/2021/02/19/threadpool/"/>
    <url>/2021/02/19/threadpool/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>线程池有几个重要的参数：</p><ul><li><code>maximumPoolSize</code> 最大线程数量，如果新提交的任务因为 <code>workQueue</code> 的容量限制而无法入队，则会尝试新开一个线程执行任务，而如果此时总线程数超过 <code>maximumPoolSize</code> 的限制，那么不再新开一个线程而是提交失败</li><li><code>corePoolSize</code> 核心线程数量，当任务执行完毕，线程也将结束它的生命周期，但最少不会低于 <code>corePoolSize</code></li><li><code>keepAliveTime</code> 空闲线程的存活时间，执行完任务的线程会存活至少 <code>keepAliveTime</code>，再根据当前线程数量和 <code>corePoolSize</code> 决定要不要结束生命</li><li><code>workQueue</code> 任务队列，当提交的任务不能被立刻执行时（线程数 &gt; <code>corePoolSize</code>），会放在 <code>workQueue</code> 排队等待执行</li></ul><p>线程池的内部状态：</p><ul><li><code>RUNNING</code>，可以提交新任务</li><li><code>SHUTDOWN</code>，不能提交新任务，但可以继续把 workQueue 里的任务执行完</li><li><code>STOP</code>，不能提交新任务，不执行 workQueue 里的任务，且中断正在执行的任务</li><li><code>TIDYING</code>，所有任务都已结束，此时线程数为零，准备执行 terminated()</li><li><code>TERMINATED</code>，<code>terminated()</code> 执行完毕</li></ul><h2 id="生产者-消费者模式的-worker"><a href="#生产者-消费者模式的-worker" class="headerlink" title="生产者 - 消费者模式的 worker"></a>生产者 - 消费者模式的 worker</h2><p>线程（worker）作为消费者，不断地从任务队列（workQueue）里获取任务并执行</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        runWorker(<span class="hljs-built_in">this</span>);    &#125;&#125;<span class="hljs-comment">// worker 的执行流程</span><span class="hljs-comment">// 用一个 while 循环不断地从 workQueue 里获取任务（blocked &amp; timeouted）</span><span class="hljs-comment">// getTask 返回 null 导致当前线程结束生命</span><span class="hljs-keyword">void</span> ThreadPoolExecutor.runWorker(Worker w) &#123;    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;    w.firstTask = <span class="hljs-literal">null</span>;    w.unlock(); <span class="hljs-comment">// allow interrupts</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;            w.lock();            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span>            <span class="hljs-comment">// requires a recheck in second case to deal with</span>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            <span class="hljs-keyword">try</span> &#123;                beforeExecute(wt, task);                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">try</span> &#123;                    task.run();                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;                    thrown = x; <span class="hljs-keyword">throw</span> x;                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;                    thrown = x; <span class="hljs-keyword">throw</span> x;                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);                &#125; <span class="hljs-keyword">finally</span> &#123;                    afterExecute(task, thrown);                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                task = <span class="hljs-literal">null</span>;                w.completedTasks++;                w.unlock();            &#125;        &#125;        completedAbruptly = <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        processWorkerExit(w, completedAbruptly);    &#125;&#125;<span class="hljs-comment">// 从 workQueue 获取任务（blocked &amp; timeouted）</span>Runnable ThreadPoolExecutor.getTask() &#123;    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);                <span class="hljs-comment">// 1. 线程池已 shutdown（只需把 workQueue 执行完毕），但 workQueue 已清空</span>        <span class="hljs-comment">// 2. 线程池已 stop，无需执行 workQueue 剩下的任务</span>        <span class="hljs-comment">// 此时返回 null 结束线程 </span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;            decrementWorkerCount();            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">// 当线程数 &gt; corePoolSize，如果阻塞 keepAliveTime 时间段都没有新任务进来，则返回 null 结束当前线程</span>        <span class="hljs-comment">// 当线程数 &gt; maximumPoolSize 且 workQueue 为空，也要结束当前线程，从而降低线程数</span>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)                <span class="hljs-keyword">return</span> r;            timedOut = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;            timedOut = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="corePoolSize，workQueue-和-maximumPoolSize-之间的关系"><a href="#corePoolSize，workQueue-和-maximumPoolSize-之间的关系" class="headerlink" title="corePoolSize，workQueue 和 maximumPoolSize 之间的关系"></a><code>corePoolSize</code>，<code>workQueue</code> 和 <code>maximumPoolSize</code> 之间的关系</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ThreadPoolExecutor.execute(Runnable command) &#123;    <span class="hljs-comment">// 如果线程数 &lt; corePoolSize，则新开一个线程执行任务</span>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))            <span class="hljs-keyword">return</span>;        c = ctl.get();    &#125;    <span class="hljs-comment">// 否则放入 workQueue 等待执行</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-comment">// 如果超过 workQueue 容量限制，则尝试新开一个线程执行任务</span>    <span class="hljs-comment">// 从下面的 addWorker 可以知道，如果新开线程的时候发现当前线程总数 &gt;= maximumPoolSize，那么任务提交失败</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))        reject(command);&#125;<span class="hljs-type">boolean</span> ThreadPoolExecutor.addWorker(Runnable firstTask, <span class="hljs-type">boolean</span> core) &#123;    retry:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);        <span class="hljs-comment">// Check if queue empty only if necessary.</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == <span class="hljs-literal">null</span> &amp;&amp;               ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-keyword">break</span> retry;            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">try</span> &#123;        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Recheck while holding lock.</span>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                <span class="hljs-comment">// shut down before lock acquired.</span>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();                    workers.add(w);                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = <span class="hljs-literal">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-keyword">if</span> (workerAdded) &#123;                t.start();                workerStarted = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (! workerStarted)            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre></div><h2 id="定时任务（ScheduledExecutorService）"><a href="#定时任务（ScheduledExecutorService）" class="headerlink" title="定时任务（ScheduledExecutorService）"></a>定时任务（<code>ScheduledExecutorService</code>）</h2><p>上文里的任务队列用的是 <code>BlockingQueue</code>，它是按照 FIFO 的优先级给任务排队的；要实现定时，就要按照执行时间点的优先级给任务排序，只有到达执行时间点的任务才能出队</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>要排序，每次取最小值（到达执行时间点的任务），而且会插入新元素，典型的数据结构是「小顶堆」；<code>DelayedWorkQueue</code> 就是用小顶堆实现的阻塞队列</p><p>堆有几个特性：</p><ul><li>堆在逻辑上是二叉树，存储为数组；节点从上到下，从左到右按顺序摊平在数组上</li><li>既然节点是按顺序排的，那么可以从索引计算出父/子节点：<ul><li><code>parent(i) = floor((i - 1)/2)</code></li><li><code>left(i) = 2i + 1</code></li><li><code>right(i) = 2i + 2</code></li></ul></li><li>父节点比子节点要小的是小顶堆，根节点最小；父节点比子节点大的是大顶堆，根节点最大；左右节点之间没有大小要求</li><li><code>shiftDown()</code>，出队最小/大值（也即根节点）后，将数组最后一个元素转移到根节点，然后从根节点开始递归地重排：如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动，这样是这个节点在数组的位置下降</li><li><code>shiftUp()</code>，入队一个新元素到数组尾部，那么从这个元素开始从下往上重排：如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置，这样是这个节点在数组的位置上升</li></ul><h3 id="DelayedWorkQueue-按执行时间优先级排序的阻塞队列"><a href="#DelayedWorkQueue-按执行时间优先级排序的阻塞队列" class="headerlink" title="DelayedWorkQueue 按执行时间优先级排序的阻塞队列"></a><code>DelayedWorkQueue</code> 按执行时间优先级排序的阻塞队列</h3><p>提交一个新任务到 <code>DelayedWorkQueue</code>，重排 workQueue</p><p>workQueue 是按执行时间点排序的，leader 是在队头任务上挂起的线程，leader 未唤醒时新来的出队请求将在 available 上挂起</p><p>队列为空时线程也在 available 上挂起</p><div class="code-wrapper"><pre><code class="hljs java">ScheduledFuture&lt;?&gt; ScheduledThreadPoolExecutor.schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>, triggerTime(delay, unit), sequencer.getAndIncrement()));    delayedExecute(t);    <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-keyword">void</span> ScheduledThreadPoolExecutor.delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123;    <span class="hljs-keyword">if</span> (isShutdown())        reject(task);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">super</span>.getQueue().add(task);        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;            remove(task))            task.cancel(<span class="hljs-literal">false</span>);        <span class="hljs-keyword">else</span>            ensurePrestart();    &#125;&#125;<span class="hljs-type">boolean</span> DelayedWorkQueue.add(Runnable e) &#123;    <span class="hljs-keyword">return</span> offer(e);&#125;<span class="hljs-comment">// 插入小顶堆</span><span class="hljs-type">boolean</span> DelayedWorkQueue.offer(Runnable x) &#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 小顶堆底层是数组，数组容量不足需要扩容（扩容 50%）</span>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;        <span class="hljs-keyword">if</span> (i &gt;= queue.length)            grow();        <span class="hljs-comment">// 小顶堆的插入操作 siftUp</span>        size = i + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;            queue[<span class="hljs-number">0</span>] = e;            setIndex(e, <span class="hljs-number">0</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            siftUp(i, e);        &#125;        <span class="hljs-comment">// 新加入的任务排在队头，它的执行时间点最近</span>        <span class="hljs-comment">// 此时 leader 是挂起在上一个队头上的，要置空（有更近的执行时间点进来了）并唤醒 available 上的线程来争抢新的队头任务</span>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;            leader = <span class="hljs-literal">null</span>;            available.signal();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// 堆是一个二叉树，广度优先、从左到右存储为数组</span><span class="hljs-comment">// 新元素添加到数组尾部（相当于二叉树中的叶子节点），k 是它的索引，为了继续满足小顶堆的要求，需要重新排序</span><span class="hljs-keyword">void</span> DelayedWorkQueue.siftUp(<span class="hljs-type">int</span> k, RunnableScheduledFuture&lt;?&gt; key) &#123;<span class="hljs-comment">// 从下往上比较，如果它比父节点小，交换之</span>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;        RunnableScheduledFuture&lt;?&gt; e = queue[parent];        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;        queue[k] = e;        setIndex(e, k);        k = parent;    &#125;    <span class="hljs-comment">// 直到满足小于父节点的要求（小顶堆），那么这就是 key 的合适位置</span>    queue[k] = key;    setIndex(key, k);&#125;</code></pre></div><p>上面说过 <code>worker</code> 是一个「生产者-消费者」模型，通过 <code>getTask</code> 不断地从 <code>workQueue</code> 获取任务</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从 workQueue 获取任务（blocked &amp; timeouted）</span>Runnable ThreadPoolExecutor.getTask() &#123;    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)                <span class="hljs-keyword">return</span> r;            timedOut = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;            timedOut = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-comment">// 任务出队（blocked）</span>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.take() <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;    lock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 任务队列为空，在 available 挂起</span>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)                available.await();            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 到达执行时间点的才能出队</span>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)                    <span class="hljs-keyword">return</span> finishPoll(first);                <span class="hljs-comment">// leader 是挂起在 first 上的线程，它将在 first 执行时间点上恢复</span>                <span class="hljs-comment">// 如果已有线程在 first 上挂起，则当前线程在 available 上挂起</span>                first = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)                    available.await();                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();                    leader = thisThread;                    <span class="hljs-keyword">try</span> &#123;                        available.awaitNanos(delay);                    &#125; <span class="hljs-keyword">finally</span> &#123;                        <span class="hljs-keyword">if</span> (leader == thisThread)                            leader = <span class="hljs-literal">null</span>;                    &#125;                &#125;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// 出队后，唤醒在 available 上挂起的线程</span>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)            available.signal();        lock.unlock();    &#125;&#125;<span class="hljs-comment">// 将小顶堆的根 queue[0] 出队后，需要重排堆：</span><span class="hljs-comment">// 1. 将最后一个数组元素转移到根节点</span><span class="hljs-comment">// 2. 从上往下重排：比较父节点和子节点，如果父节点大于子节点则交换之</span>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;    RunnableScheduledFuture&lt;?&gt; x = queue[s];    queue[s] = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)        siftDown(<span class="hljs-number">0</span>, x);    setIndex(f, -<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> f;&#125;<span class="hljs-keyword">void</span> DelayedWorkQueue.siftDown(<span class="hljs-type">int</span> k, RunnableScheduledFuture&lt;?&gt; key) &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> size &gt;&gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (k &lt; half) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;        RunnableScheduledFuture&lt;?&gt; c = queue[child];        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="hljs-number">0</span>)            c = queue[child = right];        <span class="hljs-keyword">if</span> (key.compareTo(c) &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;        queue[k] = c;        setIndex(c, k);        k = child;    &#125;    queue[k] = key;    setIndex(key, k);&#125;<span class="hljs-comment">// 任务出队（timeouted）</span>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.poll(<span class="hljs-type">long</span> timeout, TimeUnit unit)    <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;    lock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 队列为空，挂起 timeout 后继续</span>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">else</span>                    nanos = available.awaitNanos(nanos);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// first 到达执行时间点，立刻返回</span>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)                    <span class="hljs-keyword">return</span> finishPoll(first);                <span class="hljs-comment">// 否则挂起</span>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span>                <span class="hljs-keyword">if</span> (nanos &lt; delay || leader != <span class="hljs-literal">null</span>)                    nanos = available.awaitNanos(nanos);                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();                    leader = thisThread;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-type">long</span> <span class="hljs-variable">timeLeft</span> <span class="hljs-operator">=</span> available.awaitNanos(delay);                        nanos -= delay - timeLeft;                    &#125; <span class="hljs-keyword">finally</span> &#123;                        <span class="hljs-keyword">if</span> (leader == thisThread)                            leader = <span class="hljs-literal">null</span>;                    &#125;                &#125;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)            available.signal();        lock.unlock();    &#125;&#125;</code></pre></div><h2 id="如果-worker-数量超过-maximumPoolSize，task-会被-reject"><a href="#如果-worker-数量超过-maximumPoolSize，task-会被-reject" class="headerlink" title="如果 worker 数量超过 maximumPoolSize，task 会被 reject"></a>如果 worker 数量超过 maximumPoolSize，task 会被 reject</h2><p><code>ThreadPoolExecutor</code> 提供了 <code>RejectedExecutionHandler</code> 来处理这种情况，平常通过 <code>Executors</code> 创建的线程池使用默认的 <code>AbortPolicy</code>，它会抛出异常</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * A handler for rejected tasks that throws a</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> RejectedExecutionException&#125;.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Always throws RejectedExecutionException.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException always</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +                                             <span class="hljs-string">&quot; rejected from &quot;</span> +                                             e.toString());    &#125;&#125;</code></pre></div><p>其他的还有：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扔掉 task 不做任何处理</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;&#125;&#125;<span class="hljs-comment">// 既然 workQueue 满了那我就扔掉一个，然后把这个 task 入队</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;            e.getQueue().poll();            e.execute(r);        &#125;    &#125;&#125;<span class="hljs-comment">// 由提交 task 的线程负责执行 task</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;            r.run();        &#125;    &#125;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>threadpool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（五）Condition 的语言实现：Object.wait 和 Object.notify</title>
    <link href="/2021/02/11/wait-notify/"/>
    <url>/2021/02/11/wait-notify/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="../../../../2021/01/24/condition-by-lock/">Lock（三）利用 Lock 实现 Condition</a> 我们介绍了如何用 <code>Lock</code> 来实现 <code>Condition</code>，而 <code>Condition</code> 对标的是 <code>Object.wait</code> 和 <code>Object.notify</code></p><p>我们来看看 ART 是怎么实现 wait/notify 的（最好先了解下 <a href="../../../../2021/02/08/synchronized-implementation/">synchronized 的基础知识</a>）</p><h2 id="ConditionVariable"><a href="#ConditionVariable" class="headerlink" title="ConditionVariable"></a>ConditionVariable</h2><p>对 futex/mutex 的封装，宏 <code>ART_USE_FUTEXES</code> 决定底层是使用 futex 还是 mutex；它不是「条件变量」，<code>Monitor</code> 才是（而且它还包含 Lock 的角色）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::Wait</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  guard_.<span class="hljs-built_in">CheckSafeToWait</span>(self);  <span class="hljs-built_in">WaitHoldingLocks</span>(self);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::WaitHoldingLocks</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_recursion_count = guard_.recursion_count_;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>  num_waiters_++;  <span class="hljs-comment">// Ensure the Mutex is contended so that requeued threads are awoken.</span>  guard_.<span class="hljs-built_in">increment_contenders</span>();  guard_.recursion_count_ = <span class="hljs-number">1</span>;  <span class="hljs-type">int32_t</span> cur_sequence = sequence_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);  guard_.<span class="hljs-built_in">ExclusiveUnlock</span>(self);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_sequence, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// Futex failed, check it is an expected error.</span>    <span class="hljs-comment">// EAGAIN == EWOULDBLK, so we let the caller try again.</span>    <span class="hljs-comment">// EINTR implies a signal was sent to this thread.</span>    <span class="hljs-keyword">if</span> ((errno != EINTR) &amp;&amp; (errno != EAGAIN)) &#123;      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;    &#125;  &#125;  <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);  guard_.<span class="hljs-built_in">ExclusiveLock</span>(self);  <span class="hljs-built_in">CHECK_GT</span>(num_waiters_, <span class="hljs-number">0</span>);  num_waiters_--;  <span class="hljs-comment">// We awoke and so no longer require awakes from the guard_&#x27;s unlock.</span>  <span class="hljs-built_in">CHECK_GT</span>(guard_.<span class="hljs-built_in">get_contenders</span>(), <span class="hljs-number">0</span>);  guard_.<span class="hljs-built_in">decrement_contenders</span>();<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  <span class="hljs-type">pid_t</span> old_owner = guard_.<span class="hljs-built_in">GetExclusiveOwnerTid</span>();  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);  guard_.recursion_count_ = <span class="hljs-number">0</span>;  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_wait, (&amp;cond_, &amp;guard_.mutex_));  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(old_owner, std::memory_order_relaxed);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  guard_.recursion_count_ = old_recursion_count;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::Signal</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>  <span class="hljs-built_in">RequeueWaiters</span>(<span class="hljs-number">1</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_signal, (&amp;cond_));<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::RequeueWaiters</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> count)</span> </span>&#123;  <span class="hljs-keyword">if</span> (num_waiters_ &gt; <span class="hljs-number">0</span>) &#123;    sequence_++;  <span class="hljs-comment">// Indicate a signal occurred.</span>    <span class="hljs-comment">// Move waiters from the condition variable&#x27;s futex to the guard&#x27;s futex,</span>    <span class="hljs-comment">// so that they will be woken up when the mutex is released.</span>    <span class="hljs-type">bool</span> done = <span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(),                      FUTEX_REQUEUE_PRIVATE,                      <span class="hljs-comment">/* Threads to wake */</span> <span class="hljs-number">0</span>,                      <span class="hljs-comment">/* Threads to requeue*/</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> timespec*&gt;(count),                      guard_.state_and_contenders_.<span class="hljs-built_in">Address</span>(),                      <span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span> (!done &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) &#123;      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex requeue failed for &quot;</span> &lt;&lt; name_;    &#125;  &#125;&#125;</code></pre></div><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>从逻辑上实现了「条件变量」，对应 Condition；它有两条单向链表的排队队列：</p><ul><li>等待队列，被挂起的线程（wait）在这里排队，<code>Monitor::wait_set_</code> 是队头</li><li>唤醒队列，等待被唤醒的线程（notify）在这里排队，<code>Monitor::wake_set_</code> 是队头</li></ul><p><code>Thread</code> 有个成员变量充当 next 指针：<code>Thread::GetWaitNext()</code> 和 <code>Thread::SetWaitNext(Thread* next)</code></p><p>await 是把线程添加到 wait set 队尾，notify 是把 wait set 队头转移为 wake set 队头，然后在退出临界区（释放锁）时唤醒 wake set 队头</p><p>同时 <code>Thread::wait_monitor_</code> 标识线程在哪个 <code>Monitor</code> 上挂起</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;  <span class="hljs-comment">// Threads currently waiting on this monitor.</span>  <span class="hljs-function">Thread* wait_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;  <span class="hljs-comment">// Threads that were waiting on this monitor, but are now contending on it.</span>  <span class="hljs-function">Thread* wake_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;&#125;<span class="hljs-comment">// 将新挂起的线程添加到 wait set 队尾</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::AppendToWaitSet</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;  <span class="hljs-comment">// Not checking that the owner is equal to this thread, since we&#x27;ve released</span>  <span class="hljs-comment">// the monitor by the time this method is called.</span>  <span class="hljs-built_in">DCHECK</span>(thread != <span class="hljs-literal">nullptr</span>);  <span class="hljs-built_in">DCHECK</span>(thread-&gt;<span class="hljs-built_in">GetWaitNext</span>() == <span class="hljs-literal">nullptr</span>) &lt;&lt; thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();  <span class="hljs-keyword">if</span> (wait_set_ == <span class="hljs-literal">nullptr</span>) &#123;    wait_set_ = thread;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// push_back.</span>  Thread* t = wait_set_;  <span class="hljs-keyword">while</span> (t-&gt;<span class="hljs-built_in">GetWaitNext</span>() != <span class="hljs-literal">nullptr</span>) &#123;    t = t-&gt;<span class="hljs-built_in">GetWaitNext</span>();  &#125;  t-&gt;<span class="hljs-built_in">SetWaitNext</span>(thread);&#125;<span class="hljs-comment">// notify 并没有唤醒线程，而是把 wait set 的队头转移到 wake set 队头</span><span class="hljs-comment">// 实际上是在释放锁时唤醒 wake set 队头</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// Make sure that we hold the lock.</span>  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// Move one thread from waiters to wake set</span>  Thread* to_move = wait_set_;  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);    wake_set_ = to_move;  &#125;&#125;</code></pre></div><h2 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait"></a>Object.wait</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> Object.wait() <span class="hljs-keyword">throws</span> InterruptedException &#123;    wait(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">void</span> Object.wait(<span class="hljs-type">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException &#123;    wait(timeout, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> Object.wait(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/native/java_lang_Object.cc</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Object_waitJI</span><span class="hljs-params">(JNIEnv* env, jobject java_this, jlong ms, jint ns)</span> </span>&#123;  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;  soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Wait</span>(soa.<span class="hljs-built_in">Self</span>(), ms, ns);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Object::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-type">int64_t</span> ms, <span class="hljs-type">int32_t</span> ns)</span> </span>&#123;  Monitor::<span class="hljs-built_in">Wait</span>(self, <span class="hljs-keyword">this</span>, ms, ns, <span class="hljs-literal">true</span>, kTimedWaiting);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self,</span></span><span class="hljs-params"><span class="hljs-function">                   ObjPtr&lt;mirror::Object&gt; obj,</span></span><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int64_t</span> ms,</span></span><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int32_t</span> ns,</span></span><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">bool</span> interruptShouldThrow,</span></span><span class="hljs-params"><span class="hljs-function">                   ThreadState why)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;  <span class="hljs-comment">// 将锁膨胀为 fat lock</span>  LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);  <span class="hljs-keyword">while</span> (lock_word.<span class="hljs-built_in">GetState</span>() != LockWord::kFatLocked) &#123;    <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;      <span class="hljs-keyword">case</span> LockWord::kHashCode:      <span class="hljs-comment">// wait/notify 必须先用 synchronized 获取此对象上的锁</span>      <span class="hljs-comment">// 否则抛出 java 异常</span>      <span class="hljs-keyword">case</span> LockWord::kUnlocked:        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>      <span class="hljs-comment">// 同上，必须获得此对象锁；此时对象锁被别的线程持有，抛出 java 异常</span>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;        <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();        <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;          <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 将 thin lock（偏向锁）膨胀为 fat lock（重量级锁），同时创建一个监视器 Monitor</span>          <span class="hljs-comment">// We own the lock, inflate to enqueue ourself on the Monitor. May fail spuriously so</span>          <span class="hljs-comment">// re-load.</span>          <span class="hljs-built_in">Inflate</span>(self, self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>);          lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);        &#125;        <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">// 已经是 fat lock 了</span>      <span class="hljs-keyword">case</span> LockWord::kFatLocked:  <span class="hljs-comment">// Unreachable given the loop condition above. Fall-through.</span>      <span class="hljs-keyword">default</span>: &#123;        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();        <span class="hljs-built_in">UNREACHABLE</span>();      &#125;    &#125;  &#125;  <span class="hljs-comment">// 必须膨胀为 fat lock，它才有 Monitor</span>  Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();  mon-&gt;<span class="hljs-built_in">Wait</span>(self, ms, ns, interruptShouldThrow, why);&#125;<span class="hljs-comment">// 在监视器上挂起</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-type">int64_t</span> ms, <span class="hljs-type">int32_t</span> ns,</span></span><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">bool</span> interruptShouldThrow, ThreadState why)</span> </span>&#123;  <span class="hljs-comment">/*</span><span class="hljs-comment">   * Release our hold - we need to let it go even if we&#x27;re a few levels</span><span class="hljs-comment">   * deep in a recursive lock, and we need to restore that later.</span><span class="hljs-comment">   */</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prev_lock_count = lock_count_;  lock_count_ = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 挂起线程前需要释放锁</span>  <span class="hljs-comment">// 将线程添加到 wait set 队尾，释放锁，wake set 不为空则唤醒第一个（队头开始）</span>  <span class="hljs-type">bool</span> was_interrupted = <span class="hljs-literal">false</span>;  <span class="hljs-type">bool</span> timed_out = <span class="hljs-literal">false</span>;  owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);  num_waiters_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);  &#123;    <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, why)</span></span>;    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;    <span class="hljs-built_in">AppendToWaitSet</span>(self);    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);    <span class="hljs-comment">// Handle the case where the thread was interrupted before we called wait().</span>    <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">IsInterrupted</span>()) &#123;      was_interrupted = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 然后将线程在它的成员变量 Thread.wait_cond_ 上挂起</span>      <span class="hljs-comment">// Wait for a notification or a timeout to occur.</span>      <span class="hljs-keyword">if</span> (why == kWaiting) &#123;        self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Wait</span>(self);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">DCHECK</span>(why == kTimedWaiting || why == kSleeping) &lt;&lt; why;        timed_out = self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">TimedWait</span>(self, ms, ns);      &#125;      was_interrupted = self-&gt;<span class="hljs-built_in">IsInterrupted</span>();    &#125;  &#125;  <span class="hljs-comment">// 线程被唤醒后，要将线程上的监视器置空，并重新获得锁</span>  &#123;    <span class="hljs-comment">// We reset the thread&#x27;s wait_monitor_ field after transitioning back to runnable so</span>    <span class="hljs-comment">// that a thread in a waiting/sleeping state has a non-null wait_monitor_ for debugging</span>    <span class="hljs-comment">// and diagnostic purposes. (If you reset this earlier, stack dumps will claim that threads</span>    <span class="hljs-comment">// are waiting on &quot;null&quot;.)</span>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;    <span class="hljs-built_in">DCHECK</span>(self-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>);    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-literal">nullptr</span>);  &#125;  <span class="hljs-built_in">Lock</span>&lt;LockReason::kForWait&gt;(self);  lock_count_ = prev_lock_count;  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));  self-&gt;<span class="hljs-built_in">GetWaitMutex</span>()-&gt;<span class="hljs-built_in">AssertNotHeld</span>(self);  num_waiters_.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);  <span class="hljs-built_in">RemoveFromWaitSet</span>(self);&#125;</code></pre></div><h2 id="Object-notify"><a href="#Object-notify" class="headerlink" title="Object.notify"></a>Object.notify</h2><p>把挂起的线程从 wait set 转移到 wake set</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Object_notify</span><span class="hljs-params">(JNIEnv* env, jobject java_this)</span> </span>&#123;  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;  soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Notify</span>(soa.<span class="hljs-built_in">Self</span>());&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Object::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  Monitor::<span class="hljs-built_in">Notify</span>(self, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span></span><span class="hljs-function">      <span class="hljs-title">REQUIRES_SHARED</span><span class="hljs-params">(Locks::mutator_lock_)</span> </span>&#123;    <span class="hljs-built_in">DoNotify</span>(self, obj, <span class="hljs-literal">false</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::DoNotify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-type">bool</span> notify_all)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);  LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);  <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;    <span class="hljs-keyword">case</span> LockWord::kHashCode:      <span class="hljs-comment">// Fall-through.</span>    <span class="hljs-keyword">case</span> LockWord::kUnlocked:      <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;      <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();      <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();      <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// We own the lock but there&#x27;s no Monitor and therefore no waiters.</span>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span>      &#125;    &#125;    <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;      Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();      <span class="hljs-keyword">if</span> (notify_all) &#123;        mon-&gt;<span class="hljs-built_in">NotifyAll</span>(self);      &#125; <span class="hljs-keyword">else</span> &#123;        mon-&gt;<span class="hljs-built_in">Notify</span>(self);      &#125;      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span>    &#125;    <span class="hljs-keyword">default</span>: &#123;      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();      <span class="hljs-built_in">UNREACHABLE</span>();    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// Make sure that we hold the lock.</span>  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// Move one thread from waiters to wake set</span>  Thread* to_move = wait_set_;  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);    wake_set_ = to_move;  &#125;&#125;</code></pre></div><p>调用 notify 前需要先获得它的对象锁，notify 把线程转移到 wake set，释放锁时会唤醒线程（从而让线程能够重新获得锁）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);  <span class="hljs-keyword">if</span> (owner == self) &#123;    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span>    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);    <span class="hljs-built_in">AtraceMonitorUnlock</span>();    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);    &#125; <span class="hljs-keyword">else</span> &#123;      --lock_count_;      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span>      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-comment">// We want to release the monitor and signal up to one thread that was waiting</span>  <span class="hljs-comment">// but has since been notified.</span>  <span class="hljs-built_in">DCHECK_EQ</span>(lock_count_, <span class="hljs-number">0u</span>);  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));  <span class="hljs-keyword">while</span> (wake_set_ != <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-comment">// No risk of waking ourselves here; since monitor_lock_ is not released until we&#x27;re ready to</span>    <span class="hljs-comment">// return, notify can&#x27;t move the current thread from wait_set_ to wake_set_ until this</span>    <span class="hljs-comment">// method is done checking wake_set_.</span>    Thread* thread = wake_set_;    wake_set_ = thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();    thread-&gt;<span class="hljs-built_in">SetWaitNext</span>(<span class="hljs-literal">nullptr</span>);    <span class="hljs-built_in">DCHECK</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) == <span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// Check to see if the thread is still waiting.</span>    &#123;      <span class="hljs-comment">// In the case of wait(), we&#x27;ll be acquiring another thread&#x27;s GetWaitMutex with</span>      <span class="hljs-comment">// self&#x27;s GetWaitMutex held. This does not risk deadlock, because we only acquire this lock</span>      <span class="hljs-comment">// for threads in the wake_set_. A thread can only enter wake_set_ from Notify or NotifyAll,</span>      <span class="hljs-comment">// and those hold monitor_lock_. Thus, the threads whose wait mutexes we acquire here must</span>      <span class="hljs-comment">// have already been released from wait(), since we have not released monitor_lock_ until</span>      <span class="hljs-comment">// after we&#x27;ve chosen our thread to wake, so there is no risk of the following lock ordering</span>      <span class="hljs-comment">// leading to deadlock:</span>      <span class="hljs-comment">// Thread 1 waits</span>      <span class="hljs-comment">// Thread 2 waits</span>      <span class="hljs-comment">// Thread 3 moves threads 1 and 2 from wait_set_ to wake_set_</span>      <span class="hljs-comment">// Thread 1 enters this block, and attempts to acquire Thread 2&#x27;s GetWaitMutex to wake it</span>      <span class="hljs-comment">// Thread 2 enters this block, and attempts to acquire Thread 1&#x27;s GetWaitMutex to wake it</span>      <span class="hljs-comment">//</span>      <span class="hljs-comment">// Since monitor_lock_ is not released until the thread-to-be-woken-up&#x27;s GetWaitMutex is</span>      <span class="hljs-comment">// acquired, two threads cannot attempt to acquire each other&#x27;s GetWaitMutex while holding</span>      <span class="hljs-comment">// their own and cause deadlock.</span>      <span class="hljs-function">MutexLock <span class="hljs-title">wait_mu</span><span class="hljs-params">(self, *thread-&gt;GetWaitMutex())</span></span>;      <span class="hljs-keyword">if</span> (thread-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-comment">// Release the lock, so that a potentially awakened thread will not</span>        <span class="hljs-comment">// immediately contend on it. The lock ordering here is:</span>        <span class="hljs-comment">// monitor_lock_, self-&gt;GetWaitMutex, thread-&gt;GetWaitMutex</span>        monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);  <span class="hljs-comment">// Releases contenders.</span>        thread-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Signal</span>(self);        <span class="hljs-keyword">return</span>;      &#125;    &#125;  &#125;  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);  <span class="hljs-built_in">DCHECK</span>(!monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));&#125;</code></pre></div><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><ul><li>与 JCU.Condition 不同，对象监视器 Monitor 并没有把「条件变量」这部分功能抽离出来，它既是 Lock 又是 Condition</li><li>Condition 和 Monitor 都用排队队列来组织挂起的线程</li><li>Condition 在 notify 后立刻唤醒线程，而 Monitor 因为 wait/notify 需要获得锁后才能执行，只能在 notify 线程释放锁时才唤醒 wait 线程</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>wait</tag>
      
      <tag>notify</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（四）synchronized 的语言实现</title>
    <link href="/2021/02/08/synchronized-implementation/"/>
    <url>/2021/02/08/synchronized-implementation/</url>
    
    <content type="html"><![CDATA[<h2 id="monitor-指令"><a href="#monitor-指令" class="headerlink" title="monitor 指令"></a>monitor 指令</h2><p>在 <a href="../../../../2021/01/13/aqs-lock-implementation/">Lock（二）AQS 源码分析以及 Lock 的实现</a> 这篇文章里介绍了基于 AQS 的 <code>Lock</code>，它是双向链表的排队队列和系统调用 <code>futex</code> 实现的</p><p>其实 java 语言规范里自带了 Lock 的实现：<code>synchronized</code> 关键字，下面看看 ART 是怎么实现它的</p><p>先写一个使用了 <code>synchronized</code> 的测试方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapplication;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">(String msg)</span> &#123;        <span class="hljs-keyword">synchronized</span>(lock) &#123;            System.out.println(msg != <span class="hljs-literal">null</span> ? msg : <span class="hljs-string">&quot;null&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Hello</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>();        instance.say(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;&#125;</code></pre></div><p>编译打包出 apk 文件，解压出其中的 classes.dex，并用 <code>baksmali</code> 转换成 smali 指令</p><div class="code-wrapper"><pre><code class="hljs bash">java -jar baksmali-2.4.0.jar disassemble classes.dex</code></pre></div><p><code>Hello.say(String)</code> 对应的 smali 代码是这样的</p><p><code>synchronized</code> 代码块被两条指令包裹：<code>monitor-enter</code> 和 <code>monitor-exit</code></p><div class="code-wrapper"><pre><code class="hljs bash">.method public say(Ljava/lang/String;)V    .registers 5    .param p1, <span class="hljs-string">&quot;msg&quot;</span>    <span class="hljs-comment"># Ljava/lang/String;</span>    .line 8<span class="hljs-comment"># 本地变量寄存器 v0 被赋予 Hello.lock</span>    iget-object v0, p0, Lcom/example/myapplication/Hello;-&gt;lock:Ljava/lang/Object;<span class="hljs-comment"># 重点</span>    monitor-enter v0    .line 9    :try_start_3    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;    if-eqz p1, :cond_9    move-object v2, p1    goto :goto_b    :cond_9    const-string v2, <span class="hljs-string">&quot;null&quot;</span>    :goto_b    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V    .line 10<span class="hljs-comment"># 重点</span>    monitor-exit v0    .line 11    return-void    .line 10    :catchall_10    move-exception v1    monitor-exit v0    :try_end_12    .catchall &#123;:try_start_3 .. :try_end_12&#125; :catchall_10    throw v1.end method</code></pre></div><h2 id="对象锁的概念"><a href="#对象锁的概念" class="headerlink" title="对象锁的概念"></a>对象锁的概念</h2><p>在进一步分析代码之前，先要了解下 java 对象锁的一些背景知识（from <a href="https://blog.csdn.net/fan1865221/article/details/96338419">JAVA锁的膨胀过程</a>）</p><p>java 对象锁会有一个膨胀加码的过程：无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p><ul><li><strong>无锁</strong></li><li><strong>偏向锁，</strong>为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</li><li><strong>轻量级锁，</strong>在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，所以轻量级锁一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li><li><strong>重量级锁，</strong>当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。</li></ul><h2 id="LockWord"><a href="#LockWord" class="headerlink" title="LockWord"></a>LockWord</h2><p>先了解一个结构<code>LockWord</code> ，它其实是一个 <code>uint32_t</code>，低 16 bits 保存持有锁的 thread id，后续 12 bits 保存锁的个数</p><p>它是 <code>Object</code> 的成员变量 <code>monitor_</code>，所以每个 java 对象都可以作为锁使用</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> LockWord <span class="hljs-title">FromThinLockId</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> thread_id, <span class="hljs-type">uint32_t</span> count, <span class="hljs-type">uint32_t</span> gc_state)</span> </span>&#123;    <span class="hljs-built_in">CHECK_LE</span>(thread_id, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kThinLockMaxOwner));    <span class="hljs-built_in">CHECK_LE</span>(count, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kThinLockMaxCount));    <span class="hljs-comment">// DCHECK_EQ(gc_bits &amp; kGCStateMaskToggled, 0U);</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">LockWord</span>((thread_id &lt;&lt; kThinLockOwnerShift) |                    (count &lt;&lt; kThinLockCountShift) |                    (gc_state &lt;&lt; kGCStateShift) |                    (kStateThinOrUnlocked &lt;&lt; kStateShift));&#125;<span class="hljs-comment">// C++ mirror of java.lang.Object</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MANAGED</span> LOCKABLE Object &#123;<span class="hljs-comment">// Monitor and hash code information.</span><span class="hljs-type">uint32_t</span> monitor_;&#125;</code></pre></div><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>ART 使用 <code>Mutex</code> 作为互斥量的实现（lock &amp; unlock），它根据宏 <code>ART_USE_FUTEXES</code> 决定是使用 <code>futex</code> 还是 <code>mutex</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span><span class="hljs-comment">// 获取排它锁</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mutex::ExclusiveLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">do</span> &#123;      <span class="hljs-comment">// Mutex::state_and_contenders_ 是 AtomicInteger</span>      <span class="hljs-comment">// 最低 1 bit 表示互斥量是否被持有（1 - 持有，0 - 未持有），其余高位的 bits 表示在此互斥量上挂起的线程数量</span>      <span class="hljs-type">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);      <span class="hljs-comment">// 锁没有被取走，立刻获得锁（cas）</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) <span class="hljs-comment">/* lock not held */</span>) &#123;        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 否则将挂起线程的数量加一，并用 futex 挂起当前线程</span>        ScopedContentionRecorder <span class="hljs-built_in">scr</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">SafeGetTid</span>(self), <span class="hljs-built_in">GetExclusiveOwnerTid</span>());        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self, [](<span class="hljs-type">int32_t</span> v) &#123; <span class="hljs-built_in">return</span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;          <span class="hljs-comment">// Increment contender count. We can&#x27;t create enough threads for this to overflow.</span>          <span class="hljs-built_in">increment_contenders</span>();          <span class="hljs-comment">// Make cur_state again reflect the expected value of state_and_contenders.</span>          cur_state += kContenderIncrement;          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(should_respond_to_empty_checkpoint_request_)) &#123;            self-&gt;<span class="hljs-built_in">CheckEmptyCheckpointFromMutex</span>();          &#125;          <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_state, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;              <span class="hljs-keyword">if</span> ((errno != EAGAIN) &amp;&amp; (errno != EINTR)) &#123;                <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;              &#125;            &#125;            <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);            <span class="hljs-comment">// Retry until not held. In heavy contention situations we otherwise get redundant</span>            <span class="hljs-comment">// futex wakeups as a result of repeatedly decrementing and incrementing contenders.</span>            cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);          &#125; <span class="hljs-keyword">while</span> ((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>);          <span class="hljs-built_in">decrement_contenders</span>();        &#125;      &#125;    &#125; <span class="hljs-keyword">while</span> (!done);    <span class="hljs-comment">// Confirm that lock is now held.</span>    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">// 使用 pthread_mutex_lock 加锁</span>    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_lock, (&amp;mutex_));<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">// exclusive_owner_ 记下获得排他锁的 thread id</span>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);    <span class="hljs-built_in">RegisterAsLocked</span>(self);  &#125;  recursion_count_++;&#125;<span class="hljs-comment">// tryLock 方法</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">do</span> &#123;      <span class="hljs-comment">// 使用 futex 的情况下，利用一个 AtomicInteger 的最低 1 bit 表示锁有没被借出，一个 cas 操作即可</span>      <span class="hljs-type">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);      <span class="hljs-keyword">if</span> ((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// Change state to held and impose load/store ordering appropriate for lock acquisition.</span>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125; <span class="hljs-keyword">while</span> (!done);    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">// mutex</span>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">pthread_mutex_trylock</span>(&amp;mutex_);    <span class="hljs-comment">// ...</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-comment">// exclusive_owner_ 记下获得锁的 thread id</span>    <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetExclusiveOwnerTid</span>(), <span class="hljs-number">0</span>);    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);    <span class="hljs-built_in">RegisterAsLocked</span>(self);  &#125;  recursion_count_++;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// 也是 tryLock 方法，特别的是它会自旋一小会</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLockWithSpinning</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-comment">// Spin a small number of times, since this affects our ability to respond to suspension</span>  <span class="hljs-comment">// requests. We spin repeatedly only if the mutex repeatedly becomes available and unavailable</span>  <span class="hljs-comment">// in rapid succession, and then we will typically not spin for the maximal period.</span>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxSpins = <span class="hljs-number">5</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kMaxSpins; ++i) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ExclusiveTryLock</span>(self)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self,            [](<span class="hljs-type">int32_t</span> v) &#123; <span class="hljs-built_in">return</span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ExclusiveTryLock</span>(self);&#125;<span class="hljs-comment">// 释放排它锁</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mutex::ExclusiveUnlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  recursion_count_--;  <span class="hljs-keyword">if</span> (!recursive_ || recursion_count_ == <span class="hljs-number">0</span>) &#123;    <span class="hljs-built_in">RegisterAsUnlocked</span>(self);<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">do</span> &#123;      <span class="hljs-comment">// 使用 cas 将 state_and_contenders_ 最低 1 bit 置零（表示锁没被借出）</span>      <span class="hljs-type">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>)) &#123;        <span class="hljs-comment">// We&#x27;re no longer the owner.</span>        exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);        <span class="hljs-comment">// Change state to not held and impose load/store ordering appropriate for lock release.</span>        <span class="hljs-type">uint32_t</span> new_state = cur_state &amp; ~kHeldMask;  <span class="hljs-comment">// Same number of contenders.</span>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakRelease</span>(cur_state, new_state);        <span class="hljs-comment">// state_and_contenders_ 不为零表示仍有线程在锁上挂起，用 futex 让系统唤醒其中一个</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(done)) &#123;  <span class="hljs-comment">// Spurious fail or waiters changed ?</span>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(new_state != <span class="hljs-number">0</span>) <span class="hljs-comment">/* have contenders */</span>) &#123;            <span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE, kWakeOne,                  <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);          &#125;          <span class="hljs-comment">// We only do a futex wait after incrementing contenders and verifying the lock was</span>          <span class="hljs-comment">// still held. If we didn&#x27;t see waiters, then there couldn&#x27;t have been any futexes</span>          <span class="hljs-comment">// waiting on this lock when we did the CAS. New arrivals after that cannot wait for us,</span>          <span class="hljs-comment">// since the futex wait call would see the lock available and immediately return.</span>        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 异常情况...</span>      &#125;    &#125; <span class="hljs-keyword">while</span> (!done);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>    <span class="hljs-comment">// mutex</span>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_unlock, (&amp;mutex_));<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  &#125;&#125;<span class="hljs-comment">// Unlock 等同于 ExclusiveUnlock</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(Thread* self)</span> <span class="hljs-title">RELEASE</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">ExclusiveUnlock</span>(self); &#125;</code></pre></div><h2 id="monitor-enter-指令"><a href="#monitor-enter-指令" class="headerlink" title="monitor-enter 指令"></a><code>monitor-enter</code> 指令</h2><h3 id="无锁、偏向锁和轻量级锁"><a href="#无锁、偏向锁和轻量级锁" class="headerlink" title="无锁、偏向锁和轻量级锁"></a>无锁、偏向锁和轻量级锁</h3><p>进入临界区，尝试获得锁</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 在 cs.android.com 找到的相关性很高的方法，可能不是指令 monitor-enter 直接调用的方法，但最终应该会走到这里来</span><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span><span class="hljs-function"><span class="hljs-keyword">inline</span> ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Object::MonitorEnter</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorEnter</span>(self, <span class="hljs-keyword">this</span>, <span class="hljs-comment">/*trylock=*/</span><span class="hljs-literal">false</span>);&#125;<span class="hljs-function">ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Monitor::MonitorEnter</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-type">bool</span> trylock)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);  self-&gt;<span class="hljs-built_in">AssertThreadSuspensionIsAllowable</span>();  obj = <span class="hljs-built_in">FakeLock</span>(obj);  <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();  <span class="hljs-type">size_t</span> contention_count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> kExtraSpinIters = <span class="hljs-number">100</span>;  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">if</span> !ART_USE_FUTEXES</span>  <span class="hljs-comment">// In this case we cannot inflate an unowned monitor, so we sometimes defer inflation.</span>  <span class="hljs-type">bool</span> should_inflate = <span class="hljs-literal">false</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;      <span class="hljs-comment">// 无锁的情况下，升级为偏向锁（thin lock）</span>      <span class="hljs-comment">// 偏向锁记录下 thread id 和锁的个数 0，通过 cas 记录在 Object.monitor_</span>      <span class="hljs-keyword">case</span> LockWord::kUnlocked: &#123;        <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id, <span class="hljs-number">0</span>, lock_word.GCState()))</span></span>;        <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, thin_locked, CASMode::kWeak, std::memory_order_acquire)) &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> !ART_USE_FUTEXES</span>          <span class="hljs-keyword">if</span> (should_inflate) &#123;            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);          &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>          <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>        &#125;        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span>      &#125;      <span class="hljs-comment">// 偏向锁，而且当前线程跟偏向锁里记录的线程是同一个线程</span>      <span class="hljs-comment">// 那么只需把偏向锁里的锁个数加一即可，依然使用 cas 保存在 Object.monitor_</span>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;        <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();        <span class="hljs-keyword">if</span> (owner_thread_id == thread_id) &#123;          <span class="hljs-comment">// No ordering required for initial lockword read.</span>          <span class="hljs-comment">// We own the lock, increase the recursion count.</span>          <span class="hljs-type">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() + <span class="hljs-number">1</span>;          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(new_count &lt;= LockWord::kThinLockMaxCount)) &#123;            <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id,</span></span><span class="hljs-params"><span class="hljs-function">                                                          new_count,</span></span><span class="hljs-params"><span class="hljs-function">                                                          lock_word.GCState()))</span></span>;            <span class="hljs-comment">// 重新设置偏向锁，一个选择用 cas 原子操作符，另一个选择没用，不明这样区分的意义</span>            <span class="hljs-comment">// Only this thread pays attention to the count. Thus there is no need for stronger</span>            <span class="hljs-comment">// than relaxed memory ordering.</span>            <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;              h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(thin_locked, <span class="hljs-comment">/* as_volatile= */</span> <span class="hljs-literal">false</span>);              <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);              <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">// Use CAS to preserve the read barrier state.</span>              <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word,                                     thin_locked,                                     CASMode::kWeak,                                     std::memory_order_relaxed)) &#123;                <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);                <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>              &#125;            &#125;            <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span>          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 当前线程持有偏向锁，但锁的个数超过阈值 kThinLockMaxCount</span>            <span class="hljs-comment">// 那么将偏向锁（thin lock）升级为重量级锁（fat lock）</span>            <span class="hljs-comment">// We&#x27;d overflow the recursion count, so inflate the monitor.</span>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);          &#125;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 持有偏向锁的线程不是当前线程，此时的 thin lock 对应上文的轻量级锁</span>          <span class="hljs-comment">// 也就是说轻量级锁是这么一种情况：一个线程持有偏向锁，遇到了另一个线程的争抢</span>          <span class="hljs-comment">// 争抢的线程在这里自旋（spin），contention_count 表示自旋的次数</span>          <span class="hljs-comment">// 1. 如果自旋次数 &lt;= kExtraSpinIters，那么继续在外一层的 while 循环里自旋</span>          <span class="hljs-comment">// 2. 如果自旋次数 &lt; kExtraSpinIters，争抢线程让渡 CPU 给优先级更高的线程，并将自己排到 CPU 调度队列的队尾（sched_yield），相当于优化的自旋</span>          <span class="hljs-comment">// 3. 最后将轻量级锁膨胀为重量级锁</span>          <span class="hljs-keyword">if</span> (trylock) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;          &#125;          contention_count++;          Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();          <span class="hljs-keyword">if</span> (contention_count              &lt;= kExtraSpinIters + runtime-&gt;<span class="hljs-built_in">GetMaxSpinsBeforeThinLockInflation</span>()) &#123;            <span class="hljs-keyword">if</span> (contention_count &gt; kExtraSpinIters) &#123;              <span class="hljs-built_in">sched_yield</span>();            &#125;          &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>            contention_count = <span class="hljs-number">0</span>;            <span class="hljs-comment">// No ordering required for initial lockword read. Install rereads it anyway.</span>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>            <span class="hljs-comment">// Can&#x27;t inflate from non-owning thread. Keep waiting. Bad for power, but this code</span>            <span class="hljs-comment">// isn&#x27;t used on-device.</span>            should_inflate = <span class="hljs-literal">true</span>;            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">10</span>);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>          &#125;        &#125;        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span>      &#125;      <span class="hljs-comment">// 重量级锁的情况下会挂起当前线程，在下一节分析</span>      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;        std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();        <span class="hljs-keyword">if</span> (trylock) &#123;          <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">TryLock</span>(self) ? h_obj.<span class="hljs-built_in">Get</span>() : <span class="hljs-literal">nullptr</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          mon-&gt;<span class="hljs-built_in">Lock</span>(self);          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>        &#125;      &#125;      <span class="hljs-comment">// 不清楚这个条件</span>      <span class="hljs-keyword">case</span> LockWord::kHashCode:        <span class="hljs-built_in">Inflate</span>(self, <span class="hljs-literal">nullptr</span>, h_obj.<span class="hljs-built_in">Get</span>(), lock_word.<span class="hljs-built_in">GetHashCode</span>());        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span>      <span class="hljs-keyword">default</span>: &#123;        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();        <span class="hljs-built_in">UNREACHABLE</span>();      &#125;    &#125;  &#125;&#125;</code></pre></div><h3 id="锁膨胀的过程（inflate）"><a href="#锁膨胀的过程（inflate）" class="headerlink" title="锁膨胀的过程（inflate）"></a>锁膨胀的过程（inflate）</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// thin lock 膨胀至重量级锁（fat lock）的过程</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::InflateThinLocked</span><span class="hljs-params">(Thread* self, Handle&lt;mirror::Object&gt; obj, LockWord lock_word, <span class="hljs-type">uint32_t</span> hash_code)</span> </span>&#123;  <span class="hljs-comment">// 当前线程持有此偏向锁的情况（由于锁个数超过阈值导致膨胀）</span>  <span class="hljs-comment">// 升级到重量级锁（fat lock）</span>  <span class="hljs-built_in">DCHECK_EQ</span>(lock_word.<span class="hljs-built_in">GetState</span>(), LockWord::kThinLocked);  <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();  <span class="hljs-keyword">if</span> (owner_thread_id == self-&gt;<span class="hljs-built_in">GetThreadId</span>()) &#123;    <span class="hljs-comment">// We own the monitor, we can easily inflate it.</span>    <span class="hljs-built_in">Inflate</span>(self, self, obj.<span class="hljs-built_in">Get</span>(), hash_code);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 当前线程不持有此偏向锁，出现争抢（此时对应轻量级锁）</span>    <span class="hljs-comment">// 挂起持有偏向锁的线程，将轻量级锁膨胀为重量级锁（fat lock），然后恢复线程</span>    ThreadList* thread_list = Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetThreadList</span>();    <span class="hljs-comment">// Suspend the owner, inflate. First change to blocked and give up mutator_lock_.</span>    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(obj.<span class="hljs-built_in">Get</span>());    <span class="hljs-type">bool</span> timed_out;    Thread* owner;    &#123;      <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, kWaitingForLockInflation)</span></span>;      owner = thread_list-&gt;<span class="hljs-built_in">SuspendThreadByThreadId</span>(owner_thread_id, SuspendReason::kInternal, &amp;timed_out);    &#125;    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;      <span class="hljs-comment">// We succeeded in suspending the thread, check the lock&#x27;s status didn&#x27;t change.</span>      lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);      <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">GetState</span>() == LockWord::kThinLocked &amp;&amp;          lock_word.<span class="hljs-built_in">ThinLockOwner</span>() == owner_thread_id) &#123;        <span class="hljs-comment">// Go ahead and inflate the lock.</span>        <span class="hljs-built_in">Inflate</span>(self, owner, obj.<span class="hljs-built_in">Get</span>(), hash_code);      &#125;      <span class="hljs-type">bool</span> resumed = thread_list-&gt;<span class="hljs-built_in">Resume</span>(owner, SuspendReason::kInternal);      <span class="hljs-built_in">DCHECK</span>(resumed);    &#125;    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(<span class="hljs-literal">nullptr</span>);  &#125;&#125;<span class="hljs-comment">// 具体的膨胀过程</span><span class="hljs-comment">// 膨胀到 fat lock 后多个一个概念 Monitor</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Inflate</span><span class="hljs-params">(Thread* self, Thread* owner, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-type">int32_t</span> hash_code)</span> </span>&#123;  <span class="hljs-comment">// Allocate and acquire a new monitor.</span>  Monitor* m = MonitorPool::<span class="hljs-built_in">CreateMonitor</span>(self, owner, obj, hash_code);  <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">Install</span>(self)) &#123;    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetMonitorList</span>()-&gt;<span class="hljs-built_in">Add</span>(m);    <span class="hljs-built_in">CHECK_EQ</span>(obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>).<span class="hljs-built_in">GetState</span>(), LockWord::kFatLocked);  &#125; <span class="hljs-keyword">else</span> &#123;    MonitorPool::<span class="hljs-built_in">ReleaseMonitor</span>(self, m);  &#125;&#125;<span class="hljs-comment">// fat lock 在这里被设置到 Object.monitor</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::Install</span><span class="hljs-params">(Thread* self)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);  <span class="hljs-built_in">CHECK</span>(owner == <span class="hljs-literal">nullptr</span> || owner == self || (ART_USE_FUTEXES &amp;&amp; owner-&gt;<span class="hljs-built_in">IsSuspended</span>()));  <span class="hljs-function">LockWord <span class="hljs-title">lw</span><span class="hljs-params">(GetObject()-&gt;GetLockWord(<span class="hljs-literal">false</span>))</span></span>;  <span class="hljs-keyword">switch</span> (lw.<span class="hljs-built_in">GetState</span>()) &#123;    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;      lock_count_ = lw.<span class="hljs-built_in">ThinLockCount</span>();<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>      monitor_lock_.<span class="hljs-built_in">ExclusiveLockUncontendedFor</span>(owner);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>      monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(owner);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>      <span class="hljs-function">LockWord <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, lw.GCState())</span></span>;      <span class="hljs-comment">// Publish the updated lock word, which may race with other threads.</span>      <span class="hljs-type">bool</span> success = <span class="hljs-built_in">GetObject</span>()-&gt;<span class="hljs-built_in">CasLockWord</span>(lw, fat, CASMode::kWeak, std::memory_order_release);      <span class="hljs-keyword">if</span> (success) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ATraceEnabled</span>()) &#123;          <span class="hljs-built_in">SetLockingMethod</span>(owner);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>        monitor_lock_.<span class="hljs-built_in">ExclusiveUnlockUncontended</span>();<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt;= lockCount; ++i) &#123;          monitor_lock_.<span class="hljs-built_in">ExclusiveUnlock</span>(owner);        &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 上面说过，thin lock 的 LockWord 低 16 bits 是 thread id，然后是 12 bits 的锁个数</span><span class="hljs-comment">// 对于 fat lock，低 28 bits 是 monitor id</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">LockWord::LockWord</span><span class="hljs-params">(Monitor* mon, <span class="hljs-type">uint32_t</span> gc_state)</span></span><span class="hljs-function">    : value_(mon-&gt;GetMonitorId() | (gc_state &lt;&lt; kGCStateShift) | (kStateFat &lt;&lt; kStateShift)) &#123;</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LP64__</span>  <span class="hljs-built_in">DCHECK_ALIGNED</span>(mon, kMonitorIdAlignment);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">FatLockMonitor</span>(), mon);  <span class="hljs-built_in">DCHECK_LE</span>(mon-&gt;<span class="hljs-built_in">GetMonitorId</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kMaxMonitorId));  <span class="hljs-built_in">CheckReadBarrierState</span>();&#125;</code></pre></div><h3 id="Monitor-Lock-挂起线程"><a href="#Monitor-Lock-挂起线程" class="headerlink" title="Monitor::Lock 挂起线程"></a><code>Monitor::Lock</code> 挂起线程</h3><p>上面介绍的是对象锁，也就是把 <code>Object</code> 作为 <code>Lock</code> 使用，具体来说是 <code>Object.monitor</code> 的四种状态：无锁、偏向锁、轻量级锁和重量级锁</p><p>而 <code>Monitor::Lock</code> 实现的是在重量级锁状态下，「挂起」线程的过程，它包含了自旋、futex/mutex 系统调用</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;LockReason reason&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Lock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-type">bool</span> called_monitors_callback = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 一小会的自旋</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(self, <span class="hljs-comment">/*spin=*/</span> <span class="hljs-literal">true</span>)) &#123;  <span class="hljs-comment">//... 挂起</span>  <span class="hljs-comment">// Acquire monitor_lock_ without mutator_lock_, expecting to block this time.</span>  <span class="hljs-comment">// We already tried spinning above. The shutdown procedure currently assumes we stop</span>  <span class="hljs-comment">// touching monitors shortly after we suspend, so don&#x27;t spin again here.</span>  monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(self);  <span class="hljs-comment">//...</span>&#125;<span class="hljs-comment">// 自己持有锁，锁加一；否则自旋一小会尝试加锁</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::TryLock</span><span class="hljs-params">(Thread* self, <span class="hljs-type">bool</span> spin)</span> </span>&#123;  Thread *owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);  <span class="hljs-keyword">if</span> (owner == self) &#123;    lock_count_++;    <span class="hljs-built_in">CHECK_NE</span>(lock_count_, <span class="hljs-number">0u</span>);  <span class="hljs-comment">// Abort on overflow.</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-type">bool</span> success = spin ? monitor_lock_.<span class="hljs-built_in">ExclusiveTryLockWithSpinning</span>(self)        : monitor_lock_.<span class="hljs-built_in">ExclusiveTryLock</span>(self);    <span class="hljs-comment">//...</span>&#125;</code></pre></div><h2 id="monitor-exit-指令"><a href="#monitor-exit-指令" class="headerlink" title="monitor-exit 指令"></a><code>monitor-exit</code> 指令</h2><h3 id="偏向锁和轻量级锁"><a href="#偏向锁和轻量级锁" class="headerlink" title="偏向锁和轻量级锁"></a>偏向锁和轻量级锁</h3><p>退出临界区，释放锁</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Object::MonitorExit</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorExit</span>(self, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::MonitorExit</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span> </span>&#123;  <span class="hljs-comment">//...</span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);    <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;      <span class="hljs-keyword">case</span> LockWord::kHashCode:        <span class="hljs-comment">// Fall-through.</span>      <span class="hljs-comment">// 对象的锁并没有借出，抛出 java 异常</span>      <span class="hljs-keyword">case</span> LockWord::kUnlocked:        <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), <span class="hljs-number">0u</span>, <span class="hljs-literal">nullptr</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span>      <span class="hljs-comment">// 当前线程并不拥有锁，抛出 java 异常</span>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;        <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();        <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;          <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), thread_id, owner_thread_id, <span class="hljs-literal">nullptr</span>);          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span>        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 偏向锁，锁减一，如果锁为零则释放锁，最后写回 Object.monitor</span>          <span class="hljs-comment">// We own the lock, decrease the recursion count.</span>          LockWord new_lw = LockWord::<span class="hljs-built_in">Default</span>();          <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">ThinLockCount</span>() != <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() - <span class="hljs-number">1</span>;            new_lw = LockWord::<span class="hljs-built_in">FromThinLockId</span>(thread_id, new_count, lock_word.<span class="hljs-built_in">GCState</span>());          &#125; <span class="hljs-keyword">else</span> &#123;            new_lw = LockWord::<span class="hljs-built_in">FromDefault</span>(lock_word.<span class="hljs-built_in">GCState</span>());          &#125;          <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;            <span class="hljs-built_in">DCHECK_EQ</span>(new_lw.<span class="hljs-built_in">ReadBarrierState</span>(), <span class="hljs-number">0U</span>);            h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(new_lw, <span class="hljs-literal">true</span>);            <span class="hljs-built_in">AtraceMonitorUnlock</span>();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, new_lw, CASMode::kWeak, std::memory_order_release)) &#123;              <span class="hljs-built_in">AtraceMonitorUnlock</span>();              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;          &#125;          <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span>        &#125;      &#125;      <span class="hljs-comment">// 释放重量级锁</span>      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();        <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">Unlock</span>(self);      &#125;      <span class="hljs-keyword">default</span>: &#123;        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();        <span class="hljs-built_in">UNREACHABLE</span>();      &#125;    &#125;  &#125;&#125;</code></pre></div><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前线程持有此重量级锁，且锁为零，退出临界区导致释放锁并唤醒等待线程</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);  <span class="hljs-keyword">if</span> (owner == self) &#123;    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span>    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);    <span class="hljs-built_in">AtraceMonitorUnlock</span>();    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 当前线程持有此重量级锁，且锁不为零（重入）</span>      <span class="hljs-comment">// 退出临界区导致锁减一，但不释放锁</span>      --lock_count_;      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span>      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// 当前线程不持有此重量级锁，抛出 java 异常</span>  <span class="hljs-comment">// We don&#x27;t own this, so we&#x27;re not allowed to unlock it.</span>  <span class="hljs-comment">// The JNI spec says that we should throw IllegalMonitorStateException in this case.</span>  <span class="hljs-type">uint32_t</span> owner_thread_id = <span class="hljs-number">0u</span>;  &#123;    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;    owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;      owner_thread_id = owner-&gt;<span class="hljs-built_in">GetThreadId</span>();    &#125;  &#125;  <span class="hljs-built_in">FailedUnlock</span>(<span class="hljs-built_in">GetObject</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), owner_thread_id, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// Pretend to release monitor_lock_, which we should not.</span>  <span class="hljs-built_in">FakeUnlockMonitorLock</span>();  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">// 释放重量级锁</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;  <span class="hljs-comment">// ...</span>  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的代码总结下 <code>synchronized</code> 加锁的流程：</p><ul><li>初始为无锁</li><li>线程 A 进入临界区获得锁，升级为偏向锁（thin lock），偏向锁记下线程 A 的 thread id 和初始锁个数 0</li><li>如果线程 A 重入临界区，锁个数加一；当锁个数超过阈值时，膨胀为重量级锁</li><li>如果在线程 A 持有偏向锁的情况下，线程 B 尝试进入临界区；那么线程 B 首先自旋一小会等待线程 A 释放锁，失败后将偏向锁膨胀为重量级锁，并在锁上挂起；这一过程称为轻量级锁</li><li>线程 A 持有重量级锁的情况下，其他线程尝试进入临界区，会在锁上挂起（futex/mutex）</li></ul><p>总结下 <code>synchronized</code> 和 <code>Lock</code> 的区别：</p><ul><li><code>synchronized</code> 使用 <code>Object</code> 作为锁，也即所有的 <code>Object</code> 都可以当做锁使用；但具体的 lock/unlock 逻辑是在 <code>Monitor</code> 实现的，严谨地说是 <code>Object</code> + <code>Monitor</code> = Lock</li><li>偏向锁和轻量级锁并没有使用 <code>Monitor</code>，而是用 cas，<code>Object::monitor</code> 和自旋实现排他性；直到重量级锁时才构造 <code>Monitor</code>；<code>Monitor</code> 除了扮演 Lock 的角色外，<a href="../../../../2021/02/11/wait-notify/">还扮演了 Condition 的角色</a>，所以一旦调用 Object.wait/Object.notify，就会立刻升级为重量级锁</li><li>Lock 用排队队列来组织挂起的线程，而且以 FIFO 的优先级排队；<code>synchronized</code> 没有组织挂起的线程，完全由 CPU 决定谁能获得锁，可能会发生「饥饿」问题</li><li>Lock 全靠 futex/mutex 阻塞线程，而 <code>synchronized</code> 先让线程自旋一会在陷入阻塞</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（三）利用 Lock 实现 Condition</title>
    <link href="/2021/01/24/condition-by-lock/"/>
    <url>/2021/01/24/condition-by-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="Condition-简介"><a href="#Condition-简介" class="headerlink" title="Condition 简介"></a><code>Condition</code> 简介</h2><p><code>Condition</code> 主要有两类方法：</p><ul><li>await，释放锁并阻塞线程直到 signal 被调用，恢复后会重新获得锁</li><li>signal，唤醒阻塞在这个 <code>Condition</code> 上的一个或全部线程</li></ul><p>利用条件变量前需要先获得锁</p><p>所以 <code>Condition</code> 的所有方法都需要加锁</p><div class="code-wrapper"><pre><code class="hljs java">lock.lock();<span class="hljs-comment">// ...</span>condition.await();<span class="hljs-comment">// ...</span>lock.unlock();</code></pre></div><p><code>Condition</code> 的 await/signal 对标 <code>Object</code> 的 wait/notify，wait/notify 使用对象监视器实现的，而 await/signal 使用 <code>Lock</code> 实现的（<code>Lock</code> 对标 <code>synchronized</code> 关键字）</p><p><code>ConditionObject</code> 自己持有一个双向链表的排队队列 condition queue，所有阻塞在此条件变量上的线程都在此排队</p><p>被唤醒的线程会被转移到 AQS 队列尾部（又叫 sync queue）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter; <span class="hljs-comment">/** First node of condition queue. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  <span class="hljs-comment">/** Last node of condition queue. */</span>&#125;</code></pre></div><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>整个 await 大体就是以是否在 sync queue 为标识的循环，当节点转移到 sync queue 时表示线程被唤醒，跳出阻塞循环</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ConditionObject.await() <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-comment">// ... 在 condition queue 队尾添加一个 Node.CONDITION 类型的新节点（所有阻塞在此条件变量上的线程都在此排队）</span>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();    <span class="hljs-comment">// 进入阻塞状态前需要释放锁，同时唤醒下一个等待锁的线程</span>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 进入阻塞</span>    <span class="hljs-comment">// 被唤醒的线程会从 condition queue 转移到 AQS 排队队列（又叫同步队列，sync queue）</span>    <span class="hljs-comment">// isOnSyncQueue 返回 true 表示此节点已被转移到 sync queue，跳出阻塞循环</span>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;        LockSupport.park(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// await() 是可被中断的，awaitUninterruptibly() 不会被中断</span>        <span class="hljs-comment">// 线程恢复后，如果发生了中断，要跳出阻塞状态</span>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">// 线程恢复后需要重新获得锁</span>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span>        unlinkCancelledWaiters();    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)        reportInterruptAfterWait(interruptMode);&#125;<span class="hljs-keyword">private</span> Node ConditionObject.addConditionWaiter() &#123;    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;        unlinkCancelledWaiters();        t = lastWaiter;    &#125;    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Node.CONDITION)    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)        firstWaiter = node;    <span class="hljs-keyword">else</span>        t.nextWaiter = node;    lastWaiter = node;    <span class="hljs-keyword">return</span> node;&#125;<span class="hljs-type">int</span> AbstractQueuedSynchronizer.fullyRelease(Node node) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-keyword">if</span> (release(savedState))            <span class="hljs-keyword">return</span> savedState;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        node.waitStatus = Node.CANCELLED;        <span class="hljs-keyword">throw</span> t;    &#125;&#125;<span class="hljs-type">boolean</span> AbstractQueuedSynchronizer.release(<span class="hljs-type">int</span> arg) &#123;    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)            unparkSuccessor(h);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-type">boolean</span> ReentrantLock.Sync.tryRelease(<span class="hljs-type">int</span> releases) &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;        free = <span class="hljs-literal">true</span>;        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);    &#125;    setState(c);    <span class="hljs-keyword">return</span> free;&#125;</code></pre></div><h2 id="唤醒一个阻塞的线程（从队头节点开始）"><a href="#唤醒一个阻塞的线程（从队头节点开始）" class="headerlink" title="唤醒一个阻塞的线程（从队头节点开始）"></a>唤醒一个阻塞的线程（从队头节点开始）</h2><p>将在 condition queue 上节点转移到 sync queue 上</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 把 condition queue 第一个节点（等待最久的线程）从队列里移除，添加到 sync queue 并唤醒其线程</span><span class="hljs-keyword">void</span> ConditionObject.signal() &#123;    <span class="hljs-keyword">if</span> (!isHeldExclusively())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)        doSignal(first);&#125;<span class="hljs-comment">// 从 condition queue 里移除</span><span class="hljs-keyword">void</span> ConditionObject.doSignal(Node first) &#123;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)            lastWaiter = <span class="hljs-literal">null</span>;        first.nextWaiter = <span class="hljs-literal">null</span>;    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;             (first = firstWaiter) != <span class="hljs-literal">null</span>);&#125;<span class="hljs-comment">// 插入至 sync queue 队尾并唤醒其线程</span><span class="hljs-type">boolean</span> ConditionObject.transferForSignal(Node node) &#123;    <span class="hljs-keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="hljs-number">0</span>))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))        LockSupport.unpark(node.thread);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;Node AbstractQueuedSynchronizer.enq(Node node) &#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">oldTail</span> <span class="hljs-operator">=</span> tail;        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-literal">null</span>) &#123;            U.putObject(node, Node.PREV, oldTail);            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;                oldTail.next = node;                <span class="hljs-keyword">return</span> oldTail;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            initializeSyncQueue();        &#125;    &#125;&#125;</code></pre></div><h2 id="唤醒全部线程"><a href="#唤醒全部线程" class="headerlink" title="唤醒全部线程"></a>唤醒全部线程</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 跟唤醒第一个线程时一样的：</span><span class="hljs-comment">// 将所有在 Condition 上排队的线程逐个从 Condition 排队队列里移除，添加到 AQS 队尾，并唤醒其线程</span><span class="hljs-keyword">void</span> ConditionObject.signalAll() &#123;    <span class="hljs-keyword">if</span> (!isHeldExclusively())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)        doSignalAll(first);&#125;<span class="hljs-keyword">void</span> ConditionObject.doSignalAll(Node first) &#123;    lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;        first.nextWaiter = <span class="hljs-literal">null</span>;        transferForSignal(first);        first = next;    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>Condition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见面试题备忘</title>
    <link href="/2021/01/19/reviews/"/>
    <url>/2021/01/19/reviews/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>观察者（Observer），<code>LiveData</code></li><li>单例（Singleton），double check</li><li>适配器（Adapter），<code>RecyclerView.Adapter</code></li><li>装饰器（Decorator），<code>ContextWrapper</code></li><li>代理模式（Proxy），例如 VPN、Retrofit</li><li>责任链（Chain of Responsibility），<code>OkHttp</code> 大体上就是个责任链模式</li><li>建造者（Builder）</li><li>工厂（Factory）</li></ul><p>代理模式强调不能直接访问一个对象，只能通过代理间接访问，不能直接访问的原因比如：权限校验、操作日志、RPC，比如 AIDL 生成的 <code>IAidlInterface.Stub.Proxy</code> 类就是代理了 remote IBinder </p><p>装饰器模式强调增强对象的功能：把一个对象的功能拆分为几部分，在运行时按需组装，比如：<code>BufferedOutputStream</code>、<code>JarOutputStream</code>、<code>ZipOutputStream</code></p><h1 id="实现-LRU"><a href="#实现-LRU" class="headerlink" title="实现 LRU"></a>实现 LRU</h1><p><code>map</code> + 双端链表，链尾是最近使用过的，链头是最久未使用的</p><ul><li><code>get(key)</code>，通过 <code>map</code> 可以在 O(1) 时间内找到 <code>value</code>，然后把 <code>value</code> 从双端链表中断开并移到链尾，双端链表的特性使得「断开」操作很容易实现</li><li><code>put(key, value)</code>，把 <code>value</code> 添加到链尾，当超过容量限制时，从链头逐个移除 <code>value</code> 直到满足容量限制</li></ul><h1 id="几个重要的排序算法"><a href="#几个重要的排序算法" class="headerlink" title="几个重要的排序算法"></a>几个重要的排序算法</h1><ul><li><p>归并排序 O(nlogn)<br><code>step</code> 从 1 逐步递增，合并两个长度为 <code>step</code> 的已排序区间，当 <code>step</code> &gt; length/2 时，已排序区间就等于整个数组<br>合并两个有序区间很简单，用「双指针法」即可</p></li><li><p>快速排序 O(nlogn)<br>双指针，一个在头一个在尾，取第一个元素为「基准」（挖出一个坑），从尾部找一个比「基准」小的填入坑，然后又从头部找一个比「基准」大的填入尾部的坑，循环往复直到双指针碰头，那么这个位置就是「基准」的位置<br>每一轮都可以找出一个元素的排序后的位置，从整体看，这个元素和它左右两块是已排序的<br>然后递归操作左右两块区间直到区间长度为 1</p></li><li><p>堆排序 O(nlogn)<br>利用「堆」这个特殊的数据结构来排序（大顶堆、小顶堆）<br>恰好堆也是用数组实现的，初始已排序区间的长度为 1，逐步扩大长度相当于逐个添加一个新元素到堆<br>添加一个新元素到堆，相当于添加到数组尾部，逻辑上看就是添加到二叉树叶子那层最左边，为了让堆继续满足性质，需要把新元素逐层地跟它的父节点比较：新节点大于父节点则交换（大顶堆，小顶堆则相反）<br>当已排序区间 == 数组时，整个数组就排好序了</p></li></ul><h1 id="五层网络"><a href="#五层网络" class="headerlink" title="五层网络"></a>五层网络</h1><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>HTTP</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>IP 地址（替代 MAC 地址，形成网络），ARP（通过 IP 地址查询得到 MAC 地址）</td></tr><tr><td>链接层</td><td>以太网协议（Ethernet），帧（Frame），MAC 地址，广播（同一网络的所有计算机都会受到消息，它们比较帧的 MAC 地址和自己的 MAC 地址是否相同来决定是否接收）</td></tr><tr><td>物理层（实体层）</td><td></td></tr></tbody></table><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><p>抽象类是对实体的抽象，而接口是对特征的抽象；所以 Java 类最多只能继承自一个抽象类，但却可是实现多个特征</p><h1 id="多线程同步的方法"><a href="#多线程同步的方法" class="headerlink" title="多线程同步的方法"></a>多线程同步的方法</h1><ul><li><code>synchronized</code></li><li><code>volatile</code></li><li><code>Lock</code> &amp; <code>Condition</code> &amp; <code>Atoimc</code></li></ul><h1 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a><code>HashMap</code> 和 <code>HashTable</code> 的区别</h1><ul><li>都是数组 + 链表的实现（链表是为了解决 hash 冲突）</li><li><code>HashTable</code> 是线程安全的（大多数方法都加了 <code>synchronized</code>），而 <code>HashMap</code> 不是</li><li><code>HashMap</code> 允许为 <code>null</code> 的 key 和 value，而 <code>HashTable</code> 则不允许</li><li><code>HashMap</code> 重算了 hash code：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，而 <code>HashTable</code> 直接使用 <code>hashCode()</code></li></ul><h1 id="怎么解决-ANR-问题"><a href="#怎么解决-ANR-问题" class="headerlink" title="怎么解决 ANR 问题"></a>怎么解决 ANR 问题</h1><p>先把 <code>/data/anr/trace.txt</code> 拉下来，搜索包名定位到 app 进程那一段，找到 <code>main</code> 线程，看看主线程是不是出于异常状态（比如 <code>Blocked</code>、<code>Sleeping</code>）<br>如果主线程状态异常，那么查看主线程的调用堆栈，看看是哪段代码导致主线程进入异常状态<br>像 <code>Blocked</code> 有可能是锁导致的，能看到主线程被哪个锁阻塞，那个锁被哪个线程持有<br>有时候主线程没发现异常，看调用堆栈发现主线程正在执行 binder 相关操作，此时有可能是阻塞在这里（等待 binder 对面那端的响应）</p><p>还找不到问题，就在 logcat 里搜索 anr 找到 anr 相关日志，它会有一个 CPU 负载统计，如果 io 占比很大说明卡在 io 上了，继续往上找找看当时正在做什么文件操作，或者在 trace 文件里找找</p><h1 id="Double-Check-会有什么问题？"><a href="#Double-Check-会有什么问题？" class="headerlink" title="Double Check 会有什么问题？"></a>Double Check 会有什么问题？</h1><p><code>mSingleton = new Object();</code> 这行语句实际上会分解为多条 CPU 指令：</p><ol><li>为 <code>Object</code> 分配一块内存</li><li>初始化 <code>Object</code> 实例</li><li>把 <code>mSingleton</code> 指向这块内存</li></ol><p>但是「指令重排」可能导致第三部与第二部交换位置，也就是说把 <code>mSingleton</code> 指向了一块尚未初始化的内存区域；此时线程 B 在执行 <code>if (mSingleton == null)</code> 时就会发现 <code>mSingleton</code> 的确不为 null 并返回 <code>mSingleton</code>，从而导致程序异常（因为 <code>mSingleton</code> 指向的内存还没有初始化）</p><p>使用 <code>volatile</code> 修饰 <code>mSingleton</code> 即可，<code>volatile</code> 可以防止相关指令的重排</p><h1 id="IdleHandler-是怎么实现的？"><a href="#IdleHandler-是怎么实现的？" class="headerlink" title="IdleHandler 是怎么实现的？"></a><code>IdleHandler</code> 是怎么实现的？</h1><p>在 <code>MessageQueue.next</code> 里，当队列为空，或者还不到第一个消息的执行时间时（<code>Message</code> 是按照执行时间排序的），在 <code>MessageQueue.mIdleHandlers</code> 里的 <code>IdleHandler</code> 会被执行</p><h1 id="Retrofit-是怎么接口的？"><a href="#Retrofit-是怎么接口的？" class="headerlink" title="Retrofit 是怎么接口的？"></a>Retrofit 是怎么接口的？</h1><p>使用动态代理 <code>Proxy.newProxyInstance</code>，其核心是方法拦截</p><p>在运行时创建一个实现了所选接口的类，这个类的构造函数需要一个 <code>InvocationHandler</code>，接口所有的方法调用都会代理至 <code>InvocationHandler</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T Retrofit.create(<span class="hljs-keyword">final</span> Class&lt;T&gt; service) &#123;  Utils.validateServiceInterface(service);  <span class="hljs-keyword">if</span> (validateEagerly) &#123;    eagerlyValidateMethods(service);  &#125;  <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,      <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Platform</span> <span class="hljs-variable">platform</span> <span class="hljs-operator">=</span> Platform.get();        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];        <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span>            <span class="hljs-keyword">throws</span> Throwable &#123;          <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span>          <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);          &#125;          <span class="hljs-keyword">if</span> (platform.isDefaultMethod(method)) &#123;            <span class="hljs-keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);          &#125;          <span class="hljs-keyword">return</span> loadServiceMethod(method).invoke(args != <span class="hljs-literal">null</span> ? args : emptyArgs);        &#125;      &#125;);&#125;</code></pre></div><h1 id="Activity-重建的过程"><a href="#Activity-重建的过程" class="headerlink" title="Activity 重建的过程"></a><code>Activity</code> 重建的过程</h1><p>旧的 <code>Activity</code> 走向死亡（<code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>），新的 <code>Activity</code> 进入（<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>）</p><div class="code-wrapper"><pre><code class="hljs java">ActivityThread.handleRelaunchActivity(...)<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRelaunchActivityInner</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-type">int</span> configChanges,</span><span class="hljs-params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingIntents,</span><span class="hljs-params">        PendingTransactionActions pendingActions, <span class="hljs-type">boolean</span> startsNotResumed,</span><span class="hljs-params">        Configuration overrideConfig, String reason)</span> &#123;    <span class="hljs-comment">// Preserve last used intent, it may be set from Activity#setIntent().</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">customIntent</span> <span class="hljs-operator">=</span> r.activity.mIntent;    <span class="hljs-comment">// 旧的 Activity 走向死亡（销毁）</span>    <span class="hljs-comment">// Need to ensure state is saved.</span>    <span class="hljs-keyword">if</span> (!r.paused) &#123;        performPauseActivity(r, <span class="hljs-literal">false</span>, reason, <span class="hljs-literal">null</span> <span class="hljs-comment">/* pendingActions */</span>);    &#125;    <span class="hljs-keyword">if</span> (!r.stopped) &#123;        callActivityOnStop(r, <span class="hljs-literal">true</span> <span class="hljs-comment">/* saveState */</span>, reason);        handleDestroyActivity(r.token, <span class="hljs-literal">false</span>, configChanges, <span class="hljs-literal">true</span>, reason)    r.activity = <span class="hljs-literal">null</span>;    r.window = <span class="hljs-literal">null</span>;    r.hideForNow = <span class="hljs-literal">false</span>;    r.nextIdle = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// Merge any pending results and pending intents; don&#x27;t just replace them</span>    <span class="hljs-keyword">if</span> (pendingResults != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (r.pendingResults == <span class="hljs-literal">null</span>) &#123;            r.pendingResults = pendingResults;        &#125; <span class="hljs-keyword">else</span> &#123;            r.pendingResults.addAll(pendingResults);        &#125;    &#125;    <span class="hljs-keyword">if</span> (pendingIntents != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (r.pendingIntents == <span class="hljs-literal">null</span>) &#123;            r.pendingIntents = pendingIntents;        &#125; <span class="hljs-keyword">else</span> &#123;            r.pendingIntents.addAll(pendingIntents);        &#125;    &#125;    r.startsNotResumed = startsNotResumed;    r.overrideConfig = overrideConfig    <span class="hljs-comment">// 走创建新 Activity 的流程</span>    handleLaunchActivity(r, pendingActions, customIntent);&#125;</code></pre></div><h2 id="ViewModel-和-Fragment-会随之重建吗"><a href="#ViewModel-和-Fragment-会随之重建吗" class="headerlink" title="ViewModel 和 Fragment 会随之重建吗?"></a><code>ViewModel</code> 和 <code>Fragment</code> 会随之重建吗?</h2><p>不会，在 <code>Activity.onStop</code> 之后 <code>Activity.onDestory</code> 之前，<code>FragmentActivity</code> 将 <code>Fragment</code> 和 <code>ViewModelStore</code> 借由方法 <code>onRetainNonConfigurationInstance</code> 传递给 <code>ActivityClientRecord</code> 保存<br>并在 <code>Activity.attach</code> 被重新赋值给新的 <code>Activity</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object FragmentActivity.onRetainNonConfigurationInstance() &#123;    <span class="hljs-type">Object</span> <span class="hljs-variable">custom</span> <span class="hljs-operator">=</span> onRetainCustomNonConfigurationInstance()    <span class="hljs-type">FragmentManagerNonConfig</span> <span class="hljs-variable">fragments</span> <span class="hljs-operator">=</span> mFragments.retainNestedNonConfig()    <span class="hljs-keyword">if</span> (fragments == <span class="hljs-literal">null</span> &amp;&amp; mViewModelStore == <span class="hljs-literal">null</span> &amp;&amp; custom == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 在旧的 Activity 销毁前，保存 ViewModel 和 Fragment</span>    <span class="hljs-type">NonConfigurationInstances</span> <span class="hljs-variable">nci</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonConfigurationInstances</span>();    nci.custom = custom;    nci.viewModelStore = mViewModelStore;    nci.fragments = fragments;    <span class="hljs-keyword">return</span> nci;&#125;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;    mFragments.attachHost(<span class="hljs-literal">null</span> <span class="hljs-comment">/*parent*/</span>);    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);    <span class="hljs-type">NonConfigurationInstances</span> <span class="hljs-variable">nc</span> <span class="hljs-operator">=</span>            (NonConfigurationInstances) getLastNonConfigurationInstance();    <span class="hljs-comment">// 恢复 ViewModel</span>    <span class="hljs-keyword">if</span> (nc != <span class="hljs-literal">null</span> &amp;&amp; nc.viewModelStore != <span class="hljs-literal">null</span> &amp;&amp; mViewModelStore == <span class="hljs-literal">null</span>) &#123;        mViewModelStore = nc.viewModelStore;    &#125;    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-type">Parcelable</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> savedInstanceState.getParcelable(FRAGMENTS_TAG);        <span class="hljs-comment">// 恢复 Fragment</span>        mFragments.restoreAllState(p, nc != <span class="hljs-literal">null</span> ? nc.fragments : <span class="hljs-literal">null</span>);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 旧的 Activity 实例会被销毁，但其对应的 ActivityClientRecord 不会被销毁</span><span class="hljs-comment">// 那么 NonConfigurationInstances 就由 ActivityClientRecord 暂时保管</span>ActivityClientRecord <span class="hljs-title function_">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-type">boolean</span> finishing,</span><span class="hljs-params">        <span class="hljs-type">int</span> configChanges, <span class="hljs-type">boolean</span> getNonConfigInstance, String reason)</span> &#123;    <span class="hljs-type">ActivityClientRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> mActivities.get(token);    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span>&gt; activityClass = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Performing finish of &quot;</span> + r);    <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;        activityClass = r.activity.getClass();        r.activity.mConfigChangeFlags |= configChanges;        <span class="hljs-keyword">if</span> (finishing) &#123;            r.activity.mFinished = <span class="hljs-literal">true</span>;        &#125;        performPauseActivityIfNeeded(r, <span class="hljs-string">&quot;destroy&quot;</span>);        <span class="hljs-keyword">if</span> (!r.stopped) &#123;            callActivityOnStop(r, <span class="hljs-literal">false</span> <span class="hljs-comment">/* saveState */</span>, <span class="hljs-string">&quot;destroy&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (getNonConfigInstance) &#123;            <span class="hljs-keyword">try</span> &#123;                r.lastNonConfigurationInstances                        = r.activity.retainNonConfigurationInstances();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(                            <span class="hljs-string">&quot;Unable to retain activity &quot;</span>                            + r.intent.getComponent().toShortString()                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);                &#125;            &#125;        &#125;        <span class="hljs-comment">// call destory</span>    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 然后在 launch activity 时重新把 NonConfigurationInstances 赋给新建的 Activity 实例</span><span class="hljs-keyword">private</span> Activity <span class="hljs-title function_">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> &#123;    <span class="hljs-comment">// ...</span>    activity.attach(appContext, <span class="hljs-built_in">this</span>, getInstrumentation(), r.token,            r.ident, app, r.intent, r.activityInfo, title, r.parent,            r.embeddedID, r.lastNonConfigurationInstances, config,            r.referrer, r.voiceInteractor, window, r.configCallback,            r.assistToken);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(...)</span> &#123;    <span class="hljs-comment">// ...</span>    mLastNonConfigurationInstances = lastNonConfigurationInstances;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h1 id="CountDownLatch-和-CyclicBarrier-的区别"><a href="#CountDownLatch-和-CyclicBarrier-的区别" class="headerlink" title="CountDownLatch 和 CyclicBarrier 的区别"></a><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 的区别</h1><p>开始多个线程通过 <code>CountDownLatch.await()</code> 被它阻塞，然后其他线程执行完一个任务就通过 <code>countDown()</code> 把里面的计算器 <code>count</code> 减一，直到计数器归零阻塞的线程才被唤醒；它是 oneshot 不能重复使用，内部通过 <code>AQS</code> 实现</p><p>N 个并行线程执行任务，执行完就阻塞在 <code>CyclicBarrier.await()</code> 上面，直到 N 个线程都执行完任务，最后一个调用 <code>await()</code> 的线程执行完 <code>barrierCommand</code> 后，其他线程被唤醒，而 <code>CyclicBarrier</code> 被重置为初始状态；不同于 <code>CountDownLatch</code> 的一次性，<code>CyclicBarrier</code> 可以重复使用</p><h1 id="如何让-N-个线程串行执行？"><a href="#如何让-N-个线程串行执行？" class="headerlink" title="如何让 N 个线程串行执行？"></a>如何让 N 个线程串行执行？</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;    <span class="hljs-keyword">private</span> Runnable task;    <span class="hljs-keyword">private</span> Thread prev;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JoinThread</span><span class="hljs-params">(Runnable task, Thread prev)</span> &#123;        <span class="hljs-built_in">this</span>.task = task;        <span class="hljs-built_in">this</span>.prev = prev;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用 Thread.join()，调用后当前线程被阻塞直到 prev 执行完毕才恢复</span><span class="hljs-comment">     * join 可以使并行的线程串行执行</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        prev.join();        task.run();    &#125;&#125;</code></pre></div><h1 id="5-个线程，前-4-个执行完后才执行第-5-个"><a href="#5-个线程，前-4-个执行完后才执行第-5-个" class="headerlink" title="5 个线程，前 4 个执行完后才执行第 5 个"></a>5 个线程，前 4 个执行完后才执行第 5 个</h1><p>用 <code>CountDownLatch</code>，计算器设为 4，第 5 个线程通过 <code>await()</code> 阻塞在计数器上面，前 4 个执行到最后一步时使计数器减一，当计数器为零时第 5 个线程被唤醒</p><h1 id="两个线程交替输出-1-100"><a href="#两个线程交替输出-1-100" class="headerlink" title="两个线程交替输出 1 - 100"></a>两个线程交替输出 1 - 100</h1><h2 id="自旋-volatile"><a href="#自旋-volatile" class="headerlink" title="自旋 + volatile"></a>自旋 + <code>volatile</code></h2><p>既然是交替输出，那必然一个输出奇数一个输出偶数，输出日志这一操作是很快的，所以可以考虑乐观锁：自旋</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OddThread</span>().start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvenThread</span>().start();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;        System.out.printf(<span class="hljs-string">&quot;%s - %d%n&quot;</span>, Thread.currentThread().getName(), i);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">OddThread</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;Odd&quot;</span>); &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count;                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">if</span> (++c % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;                    print(c);                    count = c;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvenThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">EvenThread</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;Even&quot;</span>); &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count;                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">if</span> (++c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;                    print(c);                    count = c;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="基于条件变量-Condition"><a href="#基于条件变量-Condition" class="headerlink" title="基于条件变量 Condition"></a>基于条件变量 <code>Condition</code></h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> count;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">cond</span> <span class="hljs-operator">=</span> lock.newCondition();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Runnable</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">for</span> (;;) &#123;                    lock.lock();                    cond.signalAll();                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;                        count++;                        print(count);                        cond.await();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;                    &#125; <span class="hljs-keyword">finally</span> &#123;                        lock.unlock();                    &#125;                &#125;            &#125;        &#125;;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run, <span class="hljs-string">&quot;A&quot;</span>).start();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run, <span class="hljs-string">&quot;B&quot;</span>).start();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;        System.out.printf(<span class="hljs-string">&quot;%s - %d%n&quot;</span>, Thread.currentThread().getName(), i);    &#125;&#125;</code></pre></div><h2 id="思考：N-个线程按顺序输出-1-100-？"><a href="#思考：N-个线程按顺序输出-1-100-？" class="headerlink" title="思考：N 个线程按顺序输出 1 - 100 ？"></a>思考：N 个线程按顺序输出 1 - 100 ？</h2><p>不使用锁的情况下，把判断奇偶的逻辑改一下，通过 <code>(count % N) == i</code> 判断该数字是否应该由当前线程打印</p><p>用条件变量的情况下，每个线程都在自己的条件变量上阻塞，前面的线程持有下一个线程的条件变量（形成一个环），打印完后唤醒下一个线程；开始时主线程主动唤醒第一个线程</p><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>在 HashMap 的基础上给 Entry 添加了先后次序，也就说它里面的 Entry 是有序的：LinkedHashMap = HashMap + LinkedList，是 <code>LRU</code> 算法的典型实现</p><blockquote><p>Least Recently Used，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰</p></blockquote><ul><li>Entry 的实现为 LinkedHashMapEntry，它增加了 <code>before</code> 和 <code>after</code> 两个成员变量分别指向上一节点和下一节点，这样所有的 Entry 都可以通过这两个指针串联成一个 LinkedList</li><li><code>LinkedHashMapEntry</code> 增加了 <code>head</code> 和 <code>tail</code> 成员变量分别指向 LinkedList 的头节点和尾结点，这样 entry list 就变成了双向链表</li><li><code>head</code> 是最旧的节点，而 <code>tail</code> 是最新的节点</li><li>还增加了标识 <code>accessOrder</code>，<code>true</code>：entry list 按访问时间排序（最近访问的是尾结点），<code>false</code>：entry list 按插入次序排序（最近插入的是尾结点）</li><li>迭代器（Iterator）从 <code>head</code> 开始遍历</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMapEntry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;    LinkedHashMapEntry&lt;K,V&gt; before, after;    LinkedHashMapEntry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-built_in">super</span>(hash, key, value, next);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMap</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The head (eldest) of the doubly linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; head;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The tail (youngest) of the doubly linked list.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; tail;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><span class="hljs-comment">     * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@serial</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> accessOrder;    &#125;</code></pre></div><ul><li>新插入的节点作为新的尾结点 <code>tail</code>，相当于 <code>append</code> 到 LinkedList 上，新插入的节点也可以认为是最近访问的节点</li><li>当按访问时间排序时（<code>accessOrder == true</code>），<code>get(key)</code> 会导致 Entry 成为新的 <code>tail</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMap</span> &#123;    Node&lt;K,V&gt; <span class="hljs-title function_">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;        LinkedHashMapEntry&lt;K,V&gt; p =            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMapEntry</span>&lt;K,V&gt;(hash, key, value, e);        linkNodeLast(p);        <span class="hljs-keyword">return</span> p;    &#125;    TreeNode&lt;K,V&gt; <span class="hljs-title function_">newTreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;        TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);        linkNodeLast(p);        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-comment">// link at the end of list</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkNodeLast</span><span class="hljs-params">(LinkedHashMapEntry&lt;K,V&gt; p)</span> &#123;        LinkedHashMapEntry&lt;K,V&gt; last = tail;        tail = p;        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)            head = p;        <span class="hljs-keyword">else</span> &#123;            p.before = last;            last.after = p;        &#125;    &#125;    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;        Node&lt;K,V&gt; e;        <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (accessOrder)            afterNodeAccess(e);        <span class="hljs-keyword">return</span> e.value;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> &#123; <span class="hljs-comment">// move node to last</span>        LinkedHashMapEntry&lt;K,V&gt; last;        <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;            LinkedHashMapEntry&lt;K,V&gt; p =                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;            p.after = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>)                head = a;            <span class="hljs-keyword">else</span>                b.after = a;            <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>)                a.before = b;            <span class="hljs-keyword">else</span>                last = b;            <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)                head = p;            <span class="hljs-keyword">else</span> &#123;                p.before = last;                last.after = p;            &#125;            tail = p;            ++modCount;        &#125;    &#125;                    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>备忘录</tag>
      
      <tag>笔记</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（二）AQS 源码分析以及 Lock 的实现</title>
    <link href="/2021/01/13/aqs-lock-implementation/"/>
    <url>/2021/01/13/aqs-lock-implementation/</url>
    
    <content type="html"><![CDATA[<p>AQS 是 <code>Semaphore</code>、<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 的基础，它们紧密地结合在一块，分析 AQS 除了要明晰排队队列的操作，还要结合 <code>Semaphore</code>、<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 看看是怎么利用排队队列实现锁和信号量的</p><h2 id="AQS-是基于-CLH-锁修改而来的，它的排队队列也是双向链表"><a href="#AQS-是基于-CLH-锁修改而来的，它的排队队列也是双向链表" class="headerlink" title="AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表"></a>AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 队头节点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 队尾节点</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-keyword">volatile</span> Node prev;     <span class="hljs-comment">// 前驱节点</span>    <span class="hljs-keyword">volatile</span> Node next;     <span class="hljs-comment">// 后驱节点</span>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 节点对应的线程</span>&#125;</code></pre></div><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// tryAcquire 返回 true 表示获得锁，返回 false 表示未获得锁</span><span class="hljs-comment">// 由子类实现，比如公平锁、非公平锁等，这里先不讨论</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 如果不能获得锁，在队列里排队并阻塞</span>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="hljs-comment">// 因为 futex 可能会因为中断而返回，acquireQueued 返回 true 表示发生了中断，这里主动调用中断</span>        selfInterrupt();&#125;<span class="hljs-comment">// 在队尾添加一个新节点</span><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(mode);    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">oldTail</span> <span class="hljs-operator">=</span> tail;        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-literal">null</span>) &#123;            U.putObject(node, Node.PREV, oldTail);            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;                oldTail.next = node;                <span class="hljs-keyword">return</span> node;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            initializeSyncQueue();        &#125;    &#125;&#125;<span class="hljs-comment">// 刚开始 head 和 tail 都为 null，这里将 head 和 tail 都初始化为同一个空的 Node</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeSyncQueue</span><span class="hljs-params">()</span> &#123;    Node h;    <span class="hljs-keyword">if</span> (U.compareAndSwapObject(<span class="hljs-built_in">this</span>, HEAD, <span class="hljs-literal">null</span>, (h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>())))        tail = h;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;    Thread.currentThread().interrupt();&#125;</code></pre></div><h2 id="阻塞线程（不是自旋）"><a href="#阻塞线程（不是自旋）" class="headerlink" title="阻塞线程（不是自旋）"></a>阻塞线程（不是自旋）</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();            <span class="hljs-comment">// 当线程没有阻塞且前驱是 head 时，既是轮到当前线程去尝试获得锁</span>            <span class="hljs-comment">// 未获得锁，会进入下面的阻塞代码</span>            <span class="hljs-comment">// 获得锁时，将 node 设为新的表头</span>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node);                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>                <span class="hljs-keyword">return</span> interrupted;            &#125;            <span class="hljs-comment">// 节点入队后，如果不能获得锁，则阻塞线程；中断会打断阻塞</span>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                interrupted = <span class="hljs-literal">true</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        cancelAcquire(node);        <span class="hljs-keyword">throw</span> t;    &#125;&#125;<span class="hljs-comment">// 一般情况下，waitStatus == 0，然后被置为 SIGNAL 并返回 false</span><span class="hljs-comment">// 然后在下一次的循环里，这个方法返回 true</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">do</span> &#123;            node.prev = pred = pred.prev;        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);        pred.next = node;    &#125; <span class="hljs-keyword">else</span> &#123;        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 阻塞当前线程直到 LockSupport.unpark 被调用</span>    LockSupport.park(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">// 中断会导致 park 返回，这里返回是不是由中断引起的返回</span>    <span class="hljs-keyword">return</span> Thread.interrupted();&#125;<span class="hljs-comment">// 表头 head 其实是个空节点</span><span class="hljs-comment">// head.next 有机会去获得锁，后续的节点都是阻塞的</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHead</span><span class="hljs-params">(Node node)</span> &#123;    head = node;    node.thread = <span class="hljs-literal">null</span>;    node.prev = <span class="hljs-literal">null</span>;&#125;</code></pre></div><h2 id="LockSupport-park-LockSupport-unpark"><a href="#LockSupport-park-LockSupport-unpark" class="headerlink" title="LockSupport.park / LockSupport.unpark"></a><code>LockSupport.park</code> / <code>LockSupport.unpark</code></h2><p>它们是专为 <code>Lock</code> 设计的线程同步 API，<code>park</code> 可以阻塞线程，<code>unpark</code> 恢复线程，但它们又与 <code>wait</code>/<code>notify</code> 有所不同</p><ul><li><code>park</code>，如果 <code>permit</code> 为真则把它置为假，否则阻塞（<code>unpark</code> 和中断会导致函数返回）</li><li><code>unpark</code>，如果线程阻塞中则恢复线程，否则将 <code>permit</code> 置为真；也就是说 <code>park</code> 之前的 <code>unpark</code> 会导致下一次的 <code>park</code> 无效，而且多次 <code>unpark</code> 不叠加效果</li></ul><p>可以看到线程的阻塞和唤醒是通过 <code>futex</code> 系统调用实现的，<code>futex</code> 的原型是 <code>int futex (int *uaddr, int op, int val, const struct timespec *timeout,int *uaddr2, int val3)</code></p><ul><li>op == <code>FUTEX_WAIT</code>，原子性的检查 <code>uaddr</code> 中计数器的值是否为 <code>val，</code>如果是则让进程休眠，直到 <code>FUTEX_WAKE</code> 或者超时，也就是把进程挂到 <code>uaddr</code> 相对应的等待队列上去</li><li>op == <code>FUTEX_WAKE</code>，最多唤醒 <code>val</code> 个等待在 <code>uaddr</code> 上进程</li></ul><p>而 <code>permit</code> 则是通过 <code>tls32_.park_state_</code> 实现，它是一个 <code>AtomicInteger</code>，取值范围为 <code>kPermitAvailable</code> = 0，<code>kNoPermit</code> = 1，<code>kNoPermitWaiterWaiting</code> = 2</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();        setBlocker(t, blocker);        U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>); <span class="hljs-comment">// U 是 sun.misc.Unsafe</span>        setBlocker(t, <span class="hljs-literal">null</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)            U.unpark(thread);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unsafe</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> var1, <span class="hljs-type">long</span> var2)</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Object var1)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Unsafe.park 在 art/runtime/native/sun_misc_Unsafe.cc 里注册为 Unsafe_park</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Unsafe_park</span><span class="hljs-params">(JNIEnv* env, jobject, jboolean isAbsolute, jlong time)</span> </span>&#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;    Thread::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">Park</span>(isAbsolute, time);&#125;<span class="hljs-keyword">enum</span> &#123;    kPermitAvailable = <span class="hljs-number">0</span>,  <span class="hljs-comment">// Incrementing consumes the permit</span>    kNoPermit = <span class="hljs-number">1</span>,         <span class="hljs-comment">// Incrementing marks as waiter waiting</span>    kNoPermitWaiterWaiting = <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 初始值为 kNoPermit，自增为 kNoPermitWaiterWaiting 并阻塞；恢复后复原为 kNoPermit</span><span class="hljs-comment">// 如果执行过 unpark，那么为 kPermitAvailable，自增为 kNoPermit 但不会阻塞</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::Park</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_absolute, <span class="hljs-type">int64_t</span> time)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">int</span> old_state = tls32_.park_state_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);    <span class="hljs-keyword">if</span> (old_state == kNoPermit) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">futex</span>(tls32_.park_state_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE,            <span class="hljs-comment">/* sleep if val = */</span> kNoPermitWaiterWaiting,            <span class="hljs-comment">/* timeout */</span> <span class="hljs-literal">nullptr</span>,            <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);    <span class="hljs-comment">// Mark as no longer waiting, and consume permit if there is one.</span>    tls32_.park_state_.<span class="hljs-built_in">store</span>(kNoPermit, std::memory_order_relaxed);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 置为 kPermitAvailable，如果原值为 kNoPermitWaiterWaiting 表示线程被阻塞，需要执行系统调用 futex 唤醒</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::Unpark</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Set permit available; will be consumed either by fetch_add (when the thread</span>    <span class="hljs-comment">// tries to park) or store (when the parked thread is woken up)</span>    <span class="hljs-keyword">if</span> (tls32_.park_state_.<span class="hljs-built_in">exchange</span>(kPermitAvailable, std::memory_order_relaxed) == kNoPermitWaiterWaiting) &#123;        <span class="hljs-type">int</span> result = <span class="hljs-built_in">futex</span>(tls32_.park_state_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE,                           <span class="hljs-comment">/* number of waiters = */</span> <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><h2 id="可重入的公平锁（ReentrantLock-FairSync）"><a href="#可重入的公平锁（ReentrantLock-FairSync）" class="headerlink" title="可重入的公平锁（ReentrantLock.FairSync）"></a>可重入的公平锁（<code>ReentrantLock.FairSync</code>）</h2><p>公平锁按照 FIFO 的优先级顺序，从排队队列的头部开始依次传递锁的所有权</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;        acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 锁没有被取走，把排队队列想象成在 ATM 钱排队取钱的人们，只有当前面没有人的时候才轮到自己取钱</span>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                setExclusiveOwnerThread(current); <span class="hljs-comment">// 标识锁在谁手上</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    <span class="hljs-comment">// 可重入，如果锁在自己手上，递增 state</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            setState(nextc);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<span class="hljs-comment">// 返回 true 表示在前面有人在排队取钱，还没轮到自己；返回 false 表示前面没人了，轮到自己取钱了</span><span class="hljs-comment">// h == t 和 h.next == null 是刚初始化 head 和 tail 为空 node 且没有线程入队的情况</span><span class="hljs-comment">// h.next 是第一个等待取钱的人，如果它不是当前线程，说明还没轮到自己</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// The correctness of this depends on head being initialized</span>        <span class="hljs-comment">// before tail and on head.next being accurate if the current</span>        <span class="hljs-comment">// thread is first in queue.</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; <span class="hljs-comment">// Read fields in reverse initialization order</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;        Node s;        <span class="hljs-keyword">return</span> h != t &amp;&amp;            ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());    &#125;&#125;</code></pre></div><h2 id="可重入的非公平锁（ReentrantLock-NonfairSync）"><a href="#可重入的非公平锁（ReentrantLock-NonfairSync）" class="headerlink" title="可重入的非公平锁（ReentrantLock.NonfairSync）"></a>可重入的非公平锁（<code>ReentrantLock.NonfairSync</code>）</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 只要锁没有被取走，自己就可以获得锁</span>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))            setExclusiveOwnerThread(Thread.currentThread());        <span class="hljs-keyword">else</span>            acquire(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 锁没有被取走，那么自己可以直接获得锁</span>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                setExclusiveOwnerThread(current);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-comment">// 可重入，锁已经在自己手上，递增 state</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            setState(nextc);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>排队取锁的线程都被阻塞了，释放锁的同时需要唤醒下一个排队的线程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-comment">// tryRelease 由子类实现，返回 true 表示当前线程持有锁并成功释放锁（可重入的情况下，未必能够释放锁）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// head 是持有锁的线程</span>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)                unparkSuccessor(h);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * If status is negative (i.e., possibly needing signal) try</span><span class="hljs-comment">         * to clear in anticipation of signalling.  It is OK if this</span><span class="hljs-comment">         * fails or if status is changed by waiting thread.</span><span class="hljs-comment">         */</span>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)            node.compareAndSetWaitStatus(ws, <span class="hljs-number">0</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Thread to unpark is held in successor, which is normally</span><span class="hljs-comment">         * just the next node.  But if cancelled or apparently null,</span><span class="hljs-comment">         * traverse backwards from tail to find the actual</span><span class="hljs-comment">         * non-cancelled successor.</span><span class="hljs-comment">         * head.next 一般是排队等待锁里的第一个，但它可能被取消了或者其他原因从队伍里删除了，那么我们从队尾开始遍历找可以唤醒的线程</span><span class="hljs-comment">         */</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;            s = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != node &amp;&amp; p != <span class="hljs-literal">null</span>; p = p.prev)                <span class="hljs-keyword">if</span> (p.waitStatus &lt;= <span class="hljs-number">0</span>)                    s = p;        &#125;        <span class="hljs-comment">// 唤醒下一个线程，让他去尝试获取锁</span>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)            LockSupport.unpark(s.thread);    &#125;&#125;</code></pre></div><h2 id="可重入锁的释放过程（ReentrantLock-Sync）"><a href="#可重入锁的释放过程（ReentrantLock-Sync）" class="headerlink" title="可重入锁的释放过程（ReentrantLock.Sync）"></a>可重入锁的释放过程（<code>ReentrantLock.Sync</code>）</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;        <span class="hljs-comment">// releases 恒为一，而 state 为重入得次数，也即重入次数减一</span>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;        <span class="hljs-comment">// 当前线程不持有锁，抛出异常</span>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();        <span class="hljs-comment">// 如果重入次数为零，那么可以释放锁</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;            free = <span class="hljs-literal">true</span>;            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);        &#125;        setState(c);        <span class="hljs-keyword">return</span> free;    &#125;&#125;</code></pre></div><h2 id="可重入的读写锁（ReentrantReadWriteLock）"><a href="#可重入的读写锁（ReentrantReadWriteLock）" class="headerlink" title="可重入的读写锁（ReentrantReadWriteLock）"></a>可重入的读写锁（<code>ReentrantReadWriteLock</code>）</h2><p>一个资源能够被多个读线程访问（读锁有多把），或者被一个写线程访问（写锁只有一把），但是不能同时存在读写线程（读锁和写锁是互斥的）</p><h2 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;        sync.acquireShared(<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)            doAcquireShared(arg);    &#125;&#125;<span class="hljs-comment">// 能不能获得读锁</span><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();        <span class="hljs-comment">// 对于上面的可重入排它锁，state == 0 表示锁未被其他线程获得，</span>        <span class="hljs-comment">// state == 1 表示锁已被某个线程获得，state &gt; 1 表示重入得次数</span>        <span class="hljs-comment">// 对于读写锁，state 高 16 位表示读锁的个数，state 低 16 位表示写锁重入得个数</span>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-comment">// 写锁被其他线程获得了，读写锁是互斥的，不能借出读锁</span>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;            getExclusiveOwnerThread() != current)            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-comment">// 获得读锁，state 读锁次数加一</span>        <span class="hljs-comment">// 获得读锁的线程用 threadlocal count 记录获得的读锁的数量，这里也要加一（用来观察当前线程拿了几个读锁）</span>        <span class="hljs-comment">// readerShouldBlock 的解释见下文</span>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);        <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;            r &lt; MAX_COUNT &amp;&amp;            compareAndSetState(c, c + SHARED_UNIT)) &#123;            <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;                firstReader = current;                firstReaderHoldCount = <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;                firstReaderHoldCount++;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))                    cachedHoldCounter = rh = readHolds.get();                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)                    readHolds.set(rh);                rh.count++;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// fullTryAcquireShared 其实是 tryAcquireShared 的自旋版本</span>        <span class="hljs-comment">// 针对 compareAndSetState(c, c + SHARED_UNIT) 失败而自旋，也就是被别的线程抢先获得了一个读锁</span>        <span class="hljs-keyword">return</span> fullTryAcquireShared(current);    &#125;&#125;<span class="hljs-comment">// 不能获得锁，排队并阻塞</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED); <span class="hljs-comment">// 添加 shared 节点至队尾</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 循环取锁</span>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();                <span class="hljs-keyword">if</span> (p == head) &#123;                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                        setHeadAndPropagate(node, r);                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>                        <span class="hljs-keyword">if</span> (interrupted)                            selfInterrupt();                        <span class="hljs-keyword">return</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                    interrupted = <span class="hljs-literal">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            cancelAcquire(node);            <span class="hljs-keyword">throw</span> t;        &#125;    &#125;&#125;<span class="hljs-comment">// tryAcquireShared 有可能是在排队等待的过程中线程被唤醒而执行</span><span class="hljs-comment">// 此时对于公平锁，只有当前面没有排队的前驱时才能去拿锁</span><span class="hljs-comment">// 对于非公平锁，见下面的注释，为了防止「写饥饿」，也就是认为写操作要比读操作更重要一点，不能完全地让所有取锁的线程去争抢</span><span class="hljs-comment">// 而是得让在对头等待的写线程优先获得锁</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">/* As a heuristic to avoid indefinite writer starvation,</span><span class="hljs-comment">         * block if the thread that momentarily appears to be head</span><span class="hljs-comment">         * of queue, if one exists, is a waiting writer.  This is</span><span class="hljs-comment">         * only a probabilistic effect since a new reader will not</span><span class="hljs-comment">         * block if there is a waiting writer behind other enabled</span><span class="hljs-comment">         * readers that have not yet drained from the queue.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();    &#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> hasQueuedPredecessors();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">apparentlyFirstQueuedIsExclusive</span><span class="hljs-params">()</span> &#123;        Node h, s;        <span class="hljs-keyword">return</span> (h = head) != <span class="hljs-literal">null</span> &amp;&amp;            (s = h.next)  != <span class="hljs-literal">null</span> &amp;&amp;            !s.isShared()         &amp;&amp;            s.thread != <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><h2 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;        sync.acquire(<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))            selfInterrupt();    &#125;&#125;<span class="hljs-comment">// 能不能获得写锁；失败的话跟排它锁一样排队阻塞</span><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>            <span class="hljs-comment">// 读锁不为零，读写锁互斥，不能获得写锁</span>            <span class="hljs-comment">// 写锁不为零，但是被别的线程获得，当前线程也不能获得写锁</span>            <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-comment">// 不能超过 16 位的长度（因为写锁的数量存储在 state 的低 16 位）</span>            <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);            <span class="hljs-comment">// 当前线程已持有写锁，重入导致写锁数量加一</span>            setState(c + acquires);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">// 读锁和写锁都为零，当然可以获得写锁；state 里的写锁数量加一，记下谁拿了写锁</span>        <span class="hljs-comment">// 因为 tryAcquire 有可能是在排队过程中被唤醒而触发的，所以在非公平锁的情况下，能获得锁直接拿就好了</span>        <span class="hljs-comment">// 而在公平锁的情况下，需要等前面排队的先拿锁</span>        <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        setExclusiveOwnerThread(current);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// writers can always barge</span>    &#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 上面介绍过，判断自己前面还有没有前驱</span>        <span class="hljs-comment">// 公平锁的情况下，只有轮到自己（没有前驱，或者说前面没有排队的）的情况下，才去获取锁</span>        <span class="hljs-keyword">return</span> hasQueuedPredecessors();    &#125;&#125;</code></pre></div><h2 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;        sync.releaseShared(<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;            doReleaseShared();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;        <span class="hljs-comment">// threadlocal count（线程的读锁计数器）减一</span>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();        <span class="hljs-keyword">if</span> (firstReader == current) &#123;            <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)                firstReader = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">else</span>                firstReaderHoldCount--;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))                rh = readHolds.get();            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;                readHolds.remove();                <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">throw</span> unmatchedUnlockException();            &#125;            --rh.count;        &#125;        <span class="hljs-comment">// 总的读锁计数器减一</span>        <span class="hljs-comment">// 读锁是共享的，释放一个读锁不影响其他的读锁；但如果读锁为零，需要唤醒阻塞在写锁上的线程</span>        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))                <span class="hljs-comment">// Releasing the read lock has no effect on readers,</span>                <span class="hljs-comment">// but it may allow waiting writers to proceed if</span>                <span class="hljs-comment">// both read and write locks are now free.</span>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-comment">// 写锁个数减一，当写锁个数为零时，返回 true 导致 AQS 移除当前节点并唤醒下一个排队的线程</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;        <span class="hljs-keyword">if</span> (!isHeldExclusively())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;        <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (free)            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);        setState(nextc);        <span class="hljs-keyword">return</span> free;    &#125;&#125;</code></pre></div><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量相当于一个保存着多个锁的保险箱，它可以向外借出锁（<code>acquire</code>）和回收借出的锁（<code>release</code>），当锁用完的时候 <code>acquire</code> 会阻塞</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得锁</span><span class="hljs-keyword">void</span> Semaphore.acquire() <span class="hljs-keyword">throws</span> InterruptedException &#123;    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">void</span> AbstractQueuedSynchronizer.acquireSharedInterruptibly(<span class="hljs-type">int</span> arg) <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-keyword">if</span> (Thread.interrupted())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)        doAcquireSharedInterruptibly(arg);&#125;<span class="hljs-comment">// 看下排队队列，跟上面的 Lock 操作是一样的</span><span class="hljs-comment">// 添加节点到队尾，循环判断是否轮到自己获得锁，否则陷入阻塞直到被唤醒</span><span class="hljs-keyword">void</span> AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(<span class="hljs-type">int</span> arg) <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();            <span class="hljs-keyword">if</span> (p == head) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                    setHeadAndPropagate(node, r);                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        cancelAcquire(node);        <span class="hljs-keyword">throw</span> t;    &#125;&#125;<span class="hljs-comment">// 非公平锁</span><span class="hljs-comment">// state 表示保险箱内锁的数量</span><span class="hljs-comment">// 如果已经没有锁可以借出，则返回负数导致线程进入排队队列，排队并阻塞</span><span class="hljs-comment">// 如果可以借出锁，则更新 state 并返回</span><span class="hljs-comment">// 因为是非公平锁，所以无需考虑前面是否有排队的线程</span><span class="hljs-type">int</span> NonfairSync.tryAcquireShared(<span class="hljs-type">int</span> acquires) &#123;    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);&#125;<span class="hljs-type">int</span> Sync.nonfairTryAcquireShared(<span class="hljs-type">int</span> acquires) &#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> || compareAndSetState(available, remaining))            <span class="hljs-keyword">return</span> remaining;    &#125;&#125;<span class="hljs-comment">// 公平锁，跟非公平锁一样的，只不过当前面有排队线程时，要让它先获得锁</span><span class="hljs-type">int</span> FairSync.tryAcquireShared(<span class="hljs-type">int</span> acquires) &#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||            compareAndSetState(available, remaining))            <span class="hljs-keyword">return</span> remaining;    &#125;&#125;<span class="hljs-comment">// 释放锁</span><span class="hljs-comment">// state 加一，唤醒排队线程</span><span class="hljs-keyword">void</span> Semaphore.release() &#123;    sync.releaseShared(<span class="hljs-number">1</span>);&#125;<span class="hljs-type">boolean</span> AbstractQueuedSynchronizer.releaseShared(<span class="hljs-type">int</span> arg) &#123;    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;        doReleaseShared();        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108449850">AQS与CLH相关论文学习系列（四）- AQS的设计思路</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（一）AQS 基础</title>
    <link href="/2021/01/10/aqs-basic/"/>
    <url>/2021/01/10/aqs-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h2><p>获得锁的时候，不阻塞线程，而是跟平常一样继续获得 CPU 时间，继续执行代码/逻辑，那就是自旋锁；比如下面的 <code>lock()</code></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 一个简单的自旋锁的实现</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLock</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cas = AtomicReference&lt;Thread&gt;()    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">while</span> (!cas.compareAndSet(<span class="hljs-literal">null</span>, Thread.currentThread())) &#123;&#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span> &#123;        cas.compareAndSet(Thread.currentThread(), <span class="hljs-literal">null</span>)    &#125;&#125;</code></pre></div><h2 id="MCS-锁"><a href="#MCS-锁" class="headerlink" title="MCS 锁"></a>MCS 锁</h2><p>上面的自旋锁容易出现「饥饿」问题，因为所有线程同时争抢一个锁，如果一直有线程加入到争抢的过程中来，那么可能会出现某一个或多个线程总是抢不到锁的情况</p><p>而 MCS 在自旋的基础上，引入了「排队」的概念（基于链表）</p><ul><li><code>acquire_lock</code>，<code>L</code> 是链尾节点，<code>I</code> 是当前线程所使用的节点，<code>fetch_and_store</code> 相当于原子性地把 I 添加到链尾，并对 <code>I→locked</code> 进行自旋</li><li><code>release_lock</code>，将 <code>I→next→locked</code> 置为 <code>false</code>，从而使下一个线程获得锁（跳出自旋）</li></ul><p>那么所有未获得锁的线程都会按顺序排成一队（通过 <code>I→next</code> 形成的单向链表），并对 <code>I→locked</code> 自旋，这就是排队自旋锁</p><p>获得锁的线程负责将锁传递给下一个未获得锁的线程（<code>I→next→locked := false</code>）</p><p><img src="../../../../image/2021-01-10-aqs-basic/2020090217384261.png" alt="2020090217384261.png"></p><h2 id="CLH-锁"><a href="#CLH-锁" class="headerlink" title="CLH 锁"></a>CLH 锁</h2><p>它减少释放锁时的自旋开销：</p><ul><li>MCS 锁的持有进程在让渡锁的所有权时，由于需要关心自己的后继结点是否存在以及是否会被突然添加，所以多了一些负担</li><li>MCS 锁在持有进程在让渡锁的所有权时，由于已经知道后继结点肯定只能监控自己在入队时就设置好的结点，所以无需关心是否存在后继结点，只需要修改自己预留给后继结点监控的队列结点状态即可。</li></ul><p>MCS 实现了基于 FIFO 的优先级，而 CLH 可以实现自定义的优先级</p><p>CLH 锁的排队队列是个双向链表，<code>Lock.head</code> 和 <code>Lock.tail</code> 分别是表头和表尾</p><p><code>Process.watch</code> 是当前线程用来自旋的，<code>Process.myreq</code> 留给下一个线程进行自旋；比如线程 P2 在 <code>P2.watch</code> 上自旋，同时 <code>P2.watch</code> 又是 <code>P1.myreq</code>；而 <code>P2.myreq</code> 则是 <code>P3.watch</code>，P3 在 <code>P3.watch</code> 上自旋</p><p><code>Request.watcher</code> 表示那个线程在对它自旋，<code>Request.myproc</code> 表示自旋线程的上一个线程</p><p>从表头开始遍历线程：<code>Lock.head.watcher</code> → <code>Process.myreq.watcher</code> → <code>Process.myreq.watcher</code>→ …</p><p>从表尾开始遍历线程：<code>Lock.tail.myproc</code> → <code>Process.watch.myproc</code> → <code>Process.watch.myproc</code> → …</p><p><code>request_lock</code>（获得锁），将 <code>P.myreq</code> 添加到队尾，并在 <code>P.watch</code>（既是上一个队尾，也是上一个线程的 <code>Process.myreq</code>） 上自旋</p><p><code>grant_lock</code>（释放锁），从头开始遍历排队的线程，找到优先级最高的线程（<code>Process.pri</code>，不仅仅是 FIFO），将它的 <code>Process.watch.state := GRANTED</code> 从而使它跳出自旋（将锁的所有权转移给它）</p><p><img src="../../../../image/2021-01-10-aqs-basic/2020090322512651.png" alt="2020090322512651.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903154644711.png" alt="20200903154644711.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903162049551.png" alt="20200903162049551.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903222817656.png" alt="20200903222817656.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903223128890.png" alt="20200903223128890.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108227584">AQS与CLH相关论文学习系列（一）- 排队式自旋锁思想启蒙</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108448199">AQS与CLH相关论文学习系列（二）- MCS 锁</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108449111">AQS与CLH相关论文学习系列（三）- CLH 锁</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（三）render thread</title>
    <link href="/2020/12/27/render-thread/"/>
    <url>/2020/12/27/render-thread/</url>
    
    <content type="html"><![CDATA[<p>接着<a href="../../../../2020/12/13/ui-thread-in-vsync/">上一篇文章</a>，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 <code>DisplayList</code>，而 render thread 会根据 <code>DisplayList</code> 执行真正的渲染工作，主要是 <code>DrawFrameTask.syncFrameState</code> 和 <code>CanvasContext.draw</code> 这两个方法</p><h2 id="syncFrameState"><a href="#syncFrameState" class="headerlink" title="syncFrameState"></a>syncFrameState</h2><p>重要的方法有三个：<code>makeCurrent</code>，<code>unpinImages</code> 和 <code>prepareTree</code></p><p><code>TreeInfo</code> 用来在后续的一系列操作中收集信息，你会看到它在各个方法中作为参数传递</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DrawFrameTask::syncFrameState</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">bool</span> canDraw = mContext-&gt;<span class="hljs-built_in">makeCurrent</span>();    mContext-&gt;<span class="hljs-built_in">unpinImages</span>();    <span class="hljs-comment">// ...</span>    mContext-&gt;<span class="hljs-built_in">setContentDrawBounds</span>(mContentDrawBounds);    mContext-&gt;<span class="hljs-built_in">prepareTree</span>(info, mFrameInfo, mSyncQueued, mTargetNode);    <span class="hljs-comment">// ... If prepareTextures is false, we ran out of texture cache space</span>    <span class="hljs-keyword">return</span> info.prepareTextures;&#125;</code></pre></div><h2 id="makeCurrent"><a href="#makeCurrent" class="headerlink" title="makeCurrent"></a>makeCurrent</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CanvasContext::makeCurrent</span><span class="hljs-params">()</span></span><span class="hljs-function">MakeCurrentResult <span class="hljs-title">SkiaOpenGLPipeline::makeCurrent</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (!mEglManager.<span class="hljs-built_in">makeCurrent</span>(mEglSurface, &amp;error)) &#123;        <span class="hljs-keyword">return</span> MakeCurrentResult::AlreadyCurrent;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EglManager::makeCurrent</span><span class="hljs-params">(EGLSurface surface, EGLint* errOut, <span class="hljs-type">bool</span> force)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">eglMakeCurrent</span>(mEglDisplay, surface, surface, mEglContext)) &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>最终是调用了 opengl 的 <code>[eglMakeCurrent](https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml)</code> 方法准备 opengl 环境；现在是 ui thread，并不会在这里进行渲染，而是为了待会将 mutable images 上传到 gpu</p><p>opengl api 都是像 <code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glBindTexture</code> 这样只有方法名和参数的，它的上下文是绑定在 thread 上的，在调用 opengl api 前 <code>eglMakeCurrent</code> 就是确保当前线程有 opengl 上下文；mEglDisplay 可以理解为设备的屏幕；opengl 有双缓冲，一个被主线程读取，一个被渲染线程写入，就是第二和第三个参数，渲染完交换一下，读变写，写变读，当前都是用得同一个 surface；第四个就是 opengl 的上下文，保存了 opengl 状态机</p><h2 id="unpinImages"><a href="#unpinImages" class="headerlink" title="unpinImages"></a>unpinImages</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/** \class SkImage</span><span class="hljs-comment">    SkImage describes a two dimensional array of pixels to draw. The pixels may be</span><span class="hljs-comment">    decoded in a raster bitmap, encoded in a SkPicture or compressed data stream,</span><span class="hljs-comment">    or located in GPU memory as a GPU texture.</span><span class="hljs-comment"></span><span class="hljs-comment">    SkImage cannot be modified after it is created. SkImage may allocate additional</span><span class="hljs-comment">    storage as needed; for instance, an encoded SkImage may decode when drawn.</span><span class="hljs-comment"></span><span class="hljs-comment">    SkImage width and height are greater than zero. Creating an SkImage with zero width</span><span class="hljs-comment">    or height returns SkImage equal to nullptr.</span><span class="hljs-comment"></span><span class="hljs-comment">    SkImage may be created from SkBitmap, SkPixmap, SkSurface, SkPicture, encoded streams,</span><span class="hljs-comment">    GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported</span><span class="hljs-comment">    include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encoding details</span><span class="hljs-comment">    vary with platform.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SK_API</span> SkImage    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Pin any mutable images to the GPU cache. A pinned images is guaranteed to</span><span class="hljs-comment">     * remain in the cache until it has been unpinned. We leverage this feature</span><span class="hljs-comment">     * to avoid making a CPU copy of the pixels.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * @return true if all images have been successfully pinned to the GPU cache</span><span class="hljs-comment">     *         and false otherwise (e.g. cache limits have been exceeded).</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pinImages</span><span class="hljs-params">(std::vector&lt;SkImage*&gt;&amp; mutableImages)</span> </span>&#123;        <span class="hljs-keyword">return</span> mRenderPipeline-&gt;<span class="hljs-built_in">pinImages</span>(mutableImages);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Unpin any image that had be previously pinned to the GPU cache</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unpinImages</span><span class="hljs-params">()</span> </span>&#123; mRenderPipeline-&gt;<span class="hljs-built_in">unpinImages</span>(); &#125;</code></pre></div><p><code>SkImage</code> 对一切图像的抽象，包括 jpg、webp 等压缩格式、Bitmap 位图、流、甚至 gpu 上的纹理</p><p><code>pinImages</code> 把在内存的 SkImage 作为纹理上传到 gpu 内存，然后可以通过纹理 id 引用，从而避免在内存里操作（复制）像素</p><p><code>unpinImages</code> 从 gpu 内存里移除纹理</p><h2 id="DamageAccumulator"><a href="#DamageAccumulator" class="headerlink" title="DamageAccumulator"></a>DamageAccumulator</h2><p><code>DamageAccumulator</code> 是 <code>DirtyStack</code> stack（FIFO，用双向链表实现），用来累计脏区，它的一般用法是这样的</p><div class="code-wrapper"><pre><code class="hljs cpp">info.damageAccumulator-&gt;<span class="hljs-built_in">pushTransform</span>(<span class="hljs-keyword">this</span>);<span class="hljs-built_in">damageSelf</span>(info);info.damageAccumulator-&gt;<span class="hljs-built_in">popTransform</span>();<span class="hljs-comment">// 将 node 压入栈顶</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DamageAccumulator::pushTransform</span><span class="hljs-params">(<span class="hljs-type">const</span> RenderNode* transform)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">// 更新栈顶元素的脏区 = 已有脏区 + node 大小，也就是并集</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::damageSelf</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isRenderable</span>()) &#123;        mDamageGenerationId = info.damageGenerationId;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getClipDamageToBounds</span>()) &#123;            info.damageAccumulator-&gt;<span class="hljs-built_in">dirty</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getWidth</span>(), <span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getHeight</span>());        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Hope this is big enough?</span>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Get this from the display list ops or something</span>            info.damageAccumulator-&gt;<span class="hljs-built_in">dirty</span>(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DamageAccumulator::dirty</span><span class="hljs-params">(<span class="hljs-type">float</span> left, <span class="hljs-type">float</span> top, <span class="hljs-type">float</span> right, <span class="hljs-type">float</span> bottom)</span> </span>&#123;    mHead-&gt;pendingDirty.<span class="hljs-built_in">join</span>(&#123;left, top, right, bottom&#125;);&#125;<span class="hljs-comment">// 弹出栈顶元素 head，并将栈顶元素的脏区合并到当前栈顶元素 prev 的脏区</span><span class="hljs-comment">// 可见脏区是累加的</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DamageAccumulator::popTransform</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(mHead-&gt;prev == mHead, <span class="hljs-string">&quot;Cannot pop the root frame!&quot;</span>);    DirtyStack* dirtyFrame = mHead;    mHead = mHead-&gt;prev;    <span class="hljs-keyword">switch</span> (dirtyFrame-&gt;type) &#123;        <span class="hljs-keyword">case</span> TransformRenderNode:            <span class="hljs-built_in">applyRenderNodeTransform</span>(dirtyFrame);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> TransformMatrix4:            <span class="hljs-built_in">applyMatrix4Transform</span>(dirtyFrame);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> TransformNone:            mHead-&gt;pendingDirty.<span class="hljs-built_in">join</span>(dirtyFrame-&gt;pendingDirty);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;Tried to pop an invalid type: %d&quot;</span>, dirtyFrame-&gt;type);    &#125;&#125;</code></pre></div><h2 id="prepareTree"><a href="#prepareTree" class="headerlink" title="prepareTree"></a>prepareTree</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CanvasContext::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info, <span class="hljs-type">int64_t</span>* uiFrameInfo, <span class="hljs-type">int64_t</span> syncQueued, RenderNode* target)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;        <span class="hljs-comment">// Only the primary target node will be drawn full - all other nodes would get drawn in</span>        <span class="hljs-comment">// real time mode. In case of a window, the primary node is the window content and the other</span>        <span class="hljs-comment">// node(s) are non client / filler nodes.</span>        info.mode = (node.<span class="hljs-built_in">get</span>() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);        node-&gt;<span class="hljs-built_in">prepareTree</span>(info);    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>target 是 <code>HardwareRenderer.mRootNode</code> 对应的 native <code>RootRenderNode</code>，<code>mRenderNodes</code> 正常情况下应该只有一个元素 target，所以这里应该总是 <code>TreeInfo::MODE_FULL</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info)</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::prepareTreeImpl</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-type">bool</span> functorsNeedLayer)</span> </span>&#123;        <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;        <span class="hljs-built_in">pushStagingDisplayListChanges</span>(observer, info);    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (mDisplayList) &#123;        info.out.hasFunctors |= mDisplayList-&gt;<span class="hljs-built_in">hasFunctor</span>();        <span class="hljs-type">bool</span> isDirty = mDisplayList-&gt;<span class="hljs-built_in">prepareListAndChildren</span>(observer, info, childFunctorsNeedLayer,            [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-type">bool</span> functorsNeedLayer) &#123;                child-&gt;<span class="hljs-built_in">prepareTreeImpl</span>(observer, info, functorsNeedLayer);            &#125;);        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-built_in">pushLayerUpdate</span>(info);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::pushStagingDisplayListChanges</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mNeedsDisplayListSync) &#123;        mNeedsDisplayListSync = <span class="hljs-literal">false</span>;        <span class="hljs-built_in">damageSelf</span>(info);        <span class="hljs-built_in">syncDisplayList</span>(observer, &amp;info);        <span class="hljs-built_in">damageSelf</span>(info);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::syncDisplayList</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo* info)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mStagingDisplayList) &#123;        mStagingDisplayList-&gt;<span class="hljs-built_in">updateChildren</span>([](RenderNode* child) &#123; child-&gt;<span class="hljs-built_in">incParentRefCount</span>(); &#125;);    &#125;    <span class="hljs-built_in">deleteDisplayList</span>(observer, info);    mDisplayList = mStagingDisplayList;    mStagingDisplayList = <span class="hljs-literal">nullptr</span>;    <span class="hljs-keyword">if</span> (mDisplayList) &#123;        WebViewSyncData syncData &#123;            .applyForceDark = info &amp;&amp; !info-&gt;disableForceDark        &#125;;        mDisplayList-&gt;<span class="hljs-built_in">syncContents</span>(syncData);        <span class="hljs-built_in">handleForceDark</span>(info);    &#125;&#125;</code></pre></div><p>还记得在<a href="../../../../2020/12/13/ui-thread-in-vsync/">上篇文章</a>里提到， DisplayList 在 endRecording 阶段被放在 <code>RenderNode.mStagingDisplayList</code>，这时候转移到 <code>mDisplayList</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SkiaDisplayList::prepareListAndChildren</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-type">bool</span> functorsNeedLayer,</span></span><span class="hljs-params"><span class="hljs-function">        std::function&lt;<span class="hljs-type">void</span>(RenderNode*, TreeObserver&amp;, TreeInfo&amp;, <span class="hljs-type">bool</span>)&gt; childFn)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (info.prepareTextures &amp;&amp; !info.canvasContext.<span class="hljs-built_in">pinImages</span>(mMutableImages)) &#123;        info.prepareTextures = <span class="hljs-literal">false</span>;        info.canvasContext.<span class="hljs-built_in">unpinImages</span>();    &#125;    <span class="hljs-type">bool</span> hasBackwardProjectedNodesHere = <span class="hljs-literal">false</span>;    <span class="hljs-type">bool</span> hasBackwardProjectedNodesSubtree = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : mChildNodes) &#123;        RenderNode* childNode = child.<span class="hljs-built_in">getRenderNode</span>();        <span class="hljs-comment">// ...</span>        <span class="hljs-built_in">childFn</span>(childNode, observer, info, functorsNeedLayer);        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p><code>SkiaRecordingCanvas.drawBitmap</code> 等方法会将 mutable image 放入 <code>mMutableImages</code>，然后在 prepare 阶段上传到 gpu；为什么这么做呢，我猜想是在渲染之前需要确保所有内容都计算完毕并确保不变，mutable image 可以被修改，所以放到 gpu 里确保不被改动，immutable image 因为本身就不可修改所以无需这样处理</p><p><code>TreeInfo.prepareTextures</code> 标识 mutable images 有没上传成功；如果上传成功，ui thread 在 <code>DrawFrameTask::syncFrameState</code> 之后就会被唤醒，否则会一直阻塞直到 <code>CanvasContext.draw</code> 完成；这对 ui thread 有着很大的影响</p><p><code>SkiaDisplayList.mChildNodes</code> 应该只有一个 <code>DecorView.mRenderNode</code>，在这里它的 <code>prepareTreeImpl</code> 被调用</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::pushLayerUpdate</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (info.canvasContext.<span class="hljs-built_in">createOrUpdateLayer</span>(<span class="hljs-keyword">this</span>, *info.damageAccumulator, info.errorHandler)) &#123;        <span class="hljs-built_in">damageSelf</span>(info);    &#125;    <span class="hljs-comment">// ... 将有 layer 的 RenderNode 和它的脏区加入 TreeInfo.layerUpdateQueue</span>    SkRect dirty;    info.damageAccumulator-&gt;<span class="hljs-built_in">peekAtDirty</span>(&amp;dirty);    info.layerUpdateQueue-&gt;<span class="hljs-built_in">enqueueLayerWithDamage</span>(<span class="hljs-keyword">this</span>, dirty);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 如果 node 没有 layer，或者 node 的大小发送了改变，则新建 layer</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SkiaPipeline::createOrUpdateLayer</span><span class="hljs-params">(RenderNode* node, <span class="hljs-type">const</span> DamageAccumulator&amp; damageAccumulator,</span></span><span class="hljs-params"><span class="hljs-function">                                       ErrorHandler* errorHandler)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    SkSurface* layer = node-&gt;<span class="hljs-built_in">getLayerSurface</span>();    <span class="hljs-keyword">if</span> (!layer || layer-&gt;<span class="hljs-built_in">width</span>() != surfaceWidth || layer-&gt;<span class="hljs-built_in">height</span>() != surfaceHeight) &#123;        SkImageInfo info;        info = SkImageInfo::<span class="hljs-built_in">Make</span>(surfaceWidth, surfaceHeight, <span class="hljs-built_in">getSurfaceColorType</span>(),                                 kPremul_SkAlphaType, <span class="hljs-built_in">getSurfaceColorSpace</span>());        <span class="hljs-function">SkSurfaceProps <span class="hljs-title">props</span><span class="hljs-params">(<span class="hljs-number">0</span>, kUnknown_SkPixelGeometry)</span></span>;        node-&gt;<span class="hljs-built_in">setLayerSurface</span>(SkSurface::<span class="hljs-built_in">MakeRenderTarget</span>(mRenderThread.<span class="hljs-built_in">getGrContext</span>(),                                                          SkBudgeted::kYes, info, <span class="hljs-number">0</span>,                                                          <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getSurfaceOrigin</span>(), &amp;props));    <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p>我们知道 <code>View</code> 是 framework ui api，<code>RenderNode</code> 相当于绘制这块 <code>View</code> 所需的配置文件；这里新增了一个新的概念 layer，它是这块 <code>View</code> 对应的 surface，它所呈现的内容将绘制在这个 surface 上，同 opengl 里 surface 的概念</p><p><code>RenderNode</code> 和它的脏区被添加到 <code>TreeInfo.layerUpdateQueue</code>；queue 里应该有两个元素，一个是 <code>HardwareRenderer.mRootNode</code> 对应的 native <code>RootRenderNode</code>，一个是 <code>DecorView.mRenderNode</code></p><h2 id="CanvasContext-draw"><a href="#CanvasContext-draw" class="headerlink" title="CanvasContext.draw"></a>CanvasContext.draw</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 还记得上面说的吗，脏区是累加的，这里是总的脏区</span>    SkRect dirty;    mDamageAccumulator.<span class="hljs-built_in">finish</span>(&amp;dirty);    <span class="hljs-comment">// ...</span>    Frame frame = mRenderPipeline-&gt;<span class="hljs-built_in">getFrame</span>();    <span class="hljs-built_in">setPresentTime</span>();    <span class="hljs-comment">// 再次计算脏区</span>    SkRect windowDirty = <span class="hljs-built_in">computeDirtyRect</span>(frame, &amp;dirty);    <span class="hljs-type">bool</span> drew = mRenderPipeline-&gt;<span class="hljs-built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,                                      &amp;(<span class="hljs-built_in">profiler</span>()));    <span class="hljs-type">int64_t</span> frameCompleteNr = <span class="hljs-built_in">getFrameNumber</span>();    <span class="hljs-built_in">waitOnFences</span>();    <span class="hljs-type">bool</span> requireSwap = <span class="hljs-literal">false</span>;    <span class="hljs-type">int</span> error = OK;    <span class="hljs-type">bool</span> didSwap = mRenderPipeline-&gt;<span class="hljs-built_in">swapBuffers</span>(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="getFrame"><a href="#getFrame" class="headerlink" title="getFrame"></a>getFrame</h2><p>看下 <code>Frame</code>，它包含 <code>EGLSurface</code> 和 surface 宽高</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Frame <span class="hljs-title">SkiaOpenGLPipeline::getFrame</span><span class="hljs-params">()</span></span><span class="hljs-function">Frame <span class="hljs-title">EglManager::beginFrame</span><span class="hljs-params">(EGLSurface surface)</span> </span>&#123;    <span class="hljs-comment">// ... </span>    <span class="hljs-built_in">makeCurrent</span>(surface);    Frame frame;    frame.mSurface = surface;    <span class="hljs-built_in">eglQuerySurface</span>(mEglDisplay, surface, EGL_WIDTH, &amp;frame.mWidth);    <span class="hljs-built_in">eglQuerySurface</span>(mEglDisplay, surface, EGL_HEIGHT, &amp;frame.mHeight);    frame.mBufferAge = <span class="hljs-built_in">queryBufferAge</span>(surface);    <span class="hljs-built_in">eglBeginFrame</span>(mEglDisplay, surface);    <span class="hljs-keyword">return</span> frame;&#125;</code></pre></div><h2 id="IRenderPipeline-draw"><a href="#IRenderPipeline-draw" class="headerlink" title="IRenderPipeline::draw"></a>IRenderPipeline::draw</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SkiaOpenGLPipeline::draw</span><span class="hljs-params">(...)</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkiaPipeline::renderFrame</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    SkCanvas* canvas = <span class="hljs-built_in">tryCapture</span>(surface.<span class="hljs-built_in">get</span>(), nodes[<span class="hljs-number">0</span>].<span class="hljs-built_in">get</span>(), layers);    <span class="hljs-comment">// draw all layers up front</span>    <span class="hljs-built_in">renderLayersImpl</span>(layers, opaque);    <span class="hljs-built_in">renderFrameImpl</span>(clip, nodes, opaque, contentDrawBounds, canvas, preTransform);    <span class="hljs-built_in">endCapture</span>(surface.<span class="hljs-built_in">get</span>());    <span class="hljs-comment">// 绘制「布局边界」、「渲染分析」等 debug 信息，这里略过</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(Properties::debugOverdraw)) &#123;        <span class="hljs-built_in">renderOverdraw</span>(clip, nodes, contentDrawBounds, surface, preTransform);    &#125;    surface-&gt;<span class="hljs-built_in">getCanvas</span>()-&gt;<span class="hljs-built_in">flush</span>();    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p><code>SkiaPipeline::renderLayersImpl</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 看上面，layers 是在 RenderNode::prepareTree 阶段加入的，包括 </span><span class="hljs-comment">// HardwareRenderer.mRootNode 对应的 native RootRenderNode 和 DecorView.mRenderNode</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkiaPipeline::renderLayersImpl</span><span class="hljs-params">(<span class="hljs-type">const</span> LayerUpdateQueue&amp; layers, <span class="hljs-type">bool</span> opaque)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; layers.<span class="hljs-built_in">entries</span>().<span class="hljs-built_in">size</span>(); i++) &#123;        RenderNode* layerNode = layers.<span class="hljs-built_in">entries</span>()[i].renderNode.<span class="hljs-built_in">get</span>();        <span class="hljs-comment">// ...</span>        SkCanvas* layerCanvas = layerNode-&gt;<span class="hljs-built_in">getLayerSurface</span>()-&gt;<span class="hljs-built_in">getCanvas</span>();        <span class="hljs-comment">// ...</span>        <span class="hljs-function">RenderNodeDrawable <span class="hljs-title">root</span><span class="hljs-params">(layerNode, layerCanvas, <span class="hljs-literal">false</span>)</span></span>;        root.forceDraw(layerCanvas);        <span class="hljs-comment">// ...</span>        <span class="hljs-comment">// cache the current context so that we can defer flushing it until</span>        <span class="hljs-comment">// either all the layers have been rendered or the context changes</span>        GrContext* currentContext = layerNode-&gt;<span class="hljs-built_in">getLayerSurface</span>()-&gt;<span class="hljs-built_in">getCanvas</span>()-&gt;<span class="hljs-built_in">getGrContext</span>();        <span class="hljs-keyword">if</span> (cachedContext.<span class="hljs-built_in">get</span>() != currentContext) &#123;            <span class="hljs-keyword">if</span> (cachedContext.<span class="hljs-built_in">get</span>()) &#123;                <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;flush layers (context changed)&quot;</span>);                cachedContext-&gt;<span class="hljs-built_in">flush</span>();            &#125;            cachedContext.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">SkSafeRef</span>(currentContext));        &#125;    &#125;    <span class="hljs-comment">// ...</span>    cachedContext-&gt;<span class="hljs-built_in">flush</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNodeDrawable::forceDraw</span><span class="hljs-params">(SkCanvas* canvas)</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNodeDrawable::drawContent</span><span class="hljs-params">(SkCanvas* canvas)</span> <span class="hljs-type">const</span> </span>&#123;    <span class="hljs-comment">// displayList 是 layerNode 的，canvas 是 layerNode 对应的 layer surface 的</span>    <span class="hljs-comment">// 下面看看这个由 layer surface 作为 backend 的 canvas 做了什么</span>    displayList-&gt;<span class="hljs-built_in">draw</span>(canvas);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>RenderNode → mSkiaLayer → layerSurface，这里我们接触到 <code>RenderNode</code> 的一个属性/概念 layer</p><p>它是 <code>SkiaLayer</code> 结构体，主要包含一个 <code>layerSurface</code>，它是一个 offscreen render target，backend 可以是纹理、pixels buffer 等</p><p>它在 <code>SkiaPipeline::createOrUpdateLayer</code> 里通过 <code>RenderNode::setLayerSurface</code> 被赋予 <code>SkSurface_Gpu</code>；那么上面的 canvas 则是以 <code>SkGpuDevice</code> 为 backend 的 <code>SkCanvas</code>，所有的 draw 操作（onDrawXXX）都被重定向到 <code>SkGpuDevice</code>（drawXXX）；而在 <code>SkGpuDevice</code> 里，draw 操作又被重定向到 <code>GrRenderTargetContext</code>；在 <code>GrRenderTargetContext</code> 里，draw 操作被封装为 <code>GrDrawOp</code>，通过 <code>GrOpsTask::addDrawOp</code> 加入到 <code>GrRenderTargetContext::fOpsTask</code>；而 <code>GrRenderTargetContext::fOpsTask</code> 会被 <code>GrDrawingManager::fDAG</code> 持有</p><p>drawing op 在这里被再次包装，由 <code>DisplayList</code> 包装为 <code>GrDrawOp</code></p><p><code>RenderNode</code> 的 <code>DisplayList</code> 会被渲染到 layer 上</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Call to ensure all drawing to the context has been issued to the underlying 3D API.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrContext::flush</span><span class="hljs-params">()</span></span><span class="hljs-function"></span><span class="hljs-function">GrSemaphoresSubmitted <span class="hljs-title">GrContext::flush</span><span class="hljs-params">(<span class="hljs-type">const</span> GrFlushInfo&amp; info, <span class="hljs-type">const</span> GrPrepareForExternalIORequests&amp; externalRequests)</span></span><span class="hljs-function"></span><span class="hljs-function">GrSemaphoresSubmitted <span class="hljs-title">GrDrawingManager::flush</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">auto</span> direct = fContext-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">asDirectContext</span>();    GrGpu* gpu = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">getGpu</span>();    fFlushing = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">auto</span> resourceProvider = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">resourceProvider</span>();    <span class="hljs-keyword">auto</span> resourceCache = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">getResourceCache</span>();    <span class="hljs-function">GrOpFlushState <span class="hljs-title">flushState</span><span class="hljs-params">(gpu, resourceProvider, &amp;fTokenTracker, fCpuBufferCache)</span></span>;    <span class="hljs-function">GrOnFlushResourceProvider <span class="hljs-title">onFlushProvider</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">int</span> startIndex, stopIndex;    <span class="hljs-type">bool</span> flushed = <span class="hljs-literal">false</span>;    &#123;        <span class="hljs-keyword">while</span> (alloc.<span class="hljs-built_in">assign</span>(&amp;startIndex, &amp;stopIndex, &amp;error)) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">executeRenderTasks</span>(startIndex, stopIndex, &amp;flushState, &amp;numRenderTasksExecuted)) &#123;                flushed = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    fDAG.<span class="hljs-built_in">reset</span>();    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clearDDLTargets</span>();    GrSemaphoresSubmitted result = gpu-&gt;<span class="hljs-built_in">finishFlush</span>(proxies, numProxies, access, info, externalRequests);    <span class="hljs-comment">// Give the cache a chance to purge resources that become purgeable due to flushing.</span>    <span class="hljs-keyword">if</span> (flushed) &#123;        resourceCache-&gt;<span class="hljs-built_in">purgeAsNeeded</span>();        flushed = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">for</span> (GrOnFlushCallbackObject* onFlushCBObject : fOnFlushCBObjects) &#123;        onFlushCBObject-&gt;<span class="hljs-built_in">postFlush</span>(fTokenTracker.<span class="hljs-built_in">nextTokenToFlush</span>(), fFlushingRenderTaskIDs.<span class="hljs-built_in">begin</span>(),                                   fFlushingRenderTaskIDs.<span class="hljs-built_in">count</span>());        flushed = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (flushed) &#123;        resourceCache-&gt;<span class="hljs-built_in">purgeAsNeeded</span>();    &#125;    fFlushingRenderTaskIDs.<span class="hljs-built_in">reset</span>();    fFlushing = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GrDrawingManager::executeRenderTasks</span><span class="hljs-params">(<span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> stopIndex, GrOpFlushState* flushState,</span></span><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">int</span>* numRenderTasksExecuted)</span> </span>&#123;    <span class="hljs-built_in">SkASSERT</span>(startIndex &lt;= stopIndex &amp;&amp; stopIndex &lt;= fDAG.<span class="hljs-built_in">numRenderTasks</span>());<span class="hljs-meta">#<span class="hljs-keyword">if</span> GR_FLUSH_TIME_OP_SPEW</span>    <span class="hljs-built_in">SkDebugf</span>(<span class="hljs-string">&quot;Flushing opsTask: %d to %d out of [%d, %d]\n&quot;</span>, startIndex, stopIndex, <span class="hljs-number">0</span>, fDAG.<span class="hljs-built_in">numRenderTasks</span>());    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;        <span class="hljs-keyword">if</span> (fDAG.<span class="hljs-built_in">renderTask</span>(i)) &#123;            fDAG.<span class="hljs-built_in">renderTask</span>(i)-&gt;<span class="hljs-built_in">dump</span>(<span class="hljs-literal">true</span>);        &#125;    &#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-type">bool</span> anyRenderTasksExecuted = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;        GrRenderTask* renderTask = fDAG.<span class="hljs-built_in">renderTask</span>(i);        <span class="hljs-keyword">if</span> (!renderTask || !renderTask-&gt;<span class="hljs-built_in">isInstantiated</span>()) &#123;             <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">SkASSERT</span>(renderTask-&gt;<span class="hljs-built_in">deferredProxiesAreInstantiated</span>());        renderTask-&gt;<span class="hljs-built_in">prepare</span>(flushState);    &#125;    <span class="hljs-comment">// Upload all data to the GPU</span>    flushState-&gt;<span class="hljs-built_in">preExecuteDraws</span>();    <span class="hljs-comment">// For Vulkan, if we have too many oplists to be flushed we end up allocating a lot of resources</span>    <span class="hljs-comment">// for each command buffer associated with the oplists. If this gets too large we can cause the</span>    <span class="hljs-comment">// devices to go OOM. In practice we usually only hit this case in our tests, but to be safe we</span>    <span class="hljs-comment">// put a cap on the number of oplists we will execute before flushing to the GPU to relieve some</span>    <span class="hljs-comment">// memory pressure.</span>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> kMaxRenderTasksBeforeFlush = <span class="hljs-number">100</span>;    <span class="hljs-comment">// Execute the onFlush renderTasks first, if any.</span>    <span class="hljs-keyword">for</span> (sk_sp&lt;GrRenderTask&gt;&amp; onFlushRenderTask : fOnFlushRenderTasks) &#123;        <span class="hljs-keyword">if</span> (!onFlushRenderTask-&gt;<span class="hljs-built_in">execute</span>(flushState)) &#123;            <span class="hljs-built_in">SkDebugf</span>(<span class="hljs-string">&quot;WARNING: onFlushRenderTask failed to execute.\n&quot;</span>);        &#125;        <span class="hljs-built_in">SkASSERT</span>(onFlushRenderTask-&gt;<span class="hljs-built_in">unique</span>());        onFlushRenderTask = <span class="hljs-literal">nullptr</span>;        (*numRenderTasksExecuted)++;        <span class="hljs-keyword">if</span> (*numRenderTasksExecuted &gt;= kMaxRenderTasksBeforeFlush) &#123;            flushState-&gt;<span class="hljs-built_in">gpu</span>()-&gt;<span class="hljs-built_in">finishFlush</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SkSurface::BackendSurfaceAccess::kNoAccess,                                           <span class="hljs-built_in">GrFlushInfo</span>(), <span class="hljs-built_in">GrPrepareForExternalIORequests</span>());            *numRenderTasksExecuted = <span class="hljs-number">0</span>;        &#125;    &#125;    fOnFlushRenderTasks.<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">// Execute the normal op lists.</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;        GrRenderTask* renderTask = fDAG.<span class="hljs-built_in">renderTask</span>(i);        <span class="hljs-keyword">if</span> (!renderTask || !renderTask-&gt;<span class="hljs-built_in">isInstantiated</span>()) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (renderTask-&gt;<span class="hljs-built_in">execute</span>(flushState)) &#123;            anyRenderTasksExecuted = <span class="hljs-literal">true</span>;        &#125;        (*numRenderTasksExecuted)++;        <span class="hljs-keyword">if</span> (*numRenderTasksExecuted &gt;= kMaxRenderTasksBeforeFlush) &#123;            flushState-&gt;<span class="hljs-built_in">gpu</span>()-&gt;<span class="hljs-built_in">finishFlush</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SkSurface::BackendSurfaceAccess::kNoAccess,                                           <span class="hljs-built_in">GrFlushInfo</span>(), <span class="hljs-built_in">GrPrepareForExternalIORequests</span>());            *numRenderTasksExecuted = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-built_in">SkASSERT</span>(!flushState-&gt;<span class="hljs-built_in">opsRenderPass</span>());    <span class="hljs-built_in">SkASSERT</span>(fTokenTracker.<span class="hljs-built_in">nextDrawToken</span>() == fTokenTracker.<span class="hljs-built_in">nextTokenToFlush</span>());    <span class="hljs-comment">// We reset the flush state before the RenderTasks so that the last resources to be freed are</span>    <span class="hljs-comment">// those that are written to in the RenderTasks. This helps to make sure the most recently used</span>    <span class="hljs-comment">// resources are the last to be purged by the resource cache.</span>    flushState-&gt;<span class="hljs-built_in">reset</span>();    fDAG.<span class="hljs-built_in">removeRenderTasks</span>(startIndex, stopIndex);    <span class="hljs-keyword">return</span> anyRenderTasksExecuted;&#125;</code></pre></div><p>最终 <code>flush</code> 将 <code>GrDrawOp</code> 转换为 opengl 命令并提交给 gpu 执行，下面看看绘制一个矩形 <code>GrFillRectOp</code> 是怎么转换为 opengl 命令的</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkCanvas::drawRect</span><span class="hljs-params">(<span class="hljs-type">const</span> SkRect&amp; r, <span class="hljs-type">const</span> SkPaint&amp; paint)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkCanvas::onDrawRect</span><span class="hljs-params">(<span class="hljs-type">const</span> SkRect&amp; r, <span class="hljs-type">const</span> SkPaint&amp; paint)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">needs_autodrawlooper</span>(<span class="hljs-keyword">this</span>, paint)) &#123;        <span class="hljs-built_in">LOOPER_BEGIN_CHECK_COMPLETE_OVERWRITE</span>(paint, &amp;r, <span class="hljs-literal">false</span>)        <span class="hljs-keyword">while</span> (iter.<span class="hljs-built_in">next</span>()) &#123;            iter.fDevice-&gt;<span class="hljs-built_in">drawRect</span>(r, looper.<span class="hljs-built_in">paint</span>());        &#125;        LOOPER_END    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkGpuDevice::drawRect</span><span class="hljs-params">(<span class="hljs-type">const</span> SkRect&amp; rect, <span class="hljs-type">const</span> SkPaint&amp; paint)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrRenderTargetContext::drawRect</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-type">const</span> SkStrokeRec&amp; stroke = style-&gt;<span class="hljs-built_in">strokeRec</span>();    <span class="hljs-keyword">if</span> (stroke.<span class="hljs-built_in">getStyle</span>() == SkStrokeRec::kFill_Style) &#123;        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">drawFilledRect</span>(clip, std::<span class="hljs-built_in">move</span>(paint), aa, viewMatrix, rect);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrRenderTargetContext::drawFilledRect</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    GrAAType aaType = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">chooseAAType</span>(aa, GrAllowMixedSamples::kNo);    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addDrawOp</span>(clip, GrFillRectOp::<span class="hljs-built_in">Make</span>(fContext, std::<span class="hljs-built_in">move</span>(paint), aaType, viewMatrix,                                             croppedRect, ss));&#125;</code></pre></div><p>看看 <code>GrFillRectOp</code> 的定义</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">GrFillRectOp::Make</span><span class="hljs-params">(...)</span></span><span class="hljs-function"><span class="hljs-type">static</span> std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">Make</span><span class="hljs-params">(...)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Op, <span class="hljs-keyword">typename</span>... OpArgs&gt;</span><span class="hljs-function"><span class="hljs-type">static</span> std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">FactoryHelper</span><span class="hljs-params">(GrRecordingContext* context, GrPaint&amp;&amp; paint, OpArgs... opArgs)</span> </span>&#123;    <span class="hljs-keyword">return</span> GrSimpleMeshDrawOpHelper::<span class="hljs-built_in">FactoryHelper</span>&lt;Op, OpArgs...&gt;(context, std::<span class="hljs-built_in">move</span>(paint), std::forward&lt;OpArgs&gt;(opArgs)...);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Op, <span class="hljs-keyword">typename</span>... OpArgs&gt;<span class="hljs-function">std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">GrSimpleMeshDrawOpHelper::FactoryHelper</span><span class="hljs-params">(GrRecordingContext* context,</span></span><span class="hljs-params"><span class="hljs-function">                                                                  GrPaint&amp;&amp; paint,</span></span><span class="hljs-params"><span class="hljs-function">                                                                  OpArgs... opArgs)</span> </span>&#123;    GrOpMemoryPool* pool = context-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">opMemoryPool</span>();    MakeArgs makeArgs;    <span class="hljs-keyword">if</span> (paint.<span class="hljs-built_in">isTrivial</span>()) &#123;        makeArgs.fProcessorSet = <span class="hljs-literal">nullptr</span>;        <span class="hljs-keyword">return</span> pool-&gt;<span class="hljs-built_in">allocate</span>&lt;Op&gt;(makeArgs, paint.<span class="hljs-built_in">getColor4f</span>(), std::forward&lt;OpArgs&gt;(opArgs)...);    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-built_in">FillRectOp</span>(Helper::MakeArgs args, SkPMColor4f paintColor, GrAAType aaType,               DrawQuad* quad, <span class="hljs-type">const</span> GrUserStencilSettings* stencil, Helper::InputFlags inputFlags)            : <span class="hljs-built_in">INHERITED</span>(<span class="hljs-built_in">ClassID</span>())            , <span class="hljs-built_in">fHelper</span>(args, aaType, stencil, inputFlags)            , <span class="hljs-built_in">fQuads</span>(<span class="hljs-number">1</span>, !fHelper.<span class="hljs-built_in">isTrivial</span>()) &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrRenderTargetContext::addDrawOp</span><span class="hljs-params">(<span class="hljs-type">const</span> GrClip&amp; clip, std::unique_ptr&lt;GrDrawOp&gt; op,</span></span><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">const</span> std::function&lt;WillAddOpFn&gt;&amp; willAddFn)</span> </span>&#123;    <span class="hljs-keyword">auto</span> opList = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getRTOpList</span>();    <span class="hljs-comment">// ...</span>    opList-&gt;<span class="hljs-built_in">addDrawOp</span>(std::<span class="hljs-built_in">move</span>(op), analysis, std::<span class="hljs-built_in">move</span>(appliedClip), dstProxy, *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">caps</span>());&#125;<span class="hljs-function">GrRenderTargetOpList* <span class="hljs-title">GrRenderTargetContext::getRTOpList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (!fOpList || fOpList-&gt;<span class="hljs-built_in">isClosed</span>()) &#123;        fOpList = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">drawingManager</span>()-&gt;<span class="hljs-built_in">newRTOpList</span>(fRenderTargetProxy.<span class="hljs-built_in">get</span>(), fManagedOpList);    &#125;    <span class="hljs-keyword">return</span> fOpList.<span class="hljs-built_in">get</span>();&#125;<span class="hljs-function">sk_sp&lt;GrRenderTargetOpList&gt; <span class="hljs-title">GrDrawingManager::newRTOpList</span><span class="hljs-params">(GrRenderTargetProxy* rtp, <span class="hljs-type">bool</span> managedOpList)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">auto</span> resourceProvider = fContext-&gt;<span class="hljs-built_in">contextPriv</span>().<span class="hljs-built_in">resourceProvider</span>();    <span class="hljs-function">sk_sp&lt;GrRenderTargetOpList&gt; <span class="hljs-title">opList</span><span class="hljs-params">(<span class="hljs-keyword">new</span> GrRenderTargetOpList(resourceProvider, fContext-&gt;contextPriv().refOpMemoryPool(), rtp, fContext-&gt;contextPriv().getAuditTrail()))</span></span>;    <span class="hljs-keyword">if</span> (managedOpList) &#123;        fDAG.<span class="hljs-built_in">add</span>(opList);    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> opList;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrRenderTargetOpList::addDrawOp</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-keyword">auto</span> addDependency = [ &amp;caps, <span class="hljs-keyword">this</span> ] (GrSurfaceProxy* p) &#123;        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addDependency</span>(p, caps);    &#125;;    op-&gt;<span class="hljs-built_in">visitProxies</span>(addDependency);    clip.<span class="hljs-built_in">visitProxies</span>(addDependency);    <span class="hljs-keyword">if</span> (dstProxy.<span class="hljs-built_in">proxy</span>()) &#123;        <span class="hljs-built_in">addDependency</span>(dstProxy.<span class="hljs-built_in">proxy</span>());    &#125;    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">recordOp</span>(std::<span class="hljs-built_in">move</span>(op), processorAnalysis, clip.<span class="hljs-built_in">doesClip</span>() ? &amp;clip : <span class="hljs-literal">nullptr</span>, &amp;dstProxy, caps);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FillRectOp</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> GrMeshDrawOp &#123;    <span class="hljs-function">VertexSpec <span class="hljs-title">vertexSpec</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">auto</span> indexBufferOption = GrQuadPerEdgeAA::<span class="hljs-built_in">CalcIndexBufferOption</span>(fHelper.<span class="hljs-built_in">aaType</span>(), fQuads.<span class="hljs-built_in">count</span>());        <span class="hljs-keyword">return</span> <span class="hljs-built_in">VertexSpec</span>(fQuads.<span class="hljs-built_in">deviceQuadType</span>(), fColorType, fQuads.<span class="hljs-built_in">localQuadType</span>(),            fHelper.<span class="hljs-built_in">usesLocalCoords</span>(), GrQuadPerEdgeAA::Domain::kNo,            fHelper.<span class="hljs-built_in">aaType</span>(),            fHelper.<span class="hljs-built_in">compatibleWithCoverageAsAlpha</span>(), indexBufferOption);    &#125;       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tessellate</span><span class="hljs-params">(<span class="hljs-type">const</span> VertexSpec&amp; vertexSpec, <span class="hljs-type">char</span>* dst)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> SkRect kEmptyDomain = SkRect::<span class="hljs-built_in">MakeEmpty</span>();        <span class="hljs-function">GrQuadPerEdgeAA::Tessellator <span class="hljs-title">tessellator</span><span class="hljs-params">(vertexSpec, dst)</span></span>;        <span class="hljs-keyword">auto</span> iter = fQuads.<span class="hljs-built_in">iterator</span>();        <span class="hljs-keyword">while</span> (iter.<span class="hljs-built_in">next</span>()) &#123;            <span class="hljs-keyword">auto</span> info = iter.<span class="hljs-built_in">metadata</span>();            tessellator.<span class="hljs-built_in">append</span>(iter.<span class="hljs-built_in">deviceQuad</span>(), iter.<span class="hljs-built_in">localQuad</span>(), info.fColor, kEmptyDomain, info.fAAFlags);        &#125;    &#125;       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onPrePrepareDraws</span><span class="hljs-params">(...)</span> <span class="hljs-keyword">override</span> </span>&#123;        SkArenaAlloc* arena = context-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">recordTimeAllocator</span>();        <span class="hljs-type">const</span> VertexSpec vertexSpec = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">vertexSpec</span>();        <span class="hljs-type">const</span> <span class="hljs-type">int</span> totalNumVertices = fQuads.<span class="hljs-built_in">count</span>() * vertexSpec.<span class="hljs-built_in">verticesPerQuad</span>();        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> totalVertexSizeInBytes = vertexSpec.<span class="hljs-built_in">vertexSize</span>() * totalNumVertices;        fPrePreparedVertices = arena-&gt;<span class="hljs-built_in">makeArrayDefault</span>&lt;<span class="hljs-type">char</span>&gt;(totalVertexSizeInBytes);        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">tessellate</span>(vertexSpec, fPrePreparedVertices);    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>render thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（二）ui thread</title>
    <link href="/2020/12/13/ui-thread-in-vsync/"/>
    <url>/2020/12/13/ui-thread-in-vsync/</url>
    
    <content type="html"><![CDATA[<h2 id="从一段-systrace-开始"><a href="#从一段-systrace-开始" class="headerlink" title="从一段 systrace 开始"></a>从一段 systrace 开始</h2><p><img src="../../../../image/2020-12-13-ui-thread-in-vsync/114050.png" alt="114050.png"></p><p>这是一段 systrace 记录，看得出来页面是比较流畅的，ui thread 全都在一个 VSYNC_app 内完成绘制，surfaceflinger 也在一个 VSYNC_sf 内完成各个层的合成；但有没发现在 ui thread 完成 <code>doFrame</code> 后，总是会有一个 <code>ReaderThread</code> 跟在后面，看名字像是跟渲染相关的线程，它跟 ui 绘制有关系吗？平时我们常说的，只要 ui thread 在一个刷新周期 16ms 内完成 view 的绘制，即可保证页面流畅，真的是这样吗？</p><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从 ViewRootImpl 开始</span>ViewRootImpl.doTraversal()ViewRootImpl.performTraversals()ViewRootImpl.performDraw()ViewRootImpl.draw(<span class="hljs-type">boolean</span> fullRedrawNeeded)<span class="hljs-comment">// 进入 ThreadedRenderer</span>ThreadedRenderer.draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;    <span class="hljs-comment">// ...</span>    updateRootDisplayList(view, callbacks);    <span class="hljs-comment">// ...</span>    <span class="hljs-type">int</span> <span class="hljs-variable">syncResult</span> <span class="hljs-operator">=</span> syncAndDrawFrame(choreographer.mFrameInfo);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>这里出现了两个很重要的函数：<code>updateRootDisplayList</code> 和 <code>syncAndDrawFrame</code>，我们一个个看</p><h2 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList"></a>updateRootDisplayList</h2><div class="code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;    <span class="hljs-comment">// ...</span>    updateViewTreeDisplayList(view);    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;        <span class="hljs-type">RecordingCanvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// ...</span>            canvas.drawRenderNode(view.updateDisplayListIfDirty());            <span class="hljs-comment">// ...</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            mRootNode.endRecording();        &#125;    &#125;&#125;</code></pre></div><p>两段逻辑：</p><ol><li><code>updateViewTreeDisplayList(view)</code>，其中 view 是 root view 也就是 <code>DecorView</code></li><li><code>Canvas.drawRenderNode</code>，<code>RenderNode</code> 是 View 返回的</li></ol><h2 id="updateViewTreeDisplayList"><a href="#updateViewTreeDisplayList" class="headerlink" title="updateViewTreeDisplayList"></a>updateViewTreeDisplayList</h2><div class="code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateViewTreeDisplayList(View view)RenderNode View.updateDisplayListIfDirty() &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">RenderNode</span> <span class="hljs-variable">renderNode</span> <span class="hljs-operator">=</span> mRenderNode;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">RecordingCanvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> renderNode.beginRecording(width, height);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// ...</span>        draw(canvas);        <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        renderNode.endRecording();        setDisplayListProperties(renderNode);    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> renderNode;&#125;</code></pre></div><p>最终在这里调用了 <code>View.draw</code>，里面就是常规的画布绘制操作，我们继续看看 <code>RecordingCanvas</code> 这个类</p><h2 id="RecordingCanvas"><a href="#RecordingCanvas" class="headerlink" title="RecordingCanvas"></a>RecordingCanvas</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecordingCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DisplayListCanvas</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayListCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseRecordingCanvas</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRecordingCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Canvas</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawArc</span><span class="hljs-params">(<span class="hljs-type">float</span> left, <span class="hljs-type">float</span> top, <span class="hljs-type">float</span> right, <span class="hljs-type">float</span> bottom, <span class="hljs-type">float</span> startAngle,</span><span class="hljs-params">            <span class="hljs-type">float</span> sweepAngle, <span class="hljs-type">boolean</span> useCenter, <span class="hljs-meta">@NonNull</span> Paint paint)</span> &#123;        nDrawArc(mNativeCanvasWrapper, left, top, right, bottom, startAngle, sweepAngle,                useCenter, paint.getNativeInstance());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawBitmap</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bitmap bitmap, <span class="hljs-type">float</span> left, <span class="hljs-type">float</span> top,</span><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Paint paint)</span> &#123;        throwIfCannotDraw(bitmap);        nDrawBitmap(mNativeCanvasWrapper, bitmap.getNativeInstance(), left, top,                paint != <span class="hljs-literal">null</span> ? paint.getNativeInstance() : <span class="hljs-number">0</span>, mDensity, mScreenDensity,                bitmap.mDensity);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRect</span><span class="hljs-params">(<span class="hljs-type">float</span> left, <span class="hljs-type">float</span> top, <span class="hljs-type">float</span> right, <span class="hljs-type">float</span> bottom,</span><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Paint paint)</span> &#123;        nDrawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.getNativeInstance());    &#125;&#125;</code></pre></div><p><code>RecordingCanvas</code> 继承自 <code>DisplayListCanvas</code>，<code>DisplayListCanvas</code> 继承自 <code>BaseRecordingCanvas</code></p><p>在 <code>BaseRecordingCanvas</code> 里，<code>View.draw(Canvas)</code> 所用到的 <code>drawBitmap</code>、<code>drawText</code>、<code>drawRect</code> 等绘图方法都被重定向到 <code>BaseCanvas.mNativeCanvasWrapper</code>，继续看看它指向谁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从构造开始</span>RecordingCanvas RenderNode.beginRecording(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height) &#123;    <span class="hljs-comment">// ...</span>    mCurrentRecordingCanvas = RecordingCanvas.obtain(<span class="hljs-built_in">this</span>, width, height);    <span class="hljs-keyword">return</span> mCurrentRecordingCanvas;&#125;RecordingCanvas RecordingCanvas.obtain(RenderNode node, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;node cannot be null&quot;</span>);    <span class="hljs-type">RecordingCanvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> sPool.acquire();    <span class="hljs-keyword">if</span> (canvas == <span class="hljs-literal">null</span>) &#123;        canvas = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecordingCanvas</span>(node, width, height);    &#125; <span class="hljs-keyword">else</span> &#123;        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode, width, height);    &#125;    canvas.mNode = node;    canvas.mWidth = width;    canvas.mHeight = height;    <span class="hljs-keyword">return</span> canvas;&#125;</code></pre></div><p><code>RecordingCanvas</code> 会被频繁地创建和销毁，所以用了池化，池子大小是 25，从池子里拿出的对象用 <code>nResetDisplayListCanvas</code> 重置；我们走创建新实例这条路继续看下去</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">RecordingCanvas</span><span class="hljs-params">(RenderNode node, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;    <span class="hljs-built_in">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));&#125;<span class="hljs-comment">// /frameworks/base/core/jni/android_view_DisplayListCanvas.cpp</span><span class="hljs-keyword">static</span> jlong <span class="hljs-title function_">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="hljs-params">(jlong renderNodePtr, jint width, jint height)</span> &#123;    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));&#125;Canvas* Canvas::create_recording_canvas(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, uirenderer::RenderNode* renderNode) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">uirenderer</span>::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);&#125;</code></pre></div><p>可以看到 <code>RecordingCanvas.mNativeCanvasWrapper</code> 是 native <code>SkiaRecordingCanvas</code></p><p><code>SkiaRecordingCanvas</code> 继承自 <code>SkiaCanvas</code>，大部分 2D 绘图方法都是由 <code>SkiaCanvas</code> 实现的，而 <code>SkiaCanvas</code> 又把绘图操作交由 <code>SkiaCanvas.mCanvas</code> 执行，我们看下它指向谁</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SkiaRecordingCanvas</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;    <span class="hljs-built_in">initDisplayList</span>(renderNode, width, height);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkiaRecordingCanvas::initDisplayList</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;    mCurrentBarrier = <span class="hljs-literal">nullptr</span>;    <span class="hljs-built_in">SkASSERT</span>(mDisplayList.<span class="hljs-built_in">get</span>() == <span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">if</span> (renderNode) &#123;        mDisplayList = renderNode-&gt;<span class="hljs-built_in">detachAvailableList</span>();    &#125;    <span class="hljs-keyword">if</span> (!mDisplayList) &#123;        mDisplayList.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SkiaDisplayList</span>());    &#125;    mDisplayList-&gt;<span class="hljs-built_in">attachRecorder</span>(&amp;mRecorder, SkIRect::<span class="hljs-built_in">MakeWH</span>(width, height));    SkiaCanvas::<span class="hljs-built_in">reset</span>(&amp;mRecorder);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkiaCanvas::reset</span><span class="hljs-params">(SkCanvas* skiaCanvas)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mCanvas != skiaCanvas) &#123;        mCanvas = skiaCanvas;        mCanvasOwned.<span class="hljs-built_in">reset</span>();    &#125;    mSaveStack.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);&#125;</code></pre></div><p><code>SkiaRecordingCanvas.mRecorder</code> 被赋值给了 <code>SkiaCanvas.mCanvas</code>，它是 <code>RecordingCanvaas</code>，而它又把 draw 交由 <code>RecordingCanvas.fDL</code> 执行</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayListData::drawRect</span><span class="hljs-params">(<span class="hljs-type">const</span> SkRect&amp; rect, <span class="hljs-type">const</span> SkPaint&amp; paint)</span> </span>&#123;    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">push</span>&lt;DrawRect&gt;(<span class="hljs-number">0</span>, rect, paint);&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DrawRect</span> <span class="hljs-keyword">final</span> : Op &#123;    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> kType = Type::DrawRect;    <span class="hljs-built_in">DrawRect</span>(<span class="hljs-type">const</span> SkRect&amp; rect, <span class="hljs-type">const</span> SkPaint&amp; paint) : <span class="hljs-built_in">rect</span>(rect), <span class="hljs-built_in">paint</span>(paint) &#123;&#125;    SkRect rect;    SkPaint paint;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(SkCanvas* c, <span class="hljs-type">const</span> SkMatrix&amp;)</span> <span class="hljs-type">const</span> </span>&#123; c-&gt;<span class="hljs-built_in">drawRect</span>(rect, paint); &#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayListData::drawImage</span><span class="hljs-params">(sk_sp&lt;<span class="hljs-type">const</span> SkImage&gt; image, SkScalar x, SkScalar y, onst SkPaint* paint, BitmapPalette palette)</span> </span>&#123;    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">push</span>&lt;DrawImage&gt;(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">move</span>(image), x, y, paint, palette);&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DrawImage</span> <span class="hljs-keyword">final</span> : Op &#123;    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> kType = Type::DrawImage;    <span class="hljs-built_in">DrawImage</span>(sk_sp&lt;<span class="hljs-type">const</span> SkImage&gt;&amp;&amp; image, SkScalar x, SkScalar y, <span class="hljs-type">const</span> SkPaint* paint, BitmapPalette palette)            : <span class="hljs-built_in">image</span>(std::<span class="hljs-built_in">move</span>(image)), <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">palette</span>(palette) &#123;        <span class="hljs-keyword">if</span> (paint) &#123;            <span class="hljs-keyword">this</span>-&gt;paint = *paint;        &#125;    &#125;    sk_sp&lt;<span class="hljs-type">const</span> SkImage&gt; image;    SkScalar x, y;    SkPaint paint;    BitmapPalette palette;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(SkCanvas* c, <span class="hljs-type">const</span> SkMatrix&amp;)</span> <span class="hljs-type">const</span> </span>&#123; c-&gt;<span class="hljs-built_in">drawImage</span>(image.<span class="hljs-built_in">get</span>(), x, y, &amp;paint); &#125;&#125;;</code></pre></div><p><code>RecordingCanvas.fDL</code> 是个 <code>DisplayListData</code>，它把绘图操作的所有参数记录为一个结构体 Op 并记录起来</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkiaRecordingCanvas::initDisplayList</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkiaDisplayList::attachRecorder</span><span class="hljs-params">(RecordingCanvas* recorder, <span class="hljs-type">const</span> SkIRect&amp; bounds)</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecordingCanvas::reset</span><span class="hljs-params">(DisplayListData* dl, <span class="hljs-type">const</span> SkIRect&amp; bounds)</span> </span>&#123;    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">resetCanvas</span>(bounds.<span class="hljs-built_in">right</span>(), bounds.<span class="hljs-built_in">bottom</span>());    fDL = dl;    mClipMayBeComplex = <span class="hljs-literal">false</span>;    mSaveCount = mComplexSaveCount = <span class="hljs-number">0</span>;&#125;</code></pre></div><p>总结下：java <code>RecordingCanvas.mNativeCanvasWrapper</code> 持有 native <code>SkiaRecordingCanvas</code>，<code>SkiaRecordingCanvas→mDisplayList→mDisplayList</code> 里记录所有的绘图操作</p><h2 id="endRecording"><a href="#endRecording" class="headerlink" title="endRecording"></a>endRecording</h2><div class="code-wrapper"><pre><code class="hljs cpp">RenderNode View.<span class="hljs-built_in">updateDisplayListIfDirty</span>() &#123;    <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">final</span> RecordingCanvas canvas = renderNode.<span class="hljs-built_in">beginRecording</span>(width, height);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-built_in">draw</span>(canvas);        <span class="hljs-comment">// ...</span>    &#125; finally &#123;        renderNode.<span class="hljs-built_in">endRecording</span>();        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> renderNode;&#125;RecordingCanvas.<span class="hljs-built_in">endRecording</span>() &#123;    <span class="hljs-comment">// ...</span>    RecordingCanvas canvas = mCurrentRecordingCanvas;    mCurrentRecordingCanvas = null;    <span class="hljs-type">long</span> displayList = canvas.<span class="hljs-built_in">finishRecording</span>();    <span class="hljs-built_in">nSetDisplayList</span>(mNativeRenderNode, displayList);    canvas.<span class="hljs-built_in">recycle</span>();&#125;<span class="hljs-function">uirenderer::DisplayList* <span class="hljs-title">SkiaRecordingCanvas::finishRecording</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> mDisplayList.<span class="hljs-built_in">release</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RenderNode::setStagingDisplayList</span><span class="hljs-params">(DisplayList* displayList)</span> </span>&#123;    mValid = (displayList != <span class="hljs-literal">nullptr</span>);    mNeedsDisplayListSync = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">delete</span> mStagingDisplayList;    mStagingDisplayList = displayList;&#125;RecordingCanvas.<span class="hljs-built_in">recycle</span>() &#123;    mNode = null;    sPool.<span class="hljs-built_in">release</span>(<span class="hljs-keyword">this</span>);&#125;</code></pre></div><p>最终，<code>RecordingCanvas</code> 被回收到池里，保存了绘制 Op 的 <code>SkiaDisplayList</code> 被转移到 native <code>RenderNode.mStagingDisplayList</code></p><h2 id="drawRenderNode"><a href="#drawRenderNode" class="headerlink" title="drawRenderNode"></a>drawRenderNode</h2><div class="code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;    <span class="hljs-comment">// ...</span>    updateViewTreeDisplayList(view);    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;        <span class="hljs-type">RecordingCanvas</span> <span class="hljs-variable">canvas</span> <span class="hljs-operator">=</span> mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// ...</span>            canvas.drawRenderNode(view.updateDisplayListIfDirty());            <span class="hljs-comment">// ...</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            mRootNode.endRecording();        &#125;    &#125;&#125;<span class="hljs-keyword">void</span> SkiaRecordingCanvas::drawRenderNode(uirenderer::RenderNode* renderNode) &#123;    <span class="hljs-comment">// Record the child node. Drawable dtor will be invoked when mChildNodes deque is cleared.</span>    mDisplayList-&gt;mChildNodes.emplace_back(renderNode, asSkCanvas(), <span class="hljs-literal">true</span>, mCurrentBarrier);    auto&amp; renderNodeDrawable = mDisplayList-&gt;mChildNodes.back();    <span class="hljs-keyword">if</span> (Properties::getRenderPipelineType() == RenderPipelineType::SkiaVulkan) &#123;        <span class="hljs-comment">// Put Vulkan WebViews with non-rectangular clips in a HW layer</span>        renderNode-&gt;mutateStagingProperties().setClipMayBeComplex(mRecorder.isClipMayBeComplex());    &#125;    drawDrawable(&amp;renderNodeDrawable);    <span class="hljs-comment">// use staging property, since recording on UI thread</span>    <span class="hljs-keyword">if</span> (renderNode-&gt;stagingProperties().isProjectionReceiver()) &#123;        mDisplayList-&gt;mProjectionReceiver = &amp;renderNodeDrawable;    &#125;&#125;</code></pre></div><p>在上面，<code>DecorView</code> 的 DisplayList 已经被更新过了，所以 <code>view.updateDisplayListIfDirty()</code> 直接返回它的 <code>RenderNode</code></p><p>beginRecording → draw → endRecording 三步走跟上面的是一样的，<code>HardwareRenderer.mRootNode</code> 对应的是 native <code>RootRenderNode</code>；它的 <code>mStagingDisplayList</code> 只有一个 <code>RenderNodeDrawable</code></p><h2 id="syncAndDrawFrame"><a href="#syncAndDrawFrame" class="headerlink" title="syncAndDrawFrame"></a>syncAndDrawFrame</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 现在从新回到开头的地方</span><span class="hljs-keyword">void</span> ThreadedRenderer.draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;    <span class="hljs-comment">// ... 这里会调用 View.draw(Canvas)，并把绘制 op 保存起来</span>    updateRootDisplayList(view, callbacks);    <span class="hljs-comment">// ... 这个方法看起来会执行真正的绘制操作，进去看下</span>    <span class="hljs-type">int</span> <span class="hljs-variable">syncResult</span> <span class="hljs-operator">=</span> syncAndDrawFrame(choreographer.mFrameInfo);    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 进入 native</span><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> HardwareRenderer.syncAndDrawFrame(<span class="hljs-meta">@NonNull</span> FrameInfo frameInfo) &#123;    <span class="hljs-keyword">return</span> nSyncAndDrawFrame(mNativeProxy, frameInfo.frameInfo, frameInfo.frameInfo.length);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// frameworks/base/core/jni/android_view_ThreadedRenderer.cpp</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><span class="hljs-params"><span class="hljs-function">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;    <span class="hljs-comment">// ...</span>    RenderProxy* proxy = <span class="hljs-built_in">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);    env-&gt;<span class="hljs-built_in">GetLongArrayRegion</span>(frameInfo, <span class="hljs-number">0</span>, frameInfoSize, proxy-&gt;<span class="hljs-built_in">frameInfo</span>());    <span class="hljs-keyword">return</span> proxy-&gt;<span class="hljs-built_in">syncAndDrawFrame</span>();&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RenderProxy::syncAndDrawFrame</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> mDrawFrameTask.<span class="hljs-built_in">drawFrame</span>();&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DrawFrameTask::drawFrame</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">// 到此都还是在 ui thread</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DrawFrameTask::postAndWait</span><span class="hljs-params">()</span> </span>&#123;    AutoMutex _lock(mLock);    <span class="hljs-comment">// RenderThread 继承自 Thread，DrawFrameTask::run 被提交至 RenderThread 的 WorkQueue 等待执行</span>    mRenderThread-&gt;<span class="hljs-built_in">queue</span>().<span class="hljs-built_in">post</span>([<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-built_in">run</span>(); &#125;);    <span class="hljs-comment">// 这里会导致 ui thread 阻塞，直到 DrawFrameTask::run() 里把相关数据同步过来后才恢复 ui thread</span>    mSignal.<span class="hljs-built_in">wait</span>(mLock);&#125;<span class="hljs-comment">// 记住此时已经是在 RenderThread 而不是 ui thread，ui thread 此时被阻塞了</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DrawFrameTask::run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DrawFrame&quot;</span>);    <span class="hljs-type">bool</span> canUnblockUiThread;    <span class="hljs-type">bool</span> canDrawThisFrame;    &#123;        <span class="hljs-function">TreeInfo <span class="hljs-title">info</span><span class="hljs-params">(TreeInfo::MODE_FULL, *mContext)</span></span>;        canUnblockUiThread = <span class="hljs-built_in">syncFrameState</span>(info);        canDrawThisFrame = info.out.canDrawThisFrame;        <span class="hljs-keyword">if</span> (mFrameCompleteCallback) &#123;            mContext-&gt;<span class="hljs-built_in">addFrameCompleteListener</span>(std::<span class="hljs-built_in">move</span>(mFrameCompleteCallback));            mFrameCompleteCallback = <span class="hljs-literal">nullptr</span>;        &#125;    &#125;    <span class="hljs-comment">// Grab a copy of everything we need</span>    CanvasContext* context = mContext;    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int64_t</span>)&gt; callback = std::<span class="hljs-built_in">move</span>(mFrameCallback);    mFrameCallback = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// From this point on anything in &quot;this&quot; is *UNSAFE TO ACCESS*</span>    <span class="hljs-keyword">if</span> (canUnblockUiThread) &#123;        <span class="hljs-built_in">unblockUiThread</span>();    &#125;    <span class="hljs-comment">// Even if we aren&#x27;t drawing this vsync pulse the next frame number will still be accurate</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(callback)) &#123;        context-&gt;<span class="hljs-built_in">enqueueFrameWork</span>(                [callback, frameNr = context-&gt;<span class="hljs-built_in">getFrameNumber</span>()]() &#123; <span class="hljs-built_in">callback</span>(frameNr); &#125;);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_LIKELY</span>(canDrawThisFrame)) &#123;        context-&gt;<span class="hljs-built_in">draw</span>();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// wait on fences so tasks don&#x27;t overlap next frame</span>        context-&gt;<span class="hljs-built_in">waitOnFences</span>();    &#125;    <span class="hljs-keyword">if</span> (!canUnblockUiThread) &#123;        <span class="hljs-built_in">unblockUiThread</span>();    &#125;&#125;</code></pre></div><p>这里有两个函数是需要关注的：<code>syncFrameState(info)</code> 和 <code>context-&gt;draw()</code>，但不打算深入下去，因为后续涉及到很多状态判断和方法调用，而且会进入 skia 引擎的相关方法，不是代码跟踪就可以理解的（凡是跟 opengl 相关的代码，经过层层封装都不太好理解）</p><p>搜索 <code>DrawFrameTask</code> 或者 <code>DisplayList</code> 等关键字可以找到如何把 <code>DisplayList</code> 处理为 <code>egl</code> 相关指令的文章，这里根据<a href="https://blog.csdn.net/jinzhuojun/article/details/54234354">《Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)》</a> 的描述总结下此阶段的工作：</p><ol><li><code>syncFrameState(info)</code> 上传纹理</li><li><code>unblockUiThread()</code> 然后恢复 ui thread</li><li><code>context-&gt;draw()</code> 输出 egl 指令</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../../../../image/2020-12-13-ui-thread-in-vsync/52054.png" alt="52054.png"></p><p>这是一个 sync_app 信号内的 systrace，结合这张图片，尝试解答开头提出的问题</p><ol><li>app 内的 ui 渲染至少包含两个线程：ui thread（执行 <code>View.draw()</code>）和 render thread（执行 egl 指令）</li><li>ui thread 和 render thread 有一段重合的地方，也就是在 ui thread 完成「Record <code>View#draw()</code>」后，ui thread 被阻塞了；而 render thread 开始执行 <code>syncFrameState</code>，完成后恢复 ui thread，此时 ui thread 的任务已完成，后续的都是 render thread 的任务了</li><li>从时长看，ui thread 执行 <code>Choreographer#doFrame</code> 用时 4ms，render thread 执行 <code>DrawFrame</code> 用时 8ms；render thread 的存在大大地释放了 ui thread 的压力</li><li>要在 16ms 内完成一帧的绘制，不能都让 ui thread 给消耗掉了，还得留出一段时间给 render thread，也就是说 ui thread 在一帧内的任务 <code>Choreographer#doFrame</code> 耗时要小于 16ms 才行；而且从上图看 render thread 的耗时远大于 ui thread，留给 ui thread 的时间应该是远小于 16ms 的</li></ol><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li><code>DisplayList</code>：对 <code>Canvas</code> 的所有绘制操作并不会立刻执行，而是保存为 <code>DisplayList</code>；这一过程称为“录制”，后续可以“回放”进行渲染</li><li><code>View</code> 是表，是 framework 暴露出来的 ui api，就像 DOM 是浏览器暴露出来的 ui api；<code>RenderNode</code> 是里</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>ui thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（一）vsync</title>
    <link href="/2020/12/02/vsync/"/>
    <url>/2020/12/02/vsync/</url>
    
    <content type="html"><![CDATA[<p>android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 <code>View.invalidate</code> 讲起，看看简单的一个 <code>invalidate</code> 后面隐藏着多么复杂的工作</p><h2 id="从-View-invalidate-说起"><a href="#从-View-invalidate-说起" class="headerlink" title="从 View.invalidate() 说起"></a>从 <code>View.invalidate()</code> 说起</h2><p><img src="../../../../image/2020-12-02-vsync/invalidate.jpg" alt="invalidate.jpg"></p><p>看上图，<code>View.invalidate()</code> 主要做了两件事：</p><ol><li>将 <code>ViewRootImpl.doTraversal()</code> 加入到 <code>Choreographer</code> 的任务列表里，等待下一次 vsync 信号到来时执行；<code>doTraversal()</code>主要执行 view tree 的三个重要方法：measure、layout 和 draw；<code>Choreographer</code>则是在一次 vsync 信号到来时，依次执行 <code>INPUT</code>，<code>ANIMATION</code> 和 <code>TRAVERSAL</code> 这三个类别的任务；也就是说 view tree 的渲染和 input 的处理都是从 vsync 到来时开始的，而且此时会开启同步栅栏，屏蔽非 ui 任务（用户任务），集中力量在下一次的 vsync 到来前完成一帧的渲染</li><li>唤醒 <code>EventThread</code> 去看看有没 vsync 信号的到来；<code>EventThread</code> 看名字就知道是一个线程，看它的 loop 流程，是将 <code>mPendingEvents</code> 分发给 consumer，那么我们可以猜想下，event 也许包含了 vsync，而 consumer 很有可能最终走到 <code>Choreographer.doFrame</code>里触发 view tree 的绘制</li></ol><p>按照从下到上追踪法，下一步就是看看是谁在什么时候把 event 放到 <code>mPendingEvents</code> 里，但这里我选择掉转方向盘，先从 surfaceflinger 讲起</p><p>继续之前，我们得先了解几个跟硬件有关的概念</p><h2 id="HAL，Hardware-Abstract-Layer，硬件抽象层"><a href="#HAL，Hardware-Abstract-Layer，硬件抽象层" class="headerlink" title="HAL，Hardware Abstract Layer，硬件抽象层"></a>HAL，Hardware Abstract Layer，硬件抽象层</h2><p>看名字就知道这是跟硬件、设备相关的东西，应该是最贴近硬件的那一层软件，我没有做过相关的开发，但是结合 google 和这两篇文章：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，我大概了解了它是干什么的，我说说我的理解：</p><ul><li>它用接口的方式定义协议，而协议则定义了组件间的沟通规范；Android app 开发其实也就这个概念，就是各个业务、基础能力的 interface；我做过 java web 开发，所以对这个概念比较熟悉；整个 java web 是由很多协议构成的：Servlet、JSP、JDBC 等，sun 给出包含这些协议 interface 的 jar 包出来（它自己也可能会给出一个默认实现比如 glassfish），各个厂商给出自己对协议的实现如：Tomcat、Jboss、Resin 等；而 web app 开发者只需根据协议 jar 包开发业务，部署时根据条件可以放在各种厂商的容器上</li><li>HAL 也是这个道理，android HWC HAL 定义了各种 interface（在 <code>hardware/interfaces/graphics/composer/2.1/</code> 目录下），各个厂商需要实现这些接口并给出 so 文件；打包 android image 的时候，根据硬件设备挑选合适的 HAL 实现，把 so 文件放到镜像里；而 android framework 开发者只需根据 HAL 接口进行业务开发即可，无需关心实现细节</li></ul><h2 id="HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言"><a href="#HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言" class="headerlink" title="HIDL，HAL Interface Definition Language，HAL 接口定义语言"></a>HIDL，HAL Interface Definition Language，HAL 接口定义语言</h2><p>看名字好像跟 AIDL 有点渊源啊，对的，它是 HAL 的代码生成器；具体怎么用我们了解下即可：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/89173162">Android HIDL 之 hal 进程启动及服务注册过程</a></p><p>总结下关键点：</p><ul><li>各个 HAL 是独立进程的（看看 <code>hardware/interfaces/graphics/composer/2.1/default/</code> 是怎么启动 HWC 进程并加载厂商 so 库的），surfaceflinger 进程通过 binder 与 HWC 进程通讯（也就是 C/S 架构，HWC 是 server，surfaceflinger 是 client）</li><li>HWC 将服务注册到 <code>hwservicemanager</code>，surfaceflinger 从 <code>hwservicemanager</code> 获取 composer 服务</li><li>所以用从下到上的方法找调用栈的时候会发现，onVsync 方法找不到调用的地方，那是因为发送 vsync 信号的代码是厂商代码（framework 提供 callback interface），不在 aosp 里面</li></ul><h2 id="HWC，硬件图层合成器"><a href="#HWC，硬件图层合成器" class="headerlink" title="HWC，硬件图层合成器"></a>HWC，硬件图层合成器</h2><p><a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a> 这里也介绍了，它是一个合成多个图层的组件（原来状态栏、导航栏、壁纸、app 等不是一起渲染，而是独自渲染最后合成为屏幕内容的），这里只关心它会发出 vsync 信号</p><p><img src="../../../../image/2020-12-02-vsync/vsync_flow.jpg" alt="vsync_flow.jpg"></p><p>我们先理解这张图，屏幕（硬件）发出 vsync 信号（就是上图的 HW_VSYNC），经过软件的一系列的调整生成 SW_VSYNC，然后输出到两路：</p><ol><li><code>SF_VSYNC</code>，输出到 surfaceflinger</li><li><code>APP_VSYNC</code>，输出到 app</li></ol><h2 id="HW-VSYNC-硬件垂直同步信号"><a href="#HW-VSYNC-硬件垂直同步信号" class="headerlink" title="HW_VSYNC - 硬件垂直同步信号"></a>HW_VSYNC - 硬件垂直同步信号</h2><p><img src="../../../../image/2020-12-02-vsync/hw_vsync.jpg" alt="hw_vsync.jpg"></p><p>surfaceflinger 是一个很重要的服务进程，它跟图像和显示有关，源码在 <code>/frameworks/native/services/surfaceflinger</code>；目录下有个编译配置文件 <code>Android.bp</code> ，看下它的内容，它输出了可执行文件 surfaceflinger、共享库 libsurfaceflinger.so 和 libSurfaceFlingerProp.so；然后有个 <code>surfaceflinger.rc</code>，它是一个启动配置文件，意味着 surfaceflinger 会在系统启动后被 init 进程启动为服务进程，看下里面的内容，可执行文件是 <code>/system/bin/surfaceflinger</code>，<code>main</code> 函数入口在 main_surfaceflinger.cpp</p><p>从上图可以看到 surfaceflinger 进程启动后，会查找 HWC server 并注册 callback，当设备发出 hw_vsync 时，<code>SurfaceFlinger.onVsyncReceived</code> 被执行，看上面那张图，hw_vsync 不是直接被使用，而是被调整转换为 sw_vsync，也就是 <code>DispSync.addResyncSample</code></p><h2 id="SW-VSYNC-软件垂直同步信号"><a href="#SW-VSYNC-软件垂直同步信号" class="headerlink" title="SW_VSYNC - 软件垂直同步信号"></a>SW_VSYNC - 软件垂直同步信号</h2><p><code>DispSyncThread</code> 和 <code>DispSync</code> 收集 HW_VSYNC，计算并输出 SW_VSYNC；主循环是 <code>DispSyncThread.threadLoop()</code>，但在分析 main loop 之前，我们需要先了解 <code>DispSync</code> 几个重要的属性（参考<a href="https://www.jianshu.com/p/d3e4b1805c92">「Android SurfaceFlinger SW Vsync模型」</a>）</p><p><code>mResyncSamples</code> 数组 - 通过上面的分析我们知道 <code>addResyncSample</code> 把 HW_VSYNC 加入 <code>DispSync</code>，但 <code>mResyncSamples</code> 只会保留最新的 32 个以供后续计算；它是个首尾相连、环状的循环列表，容量为 32</p><p><code>mPeriod</code> - 两个 HW_VSYNC 之间的时间间隔，相当于刷新率，我们看下它是怎么计算的</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);    <span class="hljs-comment">// 只有收集到足够多（≥ 6）的 HW_VSYNC 才去计算刷新率（以及其他参数）</span>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Computing...&quot;</span>, mName);        <span class="hljs-type">nsecs_t</span> durationSum = <span class="hljs-number">0</span>;        <span class="hljs-type">nsecs_t</span> minDuration = INT64_MAX;        <span class="hljs-type">nsecs_t</span> maxDuration = <span class="hljs-number">0</span>;        <span class="hljs-comment">// We skip the first 2 samples because the first vsync duration on some</span>        <span class="hljs-comment">// devices may be much more inaccurate than on other devices, e.g. due</span>        <span class="hljs-comment">// to delays in ramping up from a power collapse. By doing so this</span>        <span class="hljs-comment">// actually increases the accuracy of the DispSync model even though</span>        <span class="hljs-comment">// we&#x27;re effectively relying on fewer sample points.</span>        <span class="hljs-comment">// 把收集到的 HW_VSYNC 时间间隔去掉前两个，去掉最大值和最小值，剩下的求平均值</span>        <span class="hljs-comment">// 这就算出了硬件的刷新率，它是计算出来的一个平均值，因为 HW_VSYNC 速率极可能是会变动的</span>        <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> numSamplesSkipped = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;            <span class="hljs-type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;            <span class="hljs-type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;            <span class="hljs-type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];            durationSum += duration;            minDuration = <span class="hljs-built_in">min</span>(minDuration, duration);            maxDuration = <span class="hljs-built_in">max</span>(maxDuration, duration);        &#125;        <span class="hljs-comment">// Exclude the min and max from the average</span>        durationSum -= minDuration + maxDuration;        mPeriod = durationSum / (mNumResyncSamples - numSamplesSkipped - <span class="hljs-number">2</span>);        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p><code>mPhase</code> - <code>mPeriod</code> 的偏差值；我们知道 <code>mPeriod</code> 是一个计算出来的平均值，而且还去除了一些噪音（极大值、极小值等），那么它与真实的 HW_VSYNC 之间必定会有偏差，<code>mPhase</code> 就是这个平均偏差（要从数学理论上去理解）；这里不深入细节了</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-type">double</span> sampleAvgX = <span class="hljs-number">0</span>;        <span class="hljs-type">double</span> sampleAvgY = <span class="hljs-number">0</span>;        <span class="hljs-type">double</span> scale = <span class="hljs-number">2.0</span> * M_PI / <span class="hljs-built_in">double</span>(mPeriod);        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;            <span class="hljs-type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;            <span class="hljs-type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;            <span class="hljs-type">double</span> samplePhase = <span class="hljs-built_in">double</span>(sample % mPeriod) * scale;            sampleAvgX += <span class="hljs-built_in">cos</span>(samplePhase);            sampleAvgY += <span class="hljs-built_in">sin</span>(samplePhase);        &#125;        sampleAvgX /= <span class="hljs-built_in">double</span>(mNumResyncSamples - numSamplesSkipped);        sampleAvgY /= <span class="hljs-built_in">double</span>(mNumResyncSamples - numSamplesSkipped);        mPhase = <span class="hljs-built_in">nsecs_t</span>(<span class="hljs-built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));        <span class="hljs-keyword">if</span> (mPhase &lt; -(mPeriod / <span class="hljs-number">2</span>)) &#123;            mPhase += mPeriod;            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));        &#125;        <span class="hljs-comment">// Artificially inflate the period if requested.</span>        mPeriod += mPeriod * mRefreshSkipCount;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p><code>mReferenceTime</code>，这个最新那个 HW_VSYNC 的时间，每次计算下一个 SW_VSYNC 时都是以该时间作为基准，这样可以减少误差。如果每一个 SW_VSYNC 都以上一个 SW_VSYNC 作为基准，那误差就会不停的累加；而如果以第一个 HW_VSYNC 作基准，那每次 SW_VSYNC 误差是不会累加的</p><p>现在我们看下 main loop</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">status_t</span> err;    <span class="hljs-type">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        std::vector&lt;CallbackInvocation&gt; callbackInvocations;        <span class="hljs-type">nsecs_t</span> targetTime = <span class="hljs-number">0</span>;        &#123; <span class="hljs-comment">// Scope for lock</span>            <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;            <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;                <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);            &#125;            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);            ++mFrameNumber;            <span class="hljs-keyword">if</span> (mStop) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-comment">// 收集到足够多的 HW_VSYNC 算出刷新率后，才计算 SW_VSYNC，否则 wait</span>            <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;                err = mCond.<span class="hljs-built_in">wait</span>(mMutex);                <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// computeNextEventTimeLocked 这个方法很重要，我们知道随着 HW_VSYNC 样本的不断更新，</span>            <span class="hljs-comment">// mPeriod、mPhase 和 mReferenceTime 也跟着轻微变动，上一次的 SW_VSYNC 是根据上一次的参数算出来的</span>            <span class="hljs-comment">// 下一次的 SW_VSYNC 则在上次时间戳的基础上重新计算</span>            targetTime = <span class="hljs-built_in">computeNextEventTimeLocked</span>(now);            <span class="hljs-comment">// 没到时间则 wait</span>            <span class="hljs-type">bool</span> isWakeup = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (now &lt; targetTime) &#123;                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DispSync waiting&quot;</span>);                <span class="hljs-keyword">if</span> (targetTime == INT64_MAX) &#123;                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting forever&quot;</span>, mName);                    err = mCond.<span class="hljs-built_in">wait</span>(mMutex);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(targetTime));                    err = mCond.<span class="hljs-built_in">waitRelative</span>(mMutex, targetTime - now);                &#125;                <span class="hljs-keyword">if</span> (err == TIMED_OUT) &#123;                    isWakeup = <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;            &#125;            now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);            <span class="hljs-comment">// Don&#x27;t correct by more than 1.5 ms</span>            <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">nsecs_t</span> kMaxWakeupLatency = <span class="hljs-built_in">us2ns</span>(<span class="hljs-number">1500</span>);            <span class="hljs-keyword">if</span> (isWakeup) &#123;                mWakeupLatency = ((mWakeupLatency * <span class="hljs-number">63</span>) + (now - targetTime)) / <span class="hljs-number">64</span>;                mWakeupLatency = <span class="hljs-built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);                &#125;            &#125;            <span class="hljs-comment">// 发送时，再次计算发送时间，只有此时到达发送时间的才发送（时间算得很精确）</span>            callbackInvocations = <span class="hljs-built_in">gatherCallbackInvocationsLocked</span>(now);        &#125;        <span class="hljs-keyword">if</span> (callbackInvocations.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">fireCallbackInvocations</span>(callbackInvocations);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><p>总的来说，SW_VSYNC 它去除了噪音，而且用过去 32 个 HW_VSYNC 样本的平均值作刷新率，对比 HW_VSYNC 显得平滑了很多</p><p>那谁接收 SW_VSYNC？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;    <span class="hljs-comment">// ... 一个是 app，叫做 APP_VSYNC 吧</span>    mAppConnectionHandle =            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;app&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().app,                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),                                         impl::EventThread::<span class="hljs-built_in">InterceptVSyncsCallback</span>());    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span>    mSfConnectionHandle =            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),                                         [<span class="hljs-keyword">this</span>](<span class="hljs-type">nsecs_t</span> timestamp) &#123;                                             mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);                                         &#125;);    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="APP-VSYNC-发送给-app-的垂直同步信号"><a href="#APP-VSYNC-发送给-app-的垂直同步信号" class="headerlink" title="APP_VSYNC - 发送给 app 的垂直同步信号"></a>APP_VSYNC - 发送给 app 的垂直同步信号</h2><p>还记得文章开头那张 <code>View.invalidate()</code> 时序图吗？最后面它唤醒了 <code>EventThread</code>，现在我们来看看 <code>EventThread</code> 的主循环都做了些什么</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventThread::threadMain</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;    DisplayEventConsumers consumers;    <span class="hljs-keyword">while</span> (mState != State::Quit) &#123;        std::optional&lt;DisplayEventReceiver::Event&gt; event;        <span class="hljs-comment">// 在文章的开头，我们就猜测 mPendingEvents 里放的是同步信号</span>        <span class="hljs-comment">// 现在我们知道了里面包含 SW_VSYNC，那是谁放进去的呢？</span>        <span class="hljs-keyword">if</span> (!mPendingEvents.<span class="hljs-built_in">empty</span>()) &#123;            event = mPendingEvents.<span class="hljs-built_in">front</span>();            mPendingEvents.<span class="hljs-built_in">pop_front</span>();...        &#125;        <span class="hljs-type">bool</span> vsyncRequested = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// Find connections that should consume this event.</span>        <span class="hljs-keyword">auto</span> it = mDisplayEventConnections.<span class="hljs-built_in">begin</span>();        <span class="hljs-keyword">while</span> (it != mDisplayEventConnections.<span class="hljs-built_in">end</span>()) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> connection = it-&gt;<span class="hljs-built_in">promote</span>()) &#123;                vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;                <span class="hljs-keyword">if</span> (event &amp;&amp; <span class="hljs-built_in">shouldConsumeEvent</span>(*event, connection)) &#123;                    consumers.<span class="hljs-built_in">push_back</span>(connection);                &#125;                ++it;            &#125; <span class="hljs-keyword">else</span> &#123;                it = mDisplayEventConnections.<span class="hljs-built_in">erase</span>(it);            &#125;        &#125;        <span class="hljs-comment">// 分发给消费者，怎么回调给 Choreographer？</span>        <span class="hljs-keyword">if</span> (!consumers.<span class="hljs-built_in">empty</span>()) &#123;            <span class="hljs-built_in">dispatchEvent</span>(*event, consumers);            consumers.<span class="hljs-built_in">clear</span>();        &#125;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre></div><p><code>DispSyncThread</code> 把 SW_VSYNC 压入 <code>EventThread.mPendingEvents</code></p><p><img src="../../../../image/2020-12-02-vsync/on_vsync.jpg" alt="on_vsync.jpg"></p><p>分发 SW_VSYNC 的流程</p><ul><li><code>ViewRootImpl</code> 里拿到的是接收 APP_VSYNC 的 <code>Choreographer</code></li><li><code>Choreographer</code> 在构造函数里通过 <code>SurfaceFlinger</code> 与 <code>EventThread</code> 建立连接；这个连接其实是个 <code>Parcelable</code>，一块可以 io 的内存，<code>EventThread</code> 往里面写入 SW_VSYNC，<code>DisplayEventReceiver</code> 则通过 <code>Looper.addFd</code> 监听（这是 app main looper）</li><li>当收到 SW_VSYNC 时<code>FrameDisplayEventReceiver</code> 把 <code>Choreographer.doFrame</code> 放入 message queue，这样 input、animate 和 view 绘制即将执行</li></ul><p><img src="../../../../image/2020-12-02-vsync/consumer.jpg" alt="consumer.jpg"></p><h2 id="SF-VSYNC"><a href="#SF-VSYNC" class="headerlink" title="SF_VSYNC"></a>SF_VSYNC</h2><p>上面我们在分析是谁接收 SW_VSYNC 时，除了 APP_VSYNC 外，还有一路 SF_VSYNC</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span>    mSfConnectionHandle =    mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,                                 mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),                                 [<span class="hljs-keyword">this</span>](<span class="hljs-type">nsecs_t</span> timestamp) &#123;                                     mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);                                 &#125;);    <span class="hljs-comment">// 看看 mEventQueue-&gt;setEventConnection 做了什么</span>    mEventQueue-&gt;<span class="hljs-built_in">setEventConnection</span>(mScheduler-&gt;<span class="hljs-built_in">getEventConnection</span>(mSfConnectionHandle));    <span class="hljs-comment">// ...</span>&#125; <span class="hljs-comment">// 上面有分析过，vsync event 是写入到一块内存里，通过 fd 可以监听到，而回调是 MessageQueue::cb_eventReceiver</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::setEventConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mEventTube.<span class="hljs-built_in">getFd</span>() &gt;= <span class="hljs-number">0</span>) &#123;        mLooper-&gt;<span class="hljs-built_in">removeFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>());    &#125;    mEvents = connection;    mEvents-&gt;<span class="hljs-built_in">stealReceiveChannel</span>(&amp;mEventTube);    mLooper-&gt;<span class="hljs-built_in">addFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);&#125;<span class="hljs-comment">// 继续看 eventReceiver 方法</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> events, <span class="hljs-type">void</span>* data)</span> </span>&#123;    MessageQueue* queue = <span class="hljs-built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);    <span class="hljs-keyword">return</span> queue-&gt;<span class="hljs-built_in">eventReceiver</span>(fd, events);&#125;<span class="hljs-comment">// 把 events 解包成 DisplayEventReceiver::Event，当有 vsync 时执行 dispatchInvalidate</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-type">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;    <span class="hljs-type">ssize_t</span> n;    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::<span class="hljs-built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;                mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>();                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 看来得找出 Handler.handleMessage，看看里面怎么处理 MessageQueue::INVALIDATE</span><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchInvalidate</span>() &#123;    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::INVALIDATE));    &#125;&#125;<span class="hljs-comment">// 最终发现是走到了 SurfaceFlinger::onMessageReceived</span><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">handleMessage</span>(<span class="hljs-type">const</span> Message&amp; message) &#123;    <span class="hljs-keyword">switch</span> (message.what) &#123;        <span class="hljs-keyword">case</span> INVALIDATE:            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> REFRESH:            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);            <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-comment">// 代码比较长，这就不贴出来了，总结下：</span><span class="hljs-comment">// SF_VSYNC 最终会调用 onMessageReceived(MessageQueue::INVALIDATE)，然后又会调用 onMessageReceived(MessageQueue::REFRESH)</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> what)</span> </span>&#123;&#125;</code></pre></div><h2 id="结合-systrace"><a href="#结合-systrace" class="headerlink" title="结合 systrace"></a>结合 systrace</h2><p>为什么会有 APP_VSYNC 和 SF_VSYNC 呢？这就不得不从屏幕上的内容讲起</p><p>实际上，我们在屏幕上看到的内容是由多个 layer 组合而成的：前台 app（多窗口模式下会有多个 app 显示）、桌面、壁纸、systemui 等，每个 app ui thread 负责绘制自己的内容，然后由 SurfaceFlinger 将它们合成在一起并显示在屏幕上</p><p>也就是说 APP_VSYNC 触发各个 app 的绘制，而最终屏幕内容的改变是由 SF_VSYNC 触发的；是不是这样呢？我们来看下 systrace </p><p><img src="../../../../image/2020-12-02-vsync/45517.png" alt="45517.png"></p><p><img src="../../../../image/2020-12-02-vsync/45545.png" alt="45545.png"></p><p><img src="../../../../image/2020-12-02-vsync/45553.png" alt="45553.png"></p><p><img src="../../../../image/2020-12-02-vsync/45532.png" alt="45532.png"></p><p><img src="../../../../image/2020-12-02-vsync/45628.png" alt="45628.png"></p><p><img src="../../../../image/2020-12-02-vsync/45643.png" alt="45643.png"></p><p>可以看到 ui thread doFrame 的确跟随着 APP_VSYNC（render thread 是执行 opengl 的线程，在 ui thread 计算完后获取结果并输出至 gpu），surfaceflinger onMessageReceived 也是跟随着 SF_VSYNC 的；但有没发现，它们俩似乎是同时执行的？surfaceflinger 不是应该等待 app 渲染完它那一层再合成吗？</p><p>我们重新回顾 initScheduler，有没发现这两路 vsync 都有一个 offset 参数？没错，就是这个参数控制着收到 vsync 后到执行工作的这一段延迟时间；实际上图 surfaceflinger 的延迟差不多是一个 vsync 的周期时间那么大，每个 surfaceflinger 合成的内容却是上一个周期里 app 渲染的内容；而且在合成工作完成后，当前周期的 app 渲染工作（render thread）才开始，避免了 layer 的内容被覆盖；这几个线程就这样有节奏地工作在一起。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>invalidate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scoped Storage（沙盒）</title>
    <link href="/2020/11/19/scoped-storage/"/>
    <url>/2020/11/19/scoped-storage/</url>
    
    <content type="html"><![CDATA[<h2 id="以前的存储访问权限"><a href="#以前的存储访问权限" class="headerlink" title="以前的存储访问权限"></a>以前的存储访问权限</h2><p>先看看以前（ &lt; 10/Q ）的存储访问权限是怎样的</p><p>从 APP 目录（app-specific directories）的角度看，可以分为：</p><ol><li>内部存储（app-specific directories in internal storage）<ol><li>对于 app 自己，无需申请任何读/写权限</li><li>对于其他 app，没有访问权限</li></ol></li><li>外部存储（app-specific directories in external storage）<ol><li>对于 app 自己，无需申请任何读/写权限</li><li>对于其他 app，可以访问但需要申请读/写权限</li></ol></li></ol><p>从存储设备的角度看，可以分为：</p><ol><li>内部存储，除了自己的目录，没有访问权限</li><li>外部存储，可以访问但需申请读/写权限（除了自己的目录）</li></ol><h2 id="启用-Scoped-Storage-后"><a href="#启用-Scoped-Storage-后" class="headerlink" title="启用 Scoped Storage 后"></a>启用 Scoped Storage 后</h2><p>而启用 Scoped Storage（ ≥ 10/Q）后，APP 只能通过下述三种方法访问文件：</p><ol><li>对于 APP 目录（ app-specific directories ），无论是内部存储还是外部存储，无需申请任何读/写权限即可访问（ File API ），APP 卸载时被删除</li><li>通过 MediaStore API 操作媒体文件，读/写 APP 自己的文件时无需任何权限，访问其他 APP 的内容时需要申请 READ_EXTERNAL_STORAGE；开启 Scoped Storage 后，只能访问 <code>MediaStore.Images</code>，<code>MediaStore.Video</code>，<code>MediaStore.Audio</code> 和自己的 <code>MediaStore.Downloads</code></li><li>通过 SAF（ <code>Storage Access Framework</code>，也就是文件选择器 ）读/写其他的文件，参考 <a href="https://developer.android.google.cn/guide/topics/providers/document-provider">Open files using storage access framework</a></li><li>其他方式即使拥有读写权限也会抛出 <code>java.io.IOException: Permission denied</code></li></ol><p>兼容性（ targetSDK ）</p><ol><li>&lt; 29，默认关闭，可以通过 <code>requestLegacyExternalStorage = false</code> 打开</li><li>= 29，默认开启，可以通过 <code>requestLegacyExternalStorage = true</code> 关闭</li><li>&gt; 29，强制开启，<code>requestLegacyExternalStorage</code> 被忽略</li></ol><p>常用的 APP 目录</p><table><thead><tr><th align="left">API</th><th align="left">Storage</th><th align="left">权限</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="left">getDataDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication</td></tr><tr><td align="left">getFilesDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/files</td></tr><tr><td align="left">getCacheDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/cache</td></tr><tr><td align="left">getDir(“apple”, Context.MODE_PRIVATE)</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/app_apple</td></tr><tr><td align="left">getExternalCacheDir()</td><td align="left">external storage</td><td align="left">NO</td><td align="left">/storage/emulated/0/Android/data/com.example.myapplication/cache</td></tr><tr><td align="left">getExternalFilesDir(“apple”)</td><td align="left">external storage</td><td align="left">NO</td><td align="left">/storage/emulated/0/Android/data/com.example.myapplication/files/apple</td></tr><tr><td align="left">Environment.getExternalStoragePublicDirectory()</td><td align="left">external storage</td><td align="left">YES</td><td align="left">/storage/emulated/0/Pictures, /storage/emulated/0/Alarms, …</td></tr></tbody></table><h2 id="学会使用-MediaStore-API"><a href="#学会使用-MediaStore-API" class="headerlink" title="学会使用 MediaStore API"></a>学会使用 MediaStore API</h2><p>当 APP 卸载时，APP 目录也随之被删除；如果需要将一些文件，比如图片，持久地保存下来， 媒体文件如图片、视频和音频 CURD 操作可以参考 <a href="https://developer.android.com/training/data-storage/shared/media">Access media files from shared storage</a></p><p>APP 访问自己创建的媒体文件时，无需额外的权限，因为这些媒体文件的属性「owner app」被设置为此 APP；当 APP 被卸载，这些媒体文件的「owner app」被清空；当 APP 被再次安装并访问这些媒体文件时，需要 <code>READ_EXTERNAL_STORAGE</code>，参考 <a href="https://developer.android.com/training/data-storage/shared/media#app-attribution">App attribution of media files</a></p><p>创建媒体文件时，可以通过 <code>RELATIVE_PATH</code> 指定路径，例如图片可以放在 <code>&quot;$&#123;Environment.DIRECTORY_PICTURES&#125;/tangzhi&quot;</code> 下（/storage/emulated/0/Pictures/tangzhi）</p><ol><li><code>MediaStore.Images</code> 可选择 <code>Environment.DIRECTORY_PICTURES</code> 和 <code>Environment.DIRECTORY_DCIM</code></li><li><code>MediaStore.Video</code> 可选择 <code>Environment.DIRECTORY_MOVIES</code> 和 <code>Environment.DIRECTORY_DCIM</code></li><li><code>MediaStore.Audio</code> 可选择 <code>Environment.DIRECTORY_MUSIC</code>，<code>Environment.DIRECTORY_RINGTONES</code>，<code>Environment.DIRECTORY_PODCASTS</code> …</li><li><code>MediaStore.Downloads</code> 可选择 <code>Environment.DIRECTORY_DOWNLOADS</code></li></ol><p><code>MediaStore</code> 一些重要的列</p><table><thead><tr><th align="left">字段</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">BUCKET_DISPLAY_NAME</td><td align="left">媒体文件的分类，例如：Camera，Screenshot，WeiXin</td></tr><tr><td align="left">BUCKET_ID</td><td align="left">媒体的分类 ID</td></tr><tr><td align="left">DISPLAY_NAME</td><td align="left">媒体文件名，例如：Screenshot_20201102_123620.jpg</td></tr><tr><td align="left">RELATIVE_PATH</td><td align="left">在 external storage 的相对路径，例如：Pictures/WeiXin/，DCIM/Camera/，一般是正确的</td></tr><tr><td align="left">DATA</td><td align="left">一般会将媒体文件的真实路径保存在这一列，但不保证它是正确的</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Scoped Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>starting window 和 windowDisablePreview</title>
    <link href="/2020/11/11/starting-window/"/>
    <url>/2020/11/11/starting-window/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>中午和同事聊天时，提到一个问题：设计把爱范儿 app 的启动页改成暗黑样式，本来很简单的一个改动，测试却发现启动会有闪屏；下午我看了下效果，发现确实有问题：</p><ul><li>把启动页的图片换成暗黑主体的图片后，冷/热启动都会有从白色到黑色的闪动</li><li>同事给的 bug fixed 是 <code>windowDisablePreview = true</code>，这导致 app 热启动时，会有很长的一段延迟</li></ul><h2 id="starting-window-是如何出现的"><a href="#starting-window-是如何出现的" class="headerlink" title="starting window 是如何出现的"></a>starting window 是如何出现的</h2><p>网上搜索下，发现是 starting widow 引起的，我决定看看这个 starting window 是怎么打开和关闭的，以及如何设置它的背景色来匹配启动页的黑色背景</p><p>跟寻<a href="../../../../2020/11/03/launch-activity-sequence/">上一篇文章</a>的脚步，找到 start point：<code>ActivityStarter.startActivityUnchecked</code></p><p><img src="../../../../image/2020-11-11-starting-window/starting_window.jpg" alt="starting_window.jpg"></p><p>从上图可以看到，starting window 其实是系统通过 <code>ViewManager.addView</code> 往屏幕上添加的一个 <code>window</code>；而且它的显示时间比较早，比创建 app 进程（<code>ActivityStackSupervisor.startProcessAsync</code>）和 <code>ActivityThread</code> 执行 <code>Activity</code> 生命周期函数（<code>ActivityThread.performLaunchActivity</code>）都要早，所以它才能起到快速响应用户点击操作的效果；其次它的 view 是很简单的纯色背景，这样渲染也比较快出来，下面是构建 starting window 的代码，我们来看看它的样式是如何设置的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> StartingSurface <span class="hljs-title function_">addSplashScreen</span><span class="hljs-params">(...)</span> &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// ... theme 是 launch activity theme，在这个 theme 里我们可以设置 starting window 样式</span>        <span class="hljs-keyword">if</span> (theme != context.getThemeResId() || labelRes != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                context = context.createPackageContext(packageName, CONTEXT_RESTRICTED);                context.setTheme(theme);            &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;                <span class="hljs-comment">// Ignore</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> (overrideConfig != <span class="hljs-literal">null</span> &amp;&amp; !overrideConfig.equals(EMPTY)) &#123;            <span class="hljs-keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="hljs-string">&quot;addSplashScreen: creating context based&quot;</span>                    + <span class="hljs-string">&quot; on overrideConfig&quot;</span> + overrideConfig + <span class="hljs-string">&quot; for splash screen&quot;</span>);            <span class="hljs-keyword">final</span> <span class="hljs-type">Context</span> <span class="hljs-variable">overrideContext</span> <span class="hljs-operator">=</span> context.createConfigurationContext(overrideConfig);            overrideContext.setTheme(theme);            <span class="hljs-keyword">final</span> <span class="hljs-type">TypedArray</span> <span class="hljs-variable">typedArray</span> <span class="hljs-operator">=</span> overrideContext.obtainStyledAttributes(com.android.internal.R.styleable.Window);            <span class="hljs-comment">// 我们可以通过 windowBackground 设置窗口背景</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">resId</span> <span class="hljs-operator">=</span> typedArray.getResourceId(R.styleable.Window_windowBackground, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (resId != <span class="hljs-number">0</span> &amp;&amp; overrideContext.getDrawable(resId) != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">// We want to use the windowBackground for the override context if it is</span>                <span class="hljs-comment">// available, otherwise we use the default one to make sure a themed starting</span>                <span class="hljs-comment">// window is displayed for the app.</span>                <span class="hljs-keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="hljs-string">&quot;addSplashScreen: apply overrideConfig&quot;</span>                        + overrideConfig + <span class="hljs-string">&quot; to starting window resId=&quot;</span> + resId);                context = overrideContext;            &#125;            typedArray.recycle();        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-type">PhoneWindow</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneWindow</span>(context);        <span class="hljs-comment">// ...</span>        addSplashscreenContent(win, context);        wm = (WindowManager) context.getSystemService(WINDOW_SERVICE);        view = win.getDecorView();        wm.addView(view, params);        <span class="hljs-comment">// ....</span>    &#125;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSplashscreenContent</span><span class="hljs-params">(PhoneWindow win, Context ctx)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">TypedArray</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ctx.obtainStyledAttributes(R.styleable.Window);    <span class="hljs-comment">// 看这里，我们可以通过 windowSplashscreenContent 设置 starting window content view 背景</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">resId</span> <span class="hljs-operator">=</span> a.getResourceId(R.styleable.Window_windowSplashscreenContent, <span class="hljs-number">0</span>);    a.recycle();    <span class="hljs-keyword">if</span> (resId == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">Drawable</span> <span class="hljs-variable">drawable</span> <span class="hljs-operator">=</span> ctx.getDrawable(resId);    <span class="hljs-keyword">if</span> (drawable == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// We wrap this into a view so the system insets get applied to the drawable.</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>(ctx);    v.setBackground(drawable);    win.setContentView(v);&#125;</code></pre></div><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>从上面的代码可以看出，starting window 有两个样式是比较重要的，而它们都来自于 launch activity theme</p><ol><li><code>windowBackground</code> 设置窗口背景</li><li><code>windowSplashscreenContent</code> 设置 content view 背景（requires API level 26）</li></ol><p>把 launch activity 的窗口背景设置为黑色，即可避免启动时由白到黑的闪屏问题</p><p>更进一步，把窗口背景替换为 launch activity 的 ifanr logo 素材，这样 starting window 和 launch activity 的背景一致，两个窗口无缝切换，视觉上就感受不到 starting window 的存在了，感觉上 app 的启动非常块</p>]]></content>
    
    
    
    <tags>
      
      <tag>windowDisablePreview</tag>
      
      <tag>starting window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity 启动流程时序图</title>
    <link href="/2020/11/03/launch-activity-sequence/"/>
    <url>/2020/11/03/launch-activity-sequence/</url>
    
    <content type="html"><![CDATA[<p>记录下启动 <code>Activity</code> 的时序图，方便后面查找</p><p><img src="../../../../image/2020-11-03-launch-activity-sequence/launch_activity.jpg" alt="launch_activity.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解 Glide</title>
    <link href="/2020/10/31/how-glide-work/"/>
    <url>/2020/10/31/how-glide-work/</url>
    
    <content type="html"><![CDATA[<p>网上讲解 <code>Glide</code> 的文章一搜一大把，但几乎都是以文字的形式来讲解；我自己也写过不少 <code>Glide</code> 的笔记，也是文字为主；但是时间长了经常忘了其中的细节，加上 <code>Glide</code> 的源码不太易懂，所以决定用时序图来分析和记录研究 <code>Glide</code> 的过程</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>下面两张图是一次图片加载的大体流程，有读过源码的同学基本上通过这两种图就能回忆起其中的细节；没读过源码的同学也可以先了解下 <code>Glide</code> 里各个类的作用</p><p><img src="../../../../image/2020-10-31-how-glide-work/glide_1.jpg" alt="glide_1.jpg"></p><p><img src="../../../../image/2020-10-31-how-glide-work/glide_task.jpg" alt="glide_task.jpg"></p><h2 id="RequestManager-请求管理器"><a href="#RequestManager-请求管理器" class="headerlink" title="RequestManager - 请求管理器"></a><code>RequestManager</code> - 请求管理器</h2><p>往 <code>Activity</code>/<code>Fragment</code> 添加一个 <code>RequestManagerFragment</code>（没有 <code>View</code>） 用以监听宿主的生命周期，从而实现请求的管理和绑定</p><p><img src="../../../../image/2020-10-31-how-glide-work/1.jpg" alt="1.jpg"></p><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存有 <code>ActiveResources</code> 和 <code>LruResourceCache</code>（<code>MemoryCache</code>），如下图，它们关系是：</p><ul><li>从 source/data 解码的 resource 将被加入 <code>ActiveResources</code></li><li>当 <code>onStop</code>/<code>onDestory</code>/<code>onTrimMemory</code> 时 resource 被释放，从 <code>ActiveResources</code> 移除并放入 <code>MemoryCache</code></li><li>加载时如果命中缓存，则从 <code>MemoryCache</code> 移除并加入 <code>ActiveResources</code></li></ul><p>它们的不同之处：</p><ul><li>它们对应 resource 的不同生命周期：使用中 - <code>ActiveResources</code>，释放后 - <code>MemoryCache</code></li><li><code>ActiveResources</code> 是对所有使用中 resource 的弱引用，相当于对所有使用中 resource 的收集和统计，没有大小限制</li><li><code>MemoryCache</code> 引用释放的资源，有大小限制，实现是 <code>LruResourceCache</code></li></ul><p><img src="../../../../image/2020-10-31-how-glide-work/glide_memory_cache.jpg" alt="glide_memory_cache.jpg"></p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>磁盘缓存有两层：data cache 和 resource cache，它们的关系在于：</p><ul><li>都是磁盘缓存，都以文件的形式存在于 disk cache dir，只是 key 不同</li><li>从网络抓取 → 保存为 data cache → 解码为 resource → 保存为 resource cache（optional）→ 返回 resource</li><li>下次加载时，先尝试加载 resource cache 再尝试加载 data cache</li></ul><p>它们的区别在于：</p><ul><li>data cache 缓存的是原始数据（也就是从 source 直接抓取到的数据流），resource cache 缓存的是解码后（比如 <code>Bitmap</code>）的数据</li><li>resource cache 能够加速解码的速度；比如 source 是网络上的图片，一般是 jpg or png，则从 data cache 加载需要解码为 Bitmap，而 resource cache 直接缓存 bitmap bytes，省了解码这步</li><li>resource cache 会增大磁盘缓存起码一倍；比如上述的 bitmap bytes 比压缩格式的 jpg 要大</li><li>是否有 resource cache 受几个条件的影响</li></ul><div class="code-wrapper"><pre><code class="hljs java">DiskCacheStrategyNONE      - 没有磁盘缓存DATA      - 只缓存 data cacheRESOURCE  - 只缓存 resource cacheALL       - 都缓存AUTOMATIC - 自动<span class="hljs-comment">// 看下 AUTOMATIC 的情况</span><span class="hljs-comment">// data cache，只缓存网络资源，不缓存 asset file，local disk file 等本地资源</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDataCacheable</span><span class="hljs-params">(DataSource dataSource)</span> &#123;    <span class="hljs-keyword">return</span> dataSource == DataSource.REMOTE;&#125;<span class="hljs-comment">// resource cache 只缓存 asset file，local disk file 等本地资源</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isResourceCacheable</span><span class="hljs-params">(</span><span class="hljs-params">        <span class="hljs-type">boolean</span> isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy)</span> &#123;    <span class="hljs-keyword">return</span> ((isFromAlternateCacheKey &amp;&amp; dataSource == DataSource.DATA_DISK_CACHE)            || dataSource == DataSource.LOCAL)            &amp;&amp; encodeStrategy == EncodeStrategy.TRANSFORMED;&#125;</code></pre></div><p><img src="../../../../image/2020-10-31-how-glide-work/glide_disk_cache.jpg" alt="glide_disk_cache.jpg"></p><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>使用池化技术（<code>ArrayPool</code> 和 <code>BitmapPool</code>）降低内存抖动</p><p><code>Glide</code> 在很多地方都需要临时用到一小块的内存，使用 byte array pool 可以平缓内存使用，避免频繁的内存申请</p><ul><li>io 时需要一个内存缓冲区来读写</li><li>从文件解码图片时 <code>BitmapFactory.Options.inTempStorage</code></li><li><code>downsample</code> 时需要先加载 image exif 信息</li></ul><p><code>BitmapPool</code> 则在 <code>Transformation.transform</code> 做 <code>Bitmap</code> 转换时用得比较多</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li>load memory cache 阶段是 ui 线程</li><li>decode cache 阶段是一个 decode 线程；此阶段会将 data 解码至 memory resource，采用单个线程排队解码，可以防止多个线程同时解码申请大内存造成内存抖动甚至 OOM</li><li>fetch source 阶段是线程池</li></ul><h2 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h2><p>加载路径把 model - dataClass - resourceClass - transcodeClass 串联起来</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// url string 是 model，类型是 String；transcodeClass 是 Drawable.class，最终的目标类型；此时的 resourceClass 是 Object.class</span>GlideApp.with(<span class="hljs-built_in">this</span>).as(Drawable.class).load(url).into(photoView);</code></pre></div><ol><li>通过 <code>ModelLoaderRegistry</code> 知道 model 能使用哪些 <code>ModelLoader</code>，能加载到 jvm 里成为哪些 dataClass；string url 的话，适用于 <code>StringLoader</code>，能加载为 <code>InputStream</code> 和 <code>ParcelFileDescriptor</code>；如果有多个 loader 可以用，则使用 <code>MultiModelLoader</code>，它专门用来包裹多个 loader，因为对于一个 model 可能会有多个 loader 可以处理它；对于 <code>MultiXXX</code>，内部都有个属性 <code>currentIndex</code> 指定使用哪个实例（一般情况下就是第 0 个了，除非有代码设置过 <code>currentIndex</code>）；loader 在注册表中的位置可以通过 append、prepend 调整</li><li>通过 <code>ResourceDecoderRegistry</code> 知道上述 dataClass 列表能够 decode 为哪些 resourceClass；<code>InputStream</code> 能够 decode 为 <code>Bitmap</code>，<code>GifDrawable</code> 和 <code>BitmapDrawable</code>；<code>ParcelFileDescriptor</code> 能够 decode 为 <code>Bitmap</code> 和 <code>BitmapDrawable</code></li><li>如果上述的 resourceClass 等于 transcodeClass 或它的子类，则把 resourceClass 加入到目标类型列表里；否则通过 <code>TranscoderRegistry</code> 判断能否使用注册的 <code>ResourceTranscoder</code> 将 resourceClass 转换为 transcodeClass 或它的子类，可以的话也将其加入目标类型列表里面；比如 <code>Bitmap</code> 可以用 <code>BitmapDrawableTranscoder</code> 转换为 <code>Drawable</code></li><li>最终得到一个目标类型列表，里面的类型等于 transcodeClass 或它的子类；它表明可以从 model 加载得到 <code>Drawable</code>；这个列表有：<code>Bitmap</code>，<code>BitmapDrawable</code>，<code>GifDrawable</code></li><li>按顺序（也即是注册表里的顺序），使用对应的 decoder 把 <code>InputStream</code> 解码；这里说下，因为 url 所在的是一张图片，所以 <code>StreamGifDecoder.handles</code> 发现不是 gif 会返回 false，于是不能转为 <code>GifDrawable</code>，跳到下一个；假设下一个是 <code>Bitmap</code>，可以正常 decode 为 <code>Drawable</code>，于是就略过了 <code>BitmapDrawable</code> 这个目标类型</li></ol><p><code>Glide</code> 有三层主要的 component：<code>ModelLoader</code>，<code>ResourceDecoder</code> 和 <code>ResourceTranscoder</code>；每层都注册了大量的实现，所以对于某个加载请求，会有多个路径；而到底使用哪条加载路径，取决于 component 在 <code>Register</code> 里的位置，靠前的 component 会被优先选择，如果这条路径走得通，那么后续的路径就被忽略了</p><ol><li>string url -&gt; <code>InputStream</code> -&gt; <code>Bitmap</code> -&gt; <code>Drawable</code>（用了 transcode，<code>Bitmap</code> 可以转换成 <code>BitmapDrawable</code>）</li><li>string url -&gt; <code>InputStream</code> -&gt; <code>BitmapDrawable</code></li><li>string url -&gt; <code>ByteBuffer</code> -&gt; <code>Bitmap</code> -&gt; <code>Drawable</code></li><li>…</li></ol><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li>同一个 <code>ImageView</code>，加载多个图片，为什么不会错乱呢？</li></ol><p>将 <code>Request</code> 放入 <code>View.setTag</code>，旧的 <code>Resquest</code> 将被新的 <code>Request</code> 取消，防止同一个 <code>ImageView</code> 的多个请求错乱</p>]]></content>
    
    
    
    <tags>
      
      <tag>glide</tag>
      
      <tag>fresco</tag>
      
      <tag>imageloader</tag>
      
      <tag>图片加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读源码系列：ANR 是怎么产生的</title>
    <link href="/2020/10/20/anr/"/>
    <url>/2020/10/20/anr/</url>
    
    <content type="html"><![CDATA[<p>根据日常的经验我们大概知道，如果 app 没有及时消费 <code>MotionEvent</code>，超过 5s 就会弹出 ANR 对话框；那么 ANR 的逻辑肯定是在事件分发过程中产生的，我们从事件的源头找起，看看 input 事件是怎么产生的</p><h2 id="input-的分发"><a href="#input-的分发" class="headerlink" title="input 的分发"></a>input 的分发</h2><p><img src="../../../../image/2020-10-20-anr/sequence.png" alt="sequence.png"></p><p>事件分发是从线程 <code>InputReaderThread</code> 开始的，它的主要工作是：</p><ol><li>从目录 <code>/dev/input</code> 获取 input event<ul><li>看来 android 的输入设备是挂载在 <code>/dev/input</code> 下的，当然会有多个输入设备：屏幕触摸、键盘、手柄等，使用 <code>epoll</code> 监听多个 <code>fd</code></li><li><code>EventHub.getEvents()</code> 从 <code>fd</code> 读取 <code>input_event</code> 并转换为 <code>RawEvent</code>（看来输入设备的驱动都需要构造 <code>input_event</code> 给系统）</li></ul></li><li>经过识别分类（按键、手势、手柄、滚轮等）、过滤等一系列操作后，添加到 <code>mInboundQueue</code>（等待 <code>InputDispatcher</code> 分发）<ul><li><code>InputDevice</code> 将 <code>RawEvent</code> 交由各种 <code>InputMapper</code> 处理，例如：<code>KeyboardInputMapper</code> 将 <code>RawEvent</code> 包装为 <code>NotifyKeyArgs</code>，<code>TouchInputMapper</code> 将 <code>RawEvent</code> 包装为 <code>NotifyMotionArgs</code></li><li><code>InputDispatcher.notifyXXX</code> 将各种 <code>NotifyXXXArgs</code> 包装为 <code>XXXEntry</code> 放入 <code>mInboundQueue</code></li></ul></li></ol><p>这里需要补充下 Native Looper 不同于 Java Looper 的地方：提供了监听文件描述符的机制</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @param fd       需要监听的文件描述符</span><span class="hljs-comment"> * @param ident    表示为当前发生事件的标识符，必须 &gt;= 0，或者为 POLL_CALLBACK(-2) 如果指定了 callback</span><span class="hljs-comment"> * @param events   表示为要监听的文件类型，默认是 EVENT_INPUT</span><span class="hljs-comment"> * @param callback 当有事件发生时，会回调该 callback 函数</span><span class="hljs-comment"> * @param data</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 主要做了两件事：</span><span class="hljs-comment"> * 1，把输入参数构造成 Request，添加到 mRequests</span><span class="hljs-comment"> * 2，将 fd 添加到 epoll</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ident, <span class="hljs-type">int</span> events, Looper_callbackFunc callback, <span class="hljs-type">void</span>* data)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ident, <span class="hljs-type">int</span> events, <span class="hljs-type">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-type">void</span>* data)</span></span>;</code></pre></div><p>它有两种使用方式：</p><ul><li>指定 callback 来处理事件 : 当该文件描述符上有事件到来时，该 callback 会被执行；调用 <code>Looper.wake()</code> 也会触发 callback 执行</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// pollAll() -&gt; pollOnce() -&gt; pollInner()</span><span class="hljs-type">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis)<span class="hljs-comment">// ...</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; eventCount; i++) &#123;    <span class="hljs-type">int</span> fd = eventItems[i].data.fd;    <span class="hljs-type">uint32_t</span> epollEvents = eventItems[i].events;    <span class="hljs-keyword">if</span> (fd == mWakeEventFd.<span class="hljs-built_in">get</span>()) &#123;        <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">ssize_t</span> requestIndex = mRequests.<span class="hljs-built_in">indexOfKey</span>(fd);        <span class="hljs-keyword">if</span> (requestIndex &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// ...</span>            <span class="hljs-built_in">pushResponse</span>(events, mRequests.<span class="hljs-built_in">valueAt</span>(requestIndex));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// ...</span>        &#125;    &#125;&#125;<span class="hljs-comment">// ...</span><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mResponses.<span class="hljs-built_in">size</span>(); i++) &#123;    Response&amp; response = mResponses.<span class="hljs-built_in">editItemAt</span>(i);    <span class="hljs-keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;        <span class="hljs-type">int</span> fd = response.request.fd;        <span class="hljs-type">int</span> events = response.events;        <span class="hljs-type">void</span>* data = response.request.data;        <span class="hljs-type">int</span> callbackResult = response.request.callback-&gt;<span class="hljs-built_in">handleEvent</span>(fd, events, data);        <span class="hljs-keyword">if</span> (callbackResult == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">removeFd</span>(fd, response.request.seq);        &#125;        <span class="hljs-comment">// Clear the callback reference in the response structure promptly because we</span>        <span class="hljs-comment">// will not clear the response vector itself until the next poll.</span>        response.request.callback.<span class="hljs-built_in">clear</span>();        result = POLL_CALLBACK;    &#125;&#125;</code></pre></div><ul><li>通过指定的 ident 来处理事件：当该文件描述符有数据到来时，<code>pollOnce()</code> 会返回一个 ident，调用者会判断该 ident 是否等于自己需要处理的事件 ident，如果是的话，则开始处理事件</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// pollAll() -&gt; pollOnce()</span><span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-keyword">while</span> (mResponseIndex &lt; mResponses.<span class="hljs-built_in">size</span>()) &#123;        <span class="hljs-type">const</span> Response&amp; response = mResponses.<span class="hljs-built_in">itemAt</span>(mResponseIndex++);        <span class="hljs-type">int</span> ident = response.request.ident;        <span class="hljs-keyword">if</span> (ident &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">int</span> fd = response.request.fd;            <span class="hljs-type">int</span> events = response.events;            <span class="hljs-type">void</span>* data = response.request.data;            <span class="hljs-keyword">if</span> (outFd != <span class="hljs-literal">nullptr</span>) *outFd = fd;            <span class="hljs-keyword">if</span> (outEvents != <span class="hljs-literal">nullptr</span>) *outEvents = events;            <span class="hljs-keyword">if</span> (outData != <span class="hljs-literal">nullptr</span>) *outData = data;            <span class="hljs-keyword">return</span> ident;        &#125;    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="ui-如何接收和处理-input"><a href="#ui-如何接收和处理-input" class="headerlink" title="ui 如何接收和处理 input"></a>ui 如何接收和处理 input</h2><p>在分析事件分发的逻辑之前，我们先看看 ui 线程是怎么接收 input 事件的</p><p><img src="../../../../image/2020-10-20-anr/input_channel.png" alt="input_channel.png"></p><p>可以看到在 native 层打开了一对 socket，server socket fd 给 <code>InputDispatcher</code> 线程，client socket fd 给 ui 线程（<code>ViewRootImpl.mInputChannel</code>），也就是说它们之间通过 socket 双向通讯</p><p><img src="../../../../image/2020-10-20-anr/ui_thread.png" alt="ui_thread.png"></p><ol><li>接收：在 native 层用 Native Looper 监听 client socket fd（epoll），封装成 <code>InputMessage</code> 传递给 java 层处理</li><li>经过一个 <code>InputStage</code> 责任链的处理，最终到达我们最熟悉的 <code>View.dispatchTouchEvent</code></li><li>响应：ui 线程在消费完 input event 后，通过双向的 socket 告知 dispatcher 线程；如果此时 client socket 不可写，则将响应保存起来，等待下次 client socket 可写时</li><li>dispatcher - ui 这一段分发过程实际上是异步的，那么整个事件分发的过程也就是异步的，这是 ANR 产生的前提</li></ol><h2 id="input-的生命周期"><a href="#input-的生命周期" class="headerlink" title="input 的生命周期"></a>input 的生命周期</h2><p><img src="../../../../image/2020-10-20-anr/input_dispatcher.png" alt="input_dispatcher.png"></p><p>一个 input event 的生命流程大概是这样的：</p><ul><li><code>InputReader</code> 放入 <code>InputDispatcher.mInboundQueue</code> 等待分发</li><li><code>InputDispatcher</code> 将其移入 window 对应的 <code>Connection→outboundQueue</code> 等待发送</li><li>发送成功后，移入 <code>Connection→waitQueue</code> 等待 ui 线程的确认应答</li><li>收到确认应答，将 input event 移出 <code>Connection→waitQueue</code></li></ul><p>产生 ANR 的逻辑就在 <code>dispatchKeyLocked</code>（分发一个 input event 的过程）</p><p><img src="../../../../image/2020-10-20-anr/anr.jpg" alt="anr.jpg"></p><p>1，<code>findFocusedWindowTargetsLocked</code> 找到 input event 的分发 window 对象，然后 <code>checkWindowReadyForMoreInputLocked</code> 检查 widnow 是否可以接收 input event，这里截取一段检查逻辑：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// outboundQueue 不为空说明此 window 仍有 input event 未发送，waitQueue 不为空说明有 input event 在消费中（未收到消费完成的响应）</span><span class="hljs-comment">// 也就是说 input event 必须是按顺序分发和消费的，不能乱序</span><span class="hljs-keyword">if</span> (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;    <span class="hljs-keyword">if</span> (!connection-&gt;outboundQueue.<span class="hljs-built_in">isEmpty</span>() || !connection-&gt;waitQueue.<span class="hljs-built_in">isEmpty</span>()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Waiting to send key event because the %s window has not &quot;</span>                            <span class="hljs-string">&quot;finished processing all of the input events that were previously &quot;</span>                            <span class="hljs-string">&quot;delivered to it.  Outbound queue length: %d.  Wait queue length: &quot;</span>                            <span class="hljs-string">&quot;%d.&quot;</span>,                            targetType, connection-&gt;outboundQueue.<span class="hljs-built_in">count</span>(),                            connection-&gt;waitQueue.<span class="hljs-built_in">count</span>());    &#125;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span> (!connection-&gt;waitQueue.<span class="hljs-built_in">isEmpty</span>() &amp;&amp;        currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime + STREAM_AHEAD_EVENT_TIMEOUT) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Waiting to send non-key event because the %s window has not &quot;</span>                            <span class="hljs-string">&quot;finished processing certain input events that were delivered to &quot;</span>                            <span class="hljs-string">&quot;it over &quot;</span>                            <span class="hljs-string">&quot;%0.1fms ago.  Wait queue length: %d.  Wait queue head age: &quot;</span>                            <span class="hljs-string">&quot;%0.1fms.&quot;</span>,                            targetType, STREAM_AHEAD_EVENT_TIMEOUT * <span class="hljs-number">0.000001f</span>,                            connection-&gt;waitQueue.<span class="hljs-built_in">count</span>(),                            (currentTime - connection-&gt;waitQueue.head-&gt;deliveryTime) *                                    <span class="hljs-number">0.000001f</span>);    &#125;&#125;</code></pre></div><p>2，最后走到 <code>AppErrors.handleShowAnrUi</code> 里就是弹出 ANR dialog 的地方</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>三个线程，<code>InputReader</code> 负责监听 input fd，<code>InputDispatcher</code> 负责分发给 ui，ui 消费并反馈给 <code>InputDispatcher</code></li><li><code>InputReader</code> 和 <code>InputDispatcher</code> 在同一进程，<code>mInboundQueue</code> 加锁使用即可；<code>InputDispatcher</code> 和 ui 在不同的进程，通过 socket 通讯</li><li>事件分发是一个异步的过程，所以它会在 <code>mInboundQueue</code>（待分发）、<code>outboundQueue</code>（待发送） 和 <code>waitQueue</code>（待响应） 之间流转</li><li>input event 必须按顺序分发和消费，一个 input event 在分发前必须等待上一个 input event 的响应，如果等待时间超过 5s 则发生 ANR</li><li>ANR dialog 是在 AMS 进程弹出的</li></ol><p>还学到了什么</p><p><code>epoll</code>（或者说 IO 多路复用）ui 线程是通过 socket 与 <code>InputDispatcher</code> 线程交互的，它既要等待 input event（不能阻塞）又要处理 ui 相关工作，靠的就是 epoll；具体来说是 native Looper，因为 epoll 可以同时监听多个 fd；用一个 wakeUpFd + messageQueue，当 enqueueMessage 时往 wakeUpFd 写入，从而唤醒线程处理 message；添加 socket fd，当 socket 可读时，唤醒线程处理 socket 过来的消息，而且还可以同时处理 message 和 socket</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://gityuan.com/2017/01/01/input-anr/">Input系统-ANR原理分析</a></li><li><a href="http://gityuan.com/2019/04/06/android-anr/">彻底理解安卓应用无响应机制</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ANR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂事件分发，手势冲突和滑动冲突</title>
    <link href="/2020/10/04/dispatchtouchevent/"/>
    <url>/2020/10/04/dispatchtouchevent/</url>
    
    <content type="html"><![CDATA[<p>手势冲突是 android 开发中经常遇到的一类问题了，网上讲解此问题的文章也很多，但是大都浅显地过一遍事件分发的调用栈，然后给出一个调用栈流程图；要不就是使用日志大法，用日志来验证自己的想法，完全没有参考价值；这里根据事件分发相关源码，记录下我的理解。</p><p><code>MotionEvent</code> 里定义的 <code>ACTION_XXX</code> 还不少有 10 多个，看起来情况很复杂的样子，实际上只需要关注三个：<code>ACTION_DOWN</code>，<code>ACTION_MOVE</code> 和 <code>ACTION_UP</code>，而且在一个手势里它们的顺序是：<code>ACTION_DOWN</code> → <code>ACTION_MOVE</code> → <code>ACTION_MOVE</code> → … → <code>ACTION_UP</code>。</p><h2 id="跟踪源码的调用栈"><a href="#跟踪源码的调用栈" class="headerlink" title="跟踪源码的调用栈"></a>跟踪源码的调用栈</h2><ul><li><code>Window.Callback.dispatchTouchEvent</code>（<code>Activity.dispatchTouchEvent</code> 实现了它，在 <code>Activity.attach</code> 里通过 <code>Window.setCallback</code> 设置进去）</li><li><code>Window.superDispatchTouchEvent</code>（实现在 <code>PhoneWindow.superDispatchTouchEvent</code>）</li><li><code>DecorView.superDispatchTouchEvent</code></li><li><code>ViewGroup.dispatchTouchEvent</code></li><li><code>ViewGroup.onInterceptTouchEvent</code></li><li><code>View.dispatchTouchEvent</code></li><li><code>View.onTouchEvent</code></li><li><code>ViewGroup.onTouchEvent</code></li><li><code>Activity.onTouchEvent</code></li></ul><p>网上大部分文章到此就结束了，实际上重点应该在 <code>ViewGroup.dispatchTouchEvent</code>，里面是事件分发的核心逻辑，我把它切分为三个阶段：</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DOWN 会被拦截，后续的 MOVE 和 UP 如果有 touch target 也会被拦截</span><span class="hljs-comment">// Check for interception.</span><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 可以通过 requestDisallowInterceptTouchEvent 跳过此阶段，</span>    <span class="hljs-comment">// 一般是 child 调用 parent.requestDisallowInterceptTouchEvent 来阻止 parent 拦截 touch event</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;        intercepted = onInterceptTouchEvent(ev);        ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span>    &#125; <span class="hljs-keyword">else</span> &#123;        intercepted = <span class="hljs-literal">false</span>;    &#125;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 后续的 MOVE 和 UP 没有 touch target 则直接走向 onTouchEvent 也就不需要拦截了</span>    <span class="hljs-comment">// There are no touch targets and this action is not an initial down</span>    <span class="hljs-comment">// so this view group continues to intercept touches.</span>    intercepted = <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 收到 CANCEL 或者 onInterceptTouchEvent 返回 true，则不分发 DOWN 给 children</span><span class="hljs-comment">// 导致 children 收不到 DOWN 以及没有 touch target</span><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">canceled</span> <span class="hljs-operator">=</span> resetCancelNextUpFlag(<span class="hljs-built_in">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;<span class="hljs-comment">// ...</span><span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;        <span class="hljs-comment">// ... 按顺序分发 ACTION_DOWN，child index(in children array) 越大优先级越高，child z value 越大优先级越高</span>        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedIndex(childrenCount, i, customOrder);            <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedView(preorderedList, children, childIndex);            <span class="hljs-comment">// ... touch 是否落在 child 的矩形区域内</span>            <span class="hljs-keyword">if</span> (!child.canReceivePointerEvents()                || !isTransformedTouchPointInView(x, y, child, <span class="hljs-literal">null</span>)) &#123;                ev.setTargetAccessibilityFocus(<span class="hljs-literal">false</span>);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// ... 将 touch event 坐标转换为 child 区域坐标，分发给 child；当有第一个 child 消费时，记录起来并中断剩下的分发过程</span>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;                <span class="hljs-comment">// ...</span>                newTouchTarget = addTouchTarget(child, idBitsToAssign);                alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果没有 touch target，则走自己的 View.dispatchTouchEvent 流程（相当于流向 onTouchEvent）</span><span class="hljs-comment">// Dispatch to touch targets.</span><span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// No touch targets so treat this as an ordinary view.</span>    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-literal">null</span>, TouchTarget.ALL_POINTER_IDS);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 分发给 touch target</span>    <span class="hljs-comment">// 但如果 onInterceptTouchEvent 返回 true，则发送 CANCEL 给 touch target，后续将不再流向 touch target，而是直接流向 onTouchEvent</span>    <span class="hljs-comment">// onInterceptTouchEvent 拦截的那个 touch 不会流向 onTouchEvent</span>    <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">predecessor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> mFirstTouchTarget;    <span class="hljs-keyword">while</span> (target != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> target.next;        <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;            handled = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelChild</span> <span class="hljs-operator">=</span> resetCancelNextUpFlag(target.child)                    || intercepted;            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,                    target.child, target.pointerIdBits)) &#123;                handled = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (cancelChild) &#123;                <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-literal">null</span>) &#123;                    mFirstTouchTarget = next;                &#125; <span class="hljs-keyword">else</span> &#123;                    predecessor.next = next;                &#125;                target.recycle();                target = next;                <span class="hljs-keyword">continue</span>;            &#125;        &#125;        predecessor = target;        target = next;    &#125;&#125;</code></pre></div><h2 id="总结-dispatchTouchEvent"><a href="#总结-dispatchTouchEvent" class="headerlink" title="总结 dispatchTouchEvent"></a>总结 <code>dispatchTouchEvent</code></h2><ul><li><code>onInterceptTouchEvent</code> 总是会收到 DOWN，但不一定会收到后续的 MOVE 和 UP（没有 touch target 的话，就不需要拦截了，直接走到 <code>onTouchEvent</code> 去了）</li><li>只有在第一个 DOWN 时，才会分发给所有的 children，找到第一个消费的 child（就是 touch target，后续的 MOVE 和 UP 只分发给它）</li><li><code>onInterceptTouchEvent</code> 返回 true 会导致 touch target 置空（并收到 CANCEL），这样后续的 MOVE 和 UP 因为没有 touch target 而直接走向 <code>onTouchEvent</code></li><li>child 通过 <code>requestDisallowInterceptTouchEvent</code> 告知 parent 不要拦截事件流，交由 child 处理</li></ul><h2 id="常见滑动效果的实现"><a href="#常见滑动效果的实现" class="headerlink" title="常见滑动效果的实现"></a>常见滑动效果的实现</h2><p>了解 <code>dispatchTouchEvent</code> 后，我们看看常用的具有滑动效果的 widget 是怎么处理 touch event 的，参考 <code>ViewPager</code> 和 <code>RecyclerView</code>，代码比较多，这里就不贴了，总结下其套路：</p><ul><li>在 <code>onInterceptTouchEvent</code> 和 <code>onTouchEvent</code> 这两个方法里介入</li><li><code>onInterceptTouchEvent</code> 只监听不拦截 DOWN；拦截 DOWN 会导致 children 接收不到 DOWN，那么它们的 OnClick 和 OnLongClick 就无法触发；更复杂的情况是 children 里也包含具有滑动效果的 widget</li><li><code>onTouchEvent</code> 返回 true 做一个兜底方案；万一没有 child 消费 touch（一般情况是没有 <code>OnClickListener</code>），而自己也不消费 touch 的话，就会没有 touch target，后续的 touch event 会直接流向 parent.<code>onTouchEvent</code>，我们想拦截也拦截不了</li><li>在 <code>onInterceptTouchEvent</code> 里监听和拦截（满足情况下）MOVE，<code>onTouchEvent</code> 里也要消费 MOVE（没有 child 消费 touch 的话，后续的 touch 就直接流向 <code>onTouchEvent</code> 了）</li><li><code>ACTION_MOVE</code> 不会直接触发滑动，而是与 <code>ACTION_DOWN</code> 的点有了一定长度的距离后才触发，这个距离叫 touch slop（<code>ViewConfiguration#getScaledTouchSlop</code>），用以消除抖动，使滑动效果更加顺滑</li></ul><p>记住上面的关键点，基本上就可以解决大部分手势冲突，并能够开发稳健的具有手势的 <code>ViewGroup</code> 了；但实际开发中，有一个问题是更加常见的：滑动冲突。在引入嵌套滑动之前，说说为什么 <code>dispatchTouchEvent</code> 很难解决滑动冲突。滑动一般是由 MOVE &gt; touch slop 触发，这样 parent 总是会优先触发而 child 总是会被屏蔽，而且只能由 child 发起 <code>requestDisallowInterceptTouchEvent</code> 告知 parent 不要拦截，从 parent 的视角看，没有其他办法主动得知 child 的需求，而大多数滑动冲突是需要在 parent 里解决的（脑补淘宝、京东这类 app 的首页）。</p><h2 id="引入-NestedScrollingChild-和-NestedScrollingParent-解决滑动冲突"><a href="#引入-NestedScrollingChild-和-NestedScrollingParent-解决滑动冲突" class="headerlink" title="引入 NestedScrollingChild 和 NestedScrollingParent 解决滑动冲突"></a>引入 <code>NestedScrollingChild</code> 和 <code>NestedScrollingParent</code> 解决滑动冲突</h2><p>上面我们在分析 <code>ViewPager</code> 和 <code>RecyclerView</code> 的与滚动相关的代码时了解到，<code>ACTION_MOVE</code> 会产生 scroll 和 fling 的动量 dy（垂直方向），全部由自己消费掉（View.scrollBy）就会产生滑动的效果；而嵌套滑动引入了协商机制，对于动量 dy：</p><ol><li>先给 parent 消费，parent 可以根据自身情况，选择不消费、消费一部分或者消费全部，此时 dy = dy - consumed</li><li>child 根据滋生情况，消费剩下的 dy（全部 or 部分），此时 dy = dy - consumed</li><li>如果还有 dy 剩余（dy &gt; 0），则把剩余的 dy 的处置权交由 parent</li></ol><p>对于上述流程，android 提供了实现：NestedScrollingChildHelper，我们在实现 NestedScrollingChild 时，只需把方法代理至 helper 即可实现通用的 child 逻辑</p><p>具体 api 调用流如下图：</p><p><img src="../../../../image/2020-10-04-dispatchtouchevent/01.jpg" alt="01.jpg"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><p><img src="../../../../image/2020-10-04-dispatchtouchevent/02.jpeg" alt="02.jpeg"></p><p>这里以常见的三段式布局为例子看下嵌套滑动怎么用；上图是淘宝首页，由 head、bar 和 list 三个部分组成，bar 在滑动时会粘连在顶部</p><ol><li>当 touch 落在 list 上时，由 list 产生动量 dy，在 list 消费 dy 前，先给 parent 消费，parent 完全消费 dy，scroll 三个 child 直到 head 不可见</li><li>list 因为 dy 被 parent 消费掉而不产生滑动，直到 head 不可见才有剩下的 dy 用以消费，产生滑动</li><li>当 touch 落在 head 和 bar 上时，由 parent 产生动量 dy；此时 parent 才是 child，而 list 是 parent（明确谁是 child，谁是 parent，view tree 结构上的父子关系不一定是嵌套滑动里的父子关系，动量产生者才是 child，child 主动分发动量）</li><li>parent 先消费 dy 直到 head 不可见，然后分发给 list</li><li>fling 同理</li></ol><h3 id="更复杂的布局"><a href="#更复杂的布局" class="headerlink" title="更复杂的布局"></a>更复杂的布局</h3><p><img src="../../../../image/2020-10-04-dispatchtouchevent/03.jpg" alt="03.jpg"></p><p>结合上述的所有办法，解决更加复杂的页面；上图是糖纸的首页，最外层是 <code>ViewPager</code>，然后是 refresh layout 加上三段式的布局，head 里又有可以左右滑动的 banner 和卡片列表，还有可以上下滑动的滚动资讯条，我们一个个解决：</p><ul><li>banner 是可以左右滑动的，会与 <code>ViewPager</code> 冲突；我的期望是当 touch 落在 banner 上时，左右滑动完全交由 banner 处理，所以给 <code>ViewPager</code> 添加一个 freeze 方法（当 ViewPager is freeze 时不拦截 touch，此时不能使用 <code>requestDisallowInterceptTouchEvent</code> 否则上下滑动被屏蔽）；而上下滑动距离又会引起 refresh 和三段布局的滑动，需在 banner 触发左右滑动时，调用 <code>requestDisallowInterceptTouchEvent</code> 让 parents 不在拦截 touch</li><li>上下滚动的咨询条，同 banner 的处理方式，只不过它只需解决 refresh 和三段布局的上下滑动冲突即可：它自己完全消费动量 dy</li><li>左右滑动的卡片列表同 banner</li><li><code>SwipeRefreshLayout</code> 看下述源码可以看到是由 touch event 和 nested scroll 两种方式触发，touch event 不够灵活屏蔽掉，选用 nested scroll；<code>dispatchNestedPreScroll</code>、<code>dispatchNestedScroll</code>、<code>dispatchNestedPreFling</code> 和 <code>dispatchNestedFling</code> 正常触发，<code>startNestedScroll</code> 则在 scrollY == 0 时触发，这样就只在滚动到顶的时候才触发 refresh。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 显示 loading</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startDragging</span><span class="hljs-params">(<span class="hljs-type">float</span> y)</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">yDiff</span> <span class="hljs-operator">=</span> y - mInitialDownY;    <span class="hljs-keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123;        mInitialMotionY = mInitialDownY + mTouchSlop;        mIsBeingDragged = <span class="hljs-literal">true</span>;        mProgress.setAlpha(STARTING_PROGRESS_ALPHA);    &#125;&#125;<span class="hljs-comment">// 由 touch event 触发 loading</span><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;    pointerIndex = ev.findPointerIndex(mActivePointerId);    <span class="hljs-keyword">if</span> (pointerIndex &lt; <span class="hljs-number">0</span>) &#123;        Log.e(LOG_TAG, <span class="hljs-string">&quot;Got ACTION_MOVE event but have an invalid active pointer id.&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> ev.getY(pointerIndex);    startDragging(y);    <span class="hljs-keyword">if</span> (mIsBeingDragged) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">overscrollTop</span> <span class="hljs-operator">=</span> (y - mInitialMotionY) * DRAG_RATE;        <span class="hljs-keyword">if</span> (overscrollTop &gt; <span class="hljs-number">0</span>) &#123;            moveSpinner(overscrollTop);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">// 由 nested scroll 触发 loading</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View target, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> dxConsumed, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> dyConsumed,</span><span class="hljs-params">                           <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> dxUnconsumed, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> dyUnconsumed)</span> &#123;    <span class="hljs-comment">// Dispatch up to the nested parent first</span>    dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,            mParentOffsetInWindow);    <span class="hljs-comment">// This is a bit of a hack. Nested scrolling works from the bottom up, and as we are</span>    <span class="hljs-comment">// sometimes between two nested scrolling views, we need a way to be able to know when any</span>    <span class="hljs-comment">// nested scrolling parent has stopped handling events. We do that by using the</span>    <span class="hljs-comment">// &#x27;offset in window &#x27;functionality to see if we have been moved from the event.</span>    <span class="hljs-comment">// This is a decent indication of whether we should take over the event stream or not.</span>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> dyUnconsumed + mParentOffsetInWindow[<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span> &amp;&amp; !canChildScrollUp()) &#123;        mTotalUnconsumed += Math.abs(dy);        moveSpinner(mTotalUnconsumed);    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>TouchEvent</tag>
      
      <tag>Motion</tag>
      
      <tag>NestedScrolling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官家常之Handler、MessageQueue 和 Looper</title>
    <link href="/2020/09/27/handler-messagequeue-looper/"/>
    <url>/2020/09/27/handler-messagequeue-looper/</url>
    
    <content type="html"><![CDATA[<p><code>MessageQueue</code> 是个单向链表，按 <code>Message.when</code> 自然序排</p><p>它有类似于「生产者 - 消费者」模型的阻塞队列：没有 <code>Message</code> 时，阻塞直到新 <code>Message</code> 入队；否则阻塞到下一个 <code>Message.when</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这里会阻塞</span>nativePollOnce(ptr, nextPollTimeoutMillis);<span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;    <span class="hljs-comment">// ... ...</span>    <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;            <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>            <span class="hljs-comment">// 阻塞一段时间，直到时间到达下一个 message.when</span>            nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Got a message.</span>            mBlocked = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;                prevMsg.next = msg.next;            &#125; <span class="hljs-keyword">else</span> &#123;                mMessages = msg.next;            &#125;            msg.next = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);            msg.markInUse();            <span class="hljs-keyword">return</span> msg;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// No more messages.</span>        <span class="hljs-comment">// 没有 Message，阻塞直到 enqueueMessage 时被唤醒</span>        nextPollTimeoutMillis = -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// ... ...</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 查看 c 层源码，可以看到 nativePollOnce 是通过 epoll 实现的</span><span class="hljs-comment">// 阻塞</span>MessageQueue.nativePollOnce -&gt;android_os_MessageQueue_nativePollOnce -&gt;NativeMessageQueue::pollOnce -&gt;Looper::pollOnce -&gt;Looper::pollInner -&gt;<span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<span class="hljs-comment">// 唤醒</span>MessageQueue.enqueueMessage -&gt;MessageQueue.nativeWake -&gt;android_os_MessageQueue_nativeWake -&gt;NativeMessageQueue::wake -&gt;Looper::wake -&gt;<span class="hljs-built_in">write</span>(mWakeEventFd.<span class="hljs-built_in">get</span>(), &amp;inc, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint64_t</span>));</code></pre></div><p>与 <code>NativeMessageQueue</code>、<code>NativeLooper</code> 的关系</p><ol><li>每个 <code>MessageQueue</code> 持有一个 <code>NativeMessageQueue</code>，而 <code>NativeMessageQueue</code> 又持有当前线程的 <code>NativeLooper</code></li><li>关键的阻塞和唤醒函数都是由 <code>NativeLooper</code> 实现的，也就是 <code>epoll</code> 实现的阻塞和唤醒；只不过这个线程在 <code>native</code> 层进行 loop poll 操作<ul><li><code>MessageQueue.nativePollOnce</code> → <code>NativeMessageQueue.pollOnce</code> → <code>NativeLooper.pollOnce</code></li><li><code>MessageQueue.nativeWake</code> → <code>NativeMessageQueue.wake</code> → <code>NativeLooper.wake</code></li></ul></li></ol><p>同步栅栏（<code>SyncBarrier</code>）</p><p>开启同步栅栏后，“栅栏”将会把 sync message 过滤掉，仅处理 async message，是一种提高 <code>Message</code> 优先级的方法</p><p><code>postSyncBarrier</code> 开启同步栅栏，<code>removeSyncBarrier</code> 关闭同步栅栏，“栅栏”就是一个 target == null 的 <code>Message</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;    <span class="hljs-comment">// head of linked list</span><span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// it is a barrier</span>    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>    <span class="hljs-keyword">do</span> &#123;        prevMsg = msg;        msg = msg.next;    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());&#125;</code></pre></div><p>主线程 <code>Looper</code> 与子线程 <code>Looper</code> 有什么不同？</p><p>主要区别在于 main looper <code>queue.mQuitAllowed == false</code>，即不允许 <code>looper.quit</code> 退出</p><p><code>Looper.quit()</code> 和 <code>Looper.quitSafely()</code> 有什么区别？</p><p><code>quit</code> 直接回收所有 message；而 <code>quitSafely</code> 则只回收 future message（还未到执行时间），继续执行完所有已到时间的 message 才结束</p><p>既然可以存在多个 <code>Handler</code> 往 <code>MessageQueue</code> 中添加数据（发消息时各个 <code>Handler</code> 可能处于不同线程），那它内部是如何确保线程安全的？</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 加了锁</span><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;    <span class="hljs-comment">// ... ...</span>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;        <span class="hljs-comment">// ... ...</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p><code>Looper.loop()</code> 为什么不会导致死循环？</p><p>queue 是个阻塞队列，（当前时间点）没有 message 时，会阻塞 thread 而不消耗 cpu；当有新 message 入队时，会唤醒 thread；参考上面阻塞和唤醒的代码片段</p><p><code>Handler </code>造成泄露的原因</p><p>非静态内部类会持有一个外部类的隐式引用，比如下述写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;&#125;&#125;;handler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;&#125;&#125;);</code></pre></div><p>那么我们可以追溯出一条完整的 gc root path：</p><p>activity → handler/runnable → message(target/callback) → queue → looper → class looper(static field sThreadLocal) → thread</p><p>解决办法：使用 <code>WeakReference</code></p><p>tip:</p><p>可以在 <a href="https://cs.android.com/android">https://cs.android.com/android</a> 用类名、方法名等 symbol 搜索 aosp 代码，简单方便；各种 symbol 之间还有关联，可以点击跳转</p>]]></content>
    
    
    
    <tags>
      
      <tag>Looper</tag>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git log命令全解析，打log还能这么随心所欲！</title>
    <link href="/2020/09/15/git-log/"/>
    <url>/2020/09/15/git-log/</url>
    
    <content type="html"><![CDATA[<p><code>git log</code> 命令非常强大而好用，在复杂系统的版本管理中扮演着重要的角色，但默认的 <code>git log</code> 命令显示出的东西实在太丑，不好好打扮一下根本没法见人，打扮好了用 <code>alias</code> 命令拍个照片，就正式出道了！</p><p>下面先详细而系统地介绍 <code>git log</code> 的所有配置知识（用我一向简洁清晰的表述方式），熟悉了这些东西，你就可以自由配置自己美丽的 <code>git log</code> 了～<br>最后上个干货，直接给一个我打扮好的 <code>alias</code> 配置，懒人直接跳到最后吧 ！</p><p><code>git log</code> 用于查询版本的历史，命令形式如下：<code>git log [&lt;options&gt;] [&lt;since&gt;..&lt;until&gt;] [[--] &lt;path&gt;...]</code></p><h2 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h2><ul><li>如果不带任何参数，它会列出所有历史记录，最近的排在最上方，显示提交对象的哈希值，作者、提交日期、和提交说明</li><li>如果记录过多，则按Page Up、Page Down、↓、↑来控制显示</li><li>按q退出历史记录列表</li></ul><h2 id="显示参数"><a href="#显示参数" class="headerlink" title="显示参数"></a>显示参数</h2><ul><li><code>p</code>：按补丁显示每个更新间的差异，比下一条 <code>-stat</code> 命令信息更全</li><li><code>-stat</code>：显示每次更新的修改文件的统计信息，每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计</li><li><code>-shortstat</code>：只显示 <code>-stat</code> 中最后的行数添加修改删除统计</li><li><code>-name-only</code>：尽在已修改的提交信息后显示文件清单</li><li><code>-name-status</code>：显示新增、修改和删除的文件清单</li><li><code>-abbrev-commit</code>：仅显示SHA-1的前几个字符，而非所有的40个字符</li><li><code>-relative-date</code>：使用较短的相对时间显示（例如：”two weeks ago”）</li><li><code>-graph</code>：显示 ASCII 图形表示的分支合并历史</li><li><code>-pretty＝</code>：使用其他格式显示历史提交信息，可选项有：<code>oneline</code>, <code>short</code>, <code>medium</code>, <code>full</code>, <code>fuller</code>, <code>email</code>, <code>raw</code> 以及 <code>format</code>，默认为 <code>medium</code>，如：<ul><li><code>-pretty=oneline</code>：一行显示，只显示哈希值和提交说明（<code>--online</code> 本身也可以作为单独的属性）</li><li><code>-pretty=format:</code>：控制显示的记录格式，如：<ul><li><code>%H</code> 提交对象（commit）的完整哈希字串</li><li><code>%h</code> 提交对象的简短哈希字串</li><li><code>%T</code> 树对象（tree）的完整哈希字串</li><li><code>%t</code> 树对象的简短哈希字串</li><li><code>%P</code> 父对象（parent）的完整哈希字串</li><li><code>%p</code> 父对象的简短哈希字串</li><li><code>%an</code> 作者（author）的名字</li><li><code>%ae</code> 作者的电子邮件地址</li><li><code>%ad</code> 作者修订日期（可以用 -date= 选项定制格式）</li><li><code>%ar</code> 作者修订日期，按多久以前的方式显示</li><li><code>%cn</code> 提交者(committer)的名字<ul><li>作者和提交者的区别不知道是啥？</li><li>作者与提交者的关系：作者是程序的修改者，提交者是代码提交人（自己的修改不提交是怎么能让别人拉下来再提交的？）</li><li>其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者（soga）</li></ul></li><li><code>%ce</code> 提交者的电子邮件地址</li><li><code>%cd</code> 提交日期（可以用 <code>-date=</code> 选项定制格式）</li><li><code>%cr</code> 提交日期，按多久以前的方式显示</li><li><code>%s</code> 提交说明</li></ul></li><li>带颜色的 <code>--pretty=format:</code>，这个另外写出来分析；以这句为例：<code>%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;</code>，它的效果是 <img src="../../../../image/2020-09-15-git-log/1.png" alt="1.png">；先断句：[<code>%Cred%h</code>]，[<code>%Creset -</code>]，[<code>%C(yellow)%d</code>]，[<code>%Cblue%s</code>]，[<code>%Cgreen(%cd)</code>]，[<code>%C(bold blue)&lt;%an&gt;</code>]；然后就是很明显能得到的规律了：一个颜色＋一个内容，颜色以 <code>％C</code> 开头，后边接几种颜色，还可以设置字体，如果要设置字体的话，要一块加个括号，能设置的颜色值包括：<code>reset</code>（默认的灰色），<code>normal</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code>。字体属性则有 <code>bold</code>, <code>dim</code>, <code>ul</code>, <code>blink</code>, <code>reverse</code>；内容可以是占位元字符，也可以是直接显示的普通字符。</li></ul></li><li><code>-date=(relative|local|default|iso|rfc|short|raw)</code>：定制后边如果出现 <code>%ad</code> 或 <code>%cd</code> 时的日期格式<ul><li>有几个默认选项<ol><li><code>-date=relative</code>：shows dates relative to the current time, e.g. “2 hours ago”.</li><li><code>-date=local</code>：shows timestamps in user’s local timezone.</li><li><code>-date=iso</code> (or <code>--date=iso8601</code>)：shows timestamps in ISO 8601 format.</li><li><code>-date=rfc</code> (or <code>--date=rfc2822</code>)：shows timestamps in RFC 2822 format,often found in E-mail messages.</li><li><code>-date=short</code>：shows only date but not time, in YYYY-MM-DD format.这个挺好用</li><li><code>-date=raw</code>：shows the date in the internal raw git format %s %z format.</li><li><code>-date=default</code>：shows timestamps in the original timezone (either committer’s or author’s).</li></ol></li><li>也可以自定义格式（需要git版本2.6.0以上），比如 <code>--date=format:&#39;%Y-%m-%d %H:%M:%S&#39;</code> 会格式化成：2016-01-13 11:32:13，其他的格式化占位符如下：<ol><li><code>%a</code>：Abbreviated weekday name</li><li><code>%A</code>：Full weekday name</li><li><code>%b</code>：Abbreviated month name</li><li><code>%B</code>：Full month name</li><li><code>%c</code>：Date and time representation appropriate for locale</li><li><code>%d</code>：Day of month as decimal number (01 – 31)</li><li><code>%H</code>： Hour in 24-hour format (00 – 23)</li><li><code>%I</code>：Hour in 12-hour format (01 – 12)</li><li><code>%j</code>：Day of year as decimal number (001 – 366)</li><li><code>%m</code>：Month as decimal number (01 – 12)</li><li><code>%M</code>：Minute as decimal number (00 – 59)</li><li><code>%p</code>：Current locale’s A.M./P.M. indicator for 12-hour clock</li><li><code>%S</code>：Second as decimal number (00 – 59)</li><li><code>%U</code>：Week of year as decimal number, with Sunday as first day of week (00 – 53)</li><li><code>%w</code>：Weekday as decimal number (0 – 6; Sunday is 0)</li><li><code>%W</code>：Week of year as decimal number, with Monday as first day of week (00 – 53)</li><li><code>%x</code>：Date representation for current locale</li><li><code>%X</code>：Time representation for current locale</li><li><code>%y</code>：Year without century, as decimal number (00 – 99)</li><li><code>%Y</code>：Year with century, as decimal number</li><li><code>%z</code>, <code>%Z</code>：Either the time-zone name or time zone abbreviation, depending on registry settings; no characters if time zone is unknown</li><li><code>%%</code>：Percent sign</li></ol></li></ul></li></ul><h2 id="筛选参数"><a href="#筛选参数" class="headerlink" title="筛选参数"></a>筛选参数</h2><ol><li>按数量<ol><li>n：显示前n条log</li></ol></li><li>按日期<ol><li><code>-after=</code><ol><li>比如 <code>git log --after=&quot;2014-7-1”</code>，显示2014年7月1号之后的commit(包含7月1号)</li><li>后边的日期还可以用相对时间表示，比如”1 week ago”和”yesterday”，比如 <code>git log --after=&quot;yesterday&quot;</code></li><li>这里的格式可以是什么？</li></ol></li><li><code>-before=</code><ol><li>同上</li><li>另外这两条命令可以同时使用表示时间段，比如 <code>git log --after=&quot;2014-7-1&quot; --before=&quot;2014-7-4&quot;</code></li><li>另外 <code>--since</code> <code>--until</code> 和 <code>--after`` --before</code> 是一个意思，都可以用</li></ol></li></ol></li><li>按作者<ol><li><code>-author=</code><ol><li>比如 <code>git log --author=“John&quot;</code>，显示John贡献的commit</li><li>注意：作者名不需要精确匹配，只需要包含就行了</li><li>而且：可以使用正则表达式，比如 <code>git log --author=&quot;John\|Mary”</code>，搜索Marry和John贡献的commit</li><li>而且：这个 <code>--author</code> 不仅包含名还包含email, 所以你可以用这个搜索email</li></ol></li></ol></li><li>按commit描述<ol><li><code>-grep=</code><ol><li>比如：<code>git log --grep=&quot;JRA-224&quot;</code></li><li>而且：可以传入-i用来忽略大小写</li><li>注意：如果想同时使用 <code>--grep</code> 和 <code>--author</code>，必须在附加一个 <code>--all-match</code> 参数</li></ol></li></ol></li><li>按文件<ol><li>（空格）或［没有］<ol><li>有时你可能只对某个文件的修改感兴趣, 你只想查看跟某个文件相关的历史信息, 你只需要插入你感兴趣文件的路径［对，是路径，所以经常是不太好用］就可以了</li><li>比如：<code>git log -- foo.py bar.py</code>，只返回和 foo.py 或 bar.py 相关的 commit</li><li>这里的–是告诉 Git 后面的参数是文件路径而不是 branch name. 如果后面的文件路径不会和某个 branch 产生混淆, 你可以省略 <code>--</code>，比如 <code>git log foo.py</code></li><li>另外，后边的路径还支持正则，比如：<code>git log *install.md</code> 是，指定项目路径下的所有以 install.md 结尾的文件的提交历史</li><li>另外，文件名应该放到参数的最后位置，通常在前面加上 <code>--</code> 并用空格隔开表示是文件</li><li>另外，<code>git log file/</code> 查看 file 文件夹下所有文件的提交记录</li></ol></li></ol></li><li>按分支<ol><li><ol><li><code>-branchName</code> branchName为任意一个分支名字，查看某个分支上的提交记录</li><li>需要放到参数中的最后位置处</li><li>如果分支名与文件名相同，系统会提示错 误，可通过–选项来指定给定的参数是分支名还是文件名<ol><li>比如：在当前分支中有一个名为v1的文件，同时还存在一个名为v1的分支</li><li><code>git log v1 --</code> 此时的v1代表的是分支名字（－－后边是空的）</li><li><code>git log -- v1</code> 此时的v1代表的是名为v1的文件</li><li><code>git log v1 －－ v1</code> 代表v1分支下的v1文件</li></ol></li></ol></li></ol></li><li>按内容<ol><li><code>-S&quot;&lt;&gt;&quot;</code>、<code>-G&quot;&lt;&gt;&quot;</code><ol><li>有时你想搜索和新增或删除某行代码相关的commit. 可以使用这条命令</li><li>假设你想知道Hello, World!这句话是什么时候加入到项目里去的，可以用：<code>git log -S&quot;Hello,World!&quot;</code></li><li>另外：如果你想使用正则表达式去匹配而不是字符串, 那么你可以使用-G代替-S.</li><li>这是一个非常有用的debug工具, 使用他你可以定位所有跟某行代码相关的commit. 甚至可以查看某行是什么时候被copy的, 什么时候移到另外一个文件中去的</li><li>注：-S后没有”=”，与查询内容之间也没有空格符</li></ol></li></ol></li><li>按范围<ol><li><code>git log &lt;since&gt;..&lt;until&gt;</code><ol><li>这个命令可以查看某个范围的commit</li><li>这个命令非常有用当你使用branch做为range参数的时候. 能很方便的显示2个branch之间的不同</li><li>比如：<code>git log master..feature</code>，<code>master..feature</code> 这个range包含了在feature有而在master没有的所有commit，同样，如果是feature..master包含所有master有但是feature没有的commit</li><li>另外，如果是三个点，表示或的意思：<code>git log master...test</code> 查询master或test分支中的提交记录</li></ol></li></ol></li><li>过滤掉 merge commit<ol><li><code>-no-merges</code><ol><li>默认情况下 <code>git log</code> 会输出 merge commit. 你可以通过 <code>--no-merges</code> 标记来过滤掉 merge commit，<code>git log --no-merges</code></li><li>另外，如果你只对 merge commit 感兴趣可以使用 <code>—merges</code>，<code>git log --merges</code></li></ol></li></ol></li><li>按标签tag<ol><li><code>git log v1.0</code><ol><li>直接这样是查询标签之前的commit</li><li>加两个点 <code>git log v1.0..</code> 查询从v1.0以后的提交历史记录(不包含v1.0)</li></ol></li></ol></li><li>按commit<ol><li><code>git log commit</code> ：查询commit之前的记录，包含commit</li><li><code>git log commit1 commit2</code>：查询commit1与commit2之间的记录，包括commit1和commit2</li><li><code>git log commit1..commit2</code>：同上，但是不包括commit1<ol><li>其中，commit可以是提交哈希值的简写模式，也可以使用HEAD代替<ol><li>HEAD代表最后一次提交，HEAD^为最后一个提交的父提交，等同于HEAD～1</li><li>HEAD～2代表倒数第二次提交</li></ol></li></ol></li></ol></li></ol><h2 id="最后干货，你会喜欢的"><a href="#最后干货，你会喜欢的" class="headerlink" title="最后干货，你会喜欢的~"></a>最后干货，你会喜欢的~</h2><p>下面第一条的效果是这样：<br><img src="../../../../image/2020-09-15-git-log/2.png" alt="2.png"></p><div class="code-wrapper"><pre><code class="hljs bash">git config --global alias.lm  <span class="hljs-string">&quot;log --no-merges --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;你的名字！自己修改！&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span>git config --global alias.lms  <span class="hljs-string">&quot;log --no-merges --color --stat --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;你的名字！自己修改！&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span>git config --global [alias.ls](http://alias.ls/) <span class="hljs-string">&quot;log --no-merges --color --graph --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span>git config --global alias.lss <span class="hljs-string">&quot;log --no-merges --color --stat --graph --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/bellkosmos/p/5923439.html">git log命令全解析，打log还能这么随心所欲！</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 的 merge, rebase 和 squash</title>
    <link href="/2020/09/05/merge-rebase-squash/"/>
    <url>/2020/09/05/merge-rebase-squash/</url>
    
    <content type="html"><![CDATA[<p>在团队合作中，毫无疑问，我们需要一个版本管理工具，相对于 SVN 这种在我们看来是老古董的工具，Git 在年轻化的团队中更受欢迎。并不仅仅是跟着大神们（Linux系）的路子在走，所以感觉很牛逼，而是 Git 真的很牛逼，当然，牛逼的同时你需要的学习曲线也是很陡的。<br>这几天我就遇到了一个问题，其实也不是遇到问题，而是遇到了疑惑，那就是我在 github 系统中 <code>merge</code> 同时的 PR 的时候发现有好几个选项，但是，却说不清楚这几个选项分别代表什么含义，所以就稍微花了点时间了解了下，顺带做个总结。<br>在 merge pr 的时候，默认是有三种选项的，分别是</p><ul><li>普通的 merge</li><li>rebase merge</li><li>squash merge</li></ul><p>这其实对应于我们在合并分支的时候的几种方式，所以我就以本地分支的形式来说说有啥区别。</p><p>假设我们一开始的 <code>master</code> 分支上已经有了几个提交，就像这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/00.png" alt="00.png"></p><p>然后，我们切出一条开发的分支，进行了一些 Feature 的开发，然后我们的分支可能就是这种情况：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/01.png" alt="01.png"></p><p>这种情况还好，也比较常遇到，但是，现在问题来了，如果在这个时候 <code>master</code> 有了一些新提交（可能是其他分支合并进来的），那么这个时候情形就成了这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/02.png" alt="02.png"></p><p>这个情况很有趣，但是我们不讨论，因为这和我们今天的主题无关，以后可以另外开一个话题来说，今天要说的是第二个情况。<br>说到合并分支，可能我们最熟悉的操作是这样的：</p><ol><li>先切换到目标分支（<code>master</code>）</li><li>执行命令： <code>git merge devel</code></li><li>删除旧分支（可以在上面一同做）： <code>git branch -D devel</code></li><li>提交到远程分支： <code>git push origin master</code></li></ol><p>好像这样没啥问题的样子，但是这样操作之后，你知道结果是怎么样吗？假设合并之前的这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/03.png" alt="03.png"></p><p>我们这么一番操作之后，那么最后我们的分支的历史将会是这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/04.png" alt="04.png"></p><p>是的，看上去很不错，也是一条直直的 commit line，我们在 <code>devel</code> 分支中的 commit 也是一个不差得保留在了 <code>master</code> 中。但是，很多时候，我们并不需要那么多的 commit，假设你给一个开源项目提交一个 Bug Fixes，然后一个简单的修改因为你的粗心大意 pr 了十几个 commit 过去，如果作者给你 <code>merge</code> 了，这就在这个项目的历史长河中增加了十几个 commit 啊，以后的人看 commit history 估计都崩溃了吧；同时，对于你自己管理的项目来说，当你 <code>merge</code> 之后发现有问题，想回滚都蛋疼！</p><p>在使用 git 的过程中，可能你遇到过想要合并多个 commit 为一个，然后很多人会告诉你用 <code>git commit --amend</code>，然后你发现里面有你的多个 commit 历史，你可以通过 <code>pick</code> 选择，<code>squash</code> 合并等等。同样得，<code>merge</code> 的时候也可以这么干，你只需要这么简单的两步：</p><ol><li>切换到目标分支： <code>git checkout master</code></li><li>以 squash 的形式 merge： <code>git merge --squash devel</code></li></ol><p>你会发现，在 <code>master</code> 分支上居然有未提交的修改，然后你就需要在 <code>master</code> 上主动提交了修改，注意，这里是你 commit 的，也就是改变了 commit 的 <code>author</code>。结果是这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/05.png" alt="05.png"></p><p>这里好了，比前面普通的 <code>merge</code> 来说，我们只有一个 commit 了，不管在分支中 commit 了多少，这里都只有一个！</p><p>但是，作为处女座的程序员肯定是不能忍受目前的情况的，因为我们既想合并 commits，又想保留作者的信息，那么有没有什么好办法呢？肯定是有的啦，这个时候我们可以尝试一下 <code>rebase</code>，操作步骤是这样的：</p><ol><li>先切换到 <code>devel</code> 分支（不一样咯）： <code>git checkout devel</code></li><li>变基： <code>git rebase -i master</code></li><li>切换回目标分支： <code>git checkout master</code></li><li>合并: <code>git merge devel</code></li></ol><p>这里完成了第二步之后我想你应该大概知道发生了什么事了，我们在 <code>devel</code> 里面对照 <code>master</code> 进行了变基，所谓的变基其实就是找到两个分支共同的祖先，然后在当前分支上合并从共同祖先到现在的所有 commit，所以我们在第二步的时候会选择怎么处理这些 commit，然后我们就得到了一个从公共 commit 到现在的单个 commit，这个时候别人讲我们这个 commit 合并到 <code>master</code> 也只会在 <code>master</code> 上留下一个 commit 记录，就像这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/06.png" alt="06.png"></p><p>虽然这个 commit history 线看上去很不错，而且也比较符合实际情况，但是我们需要注意到的有点就是分支上的开发者需要自己执行变基操作，从而导致他的原始 commit history 变化了（可以理解成被合并了）。</p><p>相比一下前面三种方式，我们可以总结出一些东西：</p><ol><li><code>rebase</code> 可以尽可能保持 <code>master</code> 分支干净整洁，并且易于识别 <code>author</code></li><li><code>squash</code> 也可以保持 <code>master</code> 分支干净，但是 <code>master</code> 中 <code>author</code> 都是 <code>maintainer</code>，而不是原 <code>owner</code></li><li><code>merge</code> 不能保持 <code>master</code> 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好</li></ol><p>参考</p><ol><li><a href="https://liqiang.io/post/difference-between-merge-squash-and-rebase">merge squash 和 merge rebase 区别</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[@font-face {    font-family: "LXGW WenKai";    font-style: normal;    font-weight: 400;    font-display: swap;    src: local("LXGW WenKai"),         url("/fonts/wenkai/LXGWWenKai-Regular.woff2") format("woff2");}@font-face {    font-family: "LXGW WenKai";    font-style: normal;    font-weight: 700;    font-display: swap;    src: local("LXGW WenKai Bold"),         url("/fonts/wenkai/LXGWWenKai-Bold.woff2") format("woff2");}@font-face {    font-family: "LXGW WenKai";    font-style: normal;    font-weight: 300;    font-display: swap;    src: local("LXGW WenKai Light"),         url("/fonts/wenkai/LXGWWenKai-Light.woff2") format("woff2");}code {    color: #91cb3e;}[data-user-color-scheme='dark'] .markdown-body :not(pre) > code {    background-color: transparent;}.post-content {    padding-left: 3%;    padding-right: 3%;}.markdown-body {    line-height: 1.6;}.markdown-body code {    font-size: 100% !important;}blockquote p {    margin-bottom: 0px !important;}]]></content>
    
  </entry>
  
  
  
</search>
