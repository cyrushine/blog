

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/favicon.png">
  <link rel="icon" href="/image/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#141414">
  <meta name="author" content="Cyrus">
  <meta name="keywords" content="">
  
    <meta name="description" content="捕获掉帧&#x2F;卡顿什么是掉帧&#x2F;卡顿 什么是卡顿，很多人能马上联系到的是帧率 FPS (每秒显示帧数)。那么多低的 FPS 才是卡顿呢？又或者低 FPS 真的就是卡顿吗？（以下 FPS 默认指平均帧率） 其实并非如此，举个例子，游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上，但我们平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得">
<meta property="og:type" content="article">
<meta property="og:title" content="Matrix - TraceCanary 浅析">
<meta property="og:url" content="https://www.dalvik.work/2021/04/26/matrix-tracecanary/index.html">
<meta property="og:site_name" content="Cyrus Blog">
<meta property="og:description" content="捕获掉帧&#x2F;卡顿什么是掉帧&#x2F;卡顿 什么是卡顿，很多人能马上联系到的是帧率 FPS (每秒显示帧数)。那么多低的 FPS 才是卡顿呢？又或者低 FPS 真的就是卡顿吗？（以下 FPS 默认指平均帧率） 其实并非如此，举个例子，游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上，但我们平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dalvik.work/image/2021-04-26-matrix-tracecanary/fps_board.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2021-04-26-matrix-tracecanary/build.png">
<meta property="og:image" content="https://www.dalvik.work/image/2021-04-26-matrix-tracecanary/run_store.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2021-04-26-matrix-tracecanary/stack.jpg">
<meta property="article:published_time" content="2021-04-26T04:00:00.000Z">
<meta property="article:modified_time" content="2023-01-03T11:48:08.760Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="APM">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.dalvik.work/image/2021-04-26-matrix-tracecanary/fps_board.jpg">
  
  
  
  <title>Matrix - TraceCanary 浅析 - Cyrus Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.dalvik.work","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#91cb3e","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":99},"lazyload":{"enable":true,"loading_img":"/image/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"7d0c9146781b5fb9ae68cfc826d0be54","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cyrus Land</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/sunset_sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Matrix - TraceCanary 浅析</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-04-26 04:00" pubdate>
          2021年4月26日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          46k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          382 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Matrix - TraceCanary 浅析</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="捕获掉帧-卡顿"><a href="#捕获掉帧-卡顿" class="headerlink" title="捕获掉帧/卡顿"></a>捕获掉帧/卡顿</h2><h3 id="什么是掉帧-卡顿"><a href="#什么是掉帧-卡顿" class="headerlink" title="什么是掉帧/卡顿"></a>什么是掉帧/卡顿</h3><blockquote>
<p>什么是卡顿，很多人能马上联系到的是帧率 FPS (每秒显示帧数)。那么多低的 FPS 才是卡顿呢？又或者低 FPS 真的就是卡顿吗？（以下 FPS 默认指平均帧率）</p>
<p>其实并非如此，举个例子，游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上，但我们平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得卡顿。 在人眼结构上看，当一组动作在 1 秒内有 12 次变化（即 12FPS），我们会认为这组动作是连贯的；而当大于 60FPS 时，人眼很难区分出来明显的变化，所以 60FPS 也一直作为业界衡量一个界面流畅程度的重要指标。一个稳定在 30FPS 的动画，我们不会认为是卡顿的，但一旦 FPS 很不稳定，人眼往往容易感知到。</p>
<p>FPS 低并不意味着卡顿发生，而卡顿发生 FPS 一定不高。 FPS 可以衡量一个界面的流程性，但往往不能很直观的衡量卡顿的发生，这里有另一个指标（掉帧程度）可以更直观地衡量卡顿。</p>
<p>什么是掉帧（跳帧）？ 按照理想帧率 60FPS 这个指标，计算出平均每一帧的准备时间有 1000ms/60 = 16.6667ms，如果一帧的准备时间超出这个值，则认为发生掉帧，超出的时间越长，掉帧程度越严重。假设每帧准备时间约 32ms，每次只掉一帧，那么 1 秒内实际只刷新 30 帧，即平均帧率只有 30FPS，但这时往往不会觉得是卡顿。反而如果出现某次严重掉帧（&gt;300ms），那么这一次的变化，通常很容易感知到。所以界面的掉帧程度，往往可以更直观的反映出卡顿。</p>
</blockquote>
<p>造成 <strong>掉帧</strong> 的直接原因通常是 <code>doFrame</code> 过于繁重执行超时，或者其他任务挤压了 <code>doFrame</code> 的执行时间，这些都会造成主线程不能在 <strong>帧间隔时间</strong> 内完成 ui 绘制</p>
<h3 id="计算-Message-耗时"><a href="#计算-Message-耗时" class="headerlink" title="计算 Message 耗时"></a>计算 <code>Message</code> 耗时</h3><p>我们知道主线程是「生产者 - 消费者」模型，任务（<code>Message</code>）都在消息队列（<code>MessageQueue</code>）里排队等待执行，如果能够度量出每个 <code>Message</code> 的耗时，然后与某个阈值进行比较，我们就能找出耗时任务做进一步的优化</p>
<p>从下面的代码可以看到，<code>Message</code> 执行前后都会有特定格式的日志输出，只要捕获这些日志，就能计算出每个 <code>Message</code> 的耗时</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Looper.loop() &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">for</span> (;;) &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;
        <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;
            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +
                    msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);
        &#125;
        <span class="hljs-comment">// ...</span>
        msg.target.dispatchMessage(msg);
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;
            logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<p><code>LooperMonitor</code> 通过替换 <code>Looper.mLogging</code>，从而捕获到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code> 和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 的日志输出进而算出 <code>Message</code> 耗时，并提供 <code>dispatchStart</code> 和 <code>dispatchEnd</code> 两个钩子</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperMonitor</span> &#123;
    <span class="hljs-comment">// 通过反射替换 Looper.mLogging</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetPrinter</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">Printer</span> <span class="hljs-variable">originPrinter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (!isReflectLoggingError) &#123;
                originPrinter = ReflectUtils.get(looper.getClass(), <span class="hljs-string">&quot;mLogging&quot;</span>, looper);
                <span class="hljs-keyword">if</span> (originPrinter == printer &amp;&amp; <span class="hljs-literal">null</span> != printer) &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            isReflectLoggingError = <span class="hljs-literal">true</span>;
            Log.e(TAG, <span class="hljs-string">&quot;[resetPrinter] %s&quot;</span>, e);
        &#125;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != printer) &#123;
            MatrixLog.w(TAG, <span class="hljs-string">&quot;maybe thread:%s printer[%s] was replace other[%s]!&quot;</span>,
                    looper.getThread().getName(), printer, originPrinter);
        &#125;
        looper.setMessageLogging(printer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LooperPrinter</span>(originPrinter));
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != originPrinter) &#123;
            MatrixLog.i(TAG, <span class="hljs-string">&quot;reset printer, originPrinter[%s] in %s&quot;</span>, originPrinter, looper.getThread().getName());
        &#125;
    &#125;

    <span class="hljs-comment">// 捕获根据特定格式的日志输出</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printer</span> &#123;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(String x)</span> &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != origin) &#123;
                origin.println(x);
                <span class="hljs-keyword">if</span> (origin == <span class="hljs-built_in">this</span>) &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(TAG + <span class="hljs-string">&quot; origin == this&quot;</span>);
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (!isHasChecked) &#123;
                isValid = x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span> || x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&lt;&#x27;</span>;
                isHasChecked = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (!isValid) &#123;
                    MatrixLog.e(TAG, <span class="hljs-string">&quot;[println] Printer is inValid! x:%s&quot;</span>, x);
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (isValid) &#123;
                dispatch(x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span>, x);
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">// 分发 Dispatching to 和 Finished to 事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isBegin, String log)</span> &#123;
        <span class="hljs-keyword">for</span> (LooperDispatchListener listener : listeners) &#123;
            <span class="hljs-keyword">if</span> (listener.isValid()) &#123;
                <span class="hljs-keyword">if</span> (isBegin) &#123;
                    <span class="hljs-keyword">if</span> (!listener.isHasDispatchStart) &#123;
                        listener.onDispatchStart(log);
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">if</span> (listener.isHasDispatchStart) &#123;
                        listener.onDispatchEnd(log);
                    &#125;
                &#125;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isBegin &amp;&amp; listener.isHasDispatchStart) &#123;
                listener.dispatchEnd();
            &#125;
        &#125;
    &#125;    
&#125;</code></pre></div>

<p>为了防止其他代码也替换 <code>Looper.mLogging</code>，<code>LooperMonitor</code> 还在主线程空闲的时候进行检查</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> LooperMonitor.queueIdle() &#123;
    <span class="hljs-keyword">if</span> (SystemClock.uptimeMillis() - lastCheckPrinterTime &gt;= CHECK_TIME) &#123;
        resetPrinter();
        lastCheckPrinterTime = SystemClock.uptimeMillis();
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div>

<h3 id="计算-doFrame-耗时"><a href="#计算-doFrame-耗时" class="headerlink" title="计算 doFrame 耗时"></a>计算 <code>doFrame</code> 耗时</h3><p>上面的方法可以统计主线程里每个 <code>Message</code> 的耗时，但并不是每个 <code>Message</code> 都在做 ui 绘制（<code>doFrame</code>），比如违规放入耗时的 IO 操作；为了更精确地捕获耗时的 <code>doFrame</code>，以及进行 FPS 统计，还需做更多的工作</p>
<p>参考 <a href="../../../../2020/12/02/vsync/">Android 图形栈（一）vsync</a> 我们知道，当 <code>APP_VSYNC</code> 到达时会走 <code>FrameDisplayEventReceiver.onVsync</code> -&gt; <code>Choreographer.doFrame</code> -&gt; <code>Choreographer.doCallbacks</code>，最后按 INPUT - ANIMATION - TRAVERSAL 的顺序执行 <code>Choreographer.mCallbackQueues</code> 里的 <code>Runnable</code></p>
<p>动态地往这三个队列的头部插入钩子，从而计算出每个阶段开始时间和结束时间，加上捕获 <code>Message</code> 的方法（<code>Choreographer.doFrame</code> 是由 <code>FrameDisplayEventReceiver.onVsync</code> 放入主线程任务队列的 <code>Message</code>），最终形成完整的闭环：</p>
<p><code>dispatchBegin</code> -&gt; <code>doFrameBegin</code> -&gt; <code>doQueueBegin(INPUT)</code> -&gt; <code>doQueueEnd(INPUT)</code> -&gt; <code>doQueueBegin(ANIMATION)</code> -&gt; <code>doQueueEnd(ANIMATION)</code> -&gt; <code>doQueueBegin(TRAVERSAL)</code> -&gt; <code>doQueueEnd(TRAVERSAL)</code> -&gt; <code>doFrameEnd</code> -&gt; <code>dispatchEnd</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIThreadMonitor</span> &#123;
    <span class="hljs-comment">// 最开始先在 INPUT 头部插入钩子</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> UIThreadMonitor.onStart() &#123;
        <span class="hljs-comment">// ...</span>
        queueStatus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];
        queueCost = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];
        addFrameCallback(CALLBACK_INPUT, <span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);
    &#125;

    <span class="hljs-comment">// 依次往 ANIMATION/TRAVERSAL 插入钩子</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();
        <span class="hljs-keyword">try</span> &#123;
            doFrameBegin(token);
            doQueueBegin(CALLBACK_INPUT);
            addFrameCallback(CALLBACK_ANIMATION, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
                    doQueueEnd(CALLBACK_INPUT);
                    doQueueBegin(CALLBACK_ANIMATION);
                &#125;
            &#125;, <span class="hljs-literal">true</span>);
            addFrameCallback(CALLBACK_TRAVERSAL, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
                    doQueueEnd(CALLBACK_ANIMATION);
                    doQueueBegin(CALLBACK_TRAVERSAL);
                &#125;
            &#125;, <span class="hljs-literal">true</span>);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;
                MatrixLog.d(TAG, <span class="hljs-string">&quot;[UIThreadMonitor#run] inner cost:%sns&quot;</span>, System.nanoTime() - start);
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">// 主线程消息队列的任务结束钩子，也作为 TRAVERSAL 的结束标志</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">startNs</span> <span class="hljs-operator">=</span> token;
        <span class="hljs-type">long</span> <span class="hljs-variable">intendedFrameTimeNs</span> <span class="hljs-operator">=</span> startNs;
        <span class="hljs-keyword">if</span> (isVsyncFrame) &#123;
            doFrameEnd(token);
            intendedFrameTimeNs = getIntendedFrameTimeNs(startNs);  <span class="hljs-comment">// FrameDisplayEventReceiver.mTimestampNanos</span>
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrameEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> token)</span> &#123;
        doQueueEnd(CALLBACK_TRAVERSAL);
        <span class="hljs-comment">// ...</span>
        addFrameCallback(CALLBACK_INPUT, <span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);   <span class="hljs-comment">// 继续放入下一轮 doFrame 的钩子</span>
    &#125;     
&#125;</code></pre></div>

<h3 id="LooperObserver"><a href="#LooperObserver" class="headerlink" title="LooperObserver"></a><code>LooperObserver</code></h3><p>结合上面捕获到的信息，提供一个「观察者」</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperObserver</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDispatchBegin</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Message 开始执行</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginNs       开始时间（System.nanoTime）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuBeginNs    线程的开始时间（SystemClock.currentThreadTimeMillis）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token         等于 beginNs</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@CallSuper</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBegin</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginNs, <span class="hljs-type">long</span> token)</span> &#123;
        isDispatchBegin = <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Message 耗时统计</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> focusedActivity       当前页面（Activity）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startNs               Message 的开始时间（等于 beginNs）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endNs                 Message 的结束时间（等于 endNs）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isVsyncFrame          是否 ui 绘制任务（doFrame）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> intendedFrameTimeNs   收到 APP_VSYNC 信号的时间（FrameDisplayEventReceiver.onVsync）</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputCostNs           doFrame INPUT 阶段耗时</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> animationCostNs       doFrame ANIMATION 阶段耗时</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> traversalCostNs       doFrame TRAVERSAL 阶段耗时</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrame</span><span class="hljs-params">(String focusedActivity, <span class="hljs-type">long</span> startNs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">boolean</span> isVsyncFrame, <span class="hljs-type">long</span> intendedFrameTimeNs, <span class="hljs-type">long</span> inputCostNs, <span class="hljs-type">long</span> animationCostNs, <span class="hljs-type">long</span> traversalCostNs)</span> &#123;

    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Message 结束执行</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginNs       开始时间</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuBeginMs    线程的开始时间</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endNs         结束时间</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cpuEndMs      结束的线程时间</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token         等于 beginNs</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isVsyncFrame  此任务是否 ui 绘制任务（doFrame）</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@CallSuper</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isVsyncFrame)</span> &#123;
        isDispatchBegin = <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDispatchBegin</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> isDispatchBegin;
    &#125;
&#125;</code></pre></div>

<h3 id="计算-FPS"><a href="#计算-FPS" class="headerlink" title="计算 FPS"></a>计算 FPS</h3><blockquote>
<p>我们将掉帧数划分出几个区间进行定级，掉帧数小于 3 帧的情况属于最佳，依次类推，见下表：</p>
<table>
<thead>
<tr>
<th>Best</th>
<th>Normal</th>
<th>Middle</th>
<th>High</th>
<th>Frozen</th>
</tr>
</thead>
<tbody><tr>
<td>[0:3)</td>
<td>[3:9)</td>
<td>[9:24)</td>
<td>[24:42)</td>
<td>[42:∞)</td>
</tr>
</tbody></table>
<p>相比单看平均帧率，掉帧程度的分布可以明显的看出，界面卡顿（平均帧率低）的原因是因为连续轻微的掉帧，还是某次严重掉帧造成的。再通过 <code>Activity</code> 区分不同场景，计算每个界面在有效绘制的时间片内，掉帧程度的分布情况及平均帧率，从而来评估出一个界面的整体流畅程度。</p>
</blockquote>
<p>也就是说，一次掉帧可能掉了一帧、两帧或者更多帧（<strong>掉帧数</strong>），这里根据上表把一次掉帧划分为 <code>Best/Normal/Middle/High/Frozen</code> 五个级别，后续评价掉帧时就不再关注掉帧数而是 <strong>掉帧次数</strong> 及其严重级别</p>
<p>下图绿色的 <code>62.00 FPS</code> 指的是过去 200ms 内的平均帧率</p>
<p>灰色的 <code>sum: 3.0</code> 是 <strong>总掉帧次数</strong>，下面的彩虹从左到右分别代表 <code>Normal/Middle/High/Frozen</code> 这四个级别的掉帧占总掉帧的比例，往下是当前页面的掉帧数和掉帧比例</p>
<p>最底下的图表是过去 10s 内平均帧率（200ms 时间段）的横向柱状图，每 5s 就会有 25 条记录，50 FPS 差不多是 <code>Normal</code> 的帧率下限，30 FPS 差不多是 <code>Middle</code> 的帧率下限</p>
<p><img src="../../../../image/2021-04-26-matrix-tracecanary/fps_board.jpg" srcset="/image/loading.gif" lazyload alt="fps_board"></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每帧的时间间隔，默认取 16ms（60 FPS）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIThreadMonitor</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">frameIntervalNanos</span> <span class="hljs-operator">=</span> <span class="hljs-number">16666666</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(TraceConfig config)</span> &#123;
        frameIntervalNanos = ReflectUtils.reflectObject(choreographer, <span class="hljs-string">&quot;mFrameIntervalNanos&quot;</span>, Constants.DEFAULT_FRAME_DURATION);
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameTracer</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> frameIntervalNs;     <span class="hljs-comment">// UIThreadMonitor.getMonitor().getFrameIntervalNanos()</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListener</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String focusedActivity, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> startNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> endNs, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isVsyncFrame,</span>
<span class="hljs-params">                                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> intendedFrameTimeNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> inputCostNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> animationCostNs, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> traversalCostNs)</span> &#123;
        <span class="hljs-type">long</span> <span class="hljs-variable">traceBegin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">jiter</span> <span class="hljs-operator">=</span> endNs - intendedFrameTimeNs;         <span class="hljs-comment">// 从收到 vsync 到完成 doFrame 的时间，也就是实际渲染一帧的耗时</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">dropFrame</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (jiter / frameIntervalNs);  <span class="hljs-comment">// 计算出渲染这一帧对比理论 FPS 有没掉帧，掉了多少帧</span>
            <span class="hljs-comment">// ...</span>
        &#125;
    &#125;    
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameDecorator</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrameAsync</span><span class="hljs-params">(String focusedActivity, <span class="hljs-type">long</span> startNs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">int</span> dropFrame, <span class="hljs-type">boolean</span> isVsyncFrame, <span class="hljs-type">long</span> intendedFrameTimeNs, <span class="hljs-type">long</span> inputCostNs, <span class="hljs-type">long</span> animationCostNs, <span class="hljs-type">long</span> traversalCostNs)</span> &#123;
        <span class="hljs-built_in">super</span>.doFrameAsync(focusedActivity, startNs, endNs, dropFrame, isVsyncFrame, intendedFrameTimeNs, inputCostNs, animationCostNs, traversalCostNs);

        <span class="hljs-keyword">if</span> (!Objects.equals(focusedActivity, lastVisibleScene)) &#123;        <span class="hljs-comment">// 切换页面时，重置页面的统计数据</span>
            dropLevel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[FrameTracer.DropStatus.values().length];
            lastVisibleScene = focusedActivity;
            lastCost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            lastFrames[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        &#125;

        <span class="hljs-comment">// 为什么不是用 endNs ？</span>
        <span class="hljs-comment">// 1，因为 doFrame 执行完还要等 surfacefling 在下一帧的时间点进行合成和显示，而不是 doFrame 后立即显示，所以要用 frameIntervalMs 的倍数</span>
        <span class="hljs-comment">// 2，其次考虑用户无操作/页面静止的情况，主线程的任务队列为空，没有刷新页面，如果用设备时间 endNs 会导致计算出极低的错误 FPS</span>
        sumFrameCost += (dropFrame + <span class="hljs-number">1</span>) * frameIntervalMs;
        sumFrames += <span class="hljs-number">1</span>;
        <span class="hljs-type">float</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> sumFrameCost - lastCost[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 距离上一次刷新 FPS 的时间间隔</span>

        <span class="hljs-keyword">if</span> (dropFrame &gt;= Constants.DEFAULT_DROPPED_FROZEN) &#123;    <span class="hljs-comment">// 根据掉帧数，给发生的掉帧事故分级别统计</span>
            dropLevel[FrameTracer.DropStatus.DROPPED_FROZEN.index]++;
            sumDropLevel[FrameTracer.DropStatus.DROPPED_FROZEN.index]++;
            belongColor = frozenColor;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dropFrame &gt;= Constants.DEFAULT_DROPPED_HIGH) &#123;
            dropLevel[FrameTracer.DropStatus.DROPPED_HIGH.index]++;
            sumDropLevel[FrameTracer.DropStatus.DROPPED_HIGH.index]++;
            <span class="hljs-keyword">if</span> (belongColor != frozenColor) &#123;
                belongColor = highColor;
            &#125;
        &#125; <span class="hljs-comment">// ...</span>


        <span class="hljs-type">long</span> <span class="hljs-variable">collectFrame</span> <span class="hljs-operator">=</span> sumFrames - lastFrames[<span class="hljs-number">0</span>];                              <span class="hljs-comment">// 200ms 内刷新了几帧</span>
        <span class="hljs-keyword">if</span> (duration &gt;= <span class="hljs-number">200</span>) &#123;                                                      <span class="hljs-comment">// 每隔 200ms 刷新一次 FPS</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">fps</span> <span class="hljs-operator">=</span> Math.min(maxFps, <span class="hljs-number">1000.f</span> * collectFrame / duration);   <span class="hljs-comment">// 统计过去 200ms 的 FPS</span>
            updateView(view, fps, belongColor, dropLevel[FrameTracer.DropStatus.DROPPED_NORMAL.index], dropLevel[FrameTracer.DropStatus.DROPPED_MIDDLE.index] ...);
            lastCost[<span class="hljs-number">0</span>] = sumFrameCost;
            lastFrames[<span class="hljs-number">0</span>] = sumFrames;
            <span class="hljs-comment">// ...</span>
        &#125;
    &#125;    
&#125;</code></pre></div>

<h3 id="统计耗时-Message"><a href="#统计耗时-Message" class="headerlink" title="统计耗时 Message"></a>统计耗时 <code>Message</code></h3><p><code>TraceCanary</code> 把耗时超过 700ms 的 <code>Message</code> 作为 <code>Evil Method</code> 上报</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilMethodTracer</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isVsyncFrame)</span> &#123;
        <span class="hljs-type">long</span> <span class="hljs-variable">dispatchCost</span> <span class="hljs-operator">=</span> (endNs - beginNs) / Constants.TIME_MILLIS_TO_NANO;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;
                <span class="hljs-comment">// ...</span>
            &#125;
        &#125;
    &#125;    
&#125;</code></pre></div>

<h2 id="无埋点插桩收集函数耗时"><a href="#无埋点插桩收集函数耗时" class="headerlink" title="无埋点插桩收集函数耗时"></a>无埋点插桩收集函数耗时</h2><p>为了在捕捉到卡顿堆栈后，获取各个函数的执行耗时，需要对所有函数进行无埋点插桩，在函数执行前调用 <code>MethodBeat.i</code>，在函数执行后调用 <code>MethodBeat.o</code></p>
<blockquote>
<p>通过代理编译期间的任务 <code>transformClassesWithDexTask</code>，将全局 <code>class</code> 文件作为输入，利用 <code>ASM</code> 工具，高效地对所有 <code>class</code> 文件进行扫描及插桩</p>
<p>插桩过程有几个关键点：</p>
<ol>
<li>选择在该编译任务执行时插桩，是因为 <code>proguard</code> 操作是在该任务之前就完成的，意味着插桩时的 <code>class</code> 文件已经被混淆过的。而选择 <code>proguard</code> 之后去插桩，是因为如果提前插桩会造成部分方法不符合内联规则，没法在 <code>proguard</code> 时进行优化，最终导致程序方法数无法减少，从而引发方法数过大问题</li>
<li>为了减少插桩量及性能损耗，通过遍历 <code>class</code> 方法指令集，判断扫描的函数是否只含有 <code>PUT/READ FIELD</code> 等简单的指令，来过滤一些默认或匿名构造函数，以及 <code>get/set</code> 等简单不耗时函数</li>
<li>针对界面启动耗时，因为要统计从 <code>Activity.onCreate</code> 到 <code>Activity.onWindowFocusChange</code> 间的耗时，所以在插桩过程中需要收集应用内所有 <code>Activity</code> 的实现类，并覆盖 <code>onWindowFocusChange</code> 函数进行打点</li>
<li>为了方便及高效记录函数执行过程，我们为每个插桩的函数分配一个独立 ID，在插桩过程中，记录插桩的函数签名及分配的 ID，在插桩完成后输出一份 mapping，作为数据上报后的解析支持。</li>
</ol>
<p>归纳起来，编译期所做的工作如下图：</p>
<p><img src="../../../../image/2021-04-26-matrix-tracecanary/build.png" srcset="/image/loading.gif" lazyload alt="transform class"></p>
</blockquote>
<h3 id="Gradle-Transform"><a href="#Gradle-Transform" class="headerlink" title="Gradle Transform"></a>Gradle Transform</h3><p><code>ignoreMethodMapFilePath</code> 上面说过为了减少插桩量及性能损耗会忽略一些函数，这些被忽略的函数记录在此文件里（默认放在 <code>/app/build/outputs/mapping/&#123;var&#125;/ignoreMethodMapping.txt</code>），大概长这样：</p>
<div class="code-wrapper"><pre><code class="hljs kotlin">ignore methods:
android.arch.core.executor.ArchTaskExecutor &lt;clinit&gt; ()V
android.arch.core.executor.ArchTaskExecutor &lt;<span class="hljs-keyword">init</span>&gt; ()V
android.arch.core.executor.ArchTaskExecutor$<span class="hljs-number">1</span> execute (Ljava.lang.Runnable;)V
android.arch.core.executor.DefaultTaskExecutor executeOnDiskIO (Ljava.lang.Runnable;)V
android.arch.core.<span class="hljs-keyword">internal</span>.FastSafeIterableMap &lt;<span class="hljs-keyword">init</span>&gt; ()V
android.arch.core.<span class="hljs-keyword">internal</span>.FastSafeIterableMap ceil (Ljava.lang.Object;)Ljava.util.Map$Entry;
android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap size ()I
android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap equals (Ljava.lang.Object;)Z
android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator backward (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;
android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator forward (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;
android.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$AscendingIterator &lt;<span class="hljs-keyword">init</span>&gt; (Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;Landroid.arch.core.<span class="hljs-keyword">internal</span>.SafeIterableMap$Entry;)V</code></pre></div>

<p><code>methodMapFilePath</code> 函数签名和函数 ID 的映射（默认放在 <code>/app/build/outputs/mapping/&#123;var&#125;/methodMapping.txt</code>），大概长这样：</p>
<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">6</span> run ()V
<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,sample.tencent.matrix.MatrixApplication initSQLiteLintConfig ()Lcom.tencent.sqlitelint.config.SQLiteLintConfig;
<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">5</span> onClick (Landroid.view.View;)V
<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">4</span> onClick (Landroid.view.View;)V
<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,sample.tencent.matrix.MainActivity onResume ()V
<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MatrixApplication onCreate ()V
<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">3</span> onClick (Landroid.view.View;)V
<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,sample.tencent.matrix.MainActivity onCreate (Landroid.os.Bundle;)V
<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,sample.tencent.matrix.MainActivity$<span class="hljs-number">2</span> onClick (Landroid.view.View;)V
<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,org.apache.commons.io.comparator.DirectoryFileComparator compare (Ljava.io.File;Ljava.io.File;)I</code></pre></div>

<p><code>TraceCanary</code> 用 <code>Transform API</code> 处理并输出插桩后的 <code>class</code> </p>
<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatrixTraceTransform</span>: <span class="hljs-type">Transform</span>() &#123;

    <span class="hljs-comment">// Transform 的名称</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MatrixTraceTransform&quot;</span>
    &#125;

    <span class="hljs-comment">// Transform 接收 Input 处理并输出 Output</span>
    <span class="hljs-comment">// 这里声明 MatrixTraceTransform 接收所有的 class，包括 class 文件和 jar 包中的 class</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInputTypes</span><span class="hljs-params">()</span></span>: Set&lt;QualifiedContent.ContentType&gt; &#123;
        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS
    &#125;

    <span class="hljs-comment">// 指定 class 的范围，限定项目内的所有 class</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getScopes</span><span class="hljs-params">()</span></span>: MutableSet&lt;<span class="hljs-keyword">in</span> QualifiedContent.Scope&gt;? &#123;
        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT
    &#125;

    <span class="hljs-comment">// 支持增量编译</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isIncremental</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;
        <span class="hljs-keyword">super</span>.transform(transformInvocation)
        <span class="hljs-comment">// ...</span>
        transforming(transformInvocation)
    &#125;

    <span class="hljs-comment">// 核心逻辑</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transforming</span><span class="hljs-params">(invocation: <span class="hljs-type">TransformInvocation</span>)</span></span> &#123;
        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()
        <span class="hljs-keyword">val</span> outputProvider = invocation.outputProvider!!
        <span class="hljs-keyword">val</span> isIncremental = invocation.isIncremental &amp;&amp; <span class="hljs-keyword">this</span>.isIncremental
        <span class="hljs-keyword">if</span> (!isIncremental) &#123;
            outputProvider.deleteAll()
        &#125;
        <span class="hljs-keyword">val</span> config = configure(invocation)

        <span class="hljs-keyword">val</span> changedFiles = ConcurrentHashMap&lt;File, Status&gt;()    <span class="hljs-comment">// 需要进行插桩的 class/jar</span>
        <span class="hljs-keyword">val</span> inputToOutput = ConcurrentHashMap&lt;File, File&gt;()     <span class="hljs-comment">// Input Dir -&gt; Output Dir，Input Jar -&gt; Output Jar</span>
        <span class="hljs-keyword">val</span> inputFiles = ArrayList&lt;File&gt;()                      <span class="hljs-comment">// Input Dir &amp;&amp; Input Jar</span>
        <span class="hljs-keyword">var</span> transformDirectory: File? = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">for</span> (input <span class="hljs-keyword">in</span> invocation.inputs) &#123;

            <span class="hljs-comment">// 遍历并添加 class 文件</span>
            <span class="hljs-keyword">for</span> (directoryInput <span class="hljs-keyword">in</span> input.directoryInputs) &#123;
                changedFiles.putAll(directoryInput.changedFiles)
                <span class="hljs-keyword">val</span> inputDir = directoryInput.file
                inputFiles.add(inputDir)
                <span class="hljs-keyword">val</span> outputDirectory = outputProvider.getContentLocation(
                        directoryInput.name,
                        directoryInput.contentTypes,
                        directoryInput.scopes,
                        Format.DIRECTORY)

                inputToOutput[inputDir] = outputDirectory
                <span class="hljs-keyword">if</span> (transformDirectory == <span class="hljs-literal">null</span>) transformDirectory = outputDirectory.parentFile
            &#125;

            <span class="hljs-comment">// 遍历并添加 jar 包</span>
            <span class="hljs-keyword">for</span> (jarInput <span class="hljs-keyword">in</span> input.jarInputs) &#123;
                <span class="hljs-keyword">val</span> inputFile = jarInput.file
                changedFiles[inputFile] = jarInput.status
                inputFiles.add(inputFile)
                <span class="hljs-keyword">val</span> outputJar = outputProvider.getContentLocation(
                        jarInput.name,
                        jarInput.contentTypes,
                        jarInput.scopes,
                        Format.JAR)

                inputToOutput[inputFile] = outputJar
                <span class="hljs-keyword">if</span> (transformDirectory == <span class="hljs-literal">null</span>) transformDirectory = outputJar.parentFile
            &#125;
        &#125;

        <span class="hljs-keyword">if</span> (inputFiles.size == <span class="hljs-number">0</span> || transformDirectory == <span class="hljs-literal">null</span>) &#123;
            Log.i(TAG, <span class="hljs-string">&quot;Matrix trace do not find any input files&quot;</span>)
            <span class="hljs-keyword">return</span>
        &#125;

        <span class="hljs-comment">// 执行插桩</span>
        <span class="hljs-keyword">val</span> outputDirectory = transformDirectory
        MatrixTrace(
                ignoreMethodMapFilePath = config.ignoreMethodMapFilePath,
                methodMapFilePath = config.methodMapFilePath,
                baseMethodMapPath = config.baseMethodMapPath,   <span class="hljs-comment">// 上一次插桩的 method mapping file，记录了已分配的 method id，插桩时要复用</span>
                blockListFilePath = config.blockListFilePath,   <span class="hljs-comment">// 黑名单机制，忽略匹配的函数</span>
                mappingDir = config.mappingDir                  <span class="hljs-comment">// Proguard mapping file</span>
        ).doTransform(
                classInputs = inputFiles,
                changedFiles = changedFiles,
                isIncremental = isIncremental,
                traceClassDirectoryOutput = outputDirectory,
                inputToOutput = inputToOutput,
                legacyReplaceChangedFile = <span class="hljs-literal">null</span>,
                legacyReplaceFile = <span class="hljs-literal">null</span>)

        <span class="hljs-keyword">val</span> cost = System.currentTimeMillis() - start
        Log.i(TAG, <span class="hljs-string">&quot; Insert matrix trace instrumentations cost time: %sms.&quot;</span>, cost)
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configure</span><span class="hljs-params">(transformInvocation: <span class="hljs-type">TransformInvocation</span>)</span></span>: Configuration &#123;
        <span class="hljs-keyword">val</span> buildDir = project.buildDir.absolutePath
        <span class="hljs-keyword">val</span> dirName = transformInvocation.context.variantName
        <span class="hljs-keyword">val</span> mappingOut = Joiner.on(File.separatorChar).join(
                buildDir,
                FD_OUTPUTS,
                <span class="hljs-string">&quot;mapping&quot;</span>,
                dirName)

        <span class="hljs-keyword">return</span> Configuration.Builder()
                .setBaseMethodMap(extension.baseMethodMapFile)
                .setBlockListFile(extension.blackListFile)
                .setMethodMapFilePath(<span class="hljs-string">&quot;<span class="hljs-variable">$mappingOut</span>/methodMapping.txt&quot;</span>)
                .setIgnoreMethodMapFilePath(<span class="hljs-string">&quot;<span class="hljs-variable">$mappingOut</span>/ignoreMethodMapping.txt&quot;</span>)
                .setMappingPath(mappingOut)
                .build()
    &#125;
&#125;</code></pre></div>

<h3 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;
    <span class="hljs-keyword">val</span> executor: ExecutorService = Executors.newFixedThreadPool(<span class="hljs-number">16</span>)
    <span class="hljs-keyword">val</span> config = Configuration.Builder()
            .setIgnoreMethodMapFilePath(ignoreMethodMapFilePath)
            .setMethodMapFilePath(methodMapFilePath)
            .setBaseMethodMap(baseMethodMapPath)
            .setBlockListFile(blockListFilePath)
            .setMappingPath(mappingDir)
            .build()

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * step 1</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">var</span> start = System.currentTimeMillis()
    <span class="hljs-keyword">val</span> futures = LinkedList&lt;Future&lt;*&gt;&gt;()
    <span class="hljs-keyword">val</span> mappingCollector = MappingCollector()
    <span class="hljs-keyword">val</span> methodId = AtomicInteger(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">val</span> collectedMethodMap = ConcurrentHashMap&lt;String, TraceMethod&gt;()

    <span class="hljs-comment">// 在线程池里解析各种 mapping file</span>
    futures.add(executor.submit(ParseMappingTask(
            mappingCollector, collectedMethodMap, methodId, config)))

    <span class="hljs-comment">// 在线程池里扫描 class dir 和 jar，将 Input 和 Output 映射好放在下面的两个 map 里</span>
    <span class="hljs-keyword">val</span> dirInputOutMap = ConcurrentHashMap&lt;File, File&gt;()
    <span class="hljs-keyword">val</span> jarInputOutMap = ConcurrentHashMap&lt;File, File&gt;()
    <span class="hljs-keyword">for</span> (file <span class="hljs-keyword">in</span> classInputs) &#123;
        <span class="hljs-keyword">if</span> (file.isDirectory) &#123;
            futures.add(executor.submit(CollectDirectoryInputTask(
                    directoryInput = file,
                    mapOfChangedFiles = changedFiles,
                    mapOfInputToOutput = inputToOutput,
                    isIncremental = isIncremental,
                    traceClassDirectoryOutput = traceClassDirectoryOutput,
                    legacyReplaceChangedFile = legacyReplaceChangedFile,
                    legacyReplaceFile = legacyReplaceFile,
                    resultOfDirInputToOut = dirInputOutMap
            )))
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">val</span> status = Status.CHANGED
            futures.add(executor.submit(CollectJarInputTask(
                    inputJar = file,
                    inputJarStatus = status,
                    inputToOutput = inputToOutput,
                    isIncremental = isIncremental,
                    traceClassFileOutput = traceClassDirectoryOutput,
                    legacyReplaceFile = legacyReplaceFile,
                    resultOfDirInputToOut = dirInputOutMap,
                    resultOfJarInputToOut = jarInputOutMap
            )))
        &#125;
    &#125;
    <span class="hljs-keyword">for</span> (future <span class="hljs-keyword">in</span> futures) &#123;
        future.<span class="hljs-keyword">get</span>()
    &#125;
    futures.clear()
    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(1)[Parse]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)
    <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseMappingTask</span>(...) : Runnable &#123;
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()
        <span class="hljs-keyword">val</span> mappingFile = File(config.mappingDir, <span class="hljs-string">&quot;mapping.txt&quot;</span>)    <span class="hljs-comment">// 解析 Proguard mapping file</span>
        <span class="hljs-keyword">if</span> (mappingFile.isFile) &#123;
            <span class="hljs-keyword">val</span> mappingReader = MappingReader(mappingFile)
            mappingReader.read(mappingCollector)
        &#125;
        <span class="hljs-keyword">val</span> size = config.parseBlockFile(mappingCollector)          <span class="hljs-comment">// 解析黑名单</span>
        <span class="hljs-keyword">val</span> baseMethodMapFile = File(config.baseMethodMapPath)      <span class="hljs-comment">// 加载已分配 method id 的函数列表</span>
        getMethodFromBaseMethod(baseMethodMapFile, collectedMethodMap)
        retraceMethodMap(mappingCollector, collectedMethodMap)
        Log.i(TAG, <span class="hljs-string">&quot;[ParseMappingTask#run] cost:%sms, black size:%s, collect %s method from %s&quot;</span>,
                System.currentTimeMillis() - start, size, collectedMethodMap.size, config.baseMethodMapPath)
    &#125;
&#125;</code></pre></div>

<h3 id="收集匹配的函数"><a href="#收集匹配的函数" class="headerlink" title="收集匹配的函数"></a>收集匹配的函数</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;
    <span class="hljs-comment">// ... step 2 在线程池里用 ASM 解析 class 并收集匹配的函数</span>
    start = System.currentTimeMillis()
    <span class="hljs-keyword">val</span> methodCollector = MethodCollector(executor, mappingCollector, methodId, config, collectedMethodMap)
    methodCollector.collect(dirInputOutMap.keys, jarInputOutMap.keys)
    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(2)[Collection]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 搜集匹配的函数</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> MethodCollector.collect(Set&lt;File&gt; srcFolderList, Set&lt;File&gt; dependencyJarList) <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;
    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (File srcFile : srcFolderList) &#123;                    <span class="hljs-comment">// 在 class 里收集匹配的函数</span>
        ArrayList&lt;File&gt; classFileList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">if</span> (srcFile.isDirectory()) &#123;
            listClassFiles(classFileList, srcFile);
        &#125; <span class="hljs-keyword">else</span> &#123;
            classFileList.add(srcFile);
        &#125;
        <span class="hljs-keyword">for</span> (File classFile : classFileList) &#123;
            futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectSrcTask</span>(classFile)));
        &#125;
    &#125;
    <span class="hljs-keyword">for</span> (File jarFile : dependencyJarList) &#123;                <span class="hljs-comment">// 在 jar 包里收集匹配的函数</span>
        futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectJarTask</span>(jarFile)));
    &#125;
    <span class="hljs-keyword">for</span> (Future future : futures) &#123;
        future.get();
    &#125;
    futures.clear();
    futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
            saveIgnoreCollectedMethod(mappingCollector);    <span class="hljs-comment">// 写入 ignored methods 到文件里</span>
        &#125;
    &#125;));
    futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
            saveCollectedMethod(mappingCollector);          <span class="hljs-comment">// 将 method id -&gt; method 映射写入文件里</span>
        &#125;
    &#125;));
    <span class="hljs-keyword">for</span> (Future future : futures) &#123;
        future.get();
    &#125;
    futures.clear();
&#125;

<span class="hljs-comment">// 用 ASM Core API 解析并找到匹配的函数</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> CollectMethodNode.visitEnd() &#123;
    <span class="hljs-built_in">super</span>.visitEnd();
    <span class="hljs-type">TraceMethod</span> <span class="hljs-variable">traceMethod</span> <span class="hljs-operator">=</span> TraceMethod.create(<span class="hljs-number">0</span>, access, className, name, desc);
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>.equals(name)) &#123;
        isConstructor = <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-comment">// 过滤掉空函数、getter/setter 等，加入 ignored method file 里</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">isNeedTrace</span> <span class="hljs-operator">=</span> isNeedTrace(configuration, traceMethod.className, mappingCollector);
    <span class="hljs-keyword">if</span> ((isEmptyMethod() || isGetSetMethod() || isSingleMethod())
            &amp;&amp; isNeedTrace) &#123;
        ignoreCount.incrementAndGet();
        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-comment">// 需要插桩的函数，如果没有 method id 则分配一个自增的 method id，加入 collectedMethodMap</span>
    <span class="hljs-keyword">if</span> (isNeedTrace &amp;&amp; !collectedMethodMap.containsKey(traceMethod.getMethodName())) &#123;
        traceMethod.id = methodId.incrementAndGet();
        collectedMethodMap.put(traceMethod.getMethodName(), traceMethod);
        incrementCount.incrementAndGet();
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isNeedTrace &amp;&amp; !collectedIgnoreMethodMap.containsKey(traceMethod.className)) &#123;
        ignoreCount.incrementAndGet();
        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);
    &#125;
&#125;

<span class="hljs-comment">// Jar 包则用 ZipFile API 遍历，依然用 ASM 解析</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectJarTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">ZipFile</span> <span class="hljs-variable">zipFile</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            zipFile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipFile</span>(fromJar);
            Enumeration&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ZipEntry</span>&gt; enumeration = zipFile.entries();
            <span class="hljs-keyword">while</span> (enumeration.hasMoreElements()) &#123;
                <span class="hljs-type">ZipEntry</span> <span class="hljs-variable">zipEntry</span> <span class="hljs-operator">=</span> enumeration.nextElement();
                <span class="hljs-type">String</span> <span class="hljs-variable">zipEntryName</span> <span class="hljs-operator">=</span> zipEntry.getName();
                <span class="hljs-keyword">if</span> (isNeedTraceFile(zipEntryName)) &#123;
                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> zipFile.getInputStream(zipEntry);
                    <span class="hljs-type">ClassReader</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(inputStream);
                    <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);
                    <span class="hljs-type">ClassVisitor</span> <span class="hljs-variable">visitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceClassAdapter</span>(Opcodes.ASM5, classWriter);
                    classReader.accept(visitor, <span class="hljs-number">0</span>);
                &#125;
            &#125;
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<h3 id="执行插桩操作"><a href="#执行插桩操作" class="headerlink" title="执行插桩操作"></a>执行插桩操作</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> MatrixTrace.<span class="hljs-title">doTransform</span><span class="hljs-params">(...)</span></span> &#123;
    <span class="hljs-comment">// ... step 3 执行插桩操作</span>
    start = System.currentTimeMillis()
    <span class="hljs-keyword">val</span> methodTracer = MethodTracer(executor, mappingCollector, config, methodCollector.collectedMethodMap, methodCollector.collectedClassExtendMap)
    methodTracer.trace(dirInputOutMap, jarInputOutMap)
    Log.i(TAG, <span class="hljs-string">&quot;[doTransform] Step(3)[Trace]... cost:%sms&quot;</span>, System.currentTimeMillis() - start)
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> MethodTracer.trace(Map&lt;File, File&gt; srcFolderList, Map&lt;File, File&gt; dependencyJarList) <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;
    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    traceMethodFromSrc(srcFolderList, futures);     <span class="hljs-comment">// 处理 class</span>
    traceMethodFromJar(dependencyJarList, futures); <span class="hljs-comment">// 处理 jar</span>
    <span class="hljs-keyword">for</span> (Future future : futures) &#123;
        future.get();
    &#125;
    futures.clear();
&#125;

<span class="hljs-comment">// 一个线程处理一个 class/dir </span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceMethodFromSrc</span><span class="hljs-params">(Map&lt;File, File&gt; srcMap, List&lt;Future&gt; futures)</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != srcMap) &#123;
        <span class="hljs-keyword">for</span> (Map.Entry&lt;File, File&gt; entry : srcMap.entrySet()) &#123;
            futures.add(executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; innerTraceMethodFromSrc(entry.getKey(), entry.getValue()); &#125;
            &#125;));
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">innerTraceMethodFromSrc</span><span class="hljs-params">(File input, File output)</span> &#123;
    <span class="hljs-comment">// ... 依然是 ASM 里 classReader，classWriter 和 classVisitor 的经典用法</span>
    is = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(classFile);
    <span class="hljs-type">ClassReader</span> <span class="hljs-variable">classReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(is);
    <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);
    <span class="hljs-type">ClassVisitor</span> <span class="hljs-variable">classVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceClassAdapter</span>(Opcodes.ASM5, classWriter);   <span class="hljs-comment">// 重要的类</span>
    classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);
    <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-keyword">public</span> MethodVisitor TraceClassAdapter.visitMethod(<span class="hljs-type">int</span> access, String name, String desc,
                                 String signature, String[] exceptions) &#123;
    <span class="hljs-keyword">if</span> (isABSClass) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (!hasWindowFocusMethod) &#123;    <span class="hljs-comment">// 匹配 Activity.onWindowFocusChanged，做页面打开速度统计</span>
            hasWindowFocusMethod = MethodCollector.isWindowFocusChangeMethod(name, desc);
        &#125;
        <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">methodVisitor</span> <span class="hljs-operator">=</span> cv.visitMethod(access, name, desc, signature, exceptions);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceMethodAdapter</span>(api, methodVisitor, access, name, desc, <span class="hljs-built_in">this</span>.className,
                hasWindowFocusMethod, isActivityOrSubClass, isNeedTrace);
    &#125;
&#125;

<span class="hljs-comment">// 匹配 Activity.onWindowFocusChanged(boolean hasFocus)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;onWindowFocusChanged&quot;</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(Z)V&quot;</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isWindowFocusChangeMethod</span><span class="hljs-params">(String name, String desc)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> != name &amp;&amp; <span class="hljs-literal">null</span> != desc &amp;&amp; name.equals(TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD) 
        &amp;&amp; desc.equals(TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> TraceClassAdapter.visitEnd() &#123;
    <span class="hljs-keyword">if</span> (!hasWindowFocusMethod &amp;&amp; isActivityOrSubClass &amp;&amp; isNeedTrace) &#123;
        insertWindowFocusChangeMethod(cv, className);
    &#125;
    <span class="hljs-built_in">super</span>.visitEnd();
&#125;

<span class="hljs-comment">// 如果 Activity 没有覆盖 onWindowFocusChanged 则覆盖之（需要在里面插桩统计页面打开速度）</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertWindowFocusChangeMethod</span><span class="hljs-params">(ClassVisitor cv, String classname)</span> &#123;
    <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">methodVisitor</span> <span class="hljs-operator">=</span> cv.visitMethod(Opcodes.ACC_PUBLIC, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD,
            TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
    methodVisitor.visitCode();
    methodVisitor.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number">0</span>);
    methodVisitor.visitVarInsn(Opcodes.ILOAD, <span class="hljs-number">1</span>);
    methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, TraceBuildConstants.MATRIX_TRACE_ACTIVITY_CLASS, 
        TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS, <span class="hljs-literal">false</span>);
    traceWindowFocusChangeMethod(methodVisitor, classname);
    methodVisitor.visitInsn(Opcodes.RETURN);
    methodVisitor.visitMaxs(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
    methodVisitor.visitEnd();
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceMethodAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdviceAdapter</span> &#123;
    <span class="hljs-comment">// 进入函数后先执行 MethodBeat.i</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodEnter</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">TraceMethod</span> <span class="hljs-variable">traceMethod</span> <span class="hljs-operator">=</span> collectedMethodMap.get(methodName);
        <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-literal">null</span>) &#123;
            traceMethodCount.incrementAndGet();
            mv.visitLdcInsn(traceMethod.id);
            mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-literal">false</span>);

            <span class="hljs-comment">// 在 onWindowFocusChanged 插入 AppMethodBeat.at</span>
            <span class="hljs-keyword">if</span> (checkNeedTraceWindowFocusChangeMethod(traceMethod)) &#123;
                traceWindowFocusChangeMethod(mv, className);
            &#125;
        &#125;
    &#125;
    
    <span class="hljs-comment">// 退出函数前，执行 MethodBeat.o</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodExit</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode)</span> &#123;
        <span class="hljs-type">TraceMethod</span> <span class="hljs-variable">traceMethod</span> <span class="hljs-operator">=</span> collectedMethodMap.get(methodName);
        <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-literal">null</span>) &#123;
            traceMethodCount.incrementAndGet();
            mv.visitLdcInsn(traceMethod.id);
            mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-literal">false</span>);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// jar 包一样的，只不过用的 ZipFile API 那套 ...</span></code></pre></div>

<h3 id="收集函数执行耗时"><a href="#收集函数执行耗时" class="headerlink" title="收集函数执行耗时"></a>收集函数执行耗时</h3><p>用一个 <code>long</code> 记录 <code>i/o</code> 函数调用，高位第一位表示是 <code>i</code> 函数还是 <code>o</code> 函数，后续 20 位存储 <code>method id</code>，低位 43 位存储 <em>相对时间戳</em>；运行时分配一个 100W 长度的 long 数组（占内存 7.6M）来存储，从索引 0 开始逐步递增到数组尾部，满了又从索引 0 开始，会覆盖旧数据，但因为 100W 足够大，用来收集栈帧执行时间足够了</p>
<blockquote>
<p>编译期已经对全局的函数进行插桩，在运行期间每个函数的执行前后都会调用 MethodBeat.i/o 的方法，如果是在主线程中执行，则在函数的执行前后获取当前距离 MethodBeat 模块初始化的时间 offset（为了压缩数据，存进一个long类型变量中），并将当前执行的是 MethodBeat i或者o、mehtod id 及时间 offset，存放到一个 long 类型变量中，记录到一个预先初始化好的数组 long[] 中 index 的位置（预先分配记录数据的 buffer 长度为 100w，内存占用约 7.6M）。</p>
<p><img src="../../../../image/2021-04-26-matrix-tracecanary/run_store.jpg" srcset="/image/loading.gif" lazyload alt="long buffer"></p>
<p><img src="../../../../image/2021-04-26-matrix-tracecanary/stack.jpg" srcset="/image/loading.gif" lazyload alt="summary func cast"></p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录函数的开始时间</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.i(<span class="hljs-type">int</span> methodId) &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (threadId == sMainThreadId) &#123;                <span class="hljs-comment">// 只关心主线程的慢函数，其他线程不记录</span>
        <span class="hljs-keyword">if</span> (assertIn) &#123;                             <span class="hljs-comment">// 防止重入</span>
            android.util.Log.e(TAG, <span class="hljs-string">&quot;ERROR!!! AppMethodBeat.i Recursive calls!!!&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        assertIn = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;       <span class="hljs-comment">// buffer 满了则重头开始，会覆盖掉旧数据</span>
            mergeData(methodId, sIndex, <span class="hljs-literal">true</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            sIndex = <span class="hljs-number">0</span>;
            mergeData(methodId, sIndex, <span class="hljs-literal">true</span>);
        &#125;
        ++sIndex;
        assertIn = <span class="hljs-literal">false</span>;
    &#125;
&#125;
<span class="hljs-comment">// 插入 buffer</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.mergeData(<span class="hljs-type">int</span> methodId, <span class="hljs-type">int</span> index, <span class="hljs-type">boolean</span> isIn) &#123;
    <span class="hljs-keyword">if</span> (methodId == AppMethodBeat.METHOD_ID_DISPATCH) &#123;
        sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;
    &#125;
    <span class="hljs-type">long</span> <span class="hljs-variable">trueId</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;                               <span class="hljs-comment">// 构造函数执行时间戳，第一位表示 i/o 操作</span>
    <span class="hljs-keyword">if</span> (isIn) &#123;
        trueId |= <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">63</span>;
    &#125;
    trueId |= (<span class="hljs-type">long</span>) methodId &lt;&lt; <span class="hljs-number">43</span>;                <span class="hljs-comment">// 后续 20 位存储 method id</span>
    trueId |= sCurrentDiffTime &amp; <span class="hljs-number">0x7FFFFFFFFFFL</span>;    <span class="hljs-comment">// 低 43 位存储相对时间戳</span>
    sBuffer[index] = trueId;
    checkPileup(index);
    sLastIndex = index;
&#125;
<span class="hljs-comment">// 记录函数的结束时间，跟上面是一样的</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.o(<span class="hljs-type">int</span> methodId) &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (Thread.currentThread().getId() == sMainThreadId) &#123;
        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;
            mergeData(methodId, sIndex, <span class="hljs-literal">false</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            sIndex = <span class="hljs-number">0</span>;
            mergeData(methodId, sIndex, <span class="hljs-literal">false</span>);
        &#125;
        ++sIndex;
    &#125;
&#125;</code></pre></div>

<p>值得注意的是，因为只有低 43 位存储时间戳，如果存储完整的时间戳那是不足的，而且在分析函数执行耗时用的是 duration = end - start，实际上不需要完整的时间戳，所以这里记录的是相对时间戳（<code>sCurrentDiffTime</code>）；而且为了性能，不在 <code>i/o</code> 函数里执行 <code>SystemClock.uptimeMillis()</code></p>
<p><code>sDiffTime</code> 记录加载类 <code>AppMethodBeat</code> 的时间戳，然后会起一个线程每隔 5ms 更新一次 <code>sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime</code></p>
<blockquote>
<p>另外，考虑到每个方法执行前后都获取系统时间（System.nanoTime）会对性能影响比较大，而实际上，单个函数执行耗时小于 5ms 的情况，对卡顿来说不是主要原因，可以忽略不计，如果是多次调用的情况，则在它的父级方法中可以反映出来，所以为了减少对性能的影响，通过另一条更新时间的线程每 5ms 去更新一个时间变量，而每个方法执行前后只读取该变量来减少性能损耗。</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">sUpdateDiffTimeRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
                <span class="hljs-keyword">while</span> (!isPauseUpdateTime &amp;&amp; status &gt; STATUS_STOPPED) &#123;
                    sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;
                    SystemClock.sleep(Constants.TIME_UPDATE_CYCLE_MS);
                &#125;
                <span class="hljs-keyword">synchronized</span> (updateTimeLock) &#123;
                    updateTimeLock.wait();
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            MatrixLog.e(TAG, <span class="hljs-string">&quot;&quot;</span> + e.toString());
        &#125;
    &#125;
&#125;;</code></pre></div>

<h2 id="上报耗时-Message"><a href="#上报耗时-Message" class="headerlink" title="上报耗时 Message"></a>上报耗时 <code>Message</code></h2><p>上面说过可以用一个 <code>long</code> 表示函数开始/结束的相对时间戳，然后存储在一个 100M 大小的数组里，插入索引会从 0 不断增长，到达 100M 后重置为 0</p>
<p>遇到耗时 <code>Message</code> 时，需要裁剪出有效的函数执行时间记录，所以在处理 <code>Message</code> 开始前先把索引记下来 <code>start</code>，处理完后从 <code>start</code> 到当前索引 <code>end</code> 之间就是这个 <code>Message</code> 的调用栈耗时记录</p>
<p>要注意的是索引到尾部后会重置为 0，所以要区分 <code>start</code> 和 <code>end</code> 大小关系；当 <code>start &lt; end</code> 取 <code>[start, end]</code>，当 <code>start &gt; end</code> 取 <code>[start,] + [0, end]</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilMethodTracer</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBegin</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> token)</span> &#123;
        <span class="hljs-built_in">super</span>.dispatchBegin(beginNs, cpuBeginMs, token);
        indexRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;EvilMethodTracer#dispatchBegin&quot;</span>);  <span class="hljs-comment">// 把当前索引记下来</span>
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isVsyncFrame)</span> &#123;
        <span class="hljs-built_in">super</span>.dispatchEnd(beginNs, cpuBeginMs, endNs, cpuEndMs, token, isVsyncFrame);
        <span class="hljs-type">long</span> <span class="hljs-variable">dispatchCost</span> <span class="hljs-operator">=</span> (endNs - beginNs) / Constants.TIME_MILLIS_TO_NANO;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;
                <span class="hljs-type">long</span>[] data = AppMethodBeat.getInstance().copyData(indexRecord);    <span class="hljs-comment">// 裁剪出从开始索引到当前索引间的数据</span>
                <span class="hljs-comment">// ...</span>
            &#125;
        &#125; ...
    &#125;    
&#125;

<span class="hljs-comment">// 裁剪函数执行耗时，注意区分 start &lt; end 和 start &gt; end 两种情况</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppMethodBeat</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span>[] copyData(IndexRecord startRecord) &#123;
        <span class="hljs-keyword">return</span> copyData(startRecord, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRecord</span>(sIndex - <span class="hljs-number">1</span>));
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span>[] copyData(IndexRecord startRecord, IndexRecord endRecord) &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-type">long</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> length;
        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, startRecord.index);
        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, endRecord.index);
        <span class="hljs-keyword">if</span> (end &gt; start) &#123;
            length = end - start + <span class="hljs-number">1</span>;
            data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[length];
            System.arraycopy(sBuffer, start, data, <span class="hljs-number">0</span>, length);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end &lt; start) &#123;
            length = <span class="hljs-number">1</span> + end + (sBuffer.length - start);
            data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[length];
            System.arraycopy(sBuffer, start, data, <span class="hljs-number">0</span>, sBuffer.length - start);
            System.arraycopy(sBuffer, <span class="hljs-number">0</span>, data, sBuffer.length - start, end + <span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;</code></pre></div>

<h2 id="上报-ANR"><a href="#上报-ANR" class="headerlink" title="上报 ANR"></a>上报 ANR</h2><p>在 <a href="../../../../2020/10/20/anr/">阅读源码系列：ANR 是怎么产生的</a> 说过，ANR 是因为没有及时消费 <code>MotionEvent</code>，超过 5s 后由 AMS 弹出的对话框</p>
<p>弹出 ANR 对话框的 <code>Runnable</code> 是在分发 <code>MotionEvent</code> 时放下的一个延时炸弹（<code>Handler.postDelayed</code>），如果 <code>MotionEvent</code> 在 5s 内被消费则炸弹被移除（<code>Handler.removeCallbacks</code>）</p>
<p>我们在 <code>Message</code> 执行前有钩子函数 <code>dispatchBegin</code>，那也可以学习 ANR 放入报告函数（注意是放在子线程的消息队列里，不然在主线程里还没执行就被 ANR 对话框杀掉了），延时 5s，然后在 <code>dispatchEnd</code> 里移除，如果主线程的 <code>Message</code> 超过 5s 未执行完，那极有可能触发 ANR，于是收集调用堆栈及耗时信息上报给服务器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrTracer</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBegin</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> token)</span> &#123;
        <span class="hljs-built_in">super</span>.dispatchBegin(beginNs, cpuBeginMs, token);

        anrTask.beginRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;AnrTracer#dispatchBegin&quot;</span>);     <span class="hljs-comment">// 记下调用堆栈的索引</span>
        anrTask.token = token;

        <span class="hljs-keyword">if</span> (traceConfig.isDevEnv()) &#123;
            MatrixLog.v(TAG, <span class="hljs-string">&quot;* [dispatchBegin] token:%s index:%s&quot;</span>, token, anrTask.beginRecord.index);
        &#125;
        <span class="hljs-type">long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> (System.nanoTime() - token) / Constants.TIME_MILLIS_TO_NANO;
        anrHandler.postDelayed(anrTask, Constants.DEFAULT_ANR - cost);                              <span class="hljs-comment">// 在子线程埋下延时 5s 的“炸弹”</span>
        lagHandler.postDelayed(lagTask, Constants.DEFAULT_NORMAL_LAG - cost);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchEnd</span><span class="hljs-params">(<span class="hljs-type">long</span> beginNs, <span class="hljs-type">long</span> cpuBeginMs, <span class="hljs-type">long</span> endNs, <span class="hljs-type">long</span> cpuEndMs, <span class="hljs-type">long</span> token, <span class="hljs-type">boolean</span> isBelongFrame)</span> &#123;
        <span class="hljs-built_in">super</span>.dispatchEnd(beginNs, cpuBeginMs, endNs, cpuEndMs, token, isBelongFrame);
        <span class="hljs-comment">// ... 及时移除“炸弹”</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != anrTask) &#123;
            anrTask.getBeginRecord().release();
            anrHandler.removeCallbacks(anrTask);
        &#125;
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != lagTask) &#123;
            lagHandler.removeCallbacks(lagTask);
        &#125;
    &#125;    
&#125;

<span class="hljs-comment">// 收集调用栈帧及其耗时、INPUUT/ANIMATION/TRAVERSAL 耗时、线程及进程信息等</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnrHandleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">long</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">isForeground</span> <span class="hljs-operator">=</span> isForeground();
        <span class="hljs-comment">// process</span>
        <span class="hljs-type">int</span>[] processStat = Utils.getProcessPriority(Process.myPid());
        <span class="hljs-type">long</span>[] data = AppMethodBeat.getInstance().copyData(beginRecord);
        beginRecord.release();
        <span class="hljs-type">String</span> <span class="hljs-variable">scene</span> <span class="hljs-operator">=</span> AppMethodBeat.getVisibleScene();
        <span class="hljs-comment">// memory</span>
        <span class="hljs-type">long</span>[] memoryInfo = dumpMemory();
        <span class="hljs-comment">// Thread state</span>
        Thread.<span class="hljs-type">State</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> Looper.getMainLooper().getThread().getState();
        StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();
        <span class="hljs-type">String</span> <span class="hljs-variable">dumpStack</span> <span class="hljs-operator">=</span> Utils.getStack(stackTrace, <span class="hljs-string">&quot;|*\t\t&quot;</span>, <span class="hljs-number">12</span>);
        <span class="hljs-comment">// frame</span>
        <span class="hljs-type">UIThreadMonitor</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> UIThreadMonitor.getMonitor();
        <span class="hljs-type">long</span> <span class="hljs-variable">inputCost</span> <span class="hljs-operator">=</span> monitor.getQueueCost(UIThreadMonitor.CALLBACK_INPUT, token);
        <span class="hljs-type">long</span> <span class="hljs-variable">animationCost</span> <span class="hljs-operator">=</span> monitor.getQueueCost(UIThreadMonitor.CALLBACK_ANIMATION, token);
        <span class="hljs-type">long</span> <span class="hljs-variable">traversalCost</span> <span class="hljs-operator">=</span> monitor.getQueueCost(UIThreadMonitor.CALLBACK_TRAVERSAL, token);
        <span class="hljs-comment">// trace</span>
        LinkedList&lt;MethodItem&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();
        <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span>) &#123;
            TraceDataUtils.structuredDataToStack(data, stack, <span class="hljs-literal">true</span>, curTime);
            TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TraceDataUtils</span>.IStructuredDataFilter() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFilter</span><span class="hljs-params">(<span class="hljs-type">long</span> during, <span class="hljs-type">int</span> filterCount)</span> &#123;
                    <span class="hljs-keyword">return</span> during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS;
                &#125;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFilterMaxCount</span><span class="hljs-params">()</span> &#123;
                    <span class="hljs-keyword">return</span> Constants.FILTER_STACK_MAX_COUNT;
                &#125;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-type">int</span> size)</span> &#123;
                    MatrixLog.w(TAG, <span class="hljs-string">&quot;[fallback] size:%s targetSize:%s stack:%s&quot;</span>, size, Constants.TARGET_EVIL_METHOD_STACK, stack);
                    <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK));
                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
                        iterator.next();
                        iterator.remove();
                    &#125;
                &#125;
            &#125;);
        &#125;
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">reportBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">logcatBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-type">long</span> <span class="hljs-variable">stackCost</span> <span class="hljs-operator">=</span> Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder));
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<h2 id="统计-APP-amp-页面启动耗时"><a href="#统计-APP-amp-页面启动耗时" class="headerlink" title="统计 APP &amp; 页面启动耗时"></a>统计 APP &amp; 页面启动耗时</h2><p>包括 <code>Application</code> 执行耗时、首屏启动耗时、冷/热启动耗时、页面启动耗时，它们之间的关系如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * </span>
<span class="hljs-comment"> * firstMethod.i       LAUNCH_ACTIVITY   onWindowFocusChange   LAUNCH_ACTIVITY    onWindowFocusChange</span>
<span class="hljs-comment"> * ^                         ^                   ^                     ^                  ^</span>
<span class="hljs-comment"> * |                         |                   |                     |                  |</span>
<span class="hljs-comment"> * |---------app---------|---|---firstActivity---|---------...---------|---careActivity---|</span>
<span class="hljs-comment"> * |&lt;--applicationCost--&gt;|</span>
<span class="hljs-comment"> * |&lt;--------------firstScreenCost--------------&gt;|</span>
<span class="hljs-comment"> * |&lt;---------------------------------------coldCost-------------------------------------&gt;|</span>
<span class="hljs-comment"> * .                         |&lt;-----warmCost----&gt;|</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span></code></pre></div>

<h3 id="Application-执行耗时"><a href="#Application-执行耗时" class="headerlink" title="Application 执行耗时"></a><code>Application</code> 执行耗时</h3><p>有了上面的插桩，通过给 <code>Application.attachBaseContext</code> 插桩，也就是第一次执行 <code>AppMethodBeat.i</code> 的时候，可以拿到 <code>eggBrokenTime</code> 作为 APP 启动时间</p>
<p>这里解释下为什么不在 <code>Application</code> 构造函数里插桩并作为 APP 启动时间，那是因为 APP 有冷启动/热启动的概念，冷启动下 fork app process 并构造 <code>Application</code> 实例，此时算出的启动时间是正确的；但如果是热启动，<code>Application</code> 实例并没有销毁也不会执行构造函数，而是直接走 <code>onCreate</code> 函数，此时在构造函数里插桩就无法捕获到正确的启动时间了</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppMethodBeat</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">i</span><span class="hljs-params">(<span class="hljs-type">int</span> methodId)</span> &#123;
        <span class="hljs-comment">// ... 第一次执行 AppMethodBeat.i 时</span>
        <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;
            <span class="hljs-keyword">synchronized</span> (statusLock) &#123;
                <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;
                    realExecute();
                    status = STATUS_READY;
                &#125;
            &#125;
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">realExecute</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// ...</span>
        ActivityThreadHacker.hackSysHandlerCallback();
        <span class="hljs-comment">/// ...</span>
    &#125;        
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityThreadHacker</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">sApplicationCreateBeginTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getEggBrokenTime</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> ActivityThreadHacker.sApplicationCreateBeginTime;
    &#125;    

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hackSysHandlerCallback</span><span class="hljs-params">()</span> &#123;
        sApplicationCreateBeginTime = SystemClock.uptimeMillis();   <span class="hljs-comment">// 记录 Application 的创建时间</span>
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;</code></pre></div>

<p>初始化 <code>Application</code> 后启动第一个 <code>Activity</code>/<code>Service</code>/<code>BroadcastReceiver</code> 的时刻作为 <code>Application</code> 初始化的完结时间（为啥没有 <code>ContentProvider</code> 呢？因为它是在 <code>onCreate</code> 之前启动的，see <a href="../../../../2021/04/12/leakcanary/">LeakCanary 浅析</a>）</p>
<p>上述三大组件的启动会通过主线程的消息队列在 <code>ActivityThread.mH</code> 里执行</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CREATE_SERVICE</span>          <span class="hljs-operator">=</span> <span class="hljs-number">114</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RECEIVER</span>                <span class="hljs-operator">=</span> <span class="hljs-number">113</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RELAUNCH_ACTIVITY</span>       <span class="hljs-operator">=</span> <span class="hljs-number">160</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXECUTE_TRANSACTION</span>     <span class="hljs-operator">=</span> <span class="hljs-number">159</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;
        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));
        <span class="hljs-keyword">switch</span> (msg.what) &#123;
            <span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">case</span> CREATE_SERVICE:
                <span class="hljs-keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,
                            (<span class="hljs-string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));
                &#125;
                handleCreateService((CreateServiceData)msg.obj);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                <span class="hljs-keyword">break</span>;
            
            <span class="hljs-keyword">case</span> RECEIVER:
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;broadcastReceiveComp&quot;</span>);
                handleReceiver((ReceiverData)msg.obj);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> RELAUNCH_ACTIVITY:
                handleRelaunchActivityLocally((IBinder) msg.obj);
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:
                <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> (ClientTransaction) msg.obj;
                mTransactionExecutor.execute(transaction);
                <span class="hljs-keyword">if</span> (isSystem()) &#123;
                    <span class="hljs-comment">// Client transactions inside system process are recycled on the client side</span>
                    <span class="hljs-comment">// instead of ClientLifecycleManager to avoid being cleared before this</span>
                    <span class="hljs-comment">// message is handled.</span>
                    transaction.recycle();
                &#125;
                <span class="hljs-comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span>
                <span class="hljs-keyword">break</span>;

        &#125;
    &#125;
&#125;
<span class="hljs-comment">// Activity 生命周期是通过 LaunchActivityItem/StartActivityItem/ResumeActivityItem/... 执行</span></code></pre></div>

<p>所以 <code>TraceCanary</code> 选择在第一次执行 <code>AppMethodBeat.i</code> 时，替换 <code>ActivityThread.sCurrentActivityThread.mH.mCallback</code>，在 <code>Handler.Callback.handleMessage(msg)</code> 里监听第一次启动 <code>Activity</code>/<code>Service</code>/<code>BroadcastReceiver</code> 的时刻作为 <code>Application</code> 初始化的结束点</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 第一次执行时</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.i(<span class="hljs-type">int</span> methodId) &#123;
    <span class="hljs-keyword">if</span> (status &lt;= STATUS_STOPPED) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span> (methodId &gt;= METHOD_ID_MAX) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;
        <span class="hljs-keyword">synchronized</span> (statusLock) &#123;
            <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;
                realExecute();
                status = STATUS_READY;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-comment">// 替换 Handler.Callback</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> AppMethodBeat.realExecute() &#123;
    <span class="hljs-comment">// ...</span>
    ActivityThreadHacker.hackSysHandlerCallback();
    LooperMonitor.register(looperMonitorListener);
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ActivityThreadHacker.hackSysHandlerCallback() &#123;
    <span class="hljs-keyword">try</span> &#123;
        sApplicationCreateBeginTime = SystemClock.uptimeMillis();
        sApplicationCreateBeginMethodIndex = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;ApplicationCreateBeginMethodIndex&quot;</span>);
        Class&lt;?&gt; forName = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);
        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> forName.getDeclaredField(<span class="hljs-string">&quot;sCurrentActivityThread&quot;</span>);
        field.setAccessible(<span class="hljs-literal">true</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">activityThreadValue</span> <span class="hljs-operator">=</span> field.get(forName);
        <span class="hljs-type">Field</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> forName.getDeclaredField(<span class="hljs-string">&quot;mH&quot;</span>);
        mH.setAccessible(<span class="hljs-literal">true</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> mH.get(activityThreadValue);
        Class&lt;?&gt; handlerClass = handler.getClass().getSuperclass();
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != handlerClass) &#123;
            <span class="hljs-type">Field</span> <span class="hljs-variable">callbackField</span> <span class="hljs-operator">=</span> handlerClass.getDeclaredField(<span class="hljs-string">&quot;mCallback&quot;</span>);
            callbackField.setAccessible(<span class="hljs-literal">true</span>);
            Handler.<span class="hljs-type">Callback</span> <span class="hljs-variable">originalCallback</span> <span class="hljs-operator">=</span> (Handler.Callback) callbackField.get(handler);
            <span class="hljs-type">HackCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HackCallback</span>(originalCallback);
            callbackField.set(handler, callback);
        &#125;
        MatrixLog.i(TAG, <span class="hljs-string">&quot;hook system handler completed. start:%s SDK_INT:%s&quot;</span>, sApplicationCreateBeginTime, Build.VERSION.SDK_INT);
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        MatrixLog.e(TAG, <span class="hljs-string">&quot;hook system handler err! %s&quot;</span>, e.getCause().toString());
    &#125;
&#125;

<span class="hljs-comment">// 记录时间点</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> HackCallback.handleMessage(Message msg) &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLaunchActivity</span> <span class="hljs-operator">=</span> isLaunchActivity(msg);
    <span class="hljs-keyword">if</span> (hasPrint &gt; <span class="hljs-number">0</span>) &#123;
        MatrixLog.i(TAG, <span class="hljs-string">&quot;[handleMessage] msg.what:%s begin:%s isLaunchActivity:%s SDK_INT=%s&quot;</span>, msg.what, SystemClock.uptimeMillis()isLaunchActivity, Build.VERSION.SDK_INT);
        hasPrint--;
    &#125;
    <span class="hljs-keyword">if</span> (!isCreated) &#123;
        <span class="hljs-keyword">if</span> (isLaunchActivity || msg.what == CREATE_SERVICE
                || msg.what == RECEIVER) &#123; <span class="hljs-comment">// todo for provider</span>
            ActivityThreadHacker.sApplicationCreateEndTime = SystemClock.uptimeMillis();
            ActivityThreadHacker.sApplicationCreateScene = msg.what;
            isCreated = <span class="hljs-literal">true</span>;
            sIsCreatedByLaunchActivity = isLaunchActivity;
            MatrixLog.i(TAG, <span class="hljs-string">&quot;application create end, sApplicationCreateScene:%d, isLaunchActivity:%s&quot;</span>, msg.what, isLaunchActivity);
            <span class="hljs-keyword">synchronized</span> (listeners) &#123;
                <span class="hljs-keyword">for</span> (IApplicationCreateListener listener : listeners) &#123;
                    listener.onApplicationCreateEnd();
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg);
&#125;</code></pre></div>

<h3 id="页面打开耗时"><a href="#页面打开耗时" class="headerlink" title="页面打开耗时"></a>页面打开耗时</h3><p>注册 <code>ActivityLifecycleCallbacks</code>，在 <code>onActivityCreated</code> 记录 <code>Activity</code> 的创建时间</p>
<p>在上面的插桩阶段，<code>AppMethodBeat.at(activity, isFocus)</code> 被添加到 <code>Activity.onWindowFocusChanged(hasFocus)</code> 的第一行代码，此时认为 <code>Activity</code> 获得焦点启动完毕（用户可见可交互），与 <code>Activity</code> 创建时间的差即为页面启动耗时</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartupTracer</span> &#123;

    <span class="hljs-comment">// &quot;&#123;Activity全限定类名&#125;@&#123;activity.hashCode()&#125;&quot; -&gt; uptimeMillis</span>
    <span class="hljs-keyword">private</span> HashMap&lt;String, Long&gt; createdTimeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAlive</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-built_in">super</span>.onAlive();
        MatrixLog.i(TAG, <span class="hljs-string">&quot;[onAlive] isStartupEnable:%s&quot;</span>, isStartupEnable);
        <span class="hljs-keyword">if</span> (isStartupEnable) &#123;
            AppMethodBeat.getInstance().addListener(<span class="hljs-built_in">this</span>);                              <span class="hljs-comment">// 添加 onWindowFocusChanged(hasFocus) 监视器</span>
            Matrix.with().getApplication().registerActivityLifecycleCallbacks(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">// 注册 ActivityLifecycleCallbacks</span>
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> &#123;
        MatrixLog.i(TAG, <span class="hljs-string">&quot;activeActivityCount:%d, coldCost:%d&quot;</span>, activeActivityCount, coldCost);
        <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;
            lastCreateActivity = uptimeMillis();
            MatrixLog.i(TAG, <span class="hljs-string">&quot;lastCreateActivity:%d, activity:%s&quot;</span>, lastCreateActivity, activity.getClass().getName());
            isWarmStartUp = <span class="hljs-literal">true</span>;
        &#125;
        activeActivityCount++;
        <span class="hljs-keyword">if</span> (isShouldRecordCreateTime) &#123;
            createdTimeMap.put(activity.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode(), uptimeMillis());  <span class="hljs-comment">// 记录 Activity 创建时间</span>
        &#125;
    &#125;

    <span class="hljs-comment">// 当 Activity.onWindowFocusChanged(hasFocus) hasFocus == true 时被调用</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityFocused</span><span class="hljs-params">(Activity activity)</span> &#123;
        <span class="hljs-keyword">if</span> (ActivityThreadHacker.sApplicationCreateScene == Integer.MIN_VALUE) &#123;
            Log.w(TAG, <span class="hljs-string">&quot;start up from unknown scene&quot;</span>);
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-type">String</span> <span class="hljs-variable">activityName</span> <span class="hljs-operator">=</span> activity.getClass().getName();
        <span class="hljs-keyword">if</span> (isColdStartup()) &#123;
            <span class="hljs-type">boolean</span> <span class="hljs-variable">isCreatedByLaunchActivity</span> <span class="hljs-operator">=</span> ActivityThreadHacker.isCreatedByLaunchActivity();
            MatrixLog.i(TAG, <span class="hljs-string">&quot;#ColdStartup# activity:%s, splashActivities:%s, empty:%b, &quot;</span>
                            + <span class="hljs-string">&quot;isCreatedByLaunchActivity:%b, hasShowSplashActivity:%b, &quot;</span>
                            + <span class="hljs-string">&quot;firstScreenCost:%d, now:%d, application_create_begin_time:%d, app_cost:%d&quot;</span>,
                    activityName, splashActivities, splashActivities.isEmpty(), isCreatedByLaunchActivity,
                    hasShowSplashActivity, firstScreenCost, uptimeMillis(),
                    ActivityThreadHacker.getEggBrokenTime(), ActivityThreadHacker.getApplicationCost());

            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> activityName + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode();
            <span class="hljs-type">Long</span> <span class="hljs-variable">createdTime</span> <span class="hljs-operator">=</span> createdTimeMap.get(key);
            <span class="hljs-keyword">if</span> (createdTime == <span class="hljs-literal">null</span>) &#123;
                createdTime = <span class="hljs-number">0L</span>;
            &#125;
            createdTimeMap.put(key, uptimeMillis() - createdTime);      <span class="hljs-comment">// 页面启动耗时</span>
            <span class="hljs-comment">// ...</span>
    &#125;    
&#125;

<span class="hljs-comment">// 当进入 Activity.onWindowFocusChanged(hasFocus) 函数时首先会执行此函数</span>
AppMethodBeat.at(Activity activity, <span class="hljs-type">boolean</span> isFocus) &#123;
    <span class="hljs-type">String</span> <span class="hljs-variable">activityName</span> <span class="hljs-operator">=</span> activity.getClass().getName();
    <span class="hljs-keyword">if</span> (isFocus) &#123;
        <span class="hljs-keyword">if</span> (sFocusActivitySet.add(activityName)) &#123;
            <span class="hljs-keyword">synchronized</span> (listeners) &#123;
                <span class="hljs-keyword">for</span> (IAppMethodBeatListener listener : listeners) &#123;
                    listener.onActivityFocused(activity);
                &#125;
            &#125;
            MatrixLog.i(TAG, <span class="hljs-string">&quot;[at] visibleScene[%s] has %s focus!&quot;</span>, getVisibleScene(), <span class="hljs-string">&quot;attach&quot;</span>);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (sFocusActivitySet.remove(activityName)) &#123;
            MatrixLog.i(TAG, <span class="hljs-string">&quot;[at] visibleScene[%s] has %s focus!&quot;</span>, getVisibleScene(), <span class="hljs-string">&quot;detach&quot;</span>);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="首屏打开耗时"><a href="#首屏打开耗时" class="headerlink" title="首屏打开耗时"></a>首屏打开耗时</h3><p>首屏启动耗时（<code>firstScreenCost</code>） = 第一个页面（splash activity）接收到焦点的时间 - <code>eggBrokenTime</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartupTracer</span> &#123;    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityFocused</span><span class="hljs-params">(Activity activity)</span> &#123;
        <span class="hljs-comment">// ... 记录首屏启动耗时</span>
        <span class="hljs-keyword">if</span> (firstScreenCost == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-built_in">this</span>.firstScreenCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<h3 id="冷启动和热启动耗时"><a href="#冷启动和热启动耗时" class="headerlink" title="冷启动和热启动耗时"></a>冷启动和热启动耗时</h3><p>当打开一个 <code>Activity</code> 时，如果 app process 不存在则需要通过 <code>zygote</code> 进程 <code>fork</code> 出 app process，实例化并执行 <code>Application.onCreate</code> 后再启动 <code>Activity</code>，这叫做 <strong>冷启动</strong>；APP 退出后，系统在内存充足的情况下并不会立刻销毁 app process，重新打开 APP 虽然会走 <code>Application.onCreate</code> 再打开 <code>Activity</code>，但这个 <code>Application</code> 实例并没有销毁（实际上是 JVM 没有被销毁），这叫 <strong>热启动</strong></p>
<p>怎么判断是冷启动还是热启动呢？既然 JVM 没有销毁，那么类的静态成员变量作为 <code>GC ROOT</code> 就会一直存在于内存中，判断它有没初始化即可知道是冷启动还是热启动，实际上 <code>Matrix</code> 就是这么做的，它的 <code>GC ROOT PATH</code> 是：</p>
<p><code>Matrix.sInstance</code> -&gt; <code>HashSet&lt;Plugin&gt; plugins</code> -&gt; <code>TracePlugin</code> -&gt; <code>StartupTracer</code> -&gt; <code>coldCost</code></p>
<p><code>StartupTracer.coldCost</code> 会在 <code>StartupTracer.onActivityFocused</code> 被初始化（&gt; 0），初始化时如果遇到 <code>StartupTracer.coldCost</code> == 0 则是冷启动；跟我想的不太一样的是，我认为冷启动耗时是从 <code>eggBrokenTime</code> 到第一个页面（splash activity）打开的时间，而 <code>TraceCanary</code> 计算的是到第二个页面（splash activity 之后的第一个页面）打开的时间</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityFocused(Activity activity) &#123;
    <span class="hljs-comment">// ... coldCost == 0 冷启动</span>
    <span class="hljs-keyword">if</span> (isColdStartup()) &#123;                                             
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> (hasShowSplashActivity) &#123;
            coldCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (splashActivities.contains(activityName)) &#123;
                hasShowSplashActivity = <span class="hljs-literal">true</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (splashActivities.isEmpty()) &#123;            <span class="hljs-comment">// process which is has activity but not main UI process</span>
                <span class="hljs-keyword">if</span> (isCreatedByLaunchActivity) &#123;
                    coldCost = firstScreenCost;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    firstScreenCost = <span class="hljs-number">0</span>;
                    coldCost = ActivityThreadHacker.getApplicationCost();
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">if</span> (isCreatedByLaunchActivity) &#123;
                    coldCost = firstScreenCost;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    firstScreenCost = <span class="hljs-number">0</span>;
                    coldCost = ActivityThreadHacker.getApplicationCost();
                &#125;
            &#125;
        &#125;   <span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<p>上面说过冷启动耗时是到第二个页面打开的时间，那如果在第一个页面打开时 <code>coldCost</code> &gt; 0 说明 JVM 没有销毁，是热启动（<code>isWarmStartUp</code>），热启动耗时相当于第一个页面的打开耗时</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartupTracer</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastCreateActivity</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;   <span class="hljs-comment">// 当前/上一个 Activity.onCreate 的时间</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;
        MatrixLog.i(TAG, <span class="hljs-string">&quot;activeActivityCount:%d, coldCost:%d&quot;</span>, activeActivityCount, coldCost);
        <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;
            lastCreateActivity = uptimeMillis();
            MatrixLog.i(TAG, <span class="hljs-string">&quot;lastCreateActivity:%d, activity:%s&quot;</span>, lastCreateActivity, activity.getClass().getName());
            isWarmStartUp = <span class="hljs-literal">true</span>;
        &#125;
        activeActivityCount++;
        <span class="hljs-keyword">if</span> (isShouldRecordCreateTime) &#123;
            createdTimeMap.put(activity.getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + activity.hashCode(), uptimeMillis());
        &#125;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> StartupTracer.onActivityFocused(Activity activity) &#123;
        <span class="hljs-comment">// ...</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWarmStartUp()) &#123;
            isWarmStartUp = <span class="hljs-literal">false</span>;
            <span class="hljs-type">long</span> <span class="hljs-variable">warmCost</span> <span class="hljs-operator">=</span> uptimeMillis() - lastCreateActivity;
            MatrixLog.i(TAG, <span class="hljs-string">&quot;#WarmStartup# activity:%s, warmCost:%d, now:%d, lastCreateActivity:%d&quot;</span>, activityName, warmCost, uptimeMillis(), lastCreateActivity);

            <span class="hljs-keyword">if</span> (warmCost &gt; <span class="hljs-number">0</span>) &#123;
                analyse(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, warmCost, <span class="hljs-literal">true</span>);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.wanandroid.com/blog/show/2937">ASM 入门</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dengshiwei/asm-module/blob/master/doc/blog/AOP%20%E5%88%A9%E5%99%A8%20ASM%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md">AOP 利器 ASM 基础入门</a></li>
<li><a target="_blank" rel="noopener" href="https://su18.org/post/Nlwq9S-Ru/">字节码及ASM入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/031b62d02607">Gradle Transform API 的基本使用</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">Matrix Android TraceCanary</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/APM/">#APM</a>
      
        <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#性能优化</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/07/koom/" title="KOOM - 利用子进程 dump hprof">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">KOOM - 利用子进程 dump hprof</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/23/matrix-resourcescanary/" title="Matrix - ResourcesCanary 浅析">
                        <span class="hidden-mobile">Matrix - ResourcesCanary 浅析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
