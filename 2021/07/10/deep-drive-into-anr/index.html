

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/favicon.png">
  <link rel="icon" href="/image/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#141414">
  <meta name="author" content="Cyrus">
  <meta name="keywords" content="">
  
    <meta name="description" content="overview在 阅读源码系列：ANR 是怎么产生的 聊过不及时消费 input event 会产生 ANR：  InputReaderThread 不断地从 &#x2F;dev&#x2F;input 读取 input event 并放入 InputDispatcher.mInboundQueue 等待分发 InputDispatcher 寻找 input event 对应的 window 并分发到它的待发送队列里">
<meta property="og:type" content="article">
<meta property="og:title" content="深入 ANR：产生的根源、处理流程和日志文件">
<meta property="og:url" content="https://www.dalvik.work/2021/07/10/deep-drive-into-anr/index.html">
<meta property="og:site_name" content="Cyrus Blog">
<meta property="og:description" content="overview在 阅读源码系列：ANR 是怎么产生的 聊过不及时消费 input event 会产生 ANR：  InputReaderThread 不断地从 &#x2F;dev&#x2F;input 读取 input event 并放入 InputDispatcher.mInboundQueue 等待分发 InputDispatcher 寻找 input event 对应的 window 并分发到它的待发送队列里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dalvik.work/image/2021-07-10-deep-drive-into-anr/proc_pressure_io_1.png">
<meta property="og:image" content="https://www.dalvik.work/image/2021-07-10-deep-drive-into-anr/proc_pressure_io_2.png">
<meta property="og:image" content="https://www.dalvik.work/image/2021-07-10-deep-drive-into-anr/data_anr_permission.png">
<meta property="og:image" content="https://www.dalvik.work/image/2021-07-10-deep-drive-into-anr/socket.jpg">
<meta property="og:image" content="https://www.dalvik.work/image/2021-07-10-deep-drive-into-anr/signal_catcher_thread.png">
<meta property="article:published_time" content="2021-07-10T04:00:00.000Z">
<meta property="article:modified_time" content="2023-03-30T10:46:21.965Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="anr">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.dalvik.work/image/2021-07-10-deep-drive-into-anr/proc_pressure_io_1.png">
  
  
  
  <title>深入 ANR：产生的根源、处理流程和日志文件 - Cyrus Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.dalvik.work","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#91cb3e","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":99},"lazyload":{"enable":true,"loading_img":"/image/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"7d0c9146781b5fb9ae68cfc826d0be54","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cyrus Land</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/sunset_sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">深入 ANR：产生的根源、处理流程和日志文件</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-07-10 04:00" pubdate>
          2021年7月10日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          111k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          928 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入 ANR：产生的根源、处理流程和日志文件</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>在 <a href="../../../../2020/10/20/anr/">阅读源码系列：ANR 是怎么产生的</a> 聊过不及时消费 input event 会产生 <code>ANR</code>：</p>
<ol>
<li><code>InputReaderThread</code> 不断地从 <code>/dev/input</code> 读取 input event 并放入 <code>InputDispatcher.mInboundQueue</code> 等待分发</li>
<li><code>InputDispatcher</code> 寻找 input event 对应的 window 并分发到它的待发送队列里（<code>outboundQueue</code>）</li>
<li>input event 通过 socket 发送给 app process 后转移到待消费队列（<code>waitQueue</code>）</li>
<li>app main thread 在 <code>Choreographer.doFrame</code> 渲染一帧时首先会响应 input event 并通过 socket 告诉 <code>InputDispatcher</code> 从待消费队列里移除</li>
<li>在执行第二步的过程中，如果发现 window 存在有未消费的 input event 则产生 ANR</li>
</ol>
<p><code>产生 ANR - 输出 ANR 日志 - 弹出 ANR 对话框</code> 整个流程的方法栈如下：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">InputDispatcher::start</span>
<span class="hljs-function">InputDispatcher::dispatchOnce</span>
<span class="hljs-function">InputDispatcher::processAnrsLocked</span>
<span class="hljs-function"><span class="hljs-title">InputDispatcher::onAnrLocked</span><span class="hljs-params">(<span class="hljs-type">const</span> Connection&amp; connection)</span></span>
<span class="hljs-function">InputDispatcher::doNotifyAnrLockedInterruptible</span>
<span class="hljs-function">NativeInputManager::notifyAnr</span>
<span class="hljs-function">InputManagerService.<span class="hljs-title">notifyANR</span><span class="hljs-params">(InputApplicationHandle inputApplicationHandle, IBinder token, String reason)</span></span>
<span class="hljs-function">InputManagerCallback.notifyANR</span>
<span class="hljs-function">InputManagerCallback.notifyANRInner</span>
<span class="hljs-function">ActivityManagerService.inputDispatchingTimedOut</span>
<span class="hljs-function">AnrHelper.appNotResponding</span>
<span class="hljs-function">AnrRecord.appNotResponding</span>
<span class="hljs-function">ProcessErrorStateRecord.appNotResponding</span>
<span class="hljs-function">ActivityManagerService.UiHandler.<span class="hljs-title">handleMessage</span><span class="hljs-params">(SHOW_NOT_RESPONDING_UI_MSG)</span></span>
<span class="hljs-function">AppErrors.handleShowAnrUi</span>
<span class="hljs-function">ProcessRecord.ErrorDialogController.showAnrDialogs</span></code></pre></div>

<h1 id="logcat-system"><a href="#logcat-system" class="headerlink" title="logcat system"></a>logcat system</h1><blockquote>
<p><code>adb logcat -v threadtime &gt; logcat</code></p>
<p><code>-b</code> 指定 ring buffer，默认是 <code>main</code>, <code>system</code> 和 <code>crash</code></p>
</blockquote>
<p>从上面的代码可以看到 logcat system 里会输出一段 ANR 日志如下，包含以下几部分的信息（它们的次序可能会有所变化）：</p>
<ol>
<li><code>ANR</code> 关键字</li>
<li>发生 ANR 的 app process name 及 android component name</li>
<li>app process id</li>
<li>原因/描述（看得出来这是由于没有及时消费 input event 而产生的 ANR）</li>
<li>parent component (?)</li>
<li><code>Load: 0.17 / 0.44 / 0.71</code> 读取自 <code>/proc/loadavg</code>，表示 1, 5 和 15 分钟内的系统平均负载</li>
<li>内存压力统计信息（Pressure Stall Information），读取自 <code>/proc/pressure/memory</code>，表示任务阻塞在内存资源上的总时长</li>
<li>最近几个采集点之间的 CPU 使用率（CPU Usage）</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs log"># from mi 9
09-29 16:03:03.457  1763 29602 E ActivityManager: ANR in com.example.myapplication (com.example.myapplication/.MainActivity)
09-29 16:03:03.457  1763 29602 E ActivityManager: PID: 27750
09-29 16:03:03.457  1763 29602 E ActivityManager: Reason: Input dispatching timed out (com.example.myapplication/com.example.myapplication.MainActivity, 23ec514 com.example.myapplication/com.example.myapplication.MainActivity (server) is not responding. Waited 8008ms for MotionEvent(action=DOWN))
09-29 16:03:03.457  1763 29602 E ActivityManager: Parent: com.example.myapplication/.MainActivity
09-29 16:03:03.457  1763 29602 E ActivityManager: Load: 0.17 / 0.44 / 0.71
09-29 16:03:03.457  1763 29602 E ActivityManager: ----- Output from /proc/pressure/memory -----
09-29 16:03:03.457  1763 29602 E ActivityManager: some avg10=0.00 avg60=0.00 avg300=0.02 total=32995625
09-29 16:03:03.457  1763 29602 E ActivityManager: full avg10=0.00 avg60=0.00 avg300=0.00 total=11591183
09-29 16:03:03.457  1763 29602 E ActivityManager: ----- End output from /proc/pressure/memory -----
09-29 16:03:03.457  1763 29602 E ActivityManager:
09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 0ms to 14680ms later (2021-09-29 16:02:48.726 to 2021-09-29 16:03:03.406):
09-29 16:03:03.457  1763 29602 E ActivityManager:   32% 8356/com.taobao.taobao: 17% user + 15% kernel / faults: 9334 minor 85 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   27% 19687/com.tencent.mm: 12% user + 15% kernel / faults: 14028 minor 129 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   13% 1763/system_server: 5.8% user + 7.5% kernel / faults: 7732 minor 29 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   12% 1464/media.codec: 8.5% user + 4.2% kernel / faults: 39180 minor 6 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   5.1% 969/surfaceflinger: 1.1% user + 3.9% kernel / faults: 582 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   4% 26354/com.xiaomi.mi_connect_service: 2.8% user + 1.1% kernel / faults: 2438 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1569/media.swcodec: 0% user + 0% kernel / faults: 21304 minor 8 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 876/media.hwcodec: 0% user + 0% kernel / faults: 6726 minor 20 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 23059/kworker/u16:10: 0% user + 2.3% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 5410/com.sohu.inputmethod.sogou: 1.3% user + 0.9% kernel / faults: 2961 minor 53 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   2% 2847/com.android.phone: 1.2% user + 0.7% kernel / faults: 2180 minor 12 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 1283/adbd: 0.5% user + 1.1% kernel / faults: 3 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 1362/cnss_diag: 1.3% user + 0.3% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.7% 22809/kworker/u16:2: 0% user + 1.7% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.2% 22965/kworker/u16:7: 0% user + 1.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1410/media.extractor: 0% user + 0% kernel / faults: 4053 minor 8 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   1% 2239/cds_ol_rx_threa: 0% user + 1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1% 21236/kworker/u16:3: 0% user + 1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.9% 22805/kworker/u16:1: 0% user + 0.9% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 150/kswapd0: 0% user + 0.8% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 582/logd: 0.4% user + 0.3% kernel / faults: 1 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 596/android.hardware.keymaster@4.0-service-qti: 0% user + 0.8% kernel / faults: 15 minor 4 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 795/android.hardware.camera.provider@2.4-service_64: 0% user + 0.8% kernel / faults: 74 minor 29 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 835/android.hardware.sensors@1.0-service: 0.4% user + 0.3% kernel / faults: 298 minor 15 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.8% 4647/com.android.nfc: 0.4% user + 0.3% kernel / faults: 1060 minor 4 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.7% 26974/com.miui.player: 0.2% user + 0.5% kernel / faults: 6 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 530/irq/303-fts: 0% user + 0.6% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 5337/com.miui.analytics: 0.2% user + 0.4% kernel / faults: 363 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.6% 23277/com.smile.gifmaker: 0.4% user + 0.2% kernel / faults: 119 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.5% 492/crtc_commit:131: 0% user + 0.5% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.5% 693/netd: 0.1% user + 0.4% kernel / faults: 208 minor 10 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 8387/com.taobao.taobao:channel: 0.3% user + 0.1% kernel / faults: 53 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 27750/com.example.myapplication: 0.4% user + 0% kernel / faults: 1733 minor 17 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 861/vendor.qti.hardware.perf@2.2-service: 0.1% user + 0.2% kernel / faults: 54 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.4% 27850/com.android.browser: 0.1% user + 0.2% kernel / faults: 117 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 9/rcu_preempt: 0% user + 0.3% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 21238/kworker/u16:13: 0% user + 0.3% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.3% 26155/mdnsd: 0.2% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 10/rcu_sched: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 842/android.hardware.wifi@1.0-service: 0.1% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 2457/com.android.systemui: 0.2% user + 0% kernel / faults: 80 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 25386/com.tencent.mm:appbrand0: 0.2% user + 0% kernel / faults: 20 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 26203/com.smile.gifmaker:messagesdk: 0.2% user + 0% kernel / faults: 11 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 26730/logcat: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 1/init: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 12/rcuop/0: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 13/rcuos/0: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 584/servicemanager: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 664/jbd2/sda31-8: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 685/tombstoned: 0% user + 0% kernel / faults: 26 minor 52 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 958/audioserver: 0% user + 0.1% kernel / faults: 89 minor 3 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 3509/irq/33-90cd000.: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.2% 18880/kworker/u16:4: 0% user + 0.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 22/rcuop/1: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 30/rcuop/2: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 46/rcuop/4: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 652/ipacm: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 653/android.system.suspend@1.0-service: 0.1% user + 0% kernel / faults: 70 minor 7 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 692/statsd: 0% user + 0.1% kernel / faults: 73 minor 2 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 794/android.hardware.bluetooth@1.0-service-qti: 0% user + 0% kernel / faults: 15 minor 13 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 815/android.hardware.gnss@2.1-service-qti: 0% user + 0% kernel / faults: 97 minor 17 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 821/android.hardware.health@2.1-service: 0% user + 0.1% kernel / faults: 33 minor 4 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 833/android.hardware.neuralnetworks@1.3-service-qti: 0% user + 0% kernel / faults: 108 minor 34 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 862/qrtr_rx: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1093/mi_thermald: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1371/cameraserver: 0% user + 0% kernel / faults: 46 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1388/keystore: 0% user + 0.1% kernel / faults: 252 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1436/mediaserver: 0% user + 0% kernel / faults: 42 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 1651/msm_irqbalance: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 3449/com.google.android.gms.persistent: 0.1% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 3507/irq/32-90b6400.: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 4583/tcpdump: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 4834/com.xiaomi.mircs: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 5105/com.tencent.wework: 0% user + 0% kernel / faults: 5 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 25408/com.tencent.mm:appbrand1: 0.1% user + 0% kernel / faults: 15 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0.1% 29363/kworker/0:2: 0% user + 0.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8/ksoftirqd/0: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 15/migration/0: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 31/rcuos/2: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 38/rcuop/3: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 39/rcuos/3: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 54/rcuop/5: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 70/rcuop/7: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 278/qseecom-unload-: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 370/irq/573-dma-gra: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 542/kworker/2:1H: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 556/ueventd: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 585/hwservicemanager: 0% user + 0% kernel / faults: 56 minor 8 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 626/vold: 0% user + 0% kernel / faults: 54 minor 1 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 740/kworker/3:1H: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 783/android.hardware.audio.service: 0% user + 0% kernel / faults: 65 minor 8 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 818/android.hardware.graphics.composer@2.4-service: 0% user + 0% kernel / faults: 215 minor 1 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1095/batteryd: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1272/wlan_logging_th: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1433/media.metrics: 0% user + 0% kernel / faults: 35 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1457/wificond: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1480/ipacm-diag: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1574/cnss-daemon: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1617/android.hardware.biometrics.fingerprint@2.1-service: 0% user + 0% kernel / faults: 24 minor 3 major
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1632/qcrild: 0% user + 0% kernel / faults: 3 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1644/hvdcp_opti: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1665/qcrild: 0% user + 0% kernel / faults: 3 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 1853/psimon: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 5514/com.miui.securitycenter.remote: 0% user + 0% kernel / faults: 21 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8782/com.miui.powerkeeper: 0% user + 0% kernel / faults: 23 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8829/com.taobao.taobao:sandboxed_privilege_process0: 0% user + 0% kernel / faults: 3 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 8985/com.taobao.taobao:remote: 0% user + 0% kernel / faults: 1 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 9034/cn.ticktick.task: 0% user + 0% kernel / faults: 1 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 13678/com.tencent.mm:toolsmp: 0% user + 0% kernel / faults: 17 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 13906/tv.danmaku.bili:download: 0% user + 0% kernel / faults: 2 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 14396/iptables-restore: 0% user + 0% kernel / faults: 10 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 14408/ip6tables-restore: 0% user + 0% kernel / faults: 1 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 26888/com.miui.player:remote: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 28950/kworker/1:0: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29260/com.miui.aod:settings: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29378/kworker/3:3: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29558/logcat: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   0% 29564/kworker/2:0: 0% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager: 19% TOTAL: 8% user + 9.2% kernel + 0.6% iowait + 0.9% irq + 0.4% softirq
09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 57ms to 615ms later (2021-09-29 16:02:48.783 to 2021-09-29 16:02:49.341):
09-29 16:03:03.457  1763 29602 E ActivityManager:   75% 1763/system_server: 27% user + 47% kernel / faults: 1442 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:     54% 29602/AnrConsumer: 15% user + 38% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:     15% 1772/HeapTaskDaemon: 13% user + 2.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.2% 1781/android.ui: 0% user + 2.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.2% 3385/Binder:1763_F: 0% user + 2.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   4% 835/android.hardware.sensors@1.0-service: 2% user + 2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   4.2% 969/surfaceflinger: 0% user + 4.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.1% 1040/Binder:969_1: 0% user + 2.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.1% 1214/app: 0% user + 2.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   4.2% 1362/cnss_diag: 4.2% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   5.7% 8356/com.taobao.taobao: 2.8% user + 2.8% kernel / faults: 7 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.8% 8356/m.taobao.taobao: 0% user + 2.8% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.8% 46/rcuop/4: 0% user + 1.8% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.8% 70/rcuop/7: 0% user + 1.8% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 492/crtc_commit:131: 0% user + 1.9% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 542/kworker/2:1H: 0% user + 1.9% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   1.9% 584/servicemanager: 0% user + 1.9% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.1% 1093/mi_thermald: 0% user + 2.1% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.2% 1665/qcrild: 0% user + 2.2% kernel / faults: 1 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 2239/cds_ol_rx_threa: 0% user + 2.3% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.3% 2847/com.android.phone: 2.3% user + 0% kernel / faults: 19 minor
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.3% 2847/m.android.phone: 2.3% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:     2.3% 3437/Binder:2847_A: 2.3% user + 0% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   2.4% 3509/irq/33-90cd000.: 0% user + 2.4% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   3.2% 19687/com.tencent.mm: 0% user + 3.2% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   3.3% 22965/kworker/u16:7: 0% user + 3.3% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager:   3.5% 26155/mdnsd: 0% user + 3.5% kernel
09-29 16:03:03.457  1763 29602 E ActivityManager: 15% TOTAL: 6.1% user + 7.5% kernel + 0.9% irq + 0.4% softirq</code></pre></div>

<p>上面的日志是在 <code>ProcessErrorStateRecord.appNotResponding</code> 输出的，<code>info</code> 是输出至 logcat system 的日志</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span>
<span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span>
<span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// Log the ANR to the main log.</span>
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        info.setLength(<span class="hljs-number">0</span>);
        info.append(<span class="hljs-string">&quot;ANR in &quot;</span>).append(mApp.processName);
        <span class="hljs-keyword">if</span> (activityShortComponentName != <span class="hljs-literal">null</span>) &#123;
            info.append(<span class="hljs-string">&quot; (&quot;</span>).append(activityShortComponentName).append(<span class="hljs-string">&quot;)&quot;</span>);
        &#125;
        info.append(<span class="hljs-string">&quot;\n&quot;</span>);
        info.append(<span class="hljs-string">&quot;PID: &quot;</span>).append(pid).append(<span class="hljs-string">&quot;\n&quot;</span>);
        <span class="hljs-keyword">if</span> (annotation != <span class="hljs-literal">null</span>) &#123;
            info.append(<span class="hljs-string">&quot;Reason: &quot;</span>).append(annotation).append(<span class="hljs-string">&quot;\n&quot;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (parentShortComponentName != <span class="hljs-literal">null</span>
                &amp;&amp; parentShortComponentName.equals(activityShortComponentName)) &#123;
            info.append(<span class="hljs-string">&quot;Parent: &quot;</span>).append(parentShortComponentName).append(<span class="hljs-string">&quot;\n&quot;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (errorId != <span class="hljs-literal">null</span>) &#123;
            info.append(<span class="hljs-string">&quot;ErrorId: &quot;</span>).append(errorId.toString()).append(<span class="hljs-string">&quot;\n&quot;</span>);
        &#125;
        info.append(<span class="hljs-string">&quot;Frozen: &quot;</span>).append(mApp.mOptRecord.isFrozen()).append(<span class="hljs-string">&quot;\n&quot;</span>);

        <span class="hljs-comment">// ...</span>

        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        report.append(MemoryPressureUtil.currentPsiState());
        <span class="hljs-type">ProcessCpuTracker</span> <span class="hljs-variable">processCpuTracker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessCpuTracker</span>(<span class="hljs-literal">true</span>);

        <span class="hljs-comment">// don&#x27;t dump native PIDs for background ANRs unless it is the process of interest</span>
        <span class="hljs-comment">// ...</span>

        <span class="hljs-comment">// For background ANRs, don&#x27;t pass the ProcessCpuTracker to</span>
        <span class="hljs-comment">// avoid spending 1/2 second collecting stats to rank lastPids.</span>
        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">tracesFileException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();
        <span class="hljs-comment">// To hold the start and end offset to the ANR trace file respectively.</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];
        <span class="hljs-type">File</span> <span class="hljs-variable">tracesFile</span> <span class="hljs-operator">=</span> ActivityManagerService.dumpStackTraces(firstPids,
                isSilentAnr ? <span class="hljs-literal">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-literal">null</span> : lastPids,
                nativePids, tracesFileException, offsets, annotation);

        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;
            mService.updateCpuStatsNow();
            mService.mAppProfiler.printCurrentCpuState(report, anrTime);
            info.append(processCpuTracker.printCurrentLoad());
            info.append(report);
        &#125;
        report.append(tracesFileException.getBuffer());
        info.append(processCpuTracker.printCurrentState(anrTime));
        Slog.e(TAG, info.toString());
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;</code></pre></div>

<h2 id="load-average"><a href="#load-average" class="headerlink" title="load average"></a>load average</h2><p>用进程数来描述 CPU 负载压力</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(...)</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;
            mService.updateCpuStatsNow();
            <span class="hljs-keyword">synchronized</span> (mService.mProcessCpuTracker) &#123;
                report.append(mService.mProcessCpuTracker.printCurrentState(anrTime));
            &#125;
            info.append(processCpuTracker.printCurrentLoad());  <span class="hljs-comment">// 这里输出系统平均负载</span>
            info.append(report);
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;

    <span class="hljs-comment">// 三个值分别对应 mLoad1, mLoad5 和 mLoad15</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printCurrentLoad</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();
        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastPrintWriter</span>(sw, <span class="hljs-literal">false</span>, <span class="hljs-number">128</span>);
        pw.print(<span class="hljs-string">&quot;Load: &quot;</span>);
        pw.print(mLoad1);
        pw.print(<span class="hljs-string">&quot; / &quot;</span>);
        pw.print(mLoad5);
        pw.print(<span class="hljs-string">&quot; / &quot;</span>);
        pw.println(mLoad15);
        pw.flush();
        <span class="hljs-keyword">return</span> sw.toString();
    &#125;    

    <span class="hljs-comment">// 这三个变量来自 /proc/loadavg</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[] loadAverages = mLoadAverageData;
        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/loadavg&quot;</span>, LOAD_AVERAGE_FORMAT,
                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, loadAverages)) &#123;
            <span class="hljs-type">float</span> <span class="hljs-variable">load1</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">0</span>];
            <span class="hljs-type">float</span> <span class="hljs-variable">load5</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">1</span>];
            <span class="hljs-type">float</span> <span class="hljs-variable">load15</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">2</span>];
            <span class="hljs-keyword">if</span> (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) &#123;
                mLoad1 = load1;
                mLoad5 = load5;
                mLoad15 = load15;
                onLoadChanged(load1, load5, load15);
            &#125;
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;</code></pre></div>

<blockquote>
<p>man proc.5</p>
<p>/proc/loadavg</p>
<p>The  first  three  fields in this file are load average figures giving the number of jobs in the run queue (state R) or waiting for disk I/O (state D) averaged over 1, 5, and 15 minutes.  They are the same as the load average numbers given by uptime(1) and other programs.  </p>
<p>The fourth field consists of two numbers separated by a slash (/).  The first of these is the number of currently  runnable  kernel  scheduling entities (processes, threads).  The value after the slash is the number of kernel scheduling entities that currently exist on the system.  </p>
<p>The fifth field is the PID of the process that was most recently created on the system.</p>
</blockquote>
<p>在绿联 6812（4 x <a href="mailto:&#65;&#x35;&#x33;&#x40;&#x31;&#46;&#53;&#x47;">&#65;&#x35;&#x33;&#x40;&#x31;&#46;&#53;&#x47;</a>）上获取的值是 <code>13.31 13.74 13.81 2/1167 3888</code></p>
<ul>
<li>在过去的 1, 5, 15 分钟内 CPU 的平均负载是 13.31, 13.74, 13.81</li>
<li>当前有 1167 个进程，其中有 2 个正在运行</li>
<li>最近创建的一个进程是 3888</li>
</ul>
<blockquote>
<p>在 Linux 系统中，uptime、w、top 等命令都会有系统平均负载 load average 的输出，系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数</p>
<p>如果一个进程满足以下条件则其就会位于运行队列中：它没有在等待 I/O 操作的结果，它没有主动进入等待状态(也就是没有调用’wait’)，没有被停止(例如：等待终止)</p>
<p>例如：<br><br>[root@opendigest root]# uptime <br><br>7:51pm up 2 days, 5:43, 2 users, load average: 8.13, 5.90, 4.94 <br><br>命令输出的最后内容表示在过去的 1、5、15 分钟内运行队列中的平均进程数量</p>
<p>一般来说只要每个 CPU 的当前活动进程数不大于 3 那么系统的性能就是良好的，如果每个 CPU 的任务数大于 5 那么就表示这台机器的性能有严重问题。对于上面的例子来说，假设系统有两个 CPU 那么其每个 CPU 的当前任务数为：8.13 / 2 = 4.065，这表示该系统的性能是可以接受的</p>
</blockquote>
<p>这么看来 <code>13.81 / 4 = 3.45</code> 这块绿联屏的性能还是可以接受的</p>
<h2 id="PSI-Pressure-Stall-Information"><a href="#PSI-Pressure-Stall-Information" class="headerlink" title="PSI (Pressure Stall Information)"></a>PSI (Pressure Stall Information)</h2><blockquote>
<p>Pressure Stall Information 提供了一种评估系统资源压力的方法。系统有三个基础资源：CPU、Memory 和 IO，无论这些资源配置如何增加，似乎永远无法满足软件的需求。一旦产生资源竞争，就有可能带来延迟增大，使用户体验到卡顿</p>
<p>如果没有一种相对准确的方法检测系统的资源压力程度，有两种后果：一种是资源使用者过度克制，没有充分使用系统资源；另一种是经常产生资源竞争，过度使用资源导致等待延迟过大。准确的检测方法可以帮忙资源使用者确定合适的工作量，同时也可以帮助系统制定高效的资源调度策略，最大化利用系统资源，最大化改善用户体验</p>
<p>Facebook 在 2018 年开源了一套解决重要计算集群管理问题的 Linux 内核组件和相关工具，PSI 是其中重要的资源度量工具，它提供了一种实时检测系统资源竞争程度的方法，以竞争等待时间的方式呈现，简单而准确地供用户以及资源调度者进行决策</p>
<p>在此之前，Linux 也有一些资源压力的评估方法，最具代表性的是 load average 和 vmpressure</p>
</blockquote>
<p>每类资源的压力信息都通过 proc 文件系统的独立文件来提供，路径为：<code>/proc/pressure/memory</code>，<code>/proc/pressure/cpu</code> 和 <code>/proc/pressure/io</code>，其中 /proc/pressure/io 输出格式如下：</p>
<div class="code-wrapper"><pre><code class="hljs log">some avg10=0.30 avg60=0.12 avg300=0.02 total=4170757
full avg10=0.12 avg60=0.05 avg300=0.01 total=1856503</code></pre></div>

<ul>
<li>avg10、avg60、avg300 分别代表 10s、60s、300s 的时间周期内的阻塞时间百分比</li>
<li>total 是总累计时间，以毫秒为单位</li>
<li>some 这一行，代表至少有一个任务在某个资源上阻塞的时间占比</li>
<li>full 这一行，代表所有的非 idle 任务同时被阻塞的时间占比，这期间 cpu 被完全浪费，会带来严重的性能问题</li>
</ul>
<p>我们以 IO 的 some 和 full 来举例说明，假设在 60 秒的时间段内，系统有两个 task，在 60 秒的周期内的运行情况如下图所示：</p>
<p><img src="../../../../image/2021-07-10-deep-drive-into-anr/proc_pressure_io_1.png" srcset="/image/loading.gif" lazyload alt="proc_pressure_io_1"></p>
<p>红色阴影部分表示任务由于等待 IO 资源而进入阻塞状态。Task A 和 Task B 同时阻塞的部分为 full，占比 16.66%；至少有一个任务阻塞（仅 Task B 阻塞的部分也计算入内）的部分为 some，占比 50%</p>
<p>some 和 full 都是在某一时间段内阻塞时间占比的总和，阻塞时间不一定连续，如下图所示：</p>
<p><img src="../../../../image/2021-07-10-deep-drive-into-anr/proc_pressure_io_2.png" srcset="/image/loading.gif" lazyload alt="proc_pressure_io_2"></p>
<p>IO 和 memory 都有 some 和 full 两个维度，那是因为的确有可能系统中的所有任务都阻塞在 IO 或者 memory 资源，同时 CPU 进入 idle 状态</p>
<p>但是 CPU 资源不可能出现这个情况：不可能全部的 runnable 的任务都等待 CPU 资源，至少有一个 runnable 任务会被调度器选中占有 CPU 资源，因此 CPU 资源没有 full 维度的 PSI 信息呈现</p>
<p>通过这些阻塞占比数据，我们可以看到短期以及中长期一段时间内各种资源的压力情况，可以较精确的确定时延抖动原因，并制定对应的负载管理策略</p>
<div class="code-wrapper"><pre><code class="hljs log">09-29 16:03:03.457  1763 29602 E ActivityManager: ----- Output from /proc/pressure/memory -----
09-29 16:03:03.457  1763 29602 E ActivityManager: some avg10=0.00 avg60=0.00 avg300=0.02 total=32995625
09-29 16:03:03.457  1763 29602 E ActivityManager: full avg10=0.00 avg60=0.00 avg300=0.00 total=11591183
09-29 16:03:03.457  1763 29602 E ActivityManager: ----- End output from /proc/pressure/memory -----</code></pre></div>

<p>现在我们来看看 anr logcat 里输出的 /proc/pressure/memory 内容，full 都为零说明任务同时阻塞在内存资源上的情况没有出现，some - avg300=0.02 表明在有任务阻塞在内存资源上 6s（300s * 0.02，注意这 6s 是总和，不一定是连续的）</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryPressureUtil</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FILE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/proc/pressure/memory&quot;</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MemoryPressure&quot;</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a stanza about memory PSI to add to a report.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">currentPsiState</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">final</span> StrictMode.<span class="hljs-type">ThreadPolicy</span> <span class="hljs-variable">savedPolicy</span> <span class="hljs-operator">=</span> StrictMode.allowThreadDiskReads();
        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">contents</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(FILE).exists()) &#123;
                contents.append(<span class="hljs-string">&quot;----- Output from /proc/pressure/memory -----\n&quot;</span>);
                contents.append(IoUtils.readFileAsString(FILE));
                contents.append(<span class="hljs-string">&quot;----- End output from /proc/pressure/memory -----\n\n&quot;</span>);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            Slog.e(TAG, <span class="hljs-string">&quot;Could not read &quot;</span> + FILE, e);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            StrictMode.setThreadPolicy(savedPolicy);
        &#125;
        <span class="hljs-keyword">return</span> contents.toString();
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MemoryPressureUtil</span><span class="hljs-params">()</span>&#123;&#125;
&#125;</code></pre></div>

<h2 id="CPU-usage"><a href="#CPU-usage" class="headerlink" title="CPU usage"></a>CPU usage</h2><p><code>ProcessCpuTracker</code> 顾名思义是用来跟踪进程 CPU 使用率的，它的数据是在 <code>ProcessCpuTracker.update()</code> 里采集的（<code>/proc/stat</code>, <code>/proc/[pid]/stat</code>），<code>mCurrentSampleTime</code> 是上一次执行 <code>ProcessCpuTracker.update()</code> 的时间（既是数据快照的时间，也是两次数据快照差值的结束时间），而 <code>mLastSampleTime</code> 是上上次执行 <code>ProcessCpuTracker.update()</code> 的时间（也是两次数据快照差值的开始时间），<code>now</code> 是发生 ANR 的时间，它们的关系有：</p>
<ol>
<li>如果是 <code>anr - mLastSampleTime - mCurrentSampleTime</code>，说明 ANR 发生在两次快照差值（统计时间段）之前，对应的是 <code>later</code></li>
<li>如果是 <code>mLastSampleTime - mCurrentSampleTime - anr</code>，说明 ANR 发生在两次快照差值（统计时间段）之后，对应的是 <code>ago</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs log">// 第一段 CPU Usage 是由 mService.mAppProfiler.printCurrentCpuState(report, anrTime) 打印出来的
09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 0ms to 14680ms later (2021-09-29 16:02:48.726 to 2021-09-29 16:03:03.406):
...
// 第二段 CPU Usage 是由 info.append(processCpuTracker.printCurrentState(anrTime)) 打印出来的
09-29 16:03:03.457  1763 29602 E ActivityManager: CPU usage from 57ms to 615ms later (2021-09-29 16:02:48.783 to 2021-09-29 16:02:49.341):
...</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span>
<span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span>
<span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">report</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        report.append(MemoryPressureUtil.currentPsiState());
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> (isMonitorCpuUsage()) &#123;
            mService.updateCpuStatsNow();
            mService.mAppProfiler.printCurrentCpuState(report, anrTime);
            info.append(processCpuTracker.printCurrentLoad());
            info.append(report);
        &#125;
        report.append(tracesFileException.getBuffer());
        info.append(processCpuTracker.printCurrentState(anrTime));
        Slog.e(TAG, info.toString());       <span class="hljs-comment">// info 是输出至 logcat system 的日志文本</span>
        <span class="hljs-comment">// ...</span>
    &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppProfiler</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCurrentCpuState</span><span class="hljs-params">(StringBuilder report, <span class="hljs-type">long</span> time)</span> &#123;
        <span class="hljs-keyword">synchronized</span> (mProcessCpuTracker) &#123;
            report.append(mProcessCpuTracker.printCurrentState(time));
        &#125;
    &#125;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printCurrentState</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);

        buildWorkingProcs();

        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();
        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastPrintWriter</span>(sw, <span class="hljs-literal">false</span>, <span class="hljs-number">1024</span>);

        pw.print(<span class="hljs-string">&quot;CPU usage from &quot;</span>);
        <span class="hljs-keyword">if</span> (now &gt; mLastSampleTime) &#123;
            pw.print(now-mLastSampleTime);
            pw.print(<span class="hljs-string">&quot;ms to &quot;</span>);
            pw.print(now-mCurrentSampleTime);
            pw.print(<span class="hljs-string">&quot;ms ago&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            pw.print(mLastSampleTime-now);
            pw.print(<span class="hljs-string">&quot;ms to &quot;</span>);
            pw.print(mCurrentSampleTime-now);
            pw.print(<span class="hljs-string">&quot;ms later&quot;</span>);
        &#125;
        pw.print(<span class="hljs-string">&quot; (&quot;</span>);
        pw.print(sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(mLastSampleWallTime)));
        pw.print(<span class="hljs-string">&quot; to &quot;</span>);
        pw.print(sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(mCurrentSampleWallTime)));
        pw.print(<span class="hljs-string">&quot;)&quot;</span>);

        <span class="hljs-type">long</span> <span class="hljs-variable">sampleTime</span> <span class="hljs-operator">=</span> mCurrentSampleTime - mLastSampleTime;
        <span class="hljs-type">long</span> <span class="hljs-variable">sampleRealTime</span> <span class="hljs-operator">=</span> mCurrentSampleRealTime - mLastSampleRealTime;
        <span class="hljs-type">long</span> <span class="hljs-variable">percAwake</span> <span class="hljs-operator">=</span> sampleRealTime &gt; <span class="hljs-number">0</span> ? ((sampleTime*<span class="hljs-number">100</span>) / sampleRealTime) : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (percAwake != <span class="hljs-number">100</span>) &#123;
            pw.print(<span class="hljs-string">&quot; with &quot;</span>);
            pw.print(percAwake);
            pw.print(<span class="hljs-string">&quot;% awake&quot;</span>);
        &#125;
        pw.println(<span class="hljs-string">&quot;:&quot;</span>);
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;</code></pre></div>

<h3 id="收集进程-proc-pid"><a href="#收集进程-proc-pid" class="headerlink" title="收集进程 /proc/[pid]"></a>收集进程 <code>/proc/[pid]</code></h3><p><code>Process.getPids(dir, array)</code> 遍历目录 <code>dir</code> （这里传入的是 <code>/proc</code>）下的条目，找到纯数字的条目（即为 <code>pid</code>）加入到 <code>array</code>（pid array），<code>array</code> 会复用，只有当 <code>pid</code> 的数量超过 <code>array</code> 容量时才分配新的数组</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Process.getPids(dir, array)</span>
<span class="hljs-comment">// 从 /proc 获取 pid 列表到 array</span>
<span class="hljs-function">jintArray <span class="hljs-title">android_os_Process_getPids</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span>
<span class="hljs-params"><span class="hljs-function">                                     jstring file <span class="hljs-comment">/* /proc */</span>, jintArray lastArray)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;

    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (file8 == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;

    DIR* dirp = <span class="hljs-built_in">opendir</span>(file8);

    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);

    <span class="hljs-keyword">if</span>(dirp == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;

    jsize curCount = <span class="hljs-number">0</span>;
    jint* curData = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span> (lastArray != <span class="hljs-literal">NULL</span>) &#123;
        curCount = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(lastArray);
        curData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(lastArray, <span class="hljs-number">0</span>);
    &#125;

    jint curPos = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span>* entry;
    <span class="hljs-keyword">while</span> ((entry=<span class="hljs-built_in">readdir</span>(dirp)) != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = entry-&gt;d_name;
        <span class="hljs-keyword">while</span> (*p) &#123;
            <span class="hljs-keyword">if</span> (*p &lt; <span class="hljs-string">&#x27;0&#x27;</span> || *p &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;
            p++;
        &#125;
        <span class="hljs-keyword">if</span> (*p != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

        <span class="hljs-type">char</span>* end;
        <span class="hljs-type">int</span> pid = <span class="hljs-built_in">strtol</span>(entry-&gt;d_name, &amp;end, <span class="hljs-number">10</span>);
        <span class="hljs-comment">//ALOGI(&quot;File %s pid=%d\n&quot;, entry-&gt;d_name, pid);</span>
        <span class="hljs-keyword">if</span> (curPos &gt;= curCount) &#123;
            jsize newCount = (curCount == <span class="hljs-number">0</span>) ? <span class="hljs-number">10</span> : (curCount*<span class="hljs-number">2</span>);
            jintArray newArray = env-&gt;<span class="hljs-built_in">NewIntArray</span>(newCount);
            <span class="hljs-keyword">if</span> (newArray == <span class="hljs-literal">NULL</span>) &#123;
                <span class="hljs-built_in">closedir</span>(dirp);
                <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            &#125;
            jint* newData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(newArray, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span>) &#123;
                <span class="hljs-built_in">memcpy</span>(newData, curData, <span class="hljs-built_in">sizeof</span>(jint)*curCount);
                env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(lastArray, curData, <span class="hljs-number">0</span>);
            &#125;
            lastArray = newArray;
            curCount = newCount;
            curData = newData;
        &#125;

        curData[curPos] = pid;
        curPos++;
    &#125;

    <span class="hljs-built_in">closedir</span>(dirp);

    <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span> &amp;&amp; curPos &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">qsort</span>(curData, curPos, <span class="hljs-built_in">sizeof</span>(jint), pid_compare);
    &#125;

    <span class="hljs-keyword">while</span> (curPos &lt; curCount) &#123;
        curData[curPos] = <span class="hljs-number">-1</span>;
        curPos++;
    &#125;

    <span class="hljs-keyword">if</span> (curData != <span class="hljs-literal">NULL</span>) &#123;
        env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(lastArray, curData, <span class="hljs-number">0</span>);
    &#125;

    <span class="hljs-keyword">return</span> lastArray;
&#125;</code></pre></div>

<h3 id="进程概览-proc-pid-stat"><a href="#进程概览-proc-pid-stat" class="headerlink" title="进程概览 /proc/[pid]/stat"></a>进程概览 <code>/proc/[pid]/stat</code></h3><p>在 MI 9 上通过 <code>cat /proc/8538/stat</code> 打印出的内容如下（8538 是通过 <code>ps -A | grep com.tencent.mm</code> 查找出的微信的 pid）：</p>
<div class="code-wrapper"><pre><code class="hljs shell">cepheus:/proc $ cat /proc/8538/stat
8538 (com.tencent.mm) S 690 690 0 0 -1 1077952832 2355958 1597 22562 6 39676 24386 2 1 20 0 209 0 464604 73654394880 26729 18446744073709551615 1 1 0 0 0 0 4608 4097 1073775868 0 0 0 17 0 0 0 2401 0 0 0 0 0 0 0 0 0 0</code></pre></div>

<p>一些重要字段的含义如下（来自 <code>man proc.5</code> 里的 <code>/proc/[pid]/stat</code> 章节）：</p>
<table>
<thead>
<tr>
<th>index</th>
<th>name</th>
<th>value</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>pid</td>
<td>8538</td>
<td>pid</td>
</tr>
<tr>
<td>1</td>
<td>comm</td>
<td>(com.tencent.mm)</td>
<td>command, The filename of the executable, 这里是包名</td>
</tr>
<tr>
<td>2</td>
<td>state</td>
<td>S</td>
<td>process state，进程状态：R - Running, S - Sleeping(interruptible), D - Waiting(uninterruptible), Z - Zombie …</td>
</tr>
<tr>
<td>3</td>
<td>ppid</td>
<td>690</td>
<td>父进程的 PID</td>
</tr>
<tr>
<td>4</td>
<td>pgrp</td>
<td>690</td>
<td>group ID</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>1077952832</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>minflt</td>
<td>2355958</td>
<td>minor page faults (which have not required loading a memory page from disk), 加载 CPU 指令时发生缺页错误，但指令以及加载至物理内存，只需将虚存映射到物理内存即可</td>
</tr>
<tr>
<td>10</td>
<td>cminflt</td>
<td>1597</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>majflt</td>
<td>22562</td>
<td>major page faults (which have required loading a memory page from disk), 同样是加载 CPU 指令时发生缺页错误，但此时需要从磁盘读取指令，比上面的情况要严重</td>
</tr>
<tr>
<td>12</td>
<td>cmajflt</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>utime</td>
<td>39676</td>
<td>Amount of time that this process has been scheduled in user mode, 进程运行在用户态的 CPU 时间</td>
</tr>
<tr>
<td>14</td>
<td>stime</td>
<td>24386</td>
<td>Amount of time that this process has been scheduled in kernel mode, 进程运行在内核态的 CPU 时间</td>
</tr>
<tr>
<td>15</td>
<td>cutime</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>cstime</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>priority</td>
<td>20</td>
<td>优先级（在创建进程的时候就设置好后续不能更改）</td>
</tr>
<tr>
<td>18</td>
<td>nice</td>
<td>0</td>
<td>进程最终优先级 = priorty + nice，nice 值可以在运行时动态修改</td>
</tr>
<tr>
<td>19</td>
<td>num_threads</td>
<td>209</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td></td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>starttime</td>
<td>464604</td>
<td>The time the process started after system boot, 进程的运行时间（是一个从系统启动时间开始算起的相对值）</td>
</tr>
<tr>
<td>22</td>
<td>vsize</td>
<td>73654394880</td>
<td>Virtual memory size in bytes</td>
</tr>
</tbody></table>
<blockquote>
<p>Linux 对于物理内存的管理方法</p>
<p>由 MMU 把物理内存分割成众多个 page，每个 page 是 4KB. 然后把 page 映射到进程的虚拟内存空间，CPU 在执行进程中的指令时以虚拟内存地址为基础，通过 map 映射进而找到物理内存中实际存放指令的地址</p>
<p>缺页错误 (page fault)</p>
<p>严格说这里指的是 major page fault，名字听起来挺严重，实际上并不是什么”错误”</p>
<p>大致是这样，一个程序可能占几 MB，但并不是所有的指令都要同时运行，有些是在初始化时运行，有些是在特定条件下才会去运行。因此 linux 并不会把所有的指令都从磁盘加载到物理内存，那么当 cpu 在执行指令时如果发现下一条要执行的指令不在物理内存时，就会 raise a page fault 通知 MMU 把下面要执行的指令从磁盘加载到物理内存中</p>
<p>还有另一种就是 minor fault</p>
<p>minor page fault 指的是要执行的指令实际上已经在物理内存，只是这个 page 没有映射到当前进程的虚拟内存，这时就会 raise a minor page fault 让 MMU 把这个 page 映射进当前进程的虚拟内存，因此 minor page fault 并不需要去访问磁盘</p>
<p>What a Swap?</p>
<p>当物理内存不够时，把一些物理内存 page 写入到磁盘以腾出一些空闲的 page 出来供进程使用，这就是 swap out；反过来说当 CPU 要执行的指令被发现已经 swap out 到了磁盘中，这时就需要从磁盘把这些指令再 swap in 到物理内存中让CPU去执行</p>
<p>swap in 和 swap out 的操作都是比较耗时的, 频繁的 swap in 和 swap out 操作很影响系统性能</p>
</blockquote>
<p><code>ProcessCpuTracker.update</code> 和 <code>ProcessCpuTracker.collectStats</code> 读取并解析 <code>/proc/[pid]/stat</code> 文件内容为 <code>Stats</code> 结构，保存在 <code>ProcessCpuTracker.mProcStats</code> 以供后续打印，它的重要字段有：</p>
<table>
<thead>
<tr>
<th>field</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>pid</td>
<td>进程 ID，来自 <code>/proc</code> 目录下的纯数字目录</td>
</tr>
<tr>
<td>name</td>
<td>进程名，来自 <code>/proc/[pid]/stat#comm</code></td>
</tr>
<tr>
<td>base_uptime</td>
<td>取自 <code>SystemClock.uptimeMillis()</code></td>
</tr>
<tr>
<td>base_utime</td>
<td>运行在用户态的 CPU 时间</td>
</tr>
<tr>
<td>base_stime</td>
<td>运行在核心态的 CPU 时间</td>
</tr>
<tr>
<td>base_majfaults</td>
<td>major page faults</td>
</tr>
<tr>
<td>base_minfaults</td>
<td>minor page faults</td>
</tr>
<tr>
<td>rel_uptime</td>
<td></td>
</tr>
<tr>
<td>rel_utime</td>
<td></td>
</tr>
<tr>
<td>rel_stime</td>
<td></td>
</tr>
<tr>
<td>rel_majfaults</td>
<td></td>
</tr>
<tr>
<td>rel_minfaults</td>
<td></td>
</tr>
</tbody></table>
<p>第一次遇到进程时（构造 <code>State</code>）将初始值填入 <code>base_xxx</code>，下次遇到进程时给 <code>rel_xxx</code> 赋值：<code>rel_xxx = [now] - base_xxx</code> 并更新 <code>base_xxx</code> 为当前值 <code>[now]</code>，也就是说 <code>base_xxx</code> 是当前快照而 <code>rel_xxx</code> 是当前与上一次快照的差值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Update: &quot;</span> + <span class="hljs-built_in">this</span>);

        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowUptime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowRealtime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowWallTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] sysCpu = mSystemCpuData;
        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/stat&quot;</span>, SYSTEM_CPU_FORMAT,
                <span class="hljs-literal">null</span>, sysCpu, <span class="hljs-literal">null</span>)) &#123;
            <span class="hljs-comment">// Total user time is user + nice time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">usertime</span> <span class="hljs-operator">=</span> (sysCpu[<span class="hljs-number">0</span>]+sysCpu[<span class="hljs-number">1</span>]) * mJiffyMillis;
            <span class="hljs-comment">// Total system time is simply system time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">systemtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">2</span>] * mJiffyMillis;
            <span class="hljs-comment">// Total idle time is simply idle time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">idletime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">3</span>] * mJiffyMillis;
            <span class="hljs-comment">// Total irq time is iowait + irq + softirq time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">iowaittime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">4</span>] * mJiffyMillis;
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">irqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">5</span>] * mJiffyMillis;
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">softirqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">6</span>] * mJiffyMillis;

            <span class="hljs-comment">// This code is trying to avoid issues with idle time going backwards,</span>
            <span class="hljs-comment">// but currently it gets into situations where it triggers most of the time. :(</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> || (usertime &gt;= mBaseUserTime &amp;&amp; systemtime &gt;= mBaseSystemTime
                    &amp;&amp; iowaittime &gt;= mBaseIoWaitTime &amp;&amp; irqtime &gt;= mBaseIrqTime
                    &amp;&amp; softirqtime &gt;= mBaseSoftIrqTime &amp;&amp; idletime &gt;= mBaseIdleTime)) &#123;
                mRelUserTime = (<span class="hljs-type">int</span>)(usertime - mBaseUserTime);
                mRelSystemTime = (<span class="hljs-type">int</span>)(systemtime - mBaseSystemTime);
                mRelIoWaitTime = (<span class="hljs-type">int</span>)(iowaittime - mBaseIoWaitTime);
                mRelIrqTime = (<span class="hljs-type">int</span>)(irqtime - mBaseIrqTime);
                mRelSoftIrqTime = (<span class="hljs-type">int</span>)(softirqtime - mBaseSoftIrqTime);
                mRelIdleTime = (<span class="hljs-type">int</span>)(idletime - mBaseIdleTime);
                mRelStatsAreGood = <span class="hljs-literal">true</span>;

                <span class="hljs-keyword">if</span> (DEBUG) &#123;
                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Total U:&quot;</span> + (sysCpu[<span class="hljs-number">0</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; N:&quot;</span> + (sysCpu[<span class="hljs-number">1</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; S:&quot;</span> + (sysCpu[<span class="hljs-number">2</span>]*mJiffyMillis) + <span class="hljs-string">&quot; I:&quot;</span> + (sysCpu[<span class="hljs-number">3</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; W:&quot;</span> + (sysCpu[<span class="hljs-number">4</span>]*mJiffyMillis) + <span class="hljs-string">&quot; Q:&quot;</span> + (sysCpu[<span class="hljs-number">5</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; O:&quot;</span> + (sysCpu[<span class="hljs-number">6</span>]*mJiffyMillis));
                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Rel U:&quot;</span> + mRelUserTime + <span class="hljs-string">&quot; S:&quot;</span> + mRelSystemTime
                          + <span class="hljs-string">&quot; I:&quot;</span> + mRelIdleTime + <span class="hljs-string">&quot; Q:&quot;</span> + mRelIrqTime);
                &#125;

                mBaseUserTime = usertime;
                mBaseSystemTime = systemtime;
                mBaseIoWaitTime = iowaittime;
                mBaseIrqTime = irqtime;
                mBaseSoftIrqTime = softirqtime;
                mBaseIdleTime = idletime;

            &#125; <span class="hljs-keyword">else</span> &#123;
                mRelUserTime = <span class="hljs-number">0</span>;
                mRelSystemTime = <span class="hljs-number">0</span>;
                mRelIoWaitTime = <span class="hljs-number">0</span>;
                mRelIrqTime = <span class="hljs-number">0</span>;
                mRelSoftIrqTime = <span class="hljs-number">0</span>;
                mRelIdleTime = <span class="hljs-number">0</span>;
                mRelStatsAreGood = <span class="hljs-literal">false</span>;
                Slog.w(TAG, <span class="hljs-string">&quot;/proc/stats has gone backwards; skipping CPU update&quot;</span>);
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;

        mLastSampleTime = mCurrentSampleTime;
        mCurrentSampleTime = nowUptime;
        mLastSampleRealTime = mCurrentSampleRealTime;
        mCurrentSampleRealTime = nowRealtime;
        mLastSampleWallTime = mCurrentSampleWallTime;
        mCurrentSampleWallTime = nowWallTime;

        <span class="hljs-keyword">final</span> StrictMode.<span class="hljs-type">ThreadPolicy</span> <span class="hljs-variable">savedPolicy</span> <span class="hljs-operator">=</span> StrictMode.allowThreadDiskReads();
        <span class="hljs-keyword">try</span> &#123;
            mCurPids = collectStats(<span class="hljs-string">&quot;/proc&quot;</span>, -<span class="hljs-number">1</span>, mFirst, mCurPids, mProcStats);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            StrictMode.setThreadPolicy(savedPolicy);
        &#125;

        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[] loadAverages = mLoadAverageData;
        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/loadavg&quot;</span>, LOAD_AVERAGE_FORMAT,
                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, loadAverages)) &#123;
            <span class="hljs-type">float</span> <span class="hljs-variable">load1</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">0</span>];
            <span class="hljs-type">float</span> <span class="hljs-variable">load5</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">1</span>];
            <span class="hljs-type">float</span> <span class="hljs-variable">load15</span> <span class="hljs-operator">=</span> loadAverages[<span class="hljs-number">2</span>];
            <span class="hljs-keyword">if</span> (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) &#123;
                mLoad1 = load1;
                mLoad5 = load5;
                mLoad15 = load15;
                onLoadChanged(load1, load5, load15);
            &#125;
        &#125;

        <span class="hljs-keyword">if</span> (DEBUG) Slog.i(TAG, <span class="hljs-string">&quot;*** TIME TO COLLECT STATS: &quot;</span>
                + (SystemClock.uptimeMillis()-mCurrentSampleTime));

        mWorkingProcsSorted = <span class="hljs-literal">false</span>;
        mFirst = <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] collectStats(String statsFile, <span class="hljs-type">int</span> parentPid, <span class="hljs-type">boolean</span> first,
            <span class="hljs-type">int</span>[] curPids, ArrayList&lt;Stats&gt; allProcs) &#123;

        <span class="hljs-type">int</span>[] pids = Process.getPids(statsFile, curPids);
        <span class="hljs-type">int</span> <span class="hljs-variable">NP</span> <span class="hljs-operator">=</span> (pids == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : pids.length;
        <span class="hljs-type">int</span> <span class="hljs-variable">NS</span> <span class="hljs-operator">=</span> allProcs.size();
        <span class="hljs-type">int</span> <span class="hljs-variable">curStatsIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NP; i++) &#123;
            <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> pids[i];
            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;
                NP = pid;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-type">Stats</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> curStatsIndex &lt; NS ? allProcs.get(curStatsIndex) : <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">if</span> (st != <span class="hljs-literal">null</span> &amp;&amp; st.pid == pid) &#123;
                <span class="hljs-comment">// Update an existing process...</span>
                st.added = <span class="hljs-literal">false</span>;
                st.working = <span class="hljs-literal">false</span>;
                curStatsIndex++;
                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Existing &quot;</span>
                        + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)
                        + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);

                <span class="hljs-keyword">if</span> (st.interesting) &#123;
                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">uptime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();

                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] procStats = mProcessStatsData;
                    <span class="hljs-keyword">if</span> (!Process.readProcFile(st.statFile.toString(),
                            PROCESS_STATS_FORMAT, <span class="hljs-literal">null</span>, procStats, <span class="hljs-literal">null</span>)) &#123;
                        <span class="hljs-keyword">continue</span>;
                    &#125;

                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">minfaults</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_MINOR_FAULTS];
                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">majfaults</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_MAJOR_FAULTS];
                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">utime</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_UTIME] * mJiffyMillis;
                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">stime</span> <span class="hljs-operator">=</span> procStats[PROCESS_STAT_STIME] * mJiffyMillis;

                    <span class="hljs-keyword">if</span> (utime == st.base_utime &amp;&amp; stime == st.base_stime) &#123;
                        st.rel_utime = <span class="hljs-number">0</span>;
                        st.rel_stime = <span class="hljs-number">0</span>;
                        st.rel_minfaults = <span class="hljs-number">0</span>;
                        st.rel_majfaults = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">if</span> (st.active) &#123;
                            st.active = <span class="hljs-literal">false</span>;
                        &#125;
                        <span class="hljs-keyword">continue</span>;
                    &#125;

                    <span class="hljs-keyword">if</span> (!st.active) &#123;
                        st.active = <span class="hljs-literal">true</span>;
                    &#125;

                    <span class="hljs-keyword">if</span> (parentPid &lt; <span class="hljs-number">0</span>) &#123;
                        getName(st, st.cmdlineFile);
                        <span class="hljs-keyword">if</span> (st.threadStats != <span class="hljs-literal">null</span>) &#123;
                            mCurThreadPids = collectStats(st.threadsDir, pid, <span class="hljs-literal">false</span>,
                                    mCurThreadPids, st.threadStats);
                        &#125;
                    &#125;

                    <span class="hljs-keyword">if</span> (DEBUG) Slog.v(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Stats changed &quot;</span> + st.name + <span class="hljs-string">&quot; pid=&quot;</span> + st.pid
                            + <span class="hljs-string">&quot; utime=&quot;</span> + utime + <span class="hljs-string">&quot;-&quot;</span> + st.base_utime
                            + <span class="hljs-string">&quot; stime=&quot;</span> + stime + <span class="hljs-string">&quot;-&quot;</span> + st.base_stime
                            + <span class="hljs-string">&quot; minfaults=&quot;</span> + minfaults + <span class="hljs-string">&quot;-&quot;</span> + st.base_minfaults
                            + <span class="hljs-string">&quot; majfaults=&quot;</span> + majfaults + <span class="hljs-string">&quot;-&quot;</span> + st.base_majfaults);

                    st.rel_uptime = uptime - st.base_uptime;
                    st.base_uptime = uptime;
                    st.rel_utime = (<span class="hljs-type">int</span>)(utime - st.base_utime);
                    st.rel_stime = (<span class="hljs-type">int</span>)(stime - st.base_stime);
                    st.base_utime = utime;
                    st.base_stime = stime;
                    st.rel_minfaults = (<span class="hljs-type">int</span>)(minfaults - st.base_minfaults);
                    st.rel_majfaults = (<span class="hljs-type">int</span>)(majfaults - st.base_majfaults);
                    st.base_minfaults = minfaults;
                    st.base_majfaults = majfaults;
                    st.working = <span class="hljs-literal">true</span>;
                &#125;

                <span class="hljs-keyword">continue</span>;
            &#125;

            <span class="hljs-keyword">if</span> (st == <span class="hljs-literal">null</span> || st.pid &gt; pid) &#123;
                <span class="hljs-comment">// We have a new process!</span>
                st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stats</span>(pid, parentPid, mIncludeThreads);
                allProcs.add(curStatsIndex, st);
                curStatsIndex++;
                NS++;
                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;New &quot;</span>
                        + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)
                        + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);

                <span class="hljs-keyword">final</span> String[] procStatsString = mProcessFullStatsStringData;
                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] procStats = mProcessFullStatsData;
                st.base_uptime = SystemClock.uptimeMillis();
                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> st.statFile.toString();
                <span class="hljs-comment">//Slog.d(TAG, &quot;Reading proc file: &quot; + path);</span>
                <span class="hljs-keyword">if</span> (Process.readProcFile(path, PROCESS_FULL_STATS_FORMAT, procStatsString,
                        procStats, <span class="hljs-literal">null</span>)) &#123;
                    <span class="hljs-comment">// This is a possible way to filter out processes that</span>
                    <span class="hljs-comment">// are actually kernel threads...  do we want to?  Some</span>
                    <span class="hljs-comment">// of them do use CPU, but there can be a *lot* that are</span>
                    <span class="hljs-comment">// not doing anything.</span>
                    st.vsize = procStats[PROCESS_FULL_STAT_VSIZE];
                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> || procStats[PROCESS_FULL_STAT_VSIZE] != <span class="hljs-number">0</span>) &#123;
                        st.interesting = <span class="hljs-literal">true</span>;
                        st.baseName = procStatsString[<span class="hljs-number">0</span>];
                        st.base_minfaults = procStats[PROCESS_FULL_STAT_MINOR_FAULTS];
                        st.base_majfaults = procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];
                        st.base_utime = procStats[PROCESS_FULL_STAT_UTIME] * mJiffyMillis;
                        st.base_stime = procStats[PROCESS_FULL_STAT_STIME] * mJiffyMillis;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        Slog.i(TAG, <span class="hljs-string">&quot;Skipping kernel process pid &quot;</span> + pid
                                + <span class="hljs-string">&quot; name &quot;</span> + procStatsString[<span class="hljs-number">0</span>]);
                        st.baseName = procStatsString[<span class="hljs-number">0</span>];
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    Slog.w(TAG, <span class="hljs-string">&quot;Skipping unknown process pid &quot;</span> + pid);
                    st.baseName = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;
                    st.base_utime = st.base_stime = <span class="hljs-number">0</span>;
                    st.base_minfaults = st.base_majfaults = <span class="hljs-number">0</span>;
                &#125;

                <span class="hljs-keyword">if</span> (parentPid &lt; <span class="hljs-number">0</span>) &#123;
                    getName(st, st.cmdlineFile);
                    <span class="hljs-keyword">if</span> (st.threadStats != <span class="hljs-literal">null</span>) &#123;
                        mCurThreadPids = collectStats(st.threadsDir, pid, <span class="hljs-literal">true</span>,
                                mCurThreadPids, st.threadStats);
                    &#125;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.interesting) &#123;
                    st.name = st.baseName;
                    st.nameWidth = onMeasureProcessName(st.name);
                &#125;

                <span class="hljs-keyword">if</span> (DEBUG) Slog.v(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Stats added &quot;</span> + st.name + <span class="hljs-string">&quot; pid=&quot;</span> + st.pid
                        + <span class="hljs-string">&quot; utime=&quot;</span> + st.base_utime + <span class="hljs-string">&quot; stime=&quot;</span> + st.base_stime
                        + <span class="hljs-string">&quot; minfaults=&quot;</span> + st.base_minfaults + <span class="hljs-string">&quot; majfaults=&quot;</span> + st.base_majfaults);

                st.rel_utime = <span class="hljs-number">0</span>;
                st.rel_stime = <span class="hljs-number">0</span>;
                st.rel_minfaults = <span class="hljs-number">0</span>;
                st.rel_majfaults = <span class="hljs-number">0</span>;
                st.added = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (!first &amp;&amp; st.interesting) &#123;
                    st.working = <span class="hljs-literal">true</span>;
                &#125;
                <span class="hljs-keyword">continue</span>;
            &#125;

            <span class="hljs-comment">// This process has gone away!</span>
            st.rel_utime = <span class="hljs-number">0</span>;
            st.rel_stime = <span class="hljs-number">0</span>;
            st.rel_minfaults = <span class="hljs-number">0</span>;
            st.rel_majfaults = <span class="hljs-number">0</span>;
            st.removed = <span class="hljs-literal">true</span>;
            st.working = <span class="hljs-literal">true</span>;
            allProcs.remove(curStatsIndex);
            NS--;
            <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Removed &quot;</span>
                    + (parentPid &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;process&quot;</span> : <span class="hljs-string">&quot;thread&quot;</span>)
                    + <span class="hljs-string">&quot; pid &quot;</span> + pid + <span class="hljs-string">&quot;: &quot;</span> + st);
            <span class="hljs-comment">// Decrement the loop counter so that we process the current pid</span>
            <span class="hljs-comment">// again the next time through the loop.</span>
            i--;
            <span class="hljs-keyword">continue</span>;
        &#125;

        <span class="hljs-keyword">while</span> (curStatsIndex &lt; NS) &#123;
            <span class="hljs-comment">// This process has gone away!</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">Stats</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> allProcs.get(curStatsIndex);
            st.rel_utime = <span class="hljs-number">0</span>;
            st.rel_stime = <span class="hljs-number">0</span>;
            st.rel_minfaults = <span class="hljs-number">0</span>;
            st.rel_majfaults = <span class="hljs-number">0</span>;
            st.removed = <span class="hljs-literal">true</span>;
            st.working = <span class="hljs-literal">true</span>;
            allProcs.remove(curStatsIndex);
            NS--;
            <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Removed pid &quot;</span> + st.pid + <span class="hljs-string">&quot;: &quot;</span> + st);
        &#125;

        <span class="hljs-keyword">return</span> pids;
    &#125;    
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">jboolean <span class="hljs-title">android_os_Process_readProcFile</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span>
<span class="hljs-params"><span class="hljs-function">        jstring file, jintArray format, jobjectArray outStrings,</span></span>
<span class="hljs-params"><span class="hljs-function">        jlongArray outLongs, jfloatArray outFloats)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span> || format == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> JNI_FALSE;
    &#125;

    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(file, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (file8 == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> JNI_FALSE;
    &#125;

    ::android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(open(file8, O_RDONLY | O_CLOEXEC))</span></span>;
    <span class="hljs-keyword">if</span> (!fd.<span class="hljs-built_in">ok</span>()) &#123;
        <span class="hljs-keyword">if</span> (kDebugProc) &#123;
            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Unable to open process file: %s\n&quot;</span>, file8);
        &#125;
        env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);
        <span class="hljs-keyword">return</span> JNI_FALSE;
    &#125;
    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(file, file8);

    <span class="hljs-comment">// Most proc files we read are small, so we only go through the</span>
    <span class="hljs-comment">// loop once and use the stack buffer.  We allocate a buffer big</span>
    <span class="hljs-comment">// enough for the whole file.</span>

    <span class="hljs-type">char</span> readBufferStack[kProcReadStackBufferSize];
    std::unique_ptr&lt;<span class="hljs-type">char</span>[]&gt; readBufferHeap;
    <span class="hljs-type">char</span>* readBuffer = &amp;readBufferStack[<span class="hljs-number">0</span>];
    <span class="hljs-type">ssize_t</span> readBufferSize = kProcReadStackBufferSize;
    <span class="hljs-type">ssize_t</span> numberBytesRead;
    <span class="hljs-keyword">for</span> (;;) &#123;
        <span class="hljs-comment">// By using pread, we can avoid an lseek to rewind the FD</span>
        <span class="hljs-comment">// before retry, saving a system call.</span>
        numberBytesRead = <span class="hljs-built_in">pread</span>(fd, readBuffer, readBufferSize, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (numberBytesRead &lt; <span class="hljs-number">0</span> &amp;&amp; errno == EINTR) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-keyword">if</span> (numberBytesRead &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (kDebugProc) &#123;
                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Unable to open process file: %s fd=%d\n&quot;</span>, file8, fd.<span class="hljs-built_in">get</span>());
            &#125;
            <span class="hljs-keyword">return</span> JNI_FALSE;
        &#125;
        <span class="hljs-keyword">if</span> (numberBytesRead &lt; readBufferSize) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">if</span> (readBufferSize &gt; std::numeric_limits&lt;<span class="hljs-type">ssize_t</span>&gt;::<span class="hljs-built_in">max</span>() / <span class="hljs-number">2</span>) &#123;
            <span class="hljs-keyword">if</span> (kDebugProc) &#123;
                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Proc file too big: %s fd=%d\n&quot;</span>, file8, fd.<span class="hljs-built_in">get</span>());
            &#125;
            <span class="hljs-keyword">return</span> JNI_FALSE;
        &#125;
        readBufferSize = std::<span class="hljs-built_in">max</span>(readBufferSize * <span class="hljs-number">2</span>,
                                  kProcReadMinHeapBufferSize);
        readBufferHeap.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// Free address space before getting more.</span>
        readBufferHeap = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">char</span>[]&gt;(readBufferSize);
        <span class="hljs-keyword">if</span> (!readBufferHeap) &#123;
            <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);
            <span class="hljs-keyword">return</span> JNI_FALSE;
        &#125;
        readBuffer = readBufferHeap.<span class="hljs-built_in">get</span>();
    &#125;

    <span class="hljs-comment">// parseProcLineArray below modifies the buffer while parsing!</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">android_os_Process_parseProcLineArray</span>(
        env, clazz, readBuffer, <span class="hljs-number">0</span>, numberBytesRead,
        format, outStrings, outLongs, outFloats);
&#125;

<span class="hljs-function">jboolean <span class="hljs-title">android_os_Process_parseProcLineArray</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span>
<span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">char</span>* buffer, jint startIndex, jint endIndex, jintArray format,</span></span>
<span class="hljs-params"><span class="hljs-function">        jobjectArray outStrings, jlongArray outLongs, jfloatArray outFloats)</span></span>
<span class="hljs-function"></span>&#123;

    <span class="hljs-type">const</span> jsize NF = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(format);
    <span class="hljs-type">const</span> jsize NS = outStrings ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outStrings) : <span class="hljs-number">0</span>;
    <span class="hljs-type">const</span> jsize NL = outLongs ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outLongs) : <span class="hljs-number">0</span>;
    <span class="hljs-type">const</span> jsize NR = outFloats ? env-&gt;<span class="hljs-built_in">GetArrayLength</span>(outFloats) : <span class="hljs-number">0</span>;

    jint* formatData = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(format, <span class="hljs-number">0</span>);
    jlong* longsData = outLongs ?
        env-&gt;<span class="hljs-built_in">GetLongArrayElements</span>(outLongs, <span class="hljs-number">0</span>) : <span class="hljs-literal">NULL</span>;
    jfloat* floatsData = outFloats ?
        env-&gt;<span class="hljs-built_in">GetFloatArrayElements</span>(outFloats, <span class="hljs-number">0</span>) : <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span> (formatData == <span class="hljs-literal">NULL</span> || (NL &gt; <span class="hljs-number">0</span> &amp;&amp; longsData == <span class="hljs-literal">NULL</span>)
            || (NR &gt; <span class="hljs-number">0</span> &amp;&amp; floatsData == <span class="hljs-literal">NULL</span>)) &#123;
        <span class="hljs-keyword">if</span> (formatData != <span class="hljs-literal">NULL</span>) &#123;
            env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(format, formatData, <span class="hljs-number">0</span>);
        &#125;
        <span class="hljs-keyword">if</span> (longsData != <span class="hljs-literal">NULL</span>) &#123;
            env-&gt;<span class="hljs-built_in">ReleaseLongArrayElements</span>(outLongs, longsData, <span class="hljs-number">0</span>);
        &#125;
        <span class="hljs-keyword">if</span> (floatsData != <span class="hljs-literal">NULL</span>) &#123;
            env-&gt;<span class="hljs-built_in">ReleaseFloatArrayElements</span>(outFloats, floatsData, <span class="hljs-number">0</span>);
        &#125;
        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> JNI_FALSE;
    &#125;

    jsize i = startIndex;
    jsize di = <span class="hljs-number">0</span>;

    jboolean res = JNI_TRUE;

    <span class="hljs-keyword">for</span> (jsize fi=<span class="hljs-number">0</span>; fi&lt;NF; fi++) &#123;
        jint mode = formatData[fi];
        <span class="hljs-keyword">if</span> ((mode&amp;PROC_PARENS) != <span class="hljs-number">0</span>) &#123;
            i++;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode&amp;PROC_QUOTES) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (buffer[i] == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;
                i++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                mode &amp;= ~PROC_QUOTES;
            &#125;
        &#125;
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> term = (<span class="hljs-type">char</span>)(mode&amp;PROC_TERM_MASK);
        <span class="hljs-type">const</span> jsize start = i;
        <span class="hljs-keyword">if</span> (i &gt;= endIndex) &#123;
            <span class="hljs-keyword">if</span> (kDebugProc) &#123;
                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Ran off end of data @%d&quot;</span>, i);
            &#125;
            res = JNI_FALSE;
            <span class="hljs-keyword">break</span>;
        &#125;

        jsize end = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span> ((mode&amp;PROC_PARENS) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] != <span class="hljs-string">&#x27;)&#x27;</span>) &#123;
                i++;
            &#125;
            end = i;
            i++;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode&amp;PROC_QUOTES) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">while</span> (buffer[i] != <span class="hljs-string">&#x27;&quot;&#x27;</span> &amp;&amp; i &lt; endIndex) &#123;
                i++;
            &#125;
            end = i;
            i++;
        &#125;
        <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] != term) &#123;
            i++;
        &#125;
        <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;
            end = i;
        &#125;

        <span class="hljs-keyword">if</span> (i &lt; endIndex) &#123;
            i++;
            <span class="hljs-keyword">if</span> ((mode&amp;PROC_COMBINE) != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">while</span> (i &lt; endIndex &amp;&amp; buffer[i] == term) &#123;
                    i++;
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">//ALOGI(&quot;Field %&quot; PRId32 &quot;: %&quot; PRId32 &quot;-%&quot; PRId32 &quot; dest=%&quot; PRId32 &quot; mode=0x%&quot; PRIx32 &quot;\n&quot;, i, start, end, di, mode);</span>

        <span class="hljs-keyword">if</span> ((mode&amp;(PROC_OUT_FLOAT|PROC_OUT_LONG|PROC_OUT_STRING)) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">char</span> c = buffer[end];
            buffer[end] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_FLOAT) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NR) &#123;
                <span class="hljs-type">char</span>* end;
                floatsData[di] = <span class="hljs-built_in">strtof</span>(buffer+start, &amp;end);
            &#125;
            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_LONG) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NL) &#123;
                <span class="hljs-keyword">if</span> ((mode&amp;PROC_CHAR) != <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-comment">// Caller wants single first character returned as one long.</span>
                    longsData[di] = buffer[start];
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-type">char</span>* end;
                    longsData[di] = <span class="hljs-built_in">strtoll</span>(buffer+start, &amp;end, <span class="hljs-number">10</span>);
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> ((mode&amp;PROC_OUT_STRING) != <span class="hljs-number">0</span> &amp;&amp; di &lt; NS) &#123;
                jstring str = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(buffer+start);
                env-&gt;<span class="hljs-built_in">SetObjectArrayElement</span>(outStrings, di, str);
            &#125;
            buffer[end] = c;
            di++;
        &#125;
    &#125;

    env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(format, formatData, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (longsData != <span class="hljs-literal">NULL</span>) &#123;
        env-&gt;<span class="hljs-built_in">ReleaseLongArrayElements</span>(outLongs, longsData, <span class="hljs-number">0</span>);
    &#125;
    <span class="hljs-keyword">if</span> (floatsData != <span class="hljs-literal">NULL</span>) &#123;
        env-&gt;<span class="hljs-built_in">ReleaseFloatArrayElements</span>(outFloats, floatsData, <span class="hljs-number">0</span>);
    &#125;

    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div>

<h3 id="CPU-概览-proc-stat"><a href="#CPU-概览-proc-stat" class="headerlink" title="CPU 概览 /proc/stat"></a>CPU 概览 <code>/proc/stat</code></h3><p><code>ProcessCpuTracker.update()</code> 同时也从 <code>/proc/stat</code> 收集了某个时间段内总的 CPU 时间用以计算各进程的 CPU 使用率；下面是从 MI 9 上获取的 <code>/proc/stat</code> 文件内容，看得出来它有八个核心（骁龙 855），CPU 时间的单位为 <code>jiffies</code>，各字段的含义如下：</p>
<blockquote>
<p><code>jiffies</code> 是内核中的一个全局变量，用来记录自系统启动以来产生的 <strong>节拍数</strong>，在 linux 中一个节拍大致可理解为操作系统进程调度的最小时间片，不同 linux 内核可能值有不同，通常在 1ms 到 10ms 之间</p>
</blockquote>
<table>
<thead>
<tr>
<th>index</th>
<th>name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>user</td>
<td>处于用户态的运行时间（nice &lt;= 0 的进程）</td>
</tr>
<tr>
<td>1</td>
<td>nice</td>
<td>处于用户态的运行时间（nice &gt; 0 的进程）</td>
</tr>
<tr>
<td>2</td>
<td>system</td>
<td>处于核心态的运行时间</td>
</tr>
<tr>
<td>3</td>
<td>idle</td>
<td>除 IO 等待时间以外的其它等待时间</td>
</tr>
<tr>
<td>4</td>
<td>iowait</td>
<td>IO等待时间</td>
</tr>
<tr>
<td>5</td>
<td>irq</td>
<td>硬中断时间</td>
</tr>
<tr>
<td>6</td>
<td>softirq</td>
<td>软中断时间</td>
</tr>
<tr>
<td>7</td>
<td>steal</td>
<td>被盗时间，虚拟化环境中运行其他操作系统上花费的时间（since Linux 2.6.11）</td>
</tr>
<tr>
<td>8</td>
<td>guest</td>
<td>来宾时间，操作系统运行虚拟CPU花费的时间(since Linux 2.6.24)</td>
</tr>
<tr>
<td>9</td>
<td>guest_nice</td>
<td>nice 来宾时间，运行一个带 nice 值的 guest 花费的时间(since Linux 2.6.33)</td>
</tr>
</tbody></table>
<p>可以看到跟 <code>进程概览</code> 一样，<code>mBaseXxxTime</code> 记录的是当前值，<code>mRelXxxTime</code> 记录的是当前与上一次的差值</p>
<div class="code-wrapper"><pre><code class="hljs shell">cepheus:/ $ cat /proc/stat
cpu  1908033 248762 1291479 9313559 21704 241034 75778 0 0 0
cpu0 261151 61609 246778 2138176 9728 89991 29646 0 0 0
cpu1 280460 61787 257071 884928 2710 43158 18528 0 0 0
cpu2 280724 62167 252355 892787 2211 44246 9462 0 0 0
cpu3 184034 10677 205483 975756 2070 33267 12197 0 0 0
cpu4 283943 16128 102688 1078345 1403 9754 1747 0 0 0
cpu5 289844 13063 106131 1078167 1614 10022 1788 0 0 0
cpu6 292748 12779 104992 1080547 1446 9863 1902 0 0 0
cpu7 35125 10548 15978 1184849 520 730 504 0 0 0
intr 195962347 0 0 0 0 26288625 0 2879495 0 2097574 0 0 0 0 280 76 0 11 0 2 0 199 0 2 0 2 92 0 0 2 30 0 0 390294 340099 0 35976 0 0 0 0 0 0 0 0 0 0 0 138 0 0 0 0 0 0 0 1 0 147 0 102 0 0 66880 0 0 0 0 0 0 6032 0 0 0 0 0 0 0 0 0 0 0 0 0 212 0 0 0 0 0 0 0 0 0 0 0 0 5551 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2308413 6080542 16668 0 0 29 0 0 0 0 0 0 0 2938 1213 12 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3135 0 0 0 0 0 0 0 0 0 0 0 0 467941 0 0 0 0 0 0 0 0 0 0 0 16029 443134 6 192353 303384 26156 0 0 0 0 0 226499 103608 771093 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 498 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 153671 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 4 52028 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 65667 0 77 0 0 0 0 0 0 0 330476 0 0 0 0 1342751 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 0 1 0 1 0 0 0 25847 0 0 72 0 0 0 527 4 0 2 2 0 0 3 0 0 5 0 0 0 0 0 62695 0 0 0 0 0 23 0 0 0 0 0 0 0 0 4 2 0 7 0 0 0 0 0 0 0 6 7 7 0 7 0 30 351 0 0 0 0 0 0 0 0 0 7 0 0 7 0 0 1034 504 0 760 2 0 0 1 0 0 0 0 0 0 0 0 22385 1250 4578494 1293217 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 455534 0 0 23167
ctxt 292922052
btime 1634510913
processes 215684
procs_running 1
procs_blocked 0
softirq 28955158 6101535 6564415 106706 1458910 1999704 0 1242328 6001922 0 5479638</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (DEBUG) Slog.v(TAG, <span class="hljs-string">&quot;Update: &quot;</span> + <span class="hljs-built_in">this</span>);

        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowUptime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowRealtime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nowWallTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] sysCpu = mSystemCpuData;
        <span class="hljs-keyword">if</span> (Process.readProcFile(<span class="hljs-string">&quot;/proc/stat&quot;</span>, SYSTEM_CPU_FORMAT,
                <span class="hljs-literal">null</span>, sysCpu, <span class="hljs-literal">null</span>)) &#123;
            <span class="hljs-comment">// Total user time is user + nice time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">usertime</span> <span class="hljs-operator">=</span> (sysCpu[<span class="hljs-number">0</span>]+sysCpu[<span class="hljs-number">1</span>]) * mJiffyMillis;
            <span class="hljs-comment">// Total system time is simply system time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">systemtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">2</span>] * mJiffyMillis;
            <span class="hljs-comment">// Total idle time is simply idle time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">idletime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">3</span>] * mJiffyMillis;
            <span class="hljs-comment">// Total irq time is iowait + irq + softirq time.</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">iowaittime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">4</span>] * mJiffyMillis;
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">irqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">5</span>] * mJiffyMillis;
            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">softirqtime</span> <span class="hljs-operator">=</span> sysCpu[<span class="hljs-number">6</span>] * mJiffyMillis;

            <span class="hljs-comment">// This code is trying to avoid issues with idle time going backwards,</span>
            <span class="hljs-comment">// but currently it gets into situations where it triggers most of the time. :(</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span> || (usertime &gt;= mBaseUserTime &amp;&amp; systemtime &gt;= mBaseSystemTime
                    &amp;&amp; iowaittime &gt;= mBaseIoWaitTime &amp;&amp; irqtime &gt;= mBaseIrqTime
                    &amp;&amp; softirqtime &gt;= mBaseSoftIrqTime &amp;&amp; idletime &gt;= mBaseIdleTime)) &#123;
                mRelUserTime = (<span class="hljs-type">int</span>)(usertime - mBaseUserTime);
                mRelSystemTime = (<span class="hljs-type">int</span>)(systemtime - mBaseSystemTime);
                mRelIoWaitTime = (<span class="hljs-type">int</span>)(iowaittime - mBaseIoWaitTime);
                mRelIrqTime = (<span class="hljs-type">int</span>)(irqtime - mBaseIrqTime);
                mRelSoftIrqTime = (<span class="hljs-type">int</span>)(softirqtime - mBaseSoftIrqTime);
                mRelIdleTime = (<span class="hljs-type">int</span>)(idletime - mBaseIdleTime);
                mRelStatsAreGood = <span class="hljs-literal">true</span>;

                <span class="hljs-keyword">if</span> (DEBUG) &#123;
                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Total U:&quot;</span> + (sysCpu[<span class="hljs-number">0</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; N:&quot;</span> + (sysCpu[<span class="hljs-number">1</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; S:&quot;</span> + (sysCpu[<span class="hljs-number">2</span>]*mJiffyMillis) + <span class="hljs-string">&quot; I:&quot;</span> + (sysCpu[<span class="hljs-number">3</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; W:&quot;</span> + (sysCpu[<span class="hljs-number">4</span>]*mJiffyMillis) + <span class="hljs-string">&quot; Q:&quot;</span> + (sysCpu[<span class="hljs-number">5</span>]*mJiffyMillis)
                          + <span class="hljs-string">&quot; O:&quot;</span> + (sysCpu[<span class="hljs-number">6</span>]*mJiffyMillis));
                    Slog.i(<span class="hljs-string">&quot;Load&quot;</span>, <span class="hljs-string">&quot;Rel U:&quot;</span> + mRelUserTime + <span class="hljs-string">&quot; S:&quot;</span> + mRelSystemTime
                          + <span class="hljs-string">&quot; I:&quot;</span> + mRelIdleTime + <span class="hljs-string">&quot; Q:&quot;</span> + mRelIrqTime);
                &#125;

                mBaseUserTime = usertime;
                mBaseSystemTime = systemtime;
                mBaseIoWaitTime = iowaittime;
                mBaseIrqTime = irqtime;
                mBaseSoftIrqTime = softirqtime;
                mBaseIdleTime = idletime;

            &#125; <span class="hljs-keyword">else</span> &#123;
                mRelUserTime = <span class="hljs-number">0</span>;
                mRelSystemTime = <span class="hljs-number">0</span>;
                mRelIoWaitTime = <span class="hljs-number">0</span>;
                mRelIrqTime = <span class="hljs-number">0</span>;
                mRelSoftIrqTime = <span class="hljs-number">0</span>;
                mRelIdleTime = <span class="hljs-number">0</span>;
                mRelStatsAreGood = <span class="hljs-literal">false</span>;
                Slog.w(TAG, <span class="hljs-string">&quot;/proc/stats has gone backwards; skipping CPU update&quot;</span>);
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;

        mLastSampleTime = mCurrentSampleTime;
        mCurrentSampleTime = nowUptime;
        mLastSampleRealTime = mCurrentSampleRealTime;
        mCurrentSampleRealTime = nowRealtime;
        mLastSampleWallTime = mCurrentSampleWallTime;
        mCurrentSampleWallTime = nowWallTime;
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;</code></pre></div>

<h3 id="打印进程概览"><a href="#打印进程概览" class="headerlink" title="打印进程概览"></a>打印进程概览</h3><p><code>printProcessCPU(prefix, pid, label, totalTime, user, system, iowait, irg, softIrq, minFaults, majFaults)</code> 打印出一行的 CPU 使用率（一行对应一个进程）</p>
<p><code>ProcessCpuTracker.printCurrentState</code> 会输出两类 CPU 使用率：</p>
<ol>
<li>在进程生存的时间段内（<code>SystemClock.uptimeMillis()</code>），分配给进程的 CPU 时间的占比，细分用户态和内核态</li>
<li>在两个采集点（<code>ProcessCpuTracker.update</code>）之间的时间段内，CPU 的整体使用率（idle time 表示空闲）</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs log">[prefix][(user + system + iowait + irq + softIrq) / totalTime]% [pid]/[label]: 
[user/totalTime]% user + [system/totalTime]% kernel + [iowait/totalTime]% iowait + [irq/totalTime]% irq + [softirq/totalTime]% softirq / faults: [minFaults] minor [majFaults] major

32% 8356/com.taobao.taobao: 17% user + 15% kernel / faults: 9334 minor 85 major
19% TOTAL: 8% user + 9.2% kernel + 0.6% iowait + 0.9% irq + 0.4% softirq</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">printCurrentState</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">totalTime</span> <span class="hljs-operator">=</span> mRelUserTime + mRelSystemTime + mRelIoWaitTime
                + mRelIrqTime + mRelSoftIrqTime + mRelIdleTime;

        <span class="hljs-keyword">if</span> (DEBUG) Slog.i(TAG, <span class="hljs-string">&quot;totalTime &quot;</span> + totalTime + <span class="hljs-string">&quot; over sample time &quot;</span>
                + (mCurrentSampleTime-mLastSampleTime));

        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> mWorkingProcs.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;
            <span class="hljs-type">Stats</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> mWorkingProcs.get(i);
            printProcessCPU(pw, st.added ? <span class="hljs-string">&quot; +&quot;</span> : (st.removed ? <span class="hljs-string">&quot; -&quot;</span>: <span class="hljs-string">&quot;  &quot;</span>),
                    st.pid, st.name, (<span class="hljs-type">int</span>)st.rel_uptime,
                    st.rel_utime, st.rel_stime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, st.rel_minfaults, st.rel_majfaults);
            <span class="hljs-keyword">if</span> (!st.removed &amp;&amp; st.workingThreads != <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> st.workingThreads.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;M; j++) &#123;
                    <span class="hljs-type">Stats</span> <span class="hljs-variable">tst</span> <span class="hljs-operator">=</span> st.workingThreads.get(j);
                    printProcessCPU(pw,
                            tst.added ? <span class="hljs-string">&quot;   +&quot;</span> : (tst.removed ? <span class="hljs-string">&quot;   -&quot;</span>: <span class="hljs-string">&quot;    &quot;</span>),
                            tst.pid, tst.name, (<span class="hljs-type">int</span>)st.rel_uptime,
                            tst.rel_utime, tst.rel_stime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
                &#125;
            &#125;
        &#125;

        printProcessCPU(pw, <span class="hljs-string">&quot;&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;TOTAL&quot;</span>, totalTime, mRelUserTime, mRelSystemTime,
                mRelIoWaitTime, mRelIrqTime, mRelSoftIrqTime, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

        pw.flush();
        <span class="hljs-keyword">return</span> sw.toString();
    &#125;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessCpuTracker</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcessCPU</span><span class="hljs-params">(PrintWriter pw, String prefix, <span class="hljs-type">int</span> pid, String label,</span>
<span class="hljs-params">            <span class="hljs-type">int</span> totalTime, <span class="hljs-type">int</span> user, <span class="hljs-type">int</span> system, <span class="hljs-type">int</span> iowait, <span class="hljs-type">int</span> irq, <span class="hljs-type">int</span> softIrq,</span>
<span class="hljs-params">            <span class="hljs-type">int</span> minFaults, <span class="hljs-type">int</span> majFaults)</span> &#123;
        pw.print(prefix);
        <span class="hljs-keyword">if</span> (totalTime == <span class="hljs-number">0</span>) totalTime = <span class="hljs-number">1</span>;
        printRatio(pw, user+system+iowait+irq+softIrq, totalTime);
        pw.print(<span class="hljs-string">&quot;% &quot;</span>);
        <span class="hljs-keyword">if</span> (pid &gt;= <span class="hljs-number">0</span>) &#123;
            pw.print(pid);
            pw.print(<span class="hljs-string">&quot;/&quot;</span>);
        &#125;
        pw.print(label);
        pw.print(<span class="hljs-string">&quot;: &quot;</span>);
        printRatio(pw, user, totalTime);
        pw.print(<span class="hljs-string">&quot;% user + &quot;</span>);
        printRatio(pw, system, totalTime);
        pw.print(<span class="hljs-string">&quot;% kernel&quot;</span>);
        <span class="hljs-keyword">if</span> (iowait &gt; <span class="hljs-number">0</span>) &#123;
            pw.print(<span class="hljs-string">&quot; + &quot;</span>);
            printRatio(pw, iowait, totalTime);
            pw.print(<span class="hljs-string">&quot;% iowait&quot;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (irq &gt; <span class="hljs-number">0</span>) &#123;
            pw.print(<span class="hljs-string">&quot; + &quot;</span>);
            printRatio(pw, irq, totalTime);
            pw.print(<span class="hljs-string">&quot;% irq&quot;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (softIrq &gt; <span class="hljs-number">0</span>) &#123;
            pw.print(<span class="hljs-string">&quot; + &quot;</span>);
            printRatio(pw, softIrq, totalTime);
            pw.print(<span class="hljs-string">&quot;% softirq&quot;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (minFaults &gt; <span class="hljs-number">0</span> || majFaults &gt; <span class="hljs-number">0</span>) &#123;
            pw.print(<span class="hljs-string">&quot; / faults:&quot;</span>);
            <span class="hljs-keyword">if</span> (minFaults &gt; <span class="hljs-number">0</span>) &#123;
                pw.print(<span class="hljs-string">&quot; &quot;</span>);
                pw.print(minFaults);
                pw.print(<span class="hljs-string">&quot; minor&quot;</span>);
            &#125;
            <span class="hljs-keyword">if</span> (majFaults &gt; <span class="hljs-number">0</span>) &#123;
                pw.print(<span class="hljs-string">&quot; &quot;</span>);
                pw.print(majFaults);
                pw.print(<span class="hljs-string">&quot; major&quot;</span>);
            &#125;
        &#125;
        pw.println();
    &#125;   

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 打印 numerator / denominator 至 pw，最多保留一位小数位</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printRatio</span><span class="hljs-params">(PrintWriter pw, <span class="hljs-type">long</span> numerator, <span class="hljs-type">long</span> denominator)</span> &#123;
        <span class="hljs-type">long</span> <span class="hljs-variable">thousands</span> <span class="hljs-operator">=</span> (numerator*<span class="hljs-number">1000</span>)/denominator;
        <span class="hljs-type">long</span> <span class="hljs-variable">hundreds</span> <span class="hljs-operator">=</span> thousands/<span class="hljs-number">10</span>;
        pw.print(hundreds);
        <span class="hljs-keyword">if</span> (hundreds &lt; <span class="hljs-number">10</span>) &#123;
            <span class="hljs-type">long</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> thousands - (hundreds*<span class="hljs-number">10</span>);
            <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;
                pw.print(<span class="hljs-string">&#x27;.&#x27;</span>);
                pw.print(remainder);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<h1 id="ANR-日志文件"><a href="#ANR-日志文件" class="headerlink" title="ANR 日志文件"></a>ANR 日志文件</h1><p>ANR 日志文件太大了，下面仅展示日志的基本结构，整个示例文件可以在 <a href="../../../../files/2021-06-27-deep-drive-into-anr/anr_2021-09-29-16-02-49-393">这里</a> 下载</p>
<p>日志文件包含多个进程，每个进程以 <code>----- pid [pid] at [time] -----</code> 开始，以 <code>----- end [pid] -----</code> 结束，而且很明显地分为 <code>java process</code> 和 <code>native process</code></p>
<div class="code-wrapper"><pre><code class="hljs log"># java process 包含了 JVM 各种统计信息以及 thread trace
----- pid 001 at 2021-09-29 16:02:49 -----
Cmd line: com.example.myapplication
...

DALVIK THREADS (16):
&quot;main&quot; prio=5 tid=1 Sleeping
  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x72313478 self=0xb400007f542bbc00
  | sysTid=27750 nice=-10 cgrp=default sched=0/0 handle=0x7f559584f8
  | state=S schedstat=( 439366137 82406360 402 ) utm=36 stm=7 core=0 HZ=100
  | stack=0x7ffd85d000-0x7ffd85f000 stackSize=8192KB
  | held mutexes=
  at java.lang.Thread.sleep(Native method)
  - sleeping on &lt;0x0bd69ce3&gt; (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:442)
  - locked &lt;0x0bd69ce3&gt; (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:358)
  at com.example.myapplication.MainActivity.onCreate$lambda-0(MainActivity.kt:20)
  at com.example.myapplication.MainActivity.lambda$b-o9DaQhxOUy1smA7kVJfKXtbVM(MainActivity.kt:-1)
  at com.example.myapplication.-$$Lambda$MainActivity$b-o9DaQhxOUy1smA7kVJfKXtbVM.onClick(lambda:-1)
  at android.view.View.performClick(View.java:7509)
  at android.view.View.performClickInternal(View.java:7486)
  at android.view.View.access$3600(View.java:841)
  at android.view.View$PerformClick.run(View.java:28709)
  at android.os.Handler.handleCallback(Handler.java:938)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loop(Looper.java:236)
  at android.app.ActivityThread.main(ActivityThread.java:8061)
  at java.lang.reflect.Method.invoke(Native method)
  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)

...

----- end 001 -----

# native process 就只有各个线程的 PC 寄存器值
----- pid 002 at 2021-09-29 16:02:52 -----
Cmd line: media.codec
ABI: &#x27;arm&#x27;

&quot;omx@1.0-service&quot; sysTid=1464
    #00 pc 000a0644  /apex/com.android.runtime/lib/bionic/libc.so (__ioctl+8) (BuildId: 3516bc395829323390a814b64aaaf5a1)
    #01 pc 0006c56b  /apex/com.android.runtime/lib/bionic/libc.so (ioctl+26) (BuildId: 3516bc395829323390a814b64aaaf5a1)
    #02 pc 0005f5f3  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::talkWithDriver(bool)+190) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)
    #03 pc 0005f79f  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::getAndExecuteCommand()+22) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)
    #04 pc 00060671  /apex/com.android.vndk.v30/lib/libhidlbase.so (android::hardware::IPCThreadState::joinThreadPool(bool)+100) (BuildId: 7de33783f64b9b0b626cd0b96a05b2d8)
    #05 pc 00002389  /vendor/bin/hw/android.hardware.media.omx@1.0-service (main+936) (BuildId: 116b35d790a6fac142d3d1eac096a1b8)
    #06 pc 0005fddb  /apex/com.android.runtime/lib/bionic/libc.so (__libc_init+66) (BuildId: 3516bc395829323390a814b64aaaf5a1)

...

----- end 002 -----</code></pre></div>

<h2 id="目录和文件名"><a href="#目录和文件名" class="headerlink" title="目录和文件名"></a>目录和文件名</h2><p><code>ProcessErrorStateRecord.appNotResponding</code> 在输出 logcat 日志的同时也输出了更加详细的 ANR Trace 至文件里，如下代码所示，<code>ActivityManagerService.dumpStackTraces</code> 创建了日志文件 <code>/data/anr/anr_[yyyy-MM-dd-HH-mm-ss-SSS]</code></p>
<p><code>/data/anr</code> 目录下超过一天，或者超过 64 个日志文件后最旧的，都会被清理掉</p>
<blockquote>
<p>旧版本的 Android 上日志文件在 /data/anr/traces.txt</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ANR_TRACE_DIR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/data/anr&quot;</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ANR_FILE_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;anr_&quot;</span>;

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span>
<span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span>
<span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];
        <span class="hljs-type">File</span> <span class="hljs-variable">tracesFile</span> <span class="hljs-operator">=</span> ActivityManagerService.dumpStackTraces(firstPids,
                isSilentAnr ? <span class="hljs-literal">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-literal">null</span> : lastPids,
                nativePids, tracesFileException, offsets, annotation);
        <span class="hljs-comment">// ...                </span>
        <span class="hljs-keyword">if</span> (tracesFile == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">// There is no trace file, so dump (only) the alleged culprit&#x27;s threads to the log</span>
            Process.sendSignal(pid, Process.SIGNAL_QUIT);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsets[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// We&#x27;ve dumped into the trace file successfully</span>
            mService.mProcessList.mAppExitInfoTracker.scheduleLogAnrTrace(
                    pid, mApp.uid, mApp.getPackageList(), tracesFile, offsets[<span class="hljs-number">0</span>], offsets[<span class="hljs-number">1</span>]);
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;
    <span class="hljs-comment">/* package */</span> <span class="hljs-keyword">static</span> File <span class="hljs-title function_">dumpStackTraces</span><span class="hljs-params">(ArrayList&lt;Integer&gt; firstPids,</span>
<span class="hljs-params">            ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,</span>
<span class="hljs-params">            ArrayList&lt;Integer&gt; nativePids, StringWriter logExceptionCreatingFile,</span>
<span class="hljs-params">            <span class="hljs-type">long</span>[] firstPidOffsets, String subject)</span> &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">tracesDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(ANR_TRACE_DIR);
        <span class="hljs-comment">// Each set of ANR traces is written to a separate file and dumpstate will process</span>
        <span class="hljs-comment">// all such files and add them to a captured bug report if they&#x27;re recent enough.</span>
        maybePruneOldTraces(tracesDir);

        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We should consider creating the file in native code atomically once we&#x27;ve</span>
        <span class="hljs-comment">// gotten rid of the old scheme of dumping and lot of the code that deals with paths</span>
        <span class="hljs-comment">// can be removed.</span>
        File tracesFile;
        <span class="hljs-keyword">try</span> &#123;
            tracesFile = createAnrDumpFile(tracesDir);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            Slog.w(TAG, <span class="hljs-string">&quot;Exception creating ANR dump file:&quot;</span>, e);
            <span class="hljs-keyword">if</span> (logExceptionCreatingFile != <span class="hljs-literal">null</span>) &#123;
                logExceptionCreatingFile.append(<span class="hljs-string">&quot;----- Exception creating ANR dump file -----\n&quot;</span>);
                e.printStackTrace(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(logExceptionCreatingFile));
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        &#125;
        <span class="hljs-comment">// ...</span>
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> File <span class="hljs-title function_">createAnrDumpFile</span><span class="hljs-params">(File tracesDir)</span> <span class="hljs-keyword">throws</span> IOException &#123;
        <span class="hljs-keyword">if</span> (sAnrFileDateFormat == <span class="hljs-literal">null</span>) &#123;
            sAnrFileDateFormat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd-HH-mm-ss-SSS&quot;</span>);
        &#125;

        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">formattedDate</span> <span class="hljs-operator">=</span> sAnrFileDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">anrFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tracesDir, ANR_FILE_PREFIX + formattedDate);

        <span class="hljs-keyword">if</span> (anrFile.createNewFile()) &#123;
            FileUtils.setPermissions(anrFile.getAbsolutePath(), <span class="hljs-number">0600</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// -rw-------</span>
            <span class="hljs-keyword">return</span> anrFile;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Unable to create ANR dump file: createNewFile failed&quot;</span>);
        &#125;
    &#125;  

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Prune all trace files that are more than a day old.</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> It might make sense to move this functionality to tombstoned eventually, along with a</span>
<span class="hljs-comment">     * shift away from anr_XX and tombstone_XX to a more descriptive name. We do it here for now</span>
<span class="hljs-comment">     * since it&#x27;s the system_server that creates trace files for most ANRs.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maybePruneOldTraces</span><span class="hljs-params">(File tracesDir)</span> &#123;
        <span class="hljs-keyword">final</span> File[] files = tracesDir.listFiles();
        <span class="hljs-keyword">if</span> (files == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> SystemProperties.getInt(<span class="hljs-string">&quot;tombstoned.max_anr_count&quot;</span>, <span class="hljs-number">64</span>);
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-keyword">try</span> &#123;
            Arrays.sort(files, Comparator.comparingLong(File::lastModified).reversed());
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; files.length; ++i) &#123;
                <span class="hljs-keyword">if</span> (i &gt; max || (now - files[i].lastModified()) &gt; DAY_IN_MILLIS) &#123;
                    <span class="hljs-keyword">if</span> (!files[i].delete()) &#123;
                        Slog.w(TAG, <span class="hljs-string">&quot;Unable to prune stale trace file: &quot;</span> + files[i]);
                    &#125;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;
            <span class="hljs-comment">// The modification times changed while we were sorting. Bail...</span>
            <span class="hljs-comment">// https://issuetracker.google.com/169836837</span>
            Slog.w(TAG, <span class="hljs-string">&quot;tombstone modification times changed while sorting; not pruning&quot;</span>, e);
        &#125;
    &#125;          
&#125;</code></pre></div>

<p>但是没有 root 权限的 adb 是没法查看文件的，也就没法通过 <code>adb pull</code> 把日志拉取出来进行分析，想要拿到 ANR Trace 只能通过 <code>adb bugreport</code>（参考 <a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a> 和 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/debug/bug-report">Bug Reports</a>）</p>
<p><img src="../../../../image/2021-07-10-deep-drive-into-anr/data_anr_permission.png" srcset="/image/loading.gif" lazyload alt="data_anr_permission"></p>
<h2 id="进程的次序"><a href="#进程的次序" class="headerlink" title="进程的次序"></a>进程的次序</h2><p>日志文件是由一个个的进程信息组成，而这些进程在 dump 的时候是有次序的，如下代码所示：</p>
<ol>
<li>第一个是发生 ANR 的进程的 pid</li>
<li>第二个是 parent pid（有的话）</li>
<li>第三个是 system server 进程</li>
<li>其他 APP 进程（受 AMS 管理的进程，保存在 <code>ActivityManagerService.mProcessList</code>）</li>
<li>然后是 native processes，其实就是进程的 <code>cmdline</code> 包含在 <code>WatchDog.NATIVE_STACKS_OF_INTEREST</code> 里的进程；进程的 <code>cmdline</code> 读取自 <code>/proc/[pid]/cmdline</code>，APP 是包名，其他则是可执行程序的路径</li>
<li>最后是 <code>lastPids</code>，它们是 <code>ActivityManagerService.mProcessList</code> 里不正常的进程（比如 ANR process）</li>
</ol>
<p>如果进程很多，那么 dump processes 耗费的时间也是很可观的，所以整个 dump processes 的过程有个时间上限 20s，超过这个阈值即使还有进程没有 dump 也会将其忽略，这也就解释了为什么要按上面的逻辑对进程进行排序，因为要优先打印重要的进程信息</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessErrorStateRecord</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">appNotResponding</span><span class="hljs-params">(String activityShortComponentName, ApplicationInfo aInfo,</span>
<span class="hljs-params">            String parentShortComponentName, WindowProcessController parentProcess,</span>
<span class="hljs-params">            <span class="hljs-type">boolean</span> aboveSystem, String annotation, <span class="hljs-type">boolean</span> onlyDumpSelf)</span> &#123;
        ArrayList&lt;Integer&gt; firstPids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">5</span>);
        SparseArray&lt;Boolean&gt; lastPids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;&gt;(<span class="hljs-number">20</span>);
        <span class="hljs-keyword">synchronized</span> (mService) &#123;
            <span class="hljs-comment">// ...</span>
            <span class="hljs-comment">// Dump thread traces as quickly as we can, starting with &quot;interesting&quot; processes.</span>
            firstPids.add(pid);

            <span class="hljs-comment">// Don&#x27;t dump other PIDs if it&#x27;s a background ANR or is requested to only dump self.</span>
            isSilentAnr = isSilentAnr();
            <span class="hljs-keyword">if</span> (!isSilentAnr &amp;&amp; !onlyDumpSelf) &#123;
                <span class="hljs-type">int</span> <span class="hljs-variable">parentPid</span> <span class="hljs-operator">=</span> pid;
                <span class="hljs-keyword">if</span> (parentProcess != <span class="hljs-literal">null</span> &amp;&amp; parentProcess.getPid() &gt; <span class="hljs-number">0</span>) &#123;
                    parentPid = parentProcess.getPid();
                &#125;
                <span class="hljs-keyword">if</span> (parentPid != pid) firstPids.add(parentPid);

                <span class="hljs-keyword">if</span> (MY_PID != pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);

                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ppid</span> <span class="hljs-operator">=</span> parentPid;
                mService.mProcessList.forEachLruProcessesLOSP(<span class="hljs-literal">false</span>, r -&gt; &#123;
                    <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span> &amp;&amp; r.getThread() != <span class="hljs-literal">null</span>) &#123;
                        <span class="hljs-type">int</span> <span class="hljs-variable">myPid</span> <span class="hljs-operator">=</span> r.getPid();
                        <span class="hljs-keyword">if</span> (myPid &gt; <span class="hljs-number">0</span> &amp;&amp; myPid != pid &amp;&amp; myPid != ppid &amp;&amp; myPid != MY_PID) &#123;
                            <span class="hljs-keyword">if</span> (r.isPersistent()) &#123;
                                firstPids.add(myPid);
                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding persistent proc: &quot;</span> + r);
                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.mServices.isTreatedLikeActivity()) &#123;
                                firstPids.add(myPid);
                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding likely IME: &quot;</span> + r);
                            &#125; <span class="hljs-keyword">else</span> &#123;
                                lastPids.put(myPid, Boolean.TRUE);
                                <span class="hljs-keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="hljs-string">&quot;Adding ANR proc: &quot;</span> + r);
                            &#125;
                        &#125;
                    &#125;
                &#125;);
            &#125;
        &#125;

        <span class="hljs-comment">// Log the ANR to the main log ...</span>

        <span class="hljs-comment">// don&#x27;t dump native PIDs for background ANRs unless it is the process of interest</span>
        String[] nativeProcs = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (isSilentAnr || onlyDumpSelf) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;
                <span class="hljs-keyword">if</span> (NATIVE_STACKS_OF_INTEREST[i].equals(mApp.processName)) &#123;
                    nativeProcs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; mApp.processName &#125;;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            nativeProcs = NATIVE_STACKS_OF_INTEREST;
        &#125;

        <span class="hljs-type">int</span>[] pids = nativeProcs == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : Process.getPidsForCommands(nativeProcs);
        ArrayList&lt;Integer&gt; nativePids = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (pids != <span class="hljs-literal">null</span>) &#123;
            nativePids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(pids.length);
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : pids) &#123;
                nativePids.add(i);
            &#125;
        &#125;

        <span class="hljs-comment">// For background ANRs, don&#x27;t pass the ProcessCpuTracker to</span>
        <span class="hljs-comment">// avoid spending 1/2 second collecting stats to rank lastPids.</span>
        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">tracesFileException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();
        <span class="hljs-comment">// To hold the start and end offset to the ANR trace file respectively.</span>
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] offsets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>];
        <span class="hljs-type">File</span> <span class="hljs-variable">tracesFile</span> <span class="hljs-operator">=</span> ActivityManagerService.dumpStackTraces(firstPids,
                isSilentAnr ? <span class="hljs-literal">null</span> : processCpuTracker, isSilentAnr ? <span class="hljs-literal">null</span> : lastPids,
                nativePids, tracesFileException, offsets, annotation);
        <span class="hljs-comment">// ...</span>
    &#125;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WatchDog</span> &#123;
    <span class="hljs-comment">// Which native processes to dump into dropbox&#x27;s stack traces</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NATIVE_STACKS_OF_INTEREST = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;
        <span class="hljs-string">&quot;/system/bin/audioserver&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/cameraserver&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/drmserver&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/keystore2&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/mediadrmserver&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/mediaserver&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/netd&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/sdcard&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/surfaceflinger&quot;</span>,
        <span class="hljs-string">&quot;/system/bin/vold&quot;</span>,
        <span class="hljs-string">&quot;media.extractor&quot;</span>, <span class="hljs-comment">// system/bin/mediaextractor</span>
        <span class="hljs-string">&quot;media.metrics&quot;</span>, <span class="hljs-comment">// system/bin/mediametrics</span>
        <span class="hljs-string">&quot;media.codec&quot;</span>, <span class="hljs-comment">// vendor/bin/hw/android.hardware.media.omx@1.0-service</span>
        <span class="hljs-string">&quot;media.swcodec&quot;</span>, <span class="hljs-comment">// /apex/com.android.media.swcodec/bin/mediaswcodec</span>
        <span class="hljs-string">&quot;media.transcoding&quot;</span>, <span class="hljs-comment">// Media transcoding service</span>
        <span class="hljs-string">&quot;com.android.bluetooth&quot;</span>,  <span class="hljs-comment">// Bluetooth service</span>
        <span class="hljs-string">&quot;/apex/com.android.os.statsd/bin/statsd&quot;</span>,  <span class="hljs-comment">// Stats daemon</span>
    &#125;;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;Long, Long&gt; <span class="hljs-title function_">dumpStackTraces</span><span class="hljs-params">(String tracesFile, ArrayList&lt;Integer&gt; firstPids,</span>
<span class="hljs-params">            ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids)</span> &#123;

        Slog.i(TAG, <span class="hljs-string">&quot;Dumping to &quot;</span> + tracesFile);

        <span class="hljs-comment">// We don&#x27;t need any sort of inotify based monitoring when we&#x27;re dumping traces via</span>
        <span class="hljs-comment">// tombstoned. Data is piped to an &quot;intercept&quot; FD installed in tombstoned so we&#x27;re in full</span>
        <span class="hljs-comment">// control of all writes to the file in question.</span>

        <span class="hljs-comment">// We must complete all stack dumps within 20 seconds.</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">remainingTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span> * <span class="hljs-number">1000</span> * Build.HW_TIMEOUT_MULTIPLIER;

        <span class="hljs-comment">// As applications are usually interested with the ANR stack traces, but we can&#x27;t share with</span>
        <span class="hljs-comment">// them the stack traces other than their own stacks. So after the very first PID is</span>
        <span class="hljs-comment">// dumped, remember the current file size.</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">firstPidStart</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
        <span class="hljs-type">long</span> <span class="hljs-variable">firstPidEnd</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;

        <span class="hljs-comment">// First collect all of the stacks of the most important pids.</span>
        <span class="hljs-keyword">if</span> (firstPids != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> firstPids.size();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> firstPids.get(i);
                <span class="hljs-comment">// We don&#x27;t copy ANR traces from the system_server intentionally.</span>
                <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">firstPid</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> &amp;&amp; MY_PID != pid;
                <span class="hljs-type">File</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">if</span> (firstPid) &#123;
                    tf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tracesFile);
                    firstPidStart = tf.exists() ? tf.length() : <span class="hljs-number">0</span>;
                &#125;

                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for pid &quot;</span> + pid);
                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> dumpJavaTracesTombstoned(pid, tracesFile,
                                                                remainingTime);

                remainingTime -= timeTaken;
                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;
                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current firstPid=&quot;</span> + pid
                            + <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);
                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;
                &#125;

                <span class="hljs-keyword">if</span> (firstPid) &#123;
                    firstPidEnd = tf.length();
                &#125;
                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;
                    Slog.d(TAG, <span class="hljs-string">&quot;Done with pid &quot;</span> + firstPids.get(i) + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">// Next collect the stacks of the native pids</span>
        <span class="hljs-keyword">if</span> (nativePids != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pid : nativePids) &#123;
                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for native pid &quot;</span> + pid);
                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">nativeDumpTimeoutMs</span> <span class="hljs-operator">=</span> Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);

                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();
                Debug.dumpNativeBacktraceToFileTimeout(
                        pid, tracesFile, (<span class="hljs-type">int</span>) (nativeDumpTimeoutMs / <span class="hljs-number">1000</span>));
                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime() - start;

                remainingTime -= timeTaken;
                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;
                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current native pid=&quot;</span> + pid +
                        <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);
                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;
                &#125;

                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;
                    Slog.d(TAG, <span class="hljs-string">&quot;Done with native pid &quot;</span> + pid + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">// Lastly, dump stacks for all extra PIDs from the CPU tracker.</span>
        <span class="hljs-keyword">if</span> (extraPids != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pid : extraPids) &#123;
                Slog.i(TAG, <span class="hljs-string">&quot;Collecting stacks for extra pid &quot;</span> + pid);

                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeTaken</span> <span class="hljs-operator">=</span> dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);

                remainingTime -= timeTaken;
                <span class="hljs-keyword">if</span> (remainingTime &lt;= <span class="hljs-number">0</span>) &#123;
                    Slog.e(TAG, <span class="hljs-string">&quot;Aborting stack trace dump (current extra pid=&quot;</span> + pid +
                            <span class="hljs-string">&quot;); deadline exceeded.&quot;</span>);
                    <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;
                &#125;

                <span class="hljs-keyword">if</span> (DEBUG_ANR) &#123;
                    Slog.d(TAG, <span class="hljs-string">&quot;Done with extra pid &quot;</span> + pid + <span class="hljs-string">&quot; in &quot;</span> + timeTaken + <span class="hljs-string">&quot;ms&quot;</span>);
                &#125;
            &#125;
        &#125;
        Slog.i(TAG, <span class="hljs-string">&quot;Done dumping&quot;</span>);
        <span class="hljs-keyword">return</span> firstPidStart &gt;= <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(firstPidStart, firstPidEnd) : <span class="hljs-literal">null</span>;
    &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">jintArray <span class="hljs-title">android_os_Process_getPidsForCommands</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span>
<span class="hljs-params"><span class="hljs-function">        jobjectArray commandNames)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (commandNames == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;

    Vector&lt;String8&gt; commands;

    jsize count = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(commandNames);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;count; i++) &#123;
        jobject obj = env-&gt;<span class="hljs-built_in">GetObjectArrayElement</span>(commandNames, i);
        <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str8 = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>((jstring)obj, <span class="hljs-literal">NULL</span>);
            <span class="hljs-keyword">if</span> (str8 == <span class="hljs-literal">NULL</span>) &#123;
                <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;Element in commandNames&quot;</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            &#125;
            commands.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">String8</span>(str8));
            env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>((jstring)obj, str8);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-built_in">jniThrowNullPointerException</span>(env, <span class="hljs-string">&quot;Element in commandNames&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
    &#125;

    Vector&lt;jint&gt; pids;

    DIR *proc = <span class="hljs-built_in">opendir</span>(<span class="hljs-string">&quot;/proc&quot;</span>);
    <span class="hljs-keyword">if</span> (proc == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;/proc: %s\n&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *d;
    <span class="hljs-keyword">while</span> ((d = <span class="hljs-built_in">readdir</span>(proc))) &#123;
        <span class="hljs-type">int</span> pid = <span class="hljs-built_in">atoi</span>(d-&gt;d_name);
        <span class="hljs-keyword">if</span> (pid &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

        <span class="hljs-type">char</span> path[PATH_MAX];
        <span class="hljs-type">char</span> data[PATH_MAX];
        <span class="hljs-built_in">snprintf</span>(path, <span class="hljs-built_in">sizeof</span>(path), <span class="hljs-string">&quot;/proc/%d/cmdline&quot;</span>, pid);

        <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY | O_CLOEXEC);
        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-type">const</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(fd, data, <span class="hljs-built_in">sizeof</span>(data)<span class="hljs-number">-1</span>);
        <span class="hljs-built_in">close</span>(fd);

        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;
        data[len] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;
            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;
                data[i] = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;commands.<span class="hljs-built_in">size</span>(); i++) &#123;
            <span class="hljs-keyword">if</span> (commands[i] == data) &#123;
                pids.<span class="hljs-built_in">add</span>(pid);
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-built_in">closedir</span>(proc);

    jintArray pidArray = env-&gt;<span class="hljs-built_in">NewIntArray</span>(pids.<span class="hljs-built_in">size</span>());
    <span class="hljs-keyword">if</span> (pidArray == <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">jniThrowException</span>(env, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;

    <span class="hljs-keyword">if</span> (pids.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;
        env-&gt;<span class="hljs-built_in">SetIntArrayRegion</span>(pidArray, <span class="hljs-number">0</span>, pids.<span class="hljs-built_in">size</span>(), pids.<span class="hljs-built_in">array</span>());
    &#125;

    <span class="hljs-keyword">return</span> pidArray;
&#125;</code></pre></div>

<h2 id="dump-java-traces"><a href="#dump-java-traces" class="headerlink" title="dump java traces"></a>dump java traces</h2><p>dump process 时分为 <code>java process</code> 和 <code>native process</code>，此章节将讨论 dump java process</p>
<p>跟着下面的代码一路跟踪下去最终会来到 <code>debuggerd_trigger_dump</code>，大概过一遍发现此方法并没有实现 dump java process 逻辑，那它都干了些什么：</p>
<ol>
<li>创建一条 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pipe.7.html">管道</a>：<code>pipe_read</code> - <code>pipe_write</code></li>
<li>创建一个 unix domain socket 连接到 <code>/dev/socket/tombstoned_intercept</code> 并将需要被 dump 的进程的 <code>pid</code>、<code>dumpType</code> 和 <code>pipe_write</code> 发送过去（将 <code>pipe_write</code> 注册到 <code>debuggerd.tombstoned</code>）</li>
<li>给 <code>pid</code> 进程发送信号 <code>SIGQUIT</code>，进程里的 <code>Signal Catcher</code> 线程被唤醒进行 process dump 操作，并从 <code>debuggerd.tombstoned</code> 拿到 <code>pipe_write</code> 将 dump 写入</li>
<li>在一个 <code>while(true)</code> 循环里等待 <code>pipe_read</code> 直到可读/有数据（<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/poll.2.html"><code>poll</code></a>，参考 <a href="../../../../2021/05/11/nonblocking-io/">网络 IO 演变发展过程和模型介绍</a>），将数据写入日志文件，这里的数据就是 process dump 的内容；同时上面有讲过 dump 是有时间上限的，所以循环里还要时刻检查是否还有剩余时间</li>
</ol>
<blockquote>
<p>man pipe.7</p>
<p>Pipes provide a unidirectional interprocess communication channel.  A pipe has a read end and a write end.  Data written to the write end of a pipe can be read from the read end of the pipe.</p>
<p>If a process attempts to read from an empty pipe, then read(2) will block until data is available.  If a process attempts to write to a full pipe (see below), then write(2) blocks until sufficient data has been read from &gt; the pipe to allow the write to complete.</p>
<p>A pipe has a limited capacity.  If the pipe is full, then a write(2) will block or fail, depending on whether the O_NONBLOCK flag is set (see below).  Different implementations have different limits for the pipe capacity.</p>
<p>In Linux versions before 2.6.11, the capacity of a pipe was the same as the system page size (e.g., 4096 bytes on i386).  </p>
<p>Since Linux 2.6.11, the pipe capacity is 16 pages (i.e., 65,536 bytes in a system with a page size  of  4096 bytes).  </p>
<p>Since Linux 2.6.35, the default pipe capacity is 16 pages, but the capacity can be queried and set using the fcntl(2) F_GETPIPE_SZ and F_SETPIPE_SZ operations. </p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dumpJavaTracesTombstoned</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, String fileName, <span class="hljs-type">long</span> timeoutMs)</span> &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">timeStart</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">javaSuccess</span> <span class="hljs-operator">=</span> Debug.dumpJavaBacktraceToFileTimeout(pid, fileName,
                (<span class="hljs-type">int</span>) (timeoutMs / <span class="hljs-number">1000</span>));
        <span class="hljs-keyword">if</span> (javaSuccess) &#123;
            <span class="hljs-comment">// Check that something is in the file, actually. Try-catch should not be necessary,</span>
            <span class="hljs-comment">// but better safe than sorry.</span>
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(fileName).length();
                <span class="hljs-keyword">if</span> (size &lt; JAVA_DUMP_MINIMUM_SIZE) &#123;
                    Slog.w(TAG, <span class="hljs-string">&quot;Successfully created Java ANR file is empty!&quot;</span>);
                    javaSuccess = <span class="hljs-literal">false</span>;
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                Slog.w(TAG, <span class="hljs-string">&quot;Unable to get ANR file size&quot;</span>, e);
                javaSuccess = <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (!javaSuccess) &#123;
            Slog.w(TAG, <span class="hljs-string">&quot;Dumping Java threads failed, initiating native stack dump.&quot;</span>);
            <span class="hljs-keyword">if</span> (!Debug.dumpNativeBacktraceToFileTimeout(pid, fileName,
                    (NATIVE_DUMP_TIMEOUT_MS / <span class="hljs-number">1000</span>))) &#123;
                Slog.w(TAG, <span class="hljs-string">&quot;Native stack dump failed!&quot;</span>);
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> SystemClock.elapsedRealtime() - timeStart;
    &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> jboolean <span class="hljs-title">android_os_Debug_dumpJavaBacktraceToFileTimeout</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span>
<span class="hljs-params"><span class="hljs-function">        jint pid, jstring fileName, jint timeoutSecs)</span> </span>&#123;
    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">dumpTraces</span>(env, pid, fileName, timeoutSecs, kDebuggerdJavaBacktrace);
    <span class="hljs-keyword">return</span> ret ? JNI_TRUE : JNI_FALSE;
&#125;

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">dumpTraces</span><span class="hljs-params">(JNIEnv* env, jint pid, jstring fileName, jint timeoutSecs,</span></span>
<span class="hljs-params"><span class="hljs-function">                       DebuggerdDumpType dumpType)</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-type">const</span> ScopedUtfChars <span class="hljs-title">fileNameChars</span><span class="hljs-params">(env, fileName)</span></span>;
    <span class="hljs-keyword">if</span> (fileNameChars.<span class="hljs-built_in">c_str</span>() == <span class="hljs-literal">nullptr</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    android::<span class="hljs-function">base::unique_fd <span class="hljs-title">fd</span><span class="hljs-params">(open(fileNameChars.c_str(),</span></span>
<span class="hljs-params"><span class="hljs-function">                                     O_CREAT | O_WRONLY | O_NOFOLLOW | O_CLOEXEC | O_APPEND,</span></span>
<span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-number">0666</span>))</span></span>;
    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t open &quot;</span> &lt;&lt; fileNameChars.<span class="hljs-built_in">c_str</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dump_backtrace_to_file_timeout</span>(pid, dumpType, timeoutSecs, fd);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fdatasync</span>(fd.<span class="hljs-built_in">get</span>()) != <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed flushing trace.&quot;</span>;
    &#125;
    <span class="hljs-keyword">return</span> res == <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dump_backtrace_to_file_timeout</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="hljs-type">int</span> timeout_secs,</span></span>
<span class="hljs-params"><span class="hljs-function">                                   <span class="hljs-type">int</span> fd)</span> </span>&#123;
  android::<span class="hljs-function">base::unique_fd <span class="hljs-title">copy</span><span class="hljs-params">(dup(fd))</span></span>;
  <span class="hljs-keyword">if</span> (copy == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  &#125;

  <span class="hljs-comment">// debuggerd_trigger_dump results in every thread in the process being interrupted</span>
  <span class="hljs-comment">// by a signal, so we need to fetch the wchan data before calling that.</span>
  std::string wchan_data = <span class="hljs-built_in">get_wchan_data</span>(fd, tid);

  <span class="hljs-type">int</span> timeout_ms = timeout_secs &gt; <span class="hljs-number">0</span> ? timeout_secs * <span class="hljs-number">1000</span> : <span class="hljs-number">0</span>;
  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">debuggerd_trigger_dump</span>(tid, dump_type, timeout_ms, std::<span class="hljs-built_in">move</span>(copy)) ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;

  <span class="hljs-comment">// Dump wchan data, since only privileged processes (CAP_SYS_ADMIN) can read</span>
  <span class="hljs-comment">// kernel stack traces (/proc/*/stack).</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WriteStringToFd</span>(wchan_data, fd)) &#123;
    <span class="hljs-built_in">LOG</span>(WARNING) &lt;&lt; TAG <span class="hljs-string">&quot;Failed to dump wchan data for pid: &quot;</span> &lt;&lt; tid;
  &#125;

  <span class="hljs-keyword">return</span> ret;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">debuggerd_trigger_dump</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> tid, DebuggerdDumpType dump_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> timeout_ms,</span></span>
<span class="hljs-params"><span class="hljs-function">                            unique_fd output_fd)</span> </span>&#123;
  <span class="hljs-type">pid_t</span> pid = tid;
  <span class="hljs-keyword">if</span> (dump_type == kDebuggerdJavaBacktrace) &#123;
    <span class="hljs-comment">// Java dumps always get sent to the tgid, so we need to resolve our tid to a tgid.</span>
    android::procinfo::ProcessInfo procinfo;
    std::string error;
    <span class="hljs-keyword">if</span> (!android::procinfo::<span class="hljs-built_in">GetProcessInfo</span>(tid, &amp;procinfo, &amp;error)) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to get process info: %s&quot;</span>, error.<span class="hljs-built_in">c_str</span>());
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    pid = procinfo.pid;
  &#125;

  <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; TAG <span class="hljs-string">&quot;started dumping process &quot;</span> &lt;&lt; pid;

  <span class="hljs-comment">// Rather than try to deal with poll() all the way through the flow, we update</span>
  <span class="hljs-comment">// the socket timeout between each step (and only use poll() during the final</span>
  <span class="hljs-comment">// copy loop).</span>
  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">milliseconds</span>(timeout_ms);
  <span class="hljs-keyword">auto</span> update_timeout = [timeout_ms, &amp;output_fd](<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">auto</span> end) &#123;
    <span class="hljs-keyword">if</span> (timeout_ms &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">auto</span> remaining = end - std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
    <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-keyword">decltype</span>(remaining)::<span class="hljs-built_in">zero</span>()) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> timeout;
    <span class="hljs-built_in">populate_timeval</span>(&amp;timeout, remaining);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, <span class="hljs-built_in">sizeof</span>(timeout)) != <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set receive timeout&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, <span class="hljs-built_in">sizeof</span>(timeout)) != <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set send timeout&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;;

  <span class="hljs-function">unique_fd <span class="hljs-title">sockfd</span><span class="hljs-params">(socket(AF_LOCAL, SOCK_SEQPACKET, <span class="hljs-number">0</span>))</span></span>;
  <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to create socket&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">socket_local_client_connect</span>(sockfd.<span class="hljs-built_in">get</span>(), kTombstonedInterceptSocketName,
                                  ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET) == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to connect to tombstoned&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  InterceptRequest req = &#123;
      .dump_type = dump_type,
      .pid = pid,
  &#125;;

  <span class="hljs-comment">// Create an intermediate pipe to pass to the other end.</span>
  unique_fd pipe_read, pipe_write;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Pipe</span>(&amp;pipe_read, &amp;pipe_write)) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to create pipe&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  std::string pipe_size_str;
  <span class="hljs-type">int</span> pipe_buffer_size = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
  <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/sys/fs/pipe-max-size&quot;</span>, &amp;pipe_size_str)) &#123;
    pipe_size_str = android::base::<span class="hljs-built_in">Trim</span>(pipe_size_str);

    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">ParseInt</span>(pipe_size_str.<span class="hljs-built_in">c_str</span>(), &amp;pipe_buffer_size, <span class="hljs-number">0</span>)) &#123;
      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;failed to parse pipe max size &#x27;&quot;</span> &lt;&lt; pipe_size_str &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span>;
    &#125;
  &#125;

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(pipe_read.<span class="hljs-built_in">get</span>(), F_SETPIPE_SZ, pipe_buffer_size) != pipe_buffer_size) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to set pipe buffer size&quot;</span>);
  &#125;

  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-type">ssize_t</span> rc = <span class="hljs-built_in">SendFileDescriptors</span>(sockfd, &amp;req, <span class="hljs-built_in">sizeof</span>(req), pipe_write.<span class="hljs-built_in">get</span>());
  pipe_write.<span class="hljs-built_in">reset</span>();
  <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in">sizeof</span>(req)) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to send output fd to tombstoned&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  <span class="hljs-keyword">auto</span> get_response = [&amp;output_fd](<span class="hljs-type">const</span> <span class="hljs-type">char</span>* kind, <span class="hljs-type">int</span> sockfd, InterceptResponse* response) &#123;
    <span class="hljs-type">ssize_t</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">recv</span>(sockfd, response, <span class="hljs-built_in">sizeof</span>(*response), MSG_TRUNC));
    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to read %s response from tombstoned: timeout reached?&quot;</span>, kind);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to read %s response from tombstoned&quot;</span>, kind);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in">sizeof</span>(*response)) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>,
                <span class="hljs-string">&quot;received packet of unexpected length from tombstoned while reading %s response: &quot;</span>
                <span class="hljs-string">&quot;expected %zd, received %zd&quot;</span>,
                kind, <span class="hljs-built_in">sizeof</span>(response), rc);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;;

  <span class="hljs-comment">// Check to make sure we&#x27;ve successfully registered.</span>
  InterceptResponse response;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_response</span>(<span class="hljs-string">&quot;initial&quot;</span>, sockfd, &amp;response)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (response.status != InterceptStatus::kRegistered) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;unexpected registration response: %d&quot;</span>,
              <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(response.status));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  <span class="hljs-comment">// Send the signal.</span>
  <span class="hljs-type">const</span> <span class="hljs-type">int</span> signal = (dump_type == kDebuggerdJavaBacktrace) ? SIGQUIT : BIONIC_SIGNAL_DEBUGGER;
  sigval val = &#123;.sival_int = (dump_type == kDebuggerdNativeBacktrace) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>&#125;;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigqueue</span>(pid, signal, val) != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;failed to send signal to pid %d&quot;</span>, pid);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">update_timeout</span>(sockfd, end)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_response</span>(<span class="hljs-string">&quot;status&quot;</span>, sockfd, &amp;response)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (response.status != InterceptStatus::kStarted) &#123;
    response.error_message[<span class="hljs-built_in">sizeof</span>(response.error_message) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;
    <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;tombstoned reported failure: %s&quot;</span>, response.error_message);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  <span class="hljs-comment">// Forward output from the pipe to the output fd.</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    <span class="hljs-keyword">auto</span> remaining = end - std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
    <span class="hljs-keyword">auto</span> remaining_ms = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(remaining).<span class="hljs-built_in">count</span>();
    <span class="hljs-keyword">if</span> (timeout_ms &lt;= <span class="hljs-number">0</span>) &#123;
      remaining_ms = <span class="hljs-number">-1</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remaining_ms &lt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> pfd = &#123;
        .fd = pipe_read.<span class="hljs-built_in">get</span>(), .events = POLLIN, .revents = <span class="hljs-number">0</span>,
    &#125;;

    rc = <span class="hljs-built_in">poll</span>(&amp;pfd, <span class="hljs-number">1</span>, remaining_ms);
    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;
      <span class="hljs-keyword">if</span> (errno == EINTR) &#123;
        <span class="hljs-keyword">continue</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while polling&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;timeout expired&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];
    rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">read</span>(pipe_read.<span class="hljs-built_in">get</span>(), buf, <span class="hljs-built_in">sizeof</span>(buf)));
    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">// Done.</span>
      <span class="hljs-keyword">break</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while reading&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">WriteFully</span>(output_fd.<span class="hljs-built_in">get</span>(), buf, rc)) &#123;
      <span class="hljs-built_in">log_error</span>(output_fd, errno, <span class="hljs-string">&quot;error while writing&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
  &#125;

  <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; TAG <span class="hljs-string">&quot;done dumping process &quot;</span> &lt;&lt; pid;

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-comment">// Helper for SendFileDescriptorVector that constructs a std::vector for you, e.g.:</span>
<span class="hljs-comment">//   SendFileDescriptors(sock, &quot;foo&quot;, 3, std::move(fd1), std::move(fd2))</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">SendFileDescriptors</span><span class="hljs-params">(borrowed_fd sock, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> len, Args&amp;&amp;... sent_fds)</span> </span>&#123;
  <span class="hljs-comment">// Do not allow implicit conversion to int: people might try to do something along the lines of:</span>
  <span class="hljs-comment">//   SendFileDescriptors(..., std::move(a_unique_fd))</span>
  <span class="hljs-comment">// and be surprised when the unique_fd isn&#x27;t closed afterwards.</span>
  <span class="hljs-built_in">AssertType</span>&lt;<span class="hljs-type">int</span>&gt;(std::forward&lt;Args&gt;(sent_fds)...);
  std::vector&lt;<span class="hljs-type">int</span>&gt; fds;
  <span class="hljs-built_in">Append</span>(fds, std::forward&lt;Args&gt;(sent_fds)...);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">SendFileDescriptorVector</span>(sock, data, len, fds);
&#125;

<span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">SendFileDescriptorVector</span><span class="hljs-params">(borrowed_fd sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> len,</span></span>
<span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; fds)</span> </span>&#123;
  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> page_size = <span class="hljs-built_in">sysconf</span>(_SC_PAGE_SIZE);
  <span class="hljs-type">size_t</span> cmsg_space = <span class="hljs-built_in">CMSG_SPACE</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * fds.<span class="hljs-built_in">size</span>());
  <span class="hljs-type">size_t</span> cmsg_len = <span class="hljs-built_in">CMSG_LEN</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * fds.<span class="hljs-built_in">size</span>());
  <span class="hljs-keyword">if</span> (cmsg_space &gt;= page_size) &#123;
    errno = ENOMEM;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  &#125;

  <span class="hljs-built_in">alignas</span>(<span class="hljs-keyword">struct</span> cmsghdr) <span class="hljs-type">char</span> cmsg_buf[cmsg_space];
  iovec iov = &#123;.iov_base = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(data), .iov_len = len&#125;;
  msghdr msg = &#123;
      .msg_name = <span class="hljs-literal">nullptr</span>,
      .msg_namelen = <span class="hljs-number">0</span>,
      .msg_iov = &amp;iov,
      .msg_iovlen = <span class="hljs-number">1</span>,
      .msg_control = cmsg_buf,
      <span class="hljs-comment">// We can&#x27;t cast to the actual type of the field, because it&#x27;s different across platforms.</span>
      .msg_controllen = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(cmsg_space),
      .msg_flags = <span class="hljs-number">0</span>,
  &#125;;

  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmsghdr</span>* cmsg = <span class="hljs-built_in">CMSG_FIRSTHDR</span>(&amp;msg);
  cmsg-&gt;cmsg_level = SOL_SOCKET;
  cmsg-&gt;cmsg_type = SCM_RIGHTS;
  cmsg-&gt;cmsg_len = cmsg_len;

  <span class="hljs-type">int</span>* cmsg_fds = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">CMSG_DATA</span>(cmsg));
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; fds.<span class="hljs-built_in">size</span>(); ++i) &#123;
    cmsg_fds[i] = fds[i];
  &#125;

<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__linux__)</span>
  <span class="hljs-type">int</span> flags = MSG_NOSIGNAL;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-type">int</span> flags = <span class="hljs-number">0</span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">sendmsg</span>(sockfd.<span class="hljs-built_in">get</span>(), &amp;msg, flags));
&#125;</code></pre></div>

<h3 id="Unix-Domain-Socket"><a href="#Unix-Domain-Socket" class="headerlink" title="Unix Domain Socket"></a>Unix Domain Socket</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span>
<span class="hljs-comment"> * man socket.2</span>
<span class="hljs-comment"> * </span>
<span class="hljs-comment"> * domain: </span>
<span class="hljs-comment"> *   AF_UNIX/AF_LOCAL Local communication</span>
<span class="hljs-comment"> *   AF_INET          IPv4 Internet protocols</span>
<span class="hljs-comment"> *   AF_INET6         IPv6 Internet protocols</span>
<span class="hljs-comment"> *   ...</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * type: </span>
<span class="hljs-comment"> *   SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams, 网络协议簇上的实现就是 TCP</span>
<span class="hljs-comment"> *   SOCK_DGRAM      connectionless, unreliable messages of a fixed maximum length, 网络协议簇上的实现就是 UDP</span>
<span class="hljs-comment"> *   SOCK_SEQPACKET  Provides a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length</span>
<span class="hljs-comment"> *                   a consumer is required to read an entire packet with each input system call</span>
<span class="hljs-comment"> *                   看起来像是 TCP + UDP</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span></code></pre></div>

<p>使用 Java/Kotlin 编程 <code>socket</code> 一般就是代表 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">网络协议簇</a> 中的传输层协议 TCP 和 UDP，但在 C 里 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/socket.7.html">socket</a> 包含一整套 API 如下图：</p>
<p><img src="../../../../image/2021-07-10-deep-drive-into-anr/socket.jpg" srcset="/image/loading.gif" lazyload alt="socket"></p>
<p><code>Unix Domain Socket</code>，也就是 <code>socket(AF_UNIX/AF_LOCAL, ...)</code> 则是一种 <code>IPC</code> 机制，对标的是 <code>pipe</code>、<code>FIFO</code>、<code>signal</code>，它不走网络协议簇（性能好）却又可以使用上图所示丰富的 API 实现双向的、全双工的、多路复用的 IPC。相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 Unix Domain Socket 通讯的</p>
<p>Unix Domain Socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 <code>sockaddr_un</code> 表示，网络编程的地址是 <code>ip:port</code> 而 Unix Domain Socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个文件在 <code>bind</code> 调用时创建，如果该文件已存在则 <code>bind</code> 错误返回，<code>close</code> 后需要自己主动删除</p>
<h3 id="SignalCatcher-amp-SIGQUIT"><a href="#SignalCatcher-amp-SIGQUIT" class="headerlink" title="SignalCatcher &amp; SIGQUIT"></a>SignalCatcher &amp; SIGQUIT</h3><p>如下图所示，<code>zygote</code> fork 出 system server 和 app process 后会创建一个叫 <code>Signal Catcher</code> 的 native thread 并将其绑定到 VM，它的 routine 是 <code> SignalCatcher::Run</code>，main loop 是等待并响应信号 <code>SIGQUIT</code> 和 <code>SIGUSR1</code></p>
<p><img src="../../../../image/2021-07-10-deep-drive-into-anr/signal_catcher_thread.png" srcset="/image/loading.gif" lazyload alt="signal_catcher_thread"></p>
<blockquote>
<p>int sigwait(const sigset_t *set, int *sig)</p>
<p>The  sigwait()  function  suspends execution of the calling thread until one of the signals specified in the signal set set becomes pending.  The function accepts the signal (removes it from the pending list of signals), and returns the signal number in sig</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/runtime.cc</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::InitNonZygoteOrPostFork</span><span class="hljs-params">(</span></span>
<span class="hljs-params"><span class="hljs-function">    JNIEnv* env,</span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> is_system_server,</span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// This is true when we are initializing a child-zygote. It requires</span></span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// native bridge initialization to be able to run guest native code in</span></span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// doPreload().</span></span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> is_child_zygote,</span></span>
<span class="hljs-params"><span class="hljs-function">    NativeBridgeAction action,</span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* isa,</span></span>
<span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> profile_system_server)</span> </span>&#123;
    
    <span class="hljs-comment">// ...</span>
    <span class="hljs-built_in">StartSignalCatcher</span>();
    <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::StartSignalCatcher</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">if</span> (!is_zygote_) &#123;
    signal_catcher_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SignalCatcher</span>();
  &#125;
&#125;

<span class="hljs-comment">// art/runtime/signal_catcher.cc</span>
SignalCatcher::<span class="hljs-built_in">SignalCatcher</span>()
    : <span class="hljs-built_in">lock_</span>(<span class="hljs-string">&quot;SignalCatcher lock&quot;</span>),
      <span class="hljs-built_in">cond_</span>(<span class="hljs-string">&quot;SignalCatcher::cond_&quot;</span>, lock_),
      <span class="hljs-built_in">thread_</span>(<span class="hljs-literal">nullptr</span>) &#123;
  <span class="hljs-built_in">SetHaltFlag</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-comment">// Create a raw pthread; its start routine will attach to the runtime.</span>
  <span class="hljs-built_in">CHECK_PTHREAD_CALL</span>(pthread_create, (&amp;pthread_, <span class="hljs-literal">nullptr</span>, &amp;Run, <span class="hljs-keyword">this</span>), <span class="hljs-string">&quot;signal catcher thread&quot;</span>);

  Thread* self = Thread::<span class="hljs-built_in">Current</span>();
  <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, lock_)</span></span>;
  <span class="hljs-keyword">while</span> (thread_ == <span class="hljs-literal">nullptr</span>) &#123;
    cond_.<span class="hljs-built_in">Wait</span>(self);
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">SignalCatcher::Run</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;
  SignalCatcher* signal_catcher = <span class="hljs-built_in">reinterpret_cast</span>&lt;SignalCatcher*&gt;(arg);
  <span class="hljs-built_in">CHECK</span>(signal_catcher != <span class="hljs-literal">nullptr</span>);

  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();
  <span class="hljs-built_in">CHECK</span>(runtime-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(<span class="hljs-string">&quot;Signal Catcher&quot;</span>, <span class="hljs-literal">true</span>, runtime-&gt;<span class="hljs-built_in">GetSystemThreadGroup</span>(),
                                     !runtime-&gt;<span class="hljs-built_in">IsAotCompiler</span>()));

  Thread* self = Thread::<span class="hljs-built_in">Current</span>();
  <span class="hljs-built_in">DCHECK_NE</span>(self-&gt;<span class="hljs-built_in">GetState</span>(), kRunnable);
  &#123;
    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, signal_catcher-&gt;lock_)</span></span>;
    signal_catcher-&gt;thread_ = self;
    signal_catcher-&gt;cond_.<span class="hljs-built_in">Broadcast</span>(self);
  &#125;

  <span class="hljs-comment">// Set up mask with signals we want to handle.</span>
  SignalSet signals;
  signals.<span class="hljs-built_in">Add</span>(SIGQUIT);
  signals.<span class="hljs-built_in">Add</span>(SIGUSR1);

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    <span class="hljs-type">int</span> signal_number = signal_catcher-&gt;<span class="hljs-built_in">WaitForSignal</span>(self, signals);
    <span class="hljs-keyword">if</span> (signal_catcher-&gt;<span class="hljs-built_in">ShouldHalt</span>()) &#123;
      runtime-&gt;<span class="hljs-built_in">DetachCurrentThread</span>();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    &#125;

    <span class="hljs-keyword">switch</span> (signal_number) &#123;
    <span class="hljs-keyword">case</span> SIGQUIT:
      signal_catcher-&gt;<span class="hljs-built_in">HandleSigQuit</span>();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> SIGUSR1:
      signal_catcher-&gt;<span class="hljs-built_in">HandleSigUsr1</span>();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Unexpected signal %d&quot;</span> &lt;&lt; signal_number;
      <span class="hljs-keyword">break</span>;
    &#125;
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SignalCatcher::WaitForSignal</span><span class="hljs-params">(Thread* self, SignalSet&amp; signals)</span> </span>&#123;
  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(self, kWaitingInMainSignalCatcherLoop)</span></span>;

  <span class="hljs-comment">// Signals for sigwait() must be blocked but not ignored.  We</span>
  <span class="hljs-comment">// block signals like SIGQUIT for all threads, so the condition</span>
  <span class="hljs-comment">// is met.  When the signal hits, we wake up, without any signal</span>
  <span class="hljs-comment">// handlers being invoked.</span>
  <span class="hljs-type">int</span> signal_number = signals.<span class="hljs-built_in">Wait</span>();
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ShouldHalt</span>()) &#123;
    <span class="hljs-comment">// Let the user know we got the signal, just in case the system&#x27;s too screwed for us to</span>
    <span class="hljs-comment">// actually do what they want us to do...</span>
    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; *self &lt;&lt; <span class="hljs-string">&quot;: reacting to signal &quot;</span> &lt;&lt; signal_number;

    <span class="hljs-comment">// If anyone&#x27;s holding locks (which might prevent us from getting back into state Runnable), say so...</span>
    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">DumpLockHolders</span>(<span class="hljs-built_in">LOG_STREAM</span>(INFO));
  &#125;

  <span class="hljs-keyword">return</span> signal_number;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalSet</span> &#123;
<span class="hljs-keyword">public</span>:

  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// Sleep in sigwait() until a signal arrives. gdb causes EINTR failures.</span>
    <span class="hljs-type">int</span> signal_number;
    <span class="hljs-type">int</span> rc = <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">sigwait64</span>(&amp;set_, &amp;signal_number));
    <span class="hljs-keyword">if</span> (rc != <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;sigwait failed&quot;</span>;
    &#125;
    <span class="hljs-keyword">return</span> signal_number;
  &#125;
&#125;;</code></pre></div>

<h3 id="proces-thread-dump"><a href="#proces-thread-dump" class="headerlink" title="proces/thread dump"></a>proces/thread dump</h3><p>APP 在收到信号 <code>SIGQUIT(3)</code> 后，<code>Signal Catcher</code> 线程会将有关 VM 的信息 dump 出来，如下面的代码所示，是不是跟 ANR Traces 日志里的内容很相似？这样我们就可以看着代码一点点地分析出日志里各段的含义</p>
<div class="code-wrapper"><pre><code class="hljs log">// 以下日志来自 SignalCatcher::HandleSigQuit
----- pid 27750(当前进程，也就是被 dump 的进程) at 2021-09-29 16:02:49(输出这段日志的时间) -----
Cmd line: com.example.myapplication(来自 /proc/pid/cmdline)
Build fingerprint: &#x27;Xiaomi/cepheus/cepheus:11/RKQ1.200826.002/V12.5.4.0.RFACNXM:user/release-keys&#x27;
ABI: &#x27;arm64&#x27;
Build type: optimized(debug or optimized)

// ClassLinker::DumpForSigQuit
Zygote loaded classes=15972 post zygote classes=782 (为了节省内存 zygote 会加载一些必要的 class，这样 fork 出来的 APP 进程就可以通过父子进程的 Copy-On-Write 机制共享之，15972 是 zygote 加载的 class 数量，782 是 APP 进程额外加载的 class 数量)
Dumping registered class loaders (打印 classloader 实例数组)
#0 dalvik.system.PathClassLoader: [], parent #1
#1 java.lang.BootClassLoader: [], no parent
#2 dalvik.system.PathClassLoader: [/system/framework/tcmclient.jar], parent #0
#3 dalvik.system.PathClassLoader: [], parent #0
#4 dalvik.system.PathClassLoader: [/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes4.dex:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes3.dex:/data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!classes2.dex], parent #1
#5 dalvik.system.PathClassLoader: [/system/app/MiuiContentCatcher/MiuiContentCatcher.apk], parent #1
#6 dalvik.system.PathClassLoader: [/system/app/CatcherPatch/CatcherPatch.apk], parent #1
Done dumping class loaders
Classes initialized: 371 in 14.764ms

/* 
 * InternTable::DumpForSigQuit
 * 
 * Class InternTable used to intern strings.
 * There are actually two tables: one that holds strong references to its strings, and one that holds weak references. 
 * The former is used for string literals, for which there is an effective reference from the constant pool. 
 * The latter is used for strings interned at runtime via String.intern. 
 * Some code (XML parsers being a prime example) relies on being able to intern arbitrarily many strings for the duration of a parse without permanently increasing the memory footprint.
 * 
 * 这个 InternTable 其实就是 String.intern() 方法描述里说的那个字符串池（A pool of strings, initially empty, is maintained privately by the class String）
 * 它包含两个 table，字符串字面量（来自于字符串常量池）的引用保存在 string table，通过 String.intern() 添加进来的字符串引用保存在 weak table
 * 
 * String.intern() 将搜索 InternTable，如果 InternTable 存在相同的字符串则返回它的引用，否则将当前字符串添加到 InternTable 里，这样的好处是可以降低字符串处理程序的内存波动
 * 
 */
Intern table: 32394 strong; 523 weak

//  JavaVMExt::DumpForSigQuit (JNI 相关，不太懂)
JNI: CheckJNI is on; globals=735 (plus 64 weak)
Libraries: /data/app/~~syr7K6mbdRUo_PMCa5m4Zg==/com.example.myapplication-y5fNXmdEYq8yPQiK04h7mw==/base.apk!/lib/arm64-v8a/libnative-lib.so libandroid.so libaudioeffect_jni.so libcompiler_rt.so libicu_jni.so libjavacore.so libjavacrypto.so libjnigraphics.so libmedia_jni.so libmiuinative.so libopenjdk.so libqti_performance.so librs_jni.so libsfplugin_ccodec.so libsoundpool.so libstats_jni.so libwebviewchromium_loader.so (17)

// Heap::DumpForSigQuit
Heap: 47% free, 2796KB/5303KB; 71822 objects (VM 堆相关情况，堆申请了 5303KB 的内存，用了 2795KB 剩余 47% 的内存，堆里一共有 71822 个对象)

// Heap::DumpGcPerformanceInfo (GC 相关信息)
Dumping cumulative Gc timings
Start Dumping histograms for 1 iterations for concurrent copying
ScanImmuneSpaces:	Sum: 12.444ms 99% C.I. 12.444ms-12.444ms Avg: 12.444ms Max: 12.444ms
ProcessMarkStack:	Sum: 12.292ms 99% C.I. 12.292ms-12.292ms Avg: 12.292ms Max: 12.292ms
VisitConcurrentRoots:	Sum: 6.499ms 99% C.I. 6.499ms-6.499ms Avg: 6.499ms Max: 6.499ms
ScanCardsForSpace:	Sum: 1.231ms 99% C.I. 1.231ms-1.231ms Avg: 1.231ms Max: 1.231ms
SweepSystemWeaks:	Sum: 924us 99% C.I. 924us-924us Avg: 924us Max: 924us
GrayAllDirtyImmuneObjects:	Sum: 792us 99% C.I. 792us-792us Avg: 792us Max: 792us
ClearFromSpace:	Sum: 777us 99% C.I. 777us-777us Avg: 777us Max: 777us
InitializePhase:	Sum: 544us 99% C.I. 544us-544us Avg: 544us Max: 544us
FlipOtherThreads:	Sum: 309us 99% C.I. 309us-309us Avg: 309us Max: 309us
VisitNonThreadRoots:	Sum: 270us 99% C.I. 270us-270us Avg: 270us Max: 270us
RecordFree:	Sum: 95us 99% C.I. 95us-95us Avg: 95us Max: 95us
CopyingPhase:	Sum: 82us 99% C.I. 82us-82us Avg: 82us Max: 82us
ForwardSoftReferences:	Sum: 77us 99% C.I. 77us-77us Avg: 77us Max: 77us
EnqueueFinalizerReferences:	Sum: 60us 99% C.I. 60us-60us Avg: 60us Max: 60us
MarkZygoteLargeObjects:	Sum: 56us 99% C.I. 56us-56us Avg: 56us Max: 56us
ProcessReferences:	Sum: 55us 99% C.I. 8us-47us Avg: 27.500us Max: 47us
(Paused)GrayAllNewlyDirtyImmuneObjects:	Sum: 40us 99% C.I. 40us-40us Avg: 40us Max: 40us
SweepLargeObjects:	Sum: 38us 99% C.I. 38us-38us Avg: 38us Max: 38us
SwapBitmaps:	Sum: 36us 99% C.I. 36us-36us Avg: 36us Max: 36us
ThreadListFlip:	Sum: 35us 99% C.I. 35us-35us Avg: 35us Max: 35us
SweepAllocSpace:	Sum: 26us 99% C.I. 26us-26us Avg: 26us Max: 26us
MarkStackAsLive:	Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18us
ReclaimPhase:	Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14us
EmptyRBMarkBitStack:	Sum: 13us 99% C.I. 13us-13us Avg: 13us Max: 13us
(Paused)FlipCallback:	Sum: 11us 99% C.I. 11us-11us Avg: 11us Max: 11us
ResumeRunnableThreads:	Sum: 10us 99% C.I. 10us-10us Avg: 10us Max: 10us
(Paused)SetFromSpace:	Sum: 8us 99% C.I. 8us-8us Avg: 8us Max: 8us
UnBindBitmaps:	Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7us
FlipThreadRoots:	Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6us
Sweep:	Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5us
(Paused)ClearCards:	Sum: 3us 99% C.I. 250ns-1000ns Avg: 142ns Max: 1000ns
ResumeOtherThreads:	Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us
Done Dumping histograms
concurrent copying paused:	Sum: 101us 99% C.I. 101us-101us Avg: 101us Max: 101us
concurrent copying freed-bytes: Avg: 138KB Max: 138KB Min: 138KB
Freed-bytes histogram: 0:1
concurrent copying total time: 36.779ms mean time: 36.779ms
concurrent copying freed: 1138 objects with total size 138KB
concurrent copying throughput: 31611.1/s / 3844KB/s  per cpu-time: 4429000/s / 4325KB/s
Average major GC reclaim bytes ratio 0.841027 over 1 GC cycles
Average major GC copied live bytes ratio 0.757154 over 5 major GCs
Cumulative bytes moved 13614368
Cumulative objects moved 237506
Peak regions allocated 35 (8960KB) / 1024 (256MB)
Start Dumping histograms for 1 iterations for young concurrent copying
ScanImmuneSpaces:	Sum: 9.300ms 99% C.I. 9.300ms-9.300ms Avg: 9.300ms Max: 9.300ms
ProcessMarkStack:	Sum: 2.551ms 99% C.I. 2.551ms-2.551ms Avg: 2.551ms Max: 2.551ms
VisitConcurrentRoots:	Sum: 1.263ms 99% C.I. 1.263ms-1.263ms Avg: 1.263ms Max: 1.263ms
SweepSystemWeaks:	Sum: 530us 99% C.I. 530us-530us Avg: 530us Max: 530us
ClearFromSpace:	Sum: 390us 99% C.I. 390us-390us Avg: 390us Max: 390us
InitializePhase:	Sum: 289us 99% C.I. 289us-289us Avg: 289us Max: 289us
GrayAllDirtyImmuneObjects:	Sum: 163us 99% C.I. 163us-163us Avg: 163us Max: 163us
ScanCardsForSpace:	Sum: 129us 99% C.I. 129us-129us Avg: 129us Max: 129us
FlipOtherThreads:	Sum: 75us 99% C.I. 75us-75us Avg: 75us Max: 75us
VisitNonThreadRoots:	Sum: 54us 99% C.I. 54us-54us Avg: 54us Max: 54us
EnqueueFinalizerReferences:	Sum: 45us 99% C.I. 45us-45us Avg: 45us Max: 45us
SweepArray:	Sum: 21us 99% C.I. 21us-21us Avg: 21us Max: 21us
ProcessReferences:	Sum: 20us 99% C.I. 1us-19us Avg: 10us Max: 19us
RecordFree:	Sum: 19us 99% C.I. 0.250us-19us Avg: 9.500us Max: 19us
(Paused)GrayAllNewlyDirtyImmuneObjects:	Sum: 18us 99% C.I. 18us-18us Avg: 18us Max: 18us
CopyingPhase:	Sum: 15us 99% C.I. 15us-15us Avg: 15us Max: 15us
ForwardSoftReferences:	Sum: 14us 99% C.I. 14us-14us Avg: 14us Max: 14us
FreeList:	Sum: 13us 99% C.I. 13us-13us Avg: 13us Max: 13us
ThreadListFlip:	Sum: 8us 99% C.I. 8us-8us Avg: 8us Max: 8us
SwapBitmaps:	Sum: 7us 99% C.I. 7us-7us Avg: 7us Max: 7us
ReclaimPhase:	Sum: 6us 99% C.I. 6us-6us Avg: 6us Max: 6us
MarkZygoteLargeObjects:	Sum: 5us 99% C.I. 5us-5us Avg: 5us Max: 5us
ResetStack:	Sum: 4us 99% C.I. 4us-4us Avg: 4us Max: 4us
EmptyRBMarkBitStack:	Sum: 3us 99% C.I. 3us-3us Avg: 3us Max: 3us
(Paused)FlipCallback:	Sum: 2us 99% C.I. 2us-2us Avg: 2us Max: 2us
(Paused)SetFromSpace:	Sum: 1us 99% C.I. 1us-1us Avg: 1us Max: 1us
(Paused)ClearCards:	Sum: 0 99% C.I. 0ns-0ns Avg: 0ns Max: 0ns
Done Dumping histograms
young concurrent copying paused:	Sum: 33us 99% C.I. 33us-33us Avg: 33us Max: 33us
young concurrent copying freed-bytes: Avg: 4116KB Max: 4116KB Min: 4116KB
Freed-bytes histogram: 3840:1
young concurrent copying total time: 14.952ms mean time: 14.952ms
young concurrent copying freed: 48492 objects with total size 4116KB
young concurrent copying throughput: 3.46371e+06/s / 287MB/s  per cpu-time: 602219428/s / 574MB/s
Average minor GC reclaim bytes ratio 1.88288 over 1 GC cycles
Average minor GC copied live bytes ratio 0.126374 over 3 minor GCs
Cumulative bytes moved 2004720
Cumulative objects moved 28694
Peak regions allocated 35 (8960KB) / 1024 (256MB)
Total time spent in GC: 51.731ms
Mean GC size throughput: 80MB/s per cpu-time: 103MB/s
Mean GC object throughput: 959386 objects/s
Total number of allocations 121452
Total bytes allocated 7051KB
Total bytes freed 4255KB
Free memory 2506KB
Free memory until GC 2506KB
Free memory until OOME 253MB
Total memory 5303KB
Max memory 256MB
Zygote space size 3464KB
Total mutator paused time: 134us
Total time waiting for GC to complete: 11.571ms
Total GC count: 2
Total GC time: 51.731ms
Total blocking GC count: 0
Total blocking GC time: 0
Histogram of GC count per 10000 ms: 0:16,1:1
Histogram of blocking GC count per 10000 ms: 0:17
Native bytes total: 21234628 registered: 60540
Total native bytes at last GC: 20854836

// OatFileManager::DumpForSigQuit
/data/dalvik-cache/arm64/system@priv-app@RtMiCloudSDK@RtMiCloudSDK.apk@classes.dex: speed
/data/dalvik-cache/arm64/system@app@MiuiContentCatcher@MiuiContentCatcher.apk@classes.dex: speed
/data/dalvik-cache/arm64/system@app@CatcherPatch@CatcherPatch.apk@classes.dex: speed

// Jit::DumpForSigQuit (JIT 相关)
Current JIT code cache size (used / resident): 5KB / 32KB
Current JIT data cache size (used / resident): 10KB / 32KB
Zygote JIT code cache size (at point of fork): 60KB / 64KB
Zygote JIT data cache size (at point of fork): 54KB / 60KB
Current JIT mini-debug-info size: 44KB
Current JIT capacity: 64KB
Current number of JIT JNI stub entries: 0
Current number of JIT code cache entries: 64
Total number of JIT compilations: 17
Total number of JIT compilations for on stack replacement: 0
Total number of JIT code cache collections: 0
Memory used for stack maps: Avg: 67B Max: 272B Min: 16B
Memory used for compiled code: Avg: 304B Max: 1320B Min: 20B
Memory used for profiling info: Avg: 111B Max: 728B Min: 32B
Start Dumping histograms for 64 iterations for JIT timings
Compiling:	Sum: 143.499ms 99% C.I. 0.115ms-18.703ms Avg: 2.242ms Max: 22.565ms
TrimMaps:	Sum: 4.510ms 99% C.I. 8us-707.999us Avg: 70.468us Max: 864us
Done Dumping histograms
Memory used for compilation: Avg: 139KB Max: 837KB Min: 15KB

// ProfileSaver::DumpInstanceInfo
ProfileSaver total_bytes_written=2330
ProfileSaver total_number_of_writes=1
ProfileSaver total_number_of_code_cache_queries=2
ProfileSaver total_number_of_skipped_writes=1
ProfileSaver total_number_of_failed_writes=0
ProfileSaver total_ms_of_sleep=312878
ProfileSaver total_ms_of_work=4
ProfileSaver total_number_of_hot_spikes=0
ProfileSaver total_number_of_wake_ups=1

// ThreadList::DumpForSigQuit
suspend all histogram:	Sum: 289us 99% C.I. 2us-164us Avg: 20.642us Max: 164us (应该是中断所有线程的执行耗费的时间)

// ThreadList::Dump (已绑定到 VM 的线程)
DALVIK THREADS (16):

// Thread::Dump
&quot;main&quot;(线程名) [daemon(如果是 daemon thread)] prio=5(优先级) tid=1(线程 ID) Sleeping(可以是：NEW, RUNNABLE, TIMED_WAITTING|SLEEPING, WAITTING, BLOCKED 和 TERMINATED，参考 art::ThreadState)
  | group=&quot;main&quot;(线程组) 
  
  /**
   * Thread::tls32_::suspend_count, A non-zero value is used to tell the current thread to enter a safe point at the next poll.
   * 
   * save point 是 JVM 里的一个概念，可以认为是一个函数，被 JVM 安插在各个地方：循环末尾、函数执行前/后、抛出异常时... 
   * 那它有什么用呢？比如 GC/dump 时需要 Stop-The-World 吧，debug 时打断点/单步调试需要中断线程的执行吧，
   * 那怎么才能让正在执行 CPU 指令的 java 线程暂停呢？靠的就是安插在各处的 save point 去检查某个指示线程是否可以继续执行的标识
   * 
   * 在 SafePoint 保存了其他位置没有的一些当前线程的运行信息供其他线程读取，包括：线程上下文的任何信息、对象或者非对象的内部指针等等
   * 我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息才是确定的，也只有这个时候才知道这个线程用了哪些内存，没有用哪些
   * 并且只有线程处于 SafePoint 位置，这时候对 JVM 的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到
   * 之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候才会感知
   * 
   * 也就是说当 sCount 非零时会进入 save point，非零时会跳过 save point
   * 从 ANR Trace 看只有 Signal Catcher 的 sCount 才会为零，猜测 process dump 是需要中断除 Signal Catcher 之外其他线程的执行，只留 Signal Catcher 进行 thread dump 操作
   */
  sCount=1 
  
  /**
   * Thread::tls32_::debug_suspend_count
   * How much of &#x27;suspend_count_&#x27; is by request of the debugger, used to set things right when the debugger detaches. Must be &lt;= suspend_count_.
   * debugger 可以修改 suspend_count（打断点？）但在此之前需要把 suspend_count 的值备份在这个字段，以便退出 debug 的时候可以恢复
   *
   */
  dsCount=0 
  
  /**
   * Thread::tls32_::state_and_flags::as_struct::flags, bitmap field
   * 
   * enum ThreadFlag &#123;
   *   kSuspendRequest         = 1,  // If set implies that suspend_count_ &gt; 0 and the Thread should enter the safepoint handler.
   *   kCheckpointRequest      = 2,  // Request that the thread do some checkpoint work and then continue.
   *   kEmptyCheckpointRequest = 4,  // Request that the thread do empty checkpoint and then continue.
   *   kActiveSuspendBarrier   = 8,  // Register that at least 1 suspend barrier needs to be passed.
   * &#125;;
   */
  flags=1 
  
  obj=0x72313478 (Thread::tlsPtr_::opeer, Our managed peer (an instance of java.lang.Thread)，应该是此线程对应的 java thread object 地址)
  self=0xb400007f542bbc00 (reinterpret_cast&lt;const void*&gt;(thread), native art::Thread 对象地址)
  sysTid=27750 (此线程在宿主系统上的 ID, ps -A -T) 
  nice=-10 (thread nice value，含义类似于 process nice value，可以动态调整的线程优先级)
  cgrp=default (执行此线程的 cpu 的 cpu group，来自于 /proc/self/task/[tid]/cgroup)
  
  /**
   * 左边的数字来自 sched_getscheduler(tid)，cpu scheduling policy，有以下值：
   * 
   * non-real-time
   * SCHED_NORMAL/SCHED_OTHER = 0   the standard round-robin time-sharing policy
   * SCHED_BATCH              = 3   for &quot;batch&quot; style execution of processes
   * SCHED_IDLE               = 5   for running very low priority background jobs
   * 
   * real-time
   * SCHED_FIFO               = 1   a first-in, first-out policy
   * SCHED_RR                 = 2   a round-robin policy
   *
   * 右边的数字来自于 sched_getparam, scheduling parameters，跟上面的 scheduling policy 配合使用
   *
   * 这两个都属于 cpu 调度相关，详见 man sched.7
   */
  sched=0/0 

  handle=0x7f559584f8 (Thread::tlsPtr_::pthread_self, 底层的 pthread_t 地址)

  /**
   * 来自 /proc/[pid]/task/[tid]/schedstat，分别是 CPU 上执行的时间、线程的等待时间和线程执行的时间片
   */
  schedstat=( 439366137 82406360 402 )

  /**
   * 来自 /proc/[pid]/task/[tid]/stat，里面的字段跟 /proc/[pid]/stat 类似
   * state=S(SLEEPING) 线程状态为休眠中
   * utm(utime) 线程运行在用户态的时间
   * stm(stime) 线程运行在内核态的时间
   * core(task_cpu) 运行在哪个 CPU 上
   */
  state=S  utm=36 stm=7 core=0 
  HZ=100 (sysconf(_SC_CLK_TCK)，每秒种的内核时钟滴答数)

  /**
   * Thread::tlsPtr_::stack_begin - Thread::tlsPtr_::stack_end
   * 方法栈的开始地址、结束地址和栈大小
   */
  stack=0x7ffd85d000-0x7ffd85f000 stackSize=8192KB
  
  /**
   * 此线程锁持有的锁类型，定义在 art/runtime/base/locks.h，有：
   * LockLevel::kLoggingLock, LockLevel::kSwapMutexesLock, ...
   */
  held mutexes=

  at java.lang.Thread.sleep(Native method)
  - sleeping on &lt;0x0bd69ce3&gt; (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:442)
  - locked &lt;0x0bd69ce3&gt; (a java.lang.Object)
  at java.lang.Thread.sleep(Thread.java:358)
  at com.example.myapplication.MainActivity.onCreate$lambda-0(MainActivity.kt:20)
  at com.example.myapplication.MainActivity.lambda$b-o9DaQhxOUy1smA7kVJfKXtbVM(MainActivity.kt:-1)
  at com.example.myapplication.-$$Lambda$MainActivity$b-o9DaQhxOUy1smA7kVJfKXtbVM.onClick(lambda:-1)
  at android.view.View.performClick(View.java:7509)
  at android.view.View.performClickInternal(View.java:7486)
  at android.view.View.access$3600(View.java:841)
  at android.view.View$PerformClick.run(View.java:28709)
  at android.os.Handler.handleCallback(Handler.java:938)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loop(Looper.java:236)
  at android.app.ActivityThread.main(ActivityThread.java:8061)
  at java.lang.reflect.Method.invoke(Native method)
  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)

&quot;Signal Catcher&quot; daemon prio=10 tid=4 Runnable
  | group=&quot;system&quot; sCount=0 dsCount=0 flags=0 obj=0x12d80260 self=0xb400007ebd813800
  | sysTid=27771 nice=-20 cgrp=default sched=0/0 handle=0x7ebdf73cc0
  | state=R schedstat=( 11436460 2051300 7 ) utm=0 stm=0 core=4 HZ=100
  | stack=0x7ebde7c000-0x7ebde7e000 stackSize=995KB
  | held mutexes= &quot;mutator lock&quot;(shared held)
  native: #00 pc 000000000047c188  /apex/com.android.art/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+140)
  native: #01 pc 0000000000581444  /apex/com.android.art/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, bool, BacktraceMap*, bool) const+380)
  native: #02 pc 000000000059e288  /apex/com.android.art/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+924)
  native: #03 pc 0000000000597c2c  /apex/com.android.art/lib64/libart.so (art::ThreadList::RunCheckpoint(art::Closure*, art::Closure*)+536)
  native: #04 pc 0000000000596cb4  /apex/com.android.art/lib64/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, bool)+1928)
  native: #05 pc 000000000059614c  /apex/com.android.art/lib64/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;)+776)
  native: #06 pc 0000000000543c68  /apex/com.android.art/lib64/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;)+196)
  native: #07 pc 0000000000559810  /apex/com.android.art/lib64/libart.so (art::SignalCatcher::HandleSigQuit()+1400)
  native: #08 pc 00000000005587d8  /apex/com.android.art/lib64/libart.so (art::SignalCatcher::Run(void*)+348)
  native: #09 pc 00000000000f4204  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+64)
  native: #10 pc 000000000008ec64  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)
  (no managed stack frames)</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SignalCatcher::HandleSigQuit</span><span class="hljs-params">()</span> </span>&#123;
  Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();
  std::ostringstream os;
  os &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>
      &lt;&lt; <span class="hljs-string">&quot;----- pid &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; <span class="hljs-built_in">GetIsoDate</span>() &lt;&lt; <span class="hljs-string">&quot; -----\n&quot;</span>;

  <span class="hljs-built_in">DumpCmdLine</span>(os);

  <span class="hljs-comment">// Note: The strings &quot;Build fingerprint:&quot; and &quot;ABI:&quot; are chosen to match the format used by</span>
  <span class="hljs-comment">// debuggerd. This allows, for example, the stack tool to work.</span>
  std::string fingerprint = runtime-&gt;<span class="hljs-built_in">GetFingerprint</span>();
  os &lt;&lt; <span class="hljs-string">&quot;Build fingerprint: &#x27;&quot;</span> &lt;&lt; (fingerprint.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;unknown&quot;</span> : fingerprint) &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;
  os &lt;&lt; <span class="hljs-string">&quot;ABI: &#x27;&quot;</span> &lt;&lt; <span class="hljs-built_in">GetInstructionSetString</span>(runtime-&gt;<span class="hljs-built_in">GetInstructionSet</span>()) &lt;&lt; <span class="hljs-string">&quot;&#x27;\n&quot;</span>;

  os &lt;&lt; <span class="hljs-string">&quot;Build type: &quot;</span> &lt;&lt; (kIsDebugBuild ? <span class="hljs-string">&quot;debug&quot;</span> : <span class="hljs-string">&quot;optimized&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

  runtime-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);

  <span class="hljs-keyword">if</span> ((<span class="hljs-literal">false</span>)) &#123;
    std::string maps;
    <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, &amp;maps)) &#123;
      os &lt;&lt; <span class="hljs-string">&quot;/proc/self/maps:\n&quot;</span> &lt;&lt; maps;
    &#125;
  &#125;
  os &lt;&lt; <span class="hljs-string">&quot;----- end &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; -----\n&quot;</span>;
  <span class="hljs-built_in">Output</span>(os.<span class="hljs-built_in">str</span>());
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Runtime::DumpForSigQuit</span><span class="hljs-params">(std::ostream&amp; os)</span> </span>&#123;
  <span class="hljs-built_in">GetClassLinker</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  <span class="hljs-built_in">GetInternTable</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  <span class="hljs-built_in">GetJavaVM</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  <span class="hljs-built_in">GetHeap</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  oat_file_manager_-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetJit</span>() != <span class="hljs-literal">nullptr</span>) &#123;
    <span class="hljs-built_in">GetJit</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  &#125; <span class="hljs-keyword">else</span> &#123;
    os &lt;&lt; <span class="hljs-string">&quot;Running non JIT\n&quot;</span>;
  &#125;
  <span class="hljs-built_in">DumpDeoptimizations</span>(os);
  TrackedAllocators::<span class="hljs-built_in">Dump</span>(os);
  <span class="hljs-built_in">GetMetrics</span>()-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  os &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

  thread_list_-&gt;<span class="hljs-built_in">DumpForSigQuit</span>(os);
  BaseMutex::<span class="hljs-built_in">DumpAll</span>(os);

  <span class="hljs-comment">// Inform anyone else who is interested in SigQuit.</span>
  &#123;
    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(Thread::Current())</span></span>;
    callbacks_-&gt;<span class="hljs-built_in">SigQuit</span>();
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DumpCmdLine</span><span class="hljs-params">(std::ostream&amp; os)</span> </span>&#123;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__linux__)</span>
  <span class="hljs-comment">// Show the original command line, and the current command line too if it&#x27;s changed.</span>
  <span class="hljs-comment">// On Android, /proc/self/cmdline will have been rewritten to something like &quot;system_server&quot;.</span>
  <span class="hljs-comment">// Note: The string &quot;Cmd line:&quot; is chosen to match the format used by debuggerd.</span>
  std::string current_cmd_line;
  <span class="hljs-keyword">if</span> (android::base::<span class="hljs-built_in">ReadFileToString</span>(<span class="hljs-string">&quot;/proc/self/cmdline&quot;</span>, &amp;current_cmd_line)) &#123;
    current_cmd_line.<span class="hljs-built_in">resize</span>(current_cmd_line.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&#x27;\0&#x27;</span>) + <span class="hljs-number">1</span>);  <span class="hljs-comment">// trim trailing &#x27;\0&#x27;s</span>
    std::<span class="hljs-built_in">replace</span>(current_cmd_line.<span class="hljs-built_in">begin</span>(), current_cmd_line.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>);

    os &lt;&lt; <span class="hljs-string">&quot;Cmd line: &quot;</span> &lt;&lt; current_cmd_line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* stashed_cmd_line = <span class="hljs-built_in">GetCmdLine</span>();
    <span class="hljs-keyword">if</span> (stashed_cmd_line != <span class="hljs-literal">nullptr</span> &amp;&amp; current_cmd_line != stashed_cmd_line
            &amp;&amp; <span class="hljs-built_in">strcmp</span>(stashed_cmd_line, <span class="hljs-string">&quot;&lt;unset&gt;&quot;</span>) != <span class="hljs-number">0</span>) &#123;
      os &lt;&lt; <span class="hljs-string">&quot;Original command line: &quot;</span> &lt;&lt; stashed_cmd_line &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    &#125;
  &#125;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  os &lt;&lt; <span class="hljs-string">&quot;Cmd line: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetCmdLine</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;</code></pre></div>

<h3 id="debuggerd-tombstoned"><a href="#debuggerd-tombstoned" class="headerlink" title="debuggerd.tombstoned"></a>debuggerd.tombstoned</h3><p>上一章节构造了 dump 字符串，下面我们来看看它被输出到哪里：</p>
<ol>
<li>通过 unix domain socket 连接到 <code>/dev/socket/tombstoned_java_trace</code> (<code>ANDROID_SOCKET_NAMESPACE_RESERVED</code> + <code>kTombstonedJavaTraceSocketName</code>，看名字像是一个叫 <code>debuggerd.tombstoned</code> 的服务)</li>
<li>将 <code>pid</code>、<code>dumpType</code> 等参数发送过去，返回一个 output fd (这个 fd 其实就是上面介绍过的 <code>debuggerd_trigger_dump</code> 里管道的 write fd，它被注册到 <code>debuggerd.tombstoned</code>)</li>
<li>把 dump 字符串写入 output fd</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SignalCatcher::Output</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;
  <span class="hljs-function">ScopedThreadStateChange <span class="hljs-title">tsc</span><span class="hljs-params">(Thread::Current(), kWaitingForSignalCatcherOutput)</span></span>;
  <span class="hljs-type">palette_status_t</span> status = <span class="hljs-built_in">PaletteWriteCrashThreadStacks</span>(s.<span class="hljs-built_in">data</span>(), s.<span class="hljs-built_in">size</span>());
  <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;
    <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Wrote stack traces to tombstoned&quot;</span>;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-built_in">CHECK</span>(status == PALETTE_STATUS_FAILED_CHECK_LOG);
    <span class="hljs-built_in">LOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to write stack traces to tombstoned&quot;</span>;
  &#125;
&#125;

<span class="hljs-comment">// system/libartpalette/palette_android.cc</span>
<span class="hljs-function"><span class="hljs-type">palette_status_t</span> <span class="hljs-title">PaletteWriteCrashThreadStacks</span><span class="hljs-params">(<span class="hljs-comment">/*in*/</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* stacks, <span class="hljs-type">size_t</span> stacks_len)</span> </span>&#123;
    android::base::unique_fd tombstone_fd;
    android::base::unique_fd output_fd;

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">tombstoned_connect</span>(<span class="hljs-built_in">getpid</span>(), &amp;tombstone_fd, &amp;output_fd, kDebuggerdJavaBacktrace)) &#123;
        <span class="hljs-comment">// Failure here could be due to file descriptor resource exhaustion</span>
        <span class="hljs-comment">// so write the stack trace message to the log in case it helps</span>
        <span class="hljs-comment">// debug that.</span>
        <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; std::<span class="hljs-built_in">string_view</span>(stacks, stacks_len);
        <span class="hljs-comment">// tombstoned_connect() logs failure reason.</span>
        <span class="hljs-keyword">return</span> PALETTE_STATUS_FAILED_CHECK_LOG;
    &#125;

    <span class="hljs-type">palette_status_t</span> status = PALETTE_STATUS_OK;
    <span class="hljs-keyword">if</span> (!android::base::<span class="hljs-built_in">WriteFully</span>(output_fd, stacks, stacks_len)) &#123;
        <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to write tombstoned output&quot;</span>;
        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">ftruncate</span>(output_fd, <span class="hljs-number">0</span>));
        status = PALETTE_STATUS_FAILED_CHECK_LOG;
    &#125;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fdatasync</span>(output_fd)) == <span class="hljs-number">-1</span> &amp;&amp; errno != EINVAL) &#123;
        <span class="hljs-comment">// Ignore EINVAL so we don&#x27;t report failure if we just tried to flush a pipe</span>
        <span class="hljs-comment">// or socket.</span>
        <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;
            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to fsync tombstoned output&quot;</span>;
            status = PALETTE_STATUS_FAILED_CHECK_LOG;
        &#125;
        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">ftruncate</span>(output_fd, <span class="hljs-number">0</span>));
        <span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fdatasync</span>(output_fd));
    &#125;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">close</span>(output_fd.<span class="hljs-built_in">release</span>()) == <span class="hljs-number">-1</span> &amp;&amp; errno != EINTR) &#123;
        <span class="hljs-keyword">if</span> (status == PALETTE_STATUS_OK) &#123;
            <span class="hljs-built_in">PLOG</span>(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to close tombstoned output&quot;</span>;
            status = PALETTE_STATUS_FAILED_CHECK_LOG;
        &#125;
    &#125;

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">tombstoned_notify_completion</span>(tombstone_fd)) &#123;
        <span class="hljs-comment">// tombstoned_notify_completion() logs failure.</span>
        status = PALETTE_STATUS_FAILED_CHECK_LOG;
    &#125;

    <span class="hljs-keyword">return</span> status;
&#125;

<span class="hljs-comment">// system/core/debuggerd/tombstoned/tombstoned_client.cpp</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">tombstoned_connect</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, unique_fd* tombstoned_socket, unique_fd* text_output_fd,</span></span>
<span class="hljs-params"><span class="hljs-function">                        unique_fd* proto_output_fd, DebuggerdDumpType dump_type)</span> </span>&#123;
  <span class="hljs-function">unique_fd <span class="hljs-title">sockfd</span><span class="hljs-params">(</span></span>
<span class="hljs-params"><span class="hljs-function">      socket_local_client((dump_type != kDebuggerdJavaBacktrace ? kTombstonedCrashSocketName</span></span>
<span class="hljs-params"><span class="hljs-function">                                                                : kTombstonedJavaTraceSocketName),</span></span>
<span class="hljs-params"><span class="hljs-function">                          ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_SEQPACKET))</span></span>;
  <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to connect to tombstoned: %s&quot;</span>,
                          <span class="hljs-built_in">strerror</span>(errno));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  TombstonedCrashPacket packet = &#123;&#125;;
  packet.packet_type = CrashPacketType::kDumpRequest;
  packet.packet.dump_request.pid = pid;
  packet.packet.dump_request.dump_type = dump_type;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">write</span>(sockfd, &amp;packet, <span class="hljs-built_in">sizeof</span>(packet))) != <span class="hljs-built_in">sizeof</span>(packet)) &#123;
    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to write DumpRequest packet: %s&quot;</span>,
                          <span class="hljs-built_in">strerror</span>(errno));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  unique_fd tmp_output_fd, tmp_proto_fd;
  <span class="hljs-type">ssize_t</span> rc = <span class="hljs-number">-1</span>;

  <span class="hljs-keyword">if</span> (dump_type == kDebuggerdTombstoneProto) &#123;
    rc = <span class="hljs-built_in">ReceiveFileDescriptors</span>(sockfd, &amp;packet, <span class="hljs-built_in">sizeof</span>(packet), &amp;tmp_output_fd, &amp;tmp_proto_fd);
  &#125; <span class="hljs-keyword">else</span> &#123;
    rc = <span class="hljs-built_in">ReceiveFileDescriptors</span>(sockfd, &amp;packet, <span class="hljs-built_in">sizeof</span>(packet), &amp;tmp_output_fd);
  &#125;

  <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">-1</span>) &#123;
    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>,
                          <span class="hljs-string">&quot;failed to read response to DumpRequest packet: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc != <span class="hljs-built_in">sizeof</span>(packet)) &#123;
    <span class="hljs-built_in">async_safe_format_log</span>(
        ANDROID_LOG_ERROR, <span class="hljs-string">&quot;libc&quot;</span>,
        <span class="hljs-string">&quot;received DumpRequest response packet of incorrect length (expected %zu, got %zd)&quot;</span>,
        <span class="hljs-built_in">sizeof</span>(packet), rc);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;

  <span class="hljs-comment">// Make the fd O_APPEND so that our output is guaranteed to be at the end of a file.</span>
  <span class="hljs-comment">// (This also makes selinux rules consistent, because selinux distinguishes between writing to</span>
  <span class="hljs-comment">// a regular fd, and writing to an fd with O_APPEND).</span>
  <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(tmp_output_fd.<span class="hljs-built_in">get</span>(), F_GETFL);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(tmp_output_fd.<span class="hljs-built_in">get</span>(), F_SETFL, flags | O_APPEND) != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-built_in">async_safe_format_log</span>(ANDROID_LOG_WARN, <span class="hljs-string">&quot;libc&quot;</span>, <span class="hljs-string">&quot;failed to set output fd flags: %s&quot;</span>,
                          <span class="hljs-built_in">strerror</span>(errno));
  &#125;

  *tombstoned_socket = std::<span class="hljs-built_in">move</span>(sockfd);
  *text_output_fd = std::<span class="hljs-built_in">move</span>(tmp_output_fd);
  <span class="hljs-keyword">if</span> (proto_output_fd) &#123;
    *proto_output_fd = std::<span class="hljs-built_in">move</span>(tmp_proto_fd);
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div>

<h2 id="dump-native-traces"><a href="#dump-native-traces" class="headerlink" title="dump native traces"></a>dump native traces</h2><p>最终还是来到 <code>debuggerd_trigger_dump</code>，只不过此时 <code>dump_type</code> 是 <code>kDebuggerdNativeBacktrace</code></p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Debug</span>.</span></span>dump<span class="hljs-constructor">NativeBacktraceToFileTimeout(<span class="hljs-params">pid</span>, <span class="hljs-params">file</span>, <span class="hljs-params">timeoutSecs</span>)</span>
android_os_Debug_dumpNativeBacktraceToFileTimeout
dump<span class="hljs-constructor">Traces(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jint</span> <span class="hljs-params">pid</span>, <span class="hljs-params">jstring</span> <span class="hljs-params">fileName</span>, <span class="hljs-params">jint</span> <span class="hljs-params">timeoutSecs</span>, DebuggerdDumpType <span class="hljs-params">dumpType</span>)</span>
dump<span class="hljs-constructor">_backtrace_to_file_timeout(<span class="hljs-params">pid_t</span> <span class="hljs-params">tid</span>, DebuggerdDumpType <span class="hljs-params">dump_type</span>, <span class="hljs-params">int</span> <span class="hljs-params">timeout_secs</span>, <span class="hljs-params">int</span> <span class="hljs-params">fd</span>)</span>
debuggerd<span class="hljs-constructor">_trigger_dump(<span class="hljs-params">pid_t</span> <span class="hljs-params">tid</span>, DebuggerdDumpType <span class="hljs-params">dump_type</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">timeout_ms</span>, <span class="hljs-params">unique_fd</span> <span class="hljs-params">output_fd</span>)</span></code></pre></div>

<h1 id="ANR-Dialog"><a href="#ANR-Dialog" class="headerlink" title="ANR Dialog"></a>ANR Dialog</h1><p>在 <code>ActivityManagerService.mUiHandler</code> 里打开 <code>AppNotRespondingDialog</code>，这个对话框一般会包含两个按钮：等待和关闭，如果选择关闭则会通过 <code>kill(pid, SIGKILL)</code> 杀死 ANR 进程</p>
<div class="code-wrapper"><pre><code class="hljs java">ProcessRecord.ErrorDialogController.showAnrDialogs
ProcessRecord.ErrorDialogController.scheduleForAllDialogs
ProcessRecord.ErrorDialogController.forAllDialogs

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppNotRespondingDialog</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;
            <span class="hljs-type">Intent</span> <span class="hljs-variable">appErrorIntent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

            MetricsLogger.action(getContext(), MetricsProto.MetricsEvent.ACTION_APP_ANR,
                    msg.what);

            <span class="hljs-keyword">switch</span> (msg.what) &#123;
                <span class="hljs-keyword">case</span> FORCE_CLOSE:
                    <span class="hljs-comment">// Kill the application.</span>
                    mService.killAppAtUsersRequest(mProc);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> WAIT_AND_REPORT:
                <span class="hljs-keyword">case</span> WAIT:
                    <span class="hljs-comment">// Continue waiting for the application.</span>
                    <span class="hljs-keyword">synchronized</span> (mService) &#123;
                        <span class="hljs-type">ProcessRecord</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> mProc;
                        <span class="hljs-keyword">final</span> <span class="hljs-type">ProcessErrorStateRecord</span> <span class="hljs-variable">errState</span> <span class="hljs-operator">=</span> app.mErrorState;

                        <span class="hljs-keyword">if</span> (msg.what == WAIT_AND_REPORT) &#123;
                            appErrorIntent = mService.mAppErrors.createAppErrorIntentLOSP(app,
                                    System.currentTimeMillis(), <span class="hljs-literal">null</span>);
                        &#125;

                        <span class="hljs-keyword">synchronized</span> (mService.mProcLock) &#123;
                            errState.setNotResponding(<span class="hljs-literal">false</span>);
                            errState.setNotRespondingReport(<span class="hljs-literal">null</span>);
                            errState.getDialogController().clearAnrDialogs();
                        &#125;
                        mService.mServices.scheduleServiceTimeoutLocked(app);
                    &#125;
                    <span class="hljs-keyword">break</span>;
            &#125;

            <span class="hljs-keyword">if</span> (appErrorIntent != <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    getContext().startActivity(appErrorIntent);
                &#125; <span class="hljs-keyword">catch</span> (ActivityNotFoundException e) &#123;
                    Slog.w(TAG, <span class="hljs-string">&quot;bug report receiver dissappeared&quot;</span>, e);
                &#125;
            &#125;

            dismiss();
        &#125;
    &#125;;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityManagerService</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">killAppAtUsersRequest</span><span class="hljs-params">(ProcessRecord app)</span> &#123;
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;
            mAppErrors.killAppAtUserRequestLocked(app);
        &#125;
    &#125;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppErrors</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">killAppAtUserRequestLocked</span><span class="hljs-params">(ProcessRecord app)</span> &#123;
        <span class="hljs-type">ErrorDialogController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> app.mErrorState.getDialogController();

        <span class="hljs-type">int</span> <span class="hljs-variable">reasonCode</span> <span class="hljs-operator">=</span> ApplicationExitInfo.REASON_ANR;
        <span class="hljs-type">int</span> <span class="hljs-variable">subReason</span> <span class="hljs-operator">=</span> ApplicationExitInfo.SUBREASON_UNKNOWN;
        <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;
            <span class="hljs-keyword">if</span> (controller.hasDebugWaitingDialog()) &#123;
                reasonCode = ApplicationExitInfo.REASON_OTHER;
                subReason = ApplicationExitInfo.SUBREASON_WAIT_FOR_DEBUGGER;
            &#125;
            controller.clearAllErrorDialogs();
            killAppImmediateLSP(app, reasonCode, subReason,
                    <span class="hljs-string">&quot;user-terminated&quot;</span>, <span class="hljs-string">&quot;user request after error&quot;</span>);
        &#125;
    &#125;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">killAppImmediateLSP</span><span class="hljs-params">(ProcessRecord app, <span class="hljs-type">int</span> reasonCode, <span class="hljs-type">int</span> subReason,</span>
<span class="hljs-params">            String reason, String killReason)</span> &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-type">ProcessErrorStateRecord</span> <span class="hljs-variable">errState</span> <span class="hljs-operator">=</span> app.mErrorState;
        errState.setCrashing(<span class="hljs-literal">false</span>);
        errState.setCrashingReport(<span class="hljs-literal">null</span>);
        errState.setNotResponding(<span class="hljs-literal">false</span>);
        errState.setNotRespondingReport(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> errState.mApp.getPid();
        <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span> &amp;&amp; pid != MY_PID) &#123;
            <span class="hljs-keyword">synchronized</span> (mBadProcessLock) &#123;
                handleAppCrashLSPB(app, reason,
                        <span class="hljs-literal">null</span> <span class="hljs-comment">/*shortMsg*/</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/*longMsg*/</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/*stackTrace*/</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/*data*/</span>);
            &#125;
            app.killLocked(killReason, reasonCode, subReason, <span class="hljs-literal">true</span>);
        &#125;
    &#125;     
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessRecord</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">killLocked</span><span class="hljs-params">(String reason, <span class="hljs-meta">@Reason</span> <span class="hljs-type">int</span> reasonCode, <span class="hljs-meta">@SubReason</span> <span class="hljs-type">int</span> subReason,</span>
<span class="hljs-params">            <span class="hljs-type">boolean</span> noisy)</span> &#123;
        <span class="hljs-keyword">if</span> (!mKilledByAm) &#123;
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;kill&quot;</span>);
            <span class="hljs-keyword">if</span> (mService != <span class="hljs-literal">null</span> &amp;&amp; (noisy || info.uid == mService.mCurOomAdjUid)) &#123;
                mService.reportUidInfoMessageLocked(TAG,
                        <span class="hljs-string">&quot;Killing &quot;</span> + toShortString() + <span class="hljs-string">&quot; (adj &quot;</span> + mState.getSetAdj()
                        + <span class="hljs-string">&quot;): &quot;</span> + reason, info.uid);
            &#125;
            <span class="hljs-keyword">if</span> (mPid &gt; <span class="hljs-number">0</span>) &#123;
                mService.mProcessList.noteAppKill(<span class="hljs-built_in">this</span>, reasonCode, subReason, reason);
                EventLog.writeEvent(EventLogTags.AM_KILL,
                        userId, mPid, processName, mState.getSetAdj(), reason);
                Process.killProcessQuiet(mPid);
                ProcessList.killProcessGroup(uid, mPid);
            &#125; <span class="hljs-keyword">else</span> &#123;
                mPendingStart = <span class="hljs-literal">false</span>;
            &#125;
            <span class="hljs-keyword">if</span> (!mPersistent) &#123;
                <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;
                    mKilled = <span class="hljs-literal">true</span>;
                    mKilledByAm = <span class="hljs-literal">true</span>;
                    mKillTime = SystemClock.uptimeMillis();
                &#125;
            &#125;
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        &#125;
    &#125;    
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Process</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL_KILL</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">killProcessQuiet</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span> &#123;
        sendSignalQuiet(pid, SIGNAL_KILL);
    &#125;    
&#125;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">android_os_Process_sendSignalQuiet</span><span class="hljs-params">(JNIEnv* env, jobject clazz, jint pid, jint sig)</span>
&#123;
    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;
        kill(pid, sig);
    &#125;
&#125;</code></pre></div>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f9b8c139c2ed">Linux对内存的管理, 以及page fault的概念</a></li>
<li><a target="_blank" rel="noopener" href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">Understanding page faults and memory swap-in/outs: when should you worry?</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/topic/performance/vitals/anr">Android Developer ANRs</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/studio/debug/bug-report">Android Developer Bug Reports</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649288031&idx=1&sn=91c94e16460a4685a9c0c8e1b9c362a6">微信Android客户端的ANR监控方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6058e5c6332a">每日一面 - 什么是 Safepoint？</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/anr/">#anr</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/15/kotlin-coroutine/" title="深入分析 Kotlin Coroutines 是如何实现的">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入分析 Kotlin Coroutines 是如何实现的</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/05/mp4-structure/" title="MP4 文件结构浅析">
                        <span class="hidden-mobile">MP4 文件结构浅析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
