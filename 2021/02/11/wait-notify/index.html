

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/favicon.png">
  <link rel="icon" href="/image/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#141414">
  <meta name="author" content="Cyrus">
  <meta name="keywords" content="">
  
    <meta name="description" content="在 Lock（三）利用 Lock 实现 Condition 我们介绍了如何用 Lock 来实现 Condition，而 Condition 对标的是 Object.wait 和 Object.notify 我们来看看 ART 是怎么实现 wait&#x2F;notify 的（最好先了解下 synchronized 的基础知识） ConditionVariable对 futex&#x2F;mutex 的封装，宏 ART">
<meta property="og:type" content="article">
<meta property="og:title" content="Lock（五）Condition 的语言实现：Object.wait 和 Object.notify">
<meta property="og:url" content="https://www.dalvik.work/2021/02/11/wait-notify/index.html">
<meta property="og:site_name" content="Cyrus Blog">
<meta property="og:description" content="在 Lock（三）利用 Lock 实现 Condition 我们介绍了如何用 Lock 来实现 Condition，而 Condition 对标的是 Object.wait 和 Object.notify 我们来看看 ART 是怎么实现 wait&#x2F;notify 的（最好先了解下 synchronized 的基础知识） ConditionVariable对 futex&#x2F;mutex 的封装，宏 ART">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-11T04:00:00.000Z">
<meta property="article:modified_time" content="2022-03-31T10:47:12.132Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="wait">
<meta property="article:tag" content="notify">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>Lock（五）Condition 的语言实现：Object.wait 和 Object.notify - Cyrus Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/tomorrow-night-blue.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.dalvik.work","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#91cb3e","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":99},"lazyload":{"enable":true,"loading_img":"/image/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":"7d0c9146781b5fb9ae68cfc826d0be54","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cyrus Land</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/sunset_sea.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Lock（五）Condition 的语言实现：Object.wait 和 Object.notify">
              
                Lock（五）Condition 的语言实现：Object.wait 和 Object.notify
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-11 04:00" pubdate>
        2021年2月11日
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      105 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Lock（五）Condition 的语言实现：Object.wait 和 Object.notify</h1>
            
            <div class="markdown-body">
              <p>在 <a href="../../../../2021/01/24/condition-by-lock/">Lock（三）利用 Lock 实现 Condition</a> 我们介绍了如何用 <code>Lock</code> 来实现 <code>Condition</code>，而 <code>Condition</code> 对标的是 <code>Object.wait</code> 和 <code>Object.notify</code></p>
<p>我们来看看 ART 是怎么实现 wait/notify 的（最好先了解下 <a href="../../../../2021/02/08/synchronized-implementation/">synchronized 的基础知识</a>）</p>
<h2 id="ConditionVariable"><a href="#ConditionVariable" class="headerlink" title="ConditionVariable"></a>ConditionVariable</h2><p>对 futex/mutex 的封装，宏 <code>ART_USE_FUTEXES</code> 决定底层是使用 futex 还是 mutex；它不是「条件变量」，<code>Monitor</code> 才是（而且它还包含 Lock 的角色）</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::Wait</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  guard_.<span class="hljs-built_in">CheckSafeToWait</span>(self);
  <span class="hljs-built_in">WaitHoldingLocks</span>(self);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::WaitHoldingLocks</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());
  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_recursion_count = guard_.recursion_count_;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
  num_waiters_++;
  <span class="hljs-comment">// Ensure the Mutex is contended so that requeued threads are awoken.</span>
  guard_.<span class="hljs-built_in">increment_contenders</span>();
  guard_.recursion_count_ = <span class="hljs-number">1</span>;
  <span class="hljs-type">int32_t</span> cur_sequence = sequence_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
  guard_.<span class="hljs-built_in">ExclusiveUnlock</span>(self);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_sequence, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// Futex failed, check it is an expected error.</span>
    <span class="hljs-comment">// EAGAIN == EWOULDBLK, so we let the caller try again.</span>
    <span class="hljs-comment">// EINTR implies a signal was sent to this thread.</span>
    <span class="hljs-keyword">if</span> ((errno != EINTR) &amp;&amp; (errno != EAGAIN)) &#123;
      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;
    &#125;
  &#125;
  <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);
  guard_.<span class="hljs-built_in">ExclusiveLock</span>(self);
  <span class="hljs-built_in">CHECK_GT</span>(num_waiters_, <span class="hljs-number">0</span>);
  num_waiters_--;
  <span class="hljs-comment">// We awoke and so no longer require awakes from the guard_&#x27;s unlock.</span>
  <span class="hljs-built_in">CHECK_GT</span>(guard_.<span class="hljs-built_in">get_contenders</span>(), <span class="hljs-number">0</span>);
  guard_.<span class="hljs-built_in">decrement_contenders</span>();
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-type">pid_t</span> old_owner = guard_.<span class="hljs-built_in">GetExclusiveOwnerTid</span>();
  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);
  guard_.recursion_count_ = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_wait, (&amp;cond_, &amp;guard_.mutex_));
  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(old_owner, std::memory_order_relaxed);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
  guard_.recursion_count_ = old_recursion_count;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::Signal</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());
  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
  <span class="hljs-built_in">RequeueWaiters</span>(<span class="hljs-number">1</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_signal, (&amp;cond_));
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConditionVariable::RequeueWaiters</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> count)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (num_waiters_ &gt; <span class="hljs-number">0</span>) &#123;
    sequence_++;  <span class="hljs-comment">// Indicate a signal occurred.</span>
    <span class="hljs-comment">// Move waiters from the condition variable&#x27;s futex to the guard&#x27;s futex,</span>
    <span class="hljs-comment">// so that they will be woken up when the mutex is released.</span>
    <span class="hljs-type">bool</span> done = <span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(),
                      FUTEX_REQUEUE_PRIVATE,
                      <span class="hljs-comment">/* Threads to wake */</span> <span class="hljs-number">0</span>,
                      <span class="hljs-comment">/* Threads to requeue*/</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> timespec*&gt;(count),
                      guard_.state_and_contenders_.<span class="hljs-built_in">Address</span>(),
                      <span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span> (!done &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) &#123;
      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex requeue failed for &quot;</span> &lt;&lt; name_;
    &#125;
  &#125;
&#125;</code></pre></div>

<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>从逻辑上实现了「条件变量」，对应 Condition；它有两条单向链表的排队队列：</p>
<ul>
<li>等待队列，被挂起的线程（wait）在这里排队，<code>Monitor::wait_set_</code> 是队头</li>
<li>唤醒队列，等待被唤醒的线程（notify）在这里排队，<code>Monitor::wake_set_</code> 是队头</li>
</ul>
<p><code>Thread</code> 有个成员变量充当 next 指针：<code>Thread::GetWaitNext()</code> 和 <code>Thread::SetWaitNext(Thread* next)</code></p>
<p>await 是把线程添加到 wait set 队尾，notify 是把 wait set 队头转移为 wake set 队头，然后在退出临界区（释放锁）时唤醒 wake set 队头</p>
<p>同时 <code>Thread::wait_monitor_</code> 标识线程在哪个 <code>Monitor</code> 上挂起</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;
  <span class="hljs-comment">// Threads currently waiting on this monitor.</span>
  <span class="hljs-function">Thread* wait_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;
  <span class="hljs-comment">// Threads that were waiting on this monitor, but are now contending on it.</span>
  <span class="hljs-function">Thread* wake_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;
&#125;

<span class="hljs-comment">// 将新挂起的线程添加到 wait set 队尾</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::AppendToWaitSet</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;
  <span class="hljs-comment">// Not checking that the owner is equal to this thread, since we&#x27;ve released</span>
  <span class="hljs-comment">// the monitor by the time this method is called.</span>
  <span class="hljs-built_in">DCHECK</span>(thread != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-built_in">DCHECK</span>(thread-&gt;<span class="hljs-built_in">GetWaitNext</span>() == <span class="hljs-literal">nullptr</span>) &lt;&lt; thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();
  <span class="hljs-keyword">if</span> (wait_set_ == <span class="hljs-literal">nullptr</span>) &#123;
    wait_set_ = thread;
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-comment">// push_back.</span>
  Thread* t = wait_set_;
  <span class="hljs-keyword">while</span> (t-&gt;<span class="hljs-built_in">GetWaitNext</span>() != <span class="hljs-literal">nullptr</span>) &#123;
    t = t-&gt;<span class="hljs-built_in">GetWaitNext</span>();
  &#125;
  t-&gt;<span class="hljs-built_in">SetWaitNext</span>(thread);
&#125;

<span class="hljs-comment">// notify 并没有唤醒线程，而是把 wait set 的队头转移到 wake set 队头</span>
<span class="hljs-comment">// 实际上是在释放锁时唤醒 wake set 队头</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-comment">// Make sure that we hold the lock.</span>
  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;
    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-comment">// Move one thread from waiters to wake set</span>
  Thread* to_move = wait_set_;
  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;
    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();
    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);
    wake_set_ = to_move;
  &#125;
&#125;</code></pre></div>

<h2 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait"></a>Object.wait</h2><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> Object.wait() <span class="hljs-keyword">throws</span> InterruptedException &#123;
    wait(<span class="hljs-number">0</span>);
&#125;
<span class="hljs-keyword">void</span> Object.wait(<span class="hljs-type">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException &#123;
    wait(timeout, <span class="hljs-number">0</span>);
&#125;
<span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> Object.wait(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException;</code></pre></div>

<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/native/java_lang_Object.cc</span>

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Object_waitJI</span><span class="hljs-params">(JNIEnv* env, jobject java_this, jlong ms, jint ns)</span> </span>&#123;
  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;
  soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Wait</span>(soa.<span class="hljs-built_in">Self</span>(), ms, ns);
&#125;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Object::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-type">int64_t</span> ms, <span class="hljs-type">int32_t</span> ns)</span> </span>&#123;
  Monitor::<span class="hljs-built_in">Wait</span>(self, <span class="hljs-keyword">this</span>, ms, ns, <span class="hljs-literal">true</span>, kTimedWaiting);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self,</span></span>
<span class="hljs-params"><span class="hljs-function">                   ObjPtr&lt;mirror::Object&gt; obj,</span></span>
<span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int64_t</span> ms,</span></span>
<span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int32_t</span> ns,</span></span>
<span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">bool</span> interruptShouldThrow,</span></span>
<span class="hljs-params"><span class="hljs-function">                   ThreadState why)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;
  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;

  <span class="hljs-comment">// 将锁膨胀为 fat lock</span>
  LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">while</span> (lock_word.<span class="hljs-built_in">GetState</span>() != LockWord::kFatLocked) &#123;
    <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;
      <span class="hljs-keyword">case</span> LockWord::kHashCode:

      <span class="hljs-comment">// wait/notify 必须先用 synchronized 获取此对象上的锁</span>
      <span class="hljs-comment">// 否则抛出 java 异常</span>
      <span class="hljs-keyword">case</span> LockWord::kUnlocked:
        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);
        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>

      <span class="hljs-comment">// 同上，必须获得此对象锁；此时对象锁被别的线程持有，抛出 java 异常</span>
      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;
        <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();
        <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();
        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;
          <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);
          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>
        &#125; <span class="hljs-keyword">else</span> &#123;

          <span class="hljs-comment">// 将 thin lock（偏向锁）膨胀为 fat lock（重量级锁），同时创建一个监视器 Monitor</span>
          <span class="hljs-comment">// We own the lock, inflate to enqueue ourself on the Monitor. May fail spuriously so</span>
          <span class="hljs-comment">// re-load.</span>
          <span class="hljs-built_in">Inflate</span>(self, self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>);
          lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);
        &#125;
        <span class="hljs-keyword">break</span>;
      &#125;

      <span class="hljs-comment">// 已经是 fat lock 了</span>
      <span class="hljs-keyword">case</span> LockWord::kFatLocked:  <span class="hljs-comment">// Unreachable given the loop condition above. Fall-through.</span>
      <span class="hljs-keyword">default</span>: &#123;
        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();
        <span class="hljs-built_in">UNREACHABLE</span>();
      &#125;
    &#125;
  &#125;

  <span class="hljs-comment">// 必须膨胀为 fat lock，它才有 Monitor</span>
  Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();
  mon-&gt;<span class="hljs-built_in">Wait</span>(self, ms, ns, interruptShouldThrow, why);
&#125;

<span class="hljs-comment">// 在监视器上挂起</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-type">int64_t</span> ms, <span class="hljs-type">int32_t</span> ns,</span></span>
<span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">bool</span> interruptShouldThrow, ThreadState why)</span> </span>&#123;
  <span class="hljs-comment">/*</span>
<span class="hljs-comment">   * Release our hold - we need to let it go even if we&#x27;re a few levels</span>
<span class="hljs-comment">   * deep in a recursive lock, and we need to restore that later.</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prev_lock_count = lock_count_;
  lock_count_ = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 挂起线程前需要释放锁</span>
  <span class="hljs-comment">// 将线程添加到 wait set 队尾，释放锁，wake set 不为空则唤醒第一个（队头开始）</span>
  <span class="hljs-type">bool</span> was_interrupted = <span class="hljs-literal">false</span>;
  <span class="hljs-type">bool</span> timed_out = <span class="hljs-literal">false</span>;
  owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);
  num_waiters_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);
  &#123;
    <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, why)</span></span>;
    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;
    <span class="hljs-built_in">AppendToWaitSet</span>(self);
    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-keyword">this</span>);
    <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);
    <span class="hljs-comment">// Handle the case where the thread was interrupted before we called wait().</span>
    <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">IsInterrupted</span>()) &#123;
      was_interrupted = <span class="hljs-literal">true</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;

      <span class="hljs-comment">// 然后将线程在它的成员变量 Thread.wait_cond_ 上挂起</span>
      <span class="hljs-comment">// Wait for a notification or a timeout to occur.</span>
      <span class="hljs-keyword">if</span> (why == kWaiting) &#123;
        self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Wait</span>(self);
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">DCHECK</span>(why == kTimedWaiting || why == kSleeping) &lt;&lt; why;
        timed_out = self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">TimedWait</span>(self, ms, ns);
      &#125;
      was_interrupted = self-&gt;<span class="hljs-built_in">IsInterrupted</span>();
    &#125;
  &#125;

  <span class="hljs-comment">// 线程被唤醒后，要将线程上的监视器置空，并重新获得锁</span>
  &#123;
    <span class="hljs-comment">// We reset the thread&#x27;s wait_monitor_ field after transitioning back to runnable so</span>
    <span class="hljs-comment">// that a thread in a waiting/sleeping state has a non-null wait_monitor_ for debugging</span>
    <span class="hljs-comment">// and diagnostic purposes. (If you reset this earlier, stack dumps will claim that threads</span>
    <span class="hljs-comment">// are waiting on &quot;null&quot;.)</span>
    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;
    <span class="hljs-built_in">DCHECK</span>(self-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>);
    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-literal">nullptr</span>);
  &#125;
  <span class="hljs-built_in">Lock</span>&lt;LockReason::kForWait&gt;(self);
  lock_count_ = prev_lock_count;
  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));
  self-&gt;<span class="hljs-built_in">GetWaitMutex</span>()-&gt;<span class="hljs-built_in">AssertNotHeld</span>(self);
  num_waiters_.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);
  <span class="hljs-built_in">RemoveFromWaitSet</span>(self);
&#125;</code></pre></div>

<h2 id="Object-notify"><a href="#Object-notify" class="headerlink" title="Object.notify"></a>Object.notify</h2><p>把挂起的线程从 wait set 转移到 wake set</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Object_notify</span><span class="hljs-params">(JNIEnv* env, jobject java_this)</span> </span>&#123;
  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;
  soa.<span class="hljs-built_in">Decode</span>&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Notify</span>(soa.<span class="hljs-built_in">Self</span>());
&#125;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Object::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  Monitor::<span class="hljs-built_in">Notify</span>(self, <span class="hljs-keyword">this</span>);
&#125;
<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span></span>
<span class="hljs-function">      <span class="hljs-title">REQUIRES_SHARED</span><span class="hljs-params">(Locks::mutator_lock_)</span> </span>&#123;
    <span class="hljs-built_in">DoNotify</span>(self, obj, <span class="hljs-literal">false</span>);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::DoNotify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-type">bool</span> notify_all)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);
  LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;
    <span class="hljs-keyword">case</span> LockWord::kHashCode:
      <span class="hljs-comment">// Fall-through.</span>
    <span class="hljs-keyword">case</span> LockWord::kUnlocked:
      <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);
      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>
    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;
      <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();
      <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();
      <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;
        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);
        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span>
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// We own the lock but there&#x27;s no Monitor and therefore no waiters.</span>
        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span>
      &#125;
    &#125;
    <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;
      Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();
      <span class="hljs-keyword">if</span> (notify_all) &#123;
        mon-&gt;<span class="hljs-built_in">NotifyAll</span>(self);
      &#125; <span class="hljs-keyword">else</span> &#123;
        mon-&gt;<span class="hljs-built_in">Notify</span>(self);
      &#125;
      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span>
    &#125;
    <span class="hljs-keyword">default</span>: &#123;
      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();
      <span class="hljs-built_in">UNREACHABLE</span>();
    &#125;
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-comment">// Make sure that we hold the lock.</span>
  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;
    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-comment">// Move one thread from waiters to wake set</span>
  Thread* to_move = wait_set_;
  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;
    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();
    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);
    wake_set_ = to_move;
  &#125;
&#125;</code></pre></div>

<p>调用 notify 前需要先获得它的对象锁，notify 把线程转移到 wake set，释放锁时会唤醒线程（从而让线程能够重新获得锁）</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
  <span class="hljs-keyword">if</span> (owner == self) &#123;
    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span>
    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);
    <span class="hljs-built_in">AtraceMonitorUnlock</span>();
    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;
      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);
      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);
    &#125; <span class="hljs-keyword">else</span> &#123;
      --lock_count_;
      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));
      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);
      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span>
      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-comment">// We want to release the monitor and signal up to one thread that was waiting</span>
  <span class="hljs-comment">// but has since been notified.</span>
  <span class="hljs-built_in">DCHECK_EQ</span>(lock_count_, <span class="hljs-number">0u</span>);
  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));
  <span class="hljs-keyword">while</span> (wake_set_ != <span class="hljs-literal">nullptr</span>) &#123;
    <span class="hljs-comment">// No risk of waking ourselves here; since monitor_lock_ is not released until we&#x27;re ready to</span>
    <span class="hljs-comment">// return, notify can&#x27;t move the current thread from wait_set_ to wake_set_ until this</span>
    <span class="hljs-comment">// method is done checking wake_set_.</span>
    Thread* thread = wake_set_;
    wake_set_ = thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();
    thread-&gt;<span class="hljs-built_in">SetWaitNext</span>(<span class="hljs-literal">nullptr</span>);
    <span class="hljs-built_in">DCHECK</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) == <span class="hljs-literal">nullptr</span>);

    <span class="hljs-comment">// Check to see if the thread is still waiting.</span>
    &#123;
      <span class="hljs-comment">// In the case of wait(), we&#x27;ll be acquiring another thread&#x27;s GetWaitMutex with</span>
      <span class="hljs-comment">// self&#x27;s GetWaitMutex held. This does not risk deadlock, because we only acquire this lock</span>
      <span class="hljs-comment">// for threads in the wake_set_. A thread can only enter wake_set_ from Notify or NotifyAll,</span>
      <span class="hljs-comment">// and those hold monitor_lock_. Thus, the threads whose wait mutexes we acquire here must</span>
      <span class="hljs-comment">// have already been released from wait(), since we have not released monitor_lock_ until</span>
      <span class="hljs-comment">// after we&#x27;ve chosen our thread to wake, so there is no risk of the following lock ordering</span>
      <span class="hljs-comment">// leading to deadlock:</span>
      <span class="hljs-comment">// Thread 1 waits</span>
      <span class="hljs-comment">// Thread 2 waits</span>
      <span class="hljs-comment">// Thread 3 moves threads 1 and 2 from wait_set_ to wake_set_</span>
      <span class="hljs-comment">// Thread 1 enters this block, and attempts to acquire Thread 2&#x27;s GetWaitMutex to wake it</span>
      <span class="hljs-comment">// Thread 2 enters this block, and attempts to acquire Thread 1&#x27;s GetWaitMutex to wake it</span>
      <span class="hljs-comment">//</span>
      <span class="hljs-comment">// Since monitor_lock_ is not released until the thread-to-be-woken-up&#x27;s GetWaitMutex is</span>
      <span class="hljs-comment">// acquired, two threads cannot attempt to acquire each other&#x27;s GetWaitMutex while holding</span>
      <span class="hljs-comment">// their own and cause deadlock.</span>
      <span class="hljs-function">MutexLock <span class="hljs-title">wait_mu</span><span class="hljs-params">(self, *thread-&gt;GetWaitMutex())</span></span>;
      <span class="hljs-keyword">if</span> (thread-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>) &#123;
        <span class="hljs-comment">// Release the lock, so that a potentially awakened thread will not</span>
        <span class="hljs-comment">// immediately contend on it. The lock ordering here is:</span>
        <span class="hljs-comment">// monitor_lock_, self-&gt;GetWaitMutex, thread-&gt;GetWaitMutex</span>
        monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);  <span class="hljs-comment">// Releases contenders.</span>
        thread-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Signal</span>(self);
        <span class="hljs-keyword">return</span>;
      &#125;
    &#125;
  &#125;
  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);
  <span class="hljs-built_in">DCHECK</span>(!monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));
&#125;</code></pre></div>

<h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><ul>
<li>与 JCU.Condition 不同，对象监视器 Monitor 并没有把「条件变量」这部分功能抽离出来，它既是 Lock 又是 Condition</li>
<li>Condition 和 Monitor 都用排队队列来组织挂起的线程</li>
<li>Condition 在 notify 后立刻唤醒线程，而 Monitor 因为 wait/notify 需要获得锁后才能执行，只能在 notify 线程释放锁时才唤醒 wait 线程</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/wait/">wait</a>
                    
                      <a class="hover-with-bg" href="/tags/notify/">notify</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/19/threadpool/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">线程池 ThreadPool 的实现</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/08/synchronized-implementation/">
                        <span class="hidden-mobile">Lock（四）synchronized 的语言实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
