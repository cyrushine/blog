

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/image/favicon.png">
  <link rel="icon" href="/image/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#141414">
  <meta name="author" content="Cyrus">
  <meta name="keywords" content="">
  
    <meta name="description" content="monitor 指令在 Lock（二）AQS 源码分析以及 Lock 的实现 这篇文章里介绍了基于 AQS 的 Lock，它是双向链表的排队队列和系统调用 futex 实现的 其实 java 语言规范里自带了 Lock 的实现：synchronized 关键字，下面看看 ART 是怎么实现它的 先写一个使用了 synchronized 的测试方法 package com.example.myapp">
<meta property="og:type" content="article">
<meta property="og:title" content="Lock（四）synchronized 的语言实现">
<meta property="og:url" content="https://www.dalvik.work/2021/02/08/synchronized-implementation/index.html">
<meta property="og:site_name" content="Cyrus Blog">
<meta property="og:description" content="monitor 指令在 Lock（二）AQS 源码分析以及 Lock 的实现 这篇文章里介绍了基于 AQS 的 Lock，它是双向链表的排队队列和系统调用 futex 实现的 其实 java 语言规范里自带了 Lock 的实现：synchronized 关键字，下面看看 ART 是怎么实现它的 先写一个使用了 synchronized 的测试方法 package com.example.myapp">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-08T04:00:00.000Z">
<meta property="article:modified_time" content="2023-03-27T08:59:59.378Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Lock（四）synchronized 的语言实现 - Cyrus Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.dalvik.work","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#91cb3e","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":99},"lazyload":{"enable":true,"loading_img":"/image/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"7d0c9146781b5fb9ae68cfc826d0be54","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cyrus Land</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/image/sunset_sea.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Lock（四）synchronized 的语言实现</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-02-08 04:00" pubdate>
          2021年2月8日
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          162 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Lock（四）synchronized 的语言实现</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="monitor-指令"><a href="#monitor-指令" class="headerlink" title="monitor 指令"></a>monitor 指令</h2><p>在 <a href="../../../../2021/01/13/aqs-lock-implementation/">Lock（二）AQS 源码分析以及 Lock 的实现</a> 这篇文章里介绍了基于 AQS 的 <code>Lock</code>，它是双向链表的排队队列和系统调用 <code>futex</code> 实现的</p>
<p>其实 java 语言规范里自带了 Lock 的实现：<code>synchronized</code> 关键字，下面看看 ART 是怎么实现它的</p>
<p>先写一个使用了 <code>synchronized</code> 的测试方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapplication;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">(String msg)</span> &#123;
        <span class="hljs-keyword">synchronized</span>(lock) &#123;
            System.out.println(msg != <span class="hljs-literal">null</span> ? msg : <span class="hljs-string">&quot;null&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">Hello</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hello</span>();
        instance.say(<span class="hljs-string">&quot;Hello World&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>编译打包出 apk 文件，解压出其中的 classes.dex，并用 <code>baksmali</code> 转换成 smali 指令</p>
<div class="code-wrapper"><pre><code class="hljs bash">java -jar baksmali-2.4.0.jar disassemble classes.dex</code></pre></div>

<p><code>Hello.say(String)</code> 对应的 smali 代码是这样的</p>
<p><code>synchronized</code> 代码块被两条指令包裹：<code>monitor-enter</code> 和 <code>monitor-exit</code></p>
<div class="code-wrapper"><pre><code class="hljs bash">.method public say(Ljava/lang/String;)V
    .registers 5
    .param p1, <span class="hljs-string">&quot;msg&quot;</span>    <span class="hljs-comment"># Ljava/lang/String;</span>

    .line 8
		<span class="hljs-comment"># 本地变量寄存器 v0 被赋予 Hello.lock</span>
    iget-object v0, p0, Lcom/example/myapplication/Hello;-&gt;lock:Ljava/lang/Object;

		<span class="hljs-comment"># 重点</span>
    monitor-enter v0

    .line 9
    :try_start_3
    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;

    if-eqz p1, :cond_9

    move-object v2, p1

    goto :goto_b

    :cond_9
    const-string v2, <span class="hljs-string">&quot;null&quot;</span>

    :goto_b
    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V

    .line 10
		<span class="hljs-comment"># 重点</span>
    monitor-exit v0

    .line 11
    return-void

    .line 10
    :catchall_10
    move-exception v1

    monitor-exit v0
    :try_end_12
    .catchall &#123;:try_start_3 .. :try_end_12&#125; :catchall_10

    throw v1
.end method</code></pre></div>

<h2 id="对象锁的概念"><a href="#对象锁的概念" class="headerlink" title="对象锁的概念"></a>对象锁的概念</h2><p>在进一步分析代码之前，先要了解下 java 对象锁的一些背景知识（from <a target="_blank" rel="noopener" href="https://blog.csdn.net/fan1865221/article/details/96338419">JAVA锁的膨胀过程</a>）</p>
<p>java 对象锁会有一个膨胀加码的过程：无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p>
<ul>
<li><strong>无锁</strong></li>
<li><strong>偏向锁，</strong>为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</li>
<li><strong>轻量级锁，</strong>在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，所以轻量级锁一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li>
<li><strong>重量级锁，</strong>当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。</li>
</ul>
<h2 id="LockWord"><a href="#LockWord" class="headerlink" title="LockWord"></a>LockWord</h2><p>先了解一个结构<code>LockWord</code> ，它其实是一个 <code>uint32_t</code>，低 16 bits 保存持有锁的 thread id，后续 12 bits 保存锁的个数</p>
<p>它是 <code>Object</code> 的成员变量 <code>monitor_</code>，所以每个 java 对象都可以作为锁使用</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> LockWord <span class="hljs-title">FromThinLockId</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> thread_id, <span class="hljs-type">uint32_t</span> count, <span class="hljs-type">uint32_t</span> gc_state)</span> </span>&#123;
    <span class="hljs-built_in">CHECK_LE</span>(thread_id, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kThinLockMaxOwner));
    <span class="hljs-built_in">CHECK_LE</span>(count, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kThinLockMaxCount));
    <span class="hljs-comment">// DCHECK_EQ(gc_bits &amp; kGCStateMaskToggled, 0U);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">LockWord</span>((thread_id &lt;&lt; kThinLockOwnerShift) |
                    (count &lt;&lt; kThinLockCountShift) |
                    (gc_state &lt;&lt; kGCStateShift) |
                    (kStateThinOrUnlocked &lt;&lt; kStateShift));
&#125;

<span class="hljs-comment">// C++ mirror of java.lang.Object</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MANAGED</span> LOCKABLE Object &#123;
	<span class="hljs-comment">// Monitor and hash code information.</span>
	<span class="hljs-type">uint32_t</span> monitor_;
&#125;</code></pre></div>

<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>ART 使用 <code>Mutex</code> 作为互斥量的实现（lock &amp; unlock），它根据宏 <code>ART_USE_FUTEXES</code> 决定是使用 <code>futex</code> 还是 <code>mutex</code></p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span>

<span class="hljs-comment">// 获取排它锁</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mutex::ExclusiveLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">do</span> &#123;
      <span class="hljs-comment">// Mutex::state_and_contenders_ 是 AtomicInteger</span>
      <span class="hljs-comment">// 最低 1 bit 表示互斥量是否被持有（1 - 持有，0 - 未持有），其余高位的 bits 表示在此互斥量上挂起的线程数量</span>
      <span class="hljs-type">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
      <span class="hljs-comment">// 锁没有被取走，立刻获得锁（cas）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) <span class="hljs-comment">/* lock not held */</span>) &#123;
        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);
      &#125; <span class="hljs-keyword">else</span> &#123;

        <span class="hljs-comment">// 否则将挂起线程的数量加一，并用 futex 挂起当前线程</span>
        ScopedContentionRecorder <span class="hljs-built_in">scr</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">SafeGetTid</span>(self), <span class="hljs-built_in">GetExclusiveOwnerTid</span>());
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self, [](<span class="hljs-type">int32_t</span> v) &#123; <span class="hljs-built_in">return</span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;
          <span class="hljs-comment">// Increment contender count. We can&#x27;t create enough threads for this to overflow.</span>
          <span class="hljs-built_in">increment_contenders</span>();
          <span class="hljs-comment">// Make cur_state again reflect the expected value of state_and_contenders.</span>
          cur_state += kContenderIncrement;
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(should_respond_to_empty_checkpoint_request_)) &#123;
            self-&gt;<span class="hljs-built_in">CheckEmptyCheckpointFromMutex</span>();
          &#125;
          <span class="hljs-keyword">do</span> &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_state, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;
              <span class="hljs-keyword">if</span> ((errno != EAGAIN) &amp;&amp; (errno != EINTR)) &#123;
                <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;
              &#125;
            &#125;
            <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);
            <span class="hljs-comment">// Retry until not held. In heavy contention situations we otherwise get redundant</span>
            <span class="hljs-comment">// futex wakeups as a result of repeatedly decrementing and incrementing contenders.</span>
            cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
          &#125; <span class="hljs-keyword">while</span> ((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>);
          <span class="hljs-built_in">decrement_contenders</span>();
        &#125;
      &#125;
    &#125; <span class="hljs-keyword">while</span> (!done);
    <span class="hljs-comment">// Confirm that lock is now held.</span>
    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>

    <span class="hljs-comment">// 使用 pthread_mutex_lock 加锁</span>
    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_lock, (&amp;mutex_));
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

    <span class="hljs-comment">// exclusive_owner_ 记下获得排他锁的 thread id</span>
    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);
    <span class="hljs-built_in">RegisterAsLocked</span>(self);
  &#125;
  recursion_count_++;
&#125;

<span class="hljs-comment">// tryLock 方法</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">do</span> &#123;

      <span class="hljs-comment">// 使用 futex 的情况下，利用一个 AtomicInteger 的最低 1 bit 表示锁有没被借出，一个 cas 操作即可</span>
      <span class="hljs-type">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
      <span class="hljs-keyword">if</span> ((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">// Change state to held and impose load/store ordering appropriate for lock acquisition.</span>
        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      &#125;
    &#125; <span class="hljs-keyword">while</span> (!done);
    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>

    <span class="hljs-comment">// mutex</span>
    <span class="hljs-type">int</span> result = <span class="hljs-built_in">pthread_mutex_trylock</span>(&amp;mutex_);
    <span class="hljs-comment">// ...</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

    <span class="hljs-comment">// exclusive_owner_ 记下获得锁的 thread id</span>
    <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetExclusiveOwnerTid</span>(), <span class="hljs-number">0</span>);
    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);
    <span class="hljs-built_in">RegisterAsLocked</span>(self);
  &#125;
  recursion_count_++;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-comment">// 也是 tryLock 方法，特别的是它会自旋一小会</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLockWithSpinning</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-comment">// Spin a small number of times, since this affects our ability to respond to suspension</span>
  <span class="hljs-comment">// requests. We spin repeatedly only if the mutex repeatedly becomes available and unavailable</span>
  <span class="hljs-comment">// in rapid succession, and then we will typically not spin for the maximal period.</span>
  <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxSpins = <span class="hljs-number">5</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kMaxSpins; ++i) &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ExclusiveTryLock</span>(self)) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self,
            [](<span class="hljs-type">int32_t</span> v) &#123; <span class="hljs-built_in">return</span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ExclusiveTryLock</span>(self);
&#125;

<span class="hljs-comment">// 释放排它锁</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mutex::ExclusiveUnlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  recursion_count_--;
  <span class="hljs-keyword">if</span> (!recursive_ || recursion_count_ == <span class="hljs-number">0</span>) &#123;
    <span class="hljs-built_in">RegisterAsUnlocked</span>(self);
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">do</span> &#123;

      <span class="hljs-comment">// 使用 cas 将 state_and_contenders_ 最低 1 bit 置零（表示锁没被借出）</span>
      <span class="hljs-type">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>)) &#123;
        <span class="hljs-comment">// We&#x27;re no longer the owner.</span>
        exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);
        <span class="hljs-comment">// Change state to not held and impose load/store ordering appropriate for lock release.</span>
        <span class="hljs-type">uint32_t</span> new_state = cur_state &amp; ~kHeldMask;  <span class="hljs-comment">// Same number of contenders.</span>
        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakRelease</span>(cur_state, new_state);

        <span class="hljs-comment">// state_and_contenders_ 不为零表示仍有线程在锁上挂起，用 futex 让系统唤醒其中一个</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(done)) &#123;  <span class="hljs-comment">// Spurious fail or waiters changed ?</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(new_state != <span class="hljs-number">0</span>) <span class="hljs-comment">/* have contenders */</span>) &#123;
            <span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE, kWakeOne,
                  <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);
          &#125;
          <span class="hljs-comment">// We only do a futex wait after incrementing contenders and verifying the lock was</span>
          <span class="hljs-comment">// still held. If we didn&#x27;t see waiters, then there couldn&#x27;t have been any futexes</span>
          <span class="hljs-comment">// waiting on this lock when we did the CAS. New arrivals after that cannot wait for us,</span>
          <span class="hljs-comment">// since the futex wait call would see the lock available and immediately return.</span>
        &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 异常情况...</span>
      &#125;
    &#125; <span class="hljs-keyword">while</span> (!done);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>

    <span class="hljs-comment">// mutex</span>
    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);
    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_unlock, (&amp;mutex_));
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
  &#125;
&#125;

<span class="hljs-comment">// Unlock 等同于 ExclusiveUnlock</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(Thread* self)</span> <span class="hljs-title">RELEASE</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">ExclusiveUnlock</span>(self); &#125;</code></pre></div>

<h2 id="monitor-enter-指令"><a href="#monitor-enter-指令" class="headerlink" title="monitor-enter 指令"></a><code>monitor-enter</code> 指令</h2><h3 id="无锁、偏向锁和轻量级锁"><a href="#无锁、偏向锁和轻量级锁" class="headerlink" title="无锁、偏向锁和轻量级锁"></a>无锁、偏向锁和轻量级锁</h3><p>进入临界区，尝试获得锁</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 在 cs.android.com 找到的相关性很高的方法，可能不是指令 monitor-enter 直接调用的方法，但最终应该会走到这里来</span>
<span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Object::MonitorEnter</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorEnter</span>(self, <span class="hljs-keyword">this</span>, <span class="hljs-comment">/*trylock=*/</span><span class="hljs-literal">false</span>);
&#125;

<span class="hljs-function">ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Monitor::MonitorEnter</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-type">bool</span> trylock)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);
  self-&gt;<span class="hljs-built_in">AssertThreadSuspensionIsAllowable</span>();
  obj = <span class="hljs-built_in">FakeLock</span>(obj);
  <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();
  <span class="hljs-type">size_t</span> contention_count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> kExtraSpinIters = <span class="hljs-number">100</span>;
  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;
  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> !ART_USE_FUTEXES</span>
  <span class="hljs-comment">// In this case we cannot inflate an unowned monitor, so we sometimes defer inflation.</span>
  <span class="hljs-type">bool</span> should_inflate = <span class="hljs-literal">false</span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;

      <span class="hljs-comment">// 无锁的情况下，升级为偏向锁（thin lock）</span>
      <span class="hljs-comment">// 偏向锁记录下 thread id 和锁的个数 0，通过 cas 记录在 Object.monitor_</span>
      <span class="hljs-keyword">case</span> LockWord::kUnlocked: &#123;
        <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id, <span class="hljs-number">0</span>, lock_word.GCState()))</span></span>;
        <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, thin_locked, CASMode::kWeak, std::memory_order_acquire)) &#123;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> !ART_USE_FUTEXES</span>
          <span class="hljs-keyword">if</span> (should_inflate) &#123;
            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);
          &#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
          <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);
          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>
        &#125;
        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span>
      &#125;

      <span class="hljs-comment">// 偏向锁，而且当前线程跟偏向锁里记录的线程是同一个线程</span>
      <span class="hljs-comment">// 那么只需把偏向锁里的锁个数加一即可，依然使用 cas 保存在 Object.monitor_</span>
      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;
        <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();
        <span class="hljs-keyword">if</span> (owner_thread_id == thread_id) &#123;
          <span class="hljs-comment">// No ordering required for initial lockword read.</span>
          <span class="hljs-comment">// We own the lock, increase the recursion count.</span>
          <span class="hljs-type">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() + <span class="hljs-number">1</span>;
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(new_count &lt;= LockWord::kThinLockMaxCount)) &#123;
            <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id,</span></span>
<span class="hljs-params"><span class="hljs-function">                                                          new_count,</span></span>
<span class="hljs-params"><span class="hljs-function">                                                          lock_word.GCState()))</span></span>;
            <span class="hljs-comment">// 重新设置偏向锁，一个选择用 cas 原子操作符，另一个选择没用，不明这样区分的意义</span>
            <span class="hljs-comment">// Only this thread pays attention to the count. Thus there is no need for stronger</span>
            <span class="hljs-comment">// than relaxed memory ordering.</span>
            <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;
              h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(thin_locked, <span class="hljs-comment">/* as_volatile= */</span> <span class="hljs-literal">false</span>);
              <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);
              <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>
            &#125; <span class="hljs-keyword">else</span> &#123;
              <span class="hljs-comment">// Use CAS to preserve the read barrier state.</span>
              <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word,
                                     thin_locked,
                                     CASMode::kWeak,
                                     std::memory_order_relaxed)) &#123;
                <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>
              &#125;
            &#125;
            <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span>
          &#125; <span class="hljs-keyword">else</span> &#123;

            <span class="hljs-comment">// 当前线程持有偏向锁，但锁的个数超过阈值 kThinLockMaxCount</span>
            <span class="hljs-comment">// 那么将偏向锁（thin lock）升级为重量级锁（fat lock）</span>
            <span class="hljs-comment">// We&#x27;d overflow the recursion count, so inflate the monitor.</span>
            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);
          &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;

          <span class="hljs-comment">// 持有偏向锁的线程不是当前线程，此时的 thin lock 对应上文的轻量级锁</span>
          <span class="hljs-comment">// 也就是说轻量级锁是这么一种情况：一个线程持有偏向锁，遇到了另一个线程的争抢</span>
          <span class="hljs-comment">// 争抢的线程在这里自旋（spin），contention_count 表示自旋的次数</span>
          <span class="hljs-comment">// 1. 如果自旋次数 &lt;= kExtraSpinIters，那么继续在外一层的 while 循环里自旋</span>
          <span class="hljs-comment">// 2. 如果自旋次数 &lt; kExtraSpinIters，争抢线程让渡 CPU 给优先级更高的线程，并将自己排到 CPU 调度队列的队尾（sched_yield），相当于优化的自旋</span>
          <span class="hljs-comment">// 3. 最后将轻量级锁膨胀为重量级锁</span>
          <span class="hljs-keyword">if</span> (trylock) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
          &#125;
          contention_count++;
          Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();
          <span class="hljs-keyword">if</span> (contention_count
              &lt;= kExtraSpinIters + runtime-&gt;<span class="hljs-built_in">GetMaxSpinsBeforeThinLockInflation</span>()) &#123;
            <span class="hljs-keyword">if</span> (contention_count &gt; kExtraSpinIters) &#123;
              <span class="hljs-built_in">sched_yield</span>();
            &#125;
          &#125; <span class="hljs-keyword">else</span> &#123;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
            contention_count = <span class="hljs-number">0</span>;
            <span class="hljs-comment">// No ordering required for initial lockword read. Install rereads it anyway.</span>
            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
            <span class="hljs-comment">// Can&#x27;t inflate from non-owning thread. Keep waiting. Bad for power, but this code</span>
            <span class="hljs-comment">// isn&#x27;t used on-device.</span>
            should_inflate = <span class="hljs-literal">true</span>;
            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">10</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
          &#125;
        &#125;
        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span>
      &#125;

      <span class="hljs-comment">// 重量级锁的情况下会挂起当前线程，在下一节分析</span>
      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;
        std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);
        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();
        <span class="hljs-keyword">if</span> (trylock) &#123;
          <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">TryLock</span>(self) ? h_obj.<span class="hljs-built_in">Get</span>() : <span class="hljs-literal">nullptr</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
          mon-&gt;<span class="hljs-built_in">Lock</span>(self);
          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span>
        &#125;
      &#125;

      <span class="hljs-comment">// 不清楚这个条件</span>
      <span class="hljs-keyword">case</span> LockWord::kHashCode:
        <span class="hljs-built_in">Inflate</span>(self, <span class="hljs-literal">nullptr</span>, h_obj.<span class="hljs-built_in">Get</span>(), lock_word.<span class="hljs-built_in">GetHashCode</span>());
        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span>
      <span class="hljs-keyword">default</span>: &#123;
        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();
        <span class="hljs-built_in">UNREACHABLE</span>();
      &#125;
    &#125;
  &#125;
&#125;</code></pre></div>

<h3 id="锁膨胀的过程（inflate）"><a href="#锁膨胀的过程（inflate）" class="headerlink" title="锁膨胀的过程（inflate）"></a>锁膨胀的过程（inflate）</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// thin lock 膨胀至重量级锁（fat lock）的过程</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::InflateThinLocked</span><span class="hljs-params">(Thread* self, Handle&lt;mirror::Object&gt; obj, LockWord lock_word, <span class="hljs-type">uint32_t</span> hash_code)</span> </span>&#123;
  <span class="hljs-comment">// 当前线程持有此偏向锁的情况（由于锁个数超过阈值导致膨胀）</span>
  <span class="hljs-comment">// 升级到重量级锁（fat lock）</span>
  <span class="hljs-built_in">DCHECK_EQ</span>(lock_word.<span class="hljs-built_in">GetState</span>(), LockWord::kThinLocked);
  <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();
  <span class="hljs-keyword">if</span> (owner_thread_id == self-&gt;<span class="hljs-built_in">GetThreadId</span>()) &#123;
    <span class="hljs-comment">// We own the monitor, we can easily inflate it.</span>
    <span class="hljs-built_in">Inflate</span>(self, self, obj.<span class="hljs-built_in">Get</span>(), hash_code);
  &#125; <span class="hljs-keyword">else</span> &#123;

    <span class="hljs-comment">// 当前线程不持有此偏向锁，出现争抢（此时对应轻量级锁）</span>
    <span class="hljs-comment">// 挂起持有偏向锁的线程，将轻量级锁膨胀为重量级锁（fat lock），然后恢复线程</span>
    ThreadList* thread_list = Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetThreadList</span>();
    <span class="hljs-comment">// Suspend the owner, inflate. First change to blocked and give up mutator_lock_.</span>
    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(obj.<span class="hljs-built_in">Get</span>());
    <span class="hljs-type">bool</span> timed_out;
    Thread* owner;
    &#123;
      <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, kWaitingForLockInflation)</span></span>;
      owner = thread_list-&gt;<span class="hljs-built_in">SuspendThreadByThreadId</span>(owner_thread_id, SuspendReason::kInternal, &amp;timed_out);
    &#125;
    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;
      <span class="hljs-comment">// We succeeded in suspending the thread, check the lock&#x27;s status didn&#x27;t change.</span>
      lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);
      <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">GetState</span>() == LockWord::kThinLocked &amp;&amp;
          lock_word.<span class="hljs-built_in">ThinLockOwner</span>() == owner_thread_id) &#123;
        <span class="hljs-comment">// Go ahead and inflate the lock.</span>
        <span class="hljs-built_in">Inflate</span>(self, owner, obj.<span class="hljs-built_in">Get</span>(), hash_code);
      &#125;
      <span class="hljs-type">bool</span> resumed = thread_list-&gt;<span class="hljs-built_in">Resume</span>(owner, SuspendReason::kInternal);
      <span class="hljs-built_in">DCHECK</span>(resumed);
    &#125;
    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(<span class="hljs-literal">nullptr</span>);
  &#125;
&#125;

<span class="hljs-comment">// 具体的膨胀过程</span>
<span class="hljs-comment">// 膨胀到 fat lock 后多个一个概念 Monitor</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Inflate</span><span class="hljs-params">(Thread* self, Thread* owner, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-type">int32_t</span> hash_code)</span> </span>&#123;
  <span class="hljs-comment">// Allocate and acquire a new monitor.</span>
  Monitor* m = MonitorPool::<span class="hljs-built_in">CreateMonitor</span>(self, owner, obj, hash_code);
  <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">Install</span>(self)) &#123;
    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetMonitorList</span>()-&gt;<span class="hljs-built_in">Add</span>(m);
    <span class="hljs-built_in">CHECK_EQ</span>(obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>).<span class="hljs-built_in">GetState</span>(), LockWord::kFatLocked);
  &#125; <span class="hljs-keyword">else</span> &#123;
    MonitorPool::<span class="hljs-built_in">ReleaseMonitor</span>(self, m);
  &#125;
&#125;

<span class="hljs-comment">// fat lock 在这里被设置到 Object.monitor</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::Install</span><span class="hljs-params">(Thread* self)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;
  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
  <span class="hljs-built_in">CHECK</span>(owner == <span class="hljs-literal">nullptr</span> || owner == self || (ART_USE_FUTEXES &amp;&amp; owner-&gt;<span class="hljs-built_in">IsSuspended</span>()));
  <span class="hljs-function">LockWord <span class="hljs-title">lw</span><span class="hljs-params">(GetObject()-&gt;GetLockWord(<span class="hljs-literal">false</span>))</span></span>;
  <span class="hljs-keyword">switch</span> (lw.<span class="hljs-built_in">GetState</span>()) &#123;
    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;
      lock_count_ = lw.<span class="hljs-built_in">ThinLockCount</span>();
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
      monitor_lock_.<span class="hljs-built_in">ExclusiveLockUncontendedFor</span>(owner);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
      monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(owner);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
      <span class="hljs-function">LockWord <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, lw.GCState())</span></span>;
      <span class="hljs-comment">// Publish the updated lock word, which may race with other threads.</span>
      <span class="hljs-type">bool</span> success = <span class="hljs-built_in">GetObject</span>()-&gt;<span class="hljs-built_in">CasLockWord</span>(lw, fat, CASMode::kWeak, std::memory_order_release);
      <span class="hljs-keyword">if</span> (success) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ATraceEnabled</span>()) &#123;
          <span class="hljs-built_in">SetLockingMethod</span>(owner);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
<span class="hljs-meta">#<span class="hljs-keyword">if</span> ART_USE_FUTEXES</span>
        monitor_lock_.<span class="hljs-built_in">ExclusiveUnlockUncontended</span>();
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt;= lockCount; ++i) &#123;
          monitor_lock_.<span class="hljs-built_in">ExclusiveUnlock</span>(owner);
        &#125;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      &#125;
    &#125;
    <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-comment">// 上面说过，thin lock 的 LockWord 低 16 bits 是 thread id，然后是 12 bits 的锁个数</span>
<span class="hljs-comment">// 对于 fat lock，低 28 bits 是 monitor id</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">LockWord::LockWord</span><span class="hljs-params">(Monitor* mon, <span class="hljs-type">uint32_t</span> gc_state)</span></span>
<span class="hljs-function">    : value_(mon-&gt;GetMonitorId() | (gc_state &lt;&lt; kGCStateShift) | (kStateFat &lt;&lt; kStateShift)) &#123;</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LP64__</span>
  <span class="hljs-built_in">DCHECK_ALIGNED</span>(mon, kMonitorIdAlignment);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">FatLockMonitor</span>(), mon);
  <span class="hljs-built_in">DCHECK_LE</span>(mon-&gt;<span class="hljs-built_in">GetMonitorId</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(kMaxMonitorId));
  <span class="hljs-built_in">CheckReadBarrierState</span>();
&#125;</code></pre></div>

<h3 id="Monitor-Lock-挂起线程"><a href="#Monitor-Lock-挂起线程" class="headerlink" title="Monitor::Lock 挂起线程"></a><code>Monitor::Lock</code> 挂起线程</h3><p>上面介绍的是对象锁，也就是把 <code>Object</code> 作为 <code>Lock</code> 使用，具体来说是 <code>Object.monitor</code> 的四种状态：无锁、偏向锁、轻量级锁和重量级锁</p>
<p>而 <code>Monitor::Lock</code> 实现的是在重量级锁状态下，「挂起」线程的过程，它包含了自旋、futex/mutex 系统调用</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;LockReason reason&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::Lock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-type">bool</span> called_monitors_callback = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">// 一小会的自旋</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(self, <span class="hljs-comment">/*spin=*/</span> <span class="hljs-literal">true</span>)) &#123;
  <span class="hljs-comment">//... 挂起</span>
  <span class="hljs-comment">// Acquire monitor_lock_ without mutator_lock_, expecting to block this time.</span>
  <span class="hljs-comment">// We already tried spinning above. The shutdown procedure currently assumes we stop</span>
  <span class="hljs-comment">// touching monitors shortly after we suspend, so don&#x27;t spin again here.</span>
  monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(self);
  <span class="hljs-comment">//...</span>
&#125;

<span class="hljs-comment">// 自己持有锁，锁加一；否则自旋一小会尝试加锁</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::TryLock</span><span class="hljs-params">(Thread* self, <span class="hljs-type">bool</span> spin)</span> </span>&#123;
  Thread *owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
  <span class="hljs-keyword">if</span> (owner == self) &#123;
    lock_count_++;
    <span class="hljs-built_in">CHECK_NE</span>(lock_count_, <span class="hljs-number">0u</span>);  <span class="hljs-comment">// Abort on overflow.</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-type">bool</span> success = spin ? monitor_lock_.<span class="hljs-built_in">ExclusiveTryLockWithSpinning</span>(self)
        : monitor_lock_.<span class="hljs-built_in">ExclusiveTryLock</span>(self);
    <span class="hljs-comment">//...</span>
&#125;</code></pre></div>

<h2 id="monitor-exit-指令"><a href="#monitor-exit-指令" class="headerlink" title="monitor-exit 指令"></a><code>monitor-exit</code> 指令</h2><h3 id="偏向锁和轻量级锁"><a href="#偏向锁和轻量级锁" class="headerlink" title="偏向锁和轻量级锁"></a>偏向锁和轻量级锁</h3><p>退出临界区，释放锁</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Object::MonitorExit</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorExit</span>(self, <span class="hljs-keyword">this</span>);
&#125;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::MonitorExit</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span> </span>&#123;
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">switch</span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;
      <span class="hljs-keyword">case</span> LockWord::kHashCode:
        <span class="hljs-comment">// Fall-through.</span>
			
      <span class="hljs-comment">// 对象的锁并没有借出，抛出 java 异常</span>
      <span class="hljs-keyword">case</span> LockWord::kUnlocked:
        <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), <span class="hljs-number">0u</span>, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span>

      <span class="hljs-comment">// 当前线程并不拥有锁，抛出 java 异常</span>
      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;
        <span class="hljs-type">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();
        <span class="hljs-type">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();
        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;
          <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), thread_id, owner_thread_id, <span class="hljs-literal">nullptr</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span>
        &#125; <span class="hljs-keyword">else</span> &#123;

          <span class="hljs-comment">// 偏向锁，锁减一，如果锁为零则释放锁，最后写回 Object.monitor</span>
          <span class="hljs-comment">// We own the lock, decrease the recursion count.</span>
          LockWord new_lw = LockWord::<span class="hljs-built_in">Default</span>();
          <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">ThinLockCount</span>() != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() - <span class="hljs-number">1</span>;
            new_lw = LockWord::<span class="hljs-built_in">FromThinLockId</span>(thread_id, new_count, lock_word.<span class="hljs-built_in">GCState</span>());
          &#125; <span class="hljs-keyword">else</span> &#123;
            new_lw = LockWord::<span class="hljs-built_in">FromDefault</span>(lock_word.<span class="hljs-built_in">GCState</span>());
          &#125;
          <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;
            <span class="hljs-built_in">DCHECK_EQ</span>(new_lw.<span class="hljs-built_in">ReadBarrierState</span>(), <span class="hljs-number">0U</span>);
            h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(new_lw, <span class="hljs-literal">true</span>);
            <span class="hljs-built_in">AtraceMonitorUnlock</span>();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, new_lw, CASMode::kWeak, std::memory_order_release)) &#123;
              <span class="hljs-built_in">AtraceMonitorUnlock</span>();
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
          &#125;
          <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span>
        &#125;
      &#125;
			
      <span class="hljs-comment">// 释放重量级锁</span>
      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;
        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();
        <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">Unlock</span>(self);
      &#125;

      <span class="hljs-keyword">default</span>: &#123;
        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();
        <span class="hljs-built_in">UNREACHABLE</span>();
      &#125;
    &#125;
  &#125;
&#125;</code></pre></div>

<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前线程持有此重量级锁，且锁为零，退出临界区导致释放锁并唤醒等待线程</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);
  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
  <span class="hljs-keyword">if</span> (owner == self) &#123;
    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span>
    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);
    <span class="hljs-built_in">AtraceMonitorUnlock</span>();
    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;
      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);
      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);
    &#125; <span class="hljs-keyword">else</span> &#123;

      <span class="hljs-comment">// 当前线程持有此重量级锁，且锁不为零（重入）</span>
      <span class="hljs-comment">// 退出临界区导致锁减一，但不释放锁</span>
      --lock_count_;
      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));
      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);
      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span>
      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;

  <span class="hljs-comment">// 当前线程不持有此重量级锁，抛出 java 异常</span>
  <span class="hljs-comment">// We don&#x27;t own this, so we&#x27;re not allowed to unlock it.</span>
  <span class="hljs-comment">// The JNI spec says that we should throw IllegalMonitorStateException in this case.</span>
  <span class="hljs-type">uint32_t</span> owner_thread_id = <span class="hljs-number">0u</span>;
  &#123;
    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;
    owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);
    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;
      owner_thread_id = owner-&gt;<span class="hljs-built_in">GetThreadId</span>();
    &#125;
  &#125;
  <span class="hljs-built_in">FailedUnlock</span>(<span class="hljs-built_in">GetObject</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), owner_thread_id, <span class="hljs-keyword">this</span>);
  <span class="hljs-comment">// Pretend to release monitor_lock_, which we should not.</span>
  <span class="hljs-built_in">FakeUnlockMonitorLock</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-comment">// 释放重量级锁</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;
  <span class="hljs-comment">// ...</span>
  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);
&#125;</code></pre></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的代码总结下 <code>synchronized</code> 加锁的流程：</p>
<ul>
<li>初始为无锁</li>
<li>线程 A 进入临界区获得锁，升级为偏向锁（thin lock），偏向锁记下线程 A 的 thread id 和初始锁个数 0</li>
<li>如果线程 A 重入临界区，锁个数加一；当锁个数超过阈值时，膨胀为重量级锁</li>
<li>如果在线程 A 持有偏向锁的情况下，线程 B 尝试进入临界区；那么线程 B 首先自旋一小会等待线程 A 释放锁，失败后将偏向锁膨胀为重量级锁，并在锁上挂起；这一过程称为轻量级锁</li>
<li>线程 A 持有重量级锁的情况下，其他线程尝试进入临界区，会在锁上挂起（futex/mutex）</li>
</ul>
<p>总结下 <code>synchronized</code> 和 <code>Lock</code> 的区别：</p>
<ul>
<li><code>synchronized</code> 使用 <code>Object</code> 作为锁，也即所有的 <code>Object</code> 都可以当做锁使用；但具体的 lock/unlock 逻辑是在 <code>Monitor</code> 实现的，严谨地说是 <code>Object</code> + <code>Monitor</code> = Lock</li>
<li>偏向锁和轻量级锁并没有使用 <code>Monitor</code>，而是用 cas，<code>Object::monitor</code> 和自旋实现排他性；直到重量级锁时才构造 <code>Monitor</code>；<code>Monitor</code> 除了扮演 Lock 的角色外，<a href="../../../../2021/02/11/wait-notify/">还扮演了 Condition 的角色</a>，所以一旦调用 Object.wait/Object.notify，就会立刻升级为重量级锁</li>
<li>Lock 用排队队列来组织挂起的线程，而且以 FIFO 的优先级排队；<code>synchronized</code> 没有组织挂起的线程，完全由 CPU 决定谁能获得锁，可能会发生「饥饿」问题</li>
<li>Lock 全靠 futex/mutex 阻塞线程，而 <code>synchronized</code> 先让线程自旋一会在陷入阻塞</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/synchronized/">#synchronized</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/11/wait-notify/" title="Lock（五）Condition 的语言实现：Object.wait 和 Object.notify">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Lock（五）Condition 的语言实现：Object.wait 和 Object.notify</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/24/condition-by-lock/" title="Lock（三）利用 Lock 实现 Condition">
                        <span class="hidden-mobile">Lock（三）利用 Lock 实现 Condition</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
